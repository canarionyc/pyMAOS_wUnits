<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pyMAOS/display_utils.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/display_utils.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Utilities for displaying structural engineering values with appropriate units.&#10;&quot;&quot;&quot;&#10;import numpy as np&#10;# from pyMAOS.units_mod import ureg  # Replace this import&#10;from pyMAOS.units_mod import unit_manager,INTERNAL_LENGTH_UNIT,INTERNAL_FORCE_UNIT,INTERNAL_MOMENT_UNIT&#10;&#10;# Replace any direct ureg usage with unit_manager.ureg&#10;Q_ = unit_manager.ureg.Quantity&#10;&#10;def get_unit_registry():&#10;    &quot;&quot;&quot;Get or create a unit registry for conversions&quot;&quot;&quot;&#10;    try:&#10;        from pyMAOS.units_mod import unit_manager&#10;        return unit_manager.ureg&#10;    except ImportError:&#10;        from pint import UnitRegistry&#10;        return UnitRegistry()&#10;&#10;def display_node_load_vector_in_units(load_vector, node_uid, force_unit=None, length_unit=None, &#10;                                     load_combo_name=None, units_system=None):&#10;    &quot;&quot;&quot;&#10;    Display a nodal load vector with appropriate units.&#10;    &#10;    Parameters&#10;    ----------&#10;    load_vector : list or ndarray&#10;        Vector of [Fx, Fy, Mz]&#10;    node_uid : int&#10;        Node ID&#10;    force_unit : str, optional&#10;        Force unit (takes precedence over units_system)&#10;    length_unit : str, optional&#10;        Length unit (takes precedence over units_system)&#10;    load_combo_name : str, optional&#10;        Name of load combination&#10;    units_system : dict, optional&#10;        Dictionary containing unit definitions (e.g., SI_UNITS)&#10;    &quot;&quot;&quot;&#10;    # First try specific units, then fall back to units_system if available&#10;    force_unit = force_unit or (units_system.get(&quot;force&quot;) if units_system else INTERNAL_FORCE_UNIT)&#10;    length_unit = length_unit or (units_system.get(&quot;length&quot;) if units_system else INTERNAL_LENGTH_UNIT)&#10;    &#10;    moment_unit = f&quot;{force_unit}*{length_unit}&quot;&#10;    &#10;    # Get unit registry&#10;    #from pyMAOS.units_mod import unit_manager&#10;    &#10;    # Convert load vector to display units&#10;    fx_display = load_vector[0]&#10;    fy_display = load_vector[1]&#10;    mz_display = load_vector[2]&#10;    &#10;    try:&#10;        # Try to convert with pint if needed&#10;        fx_display = unit_manager.ureg.Quantity(fx_display, INTERNAL_FORCE_UNIT).to(force_unit).magnitude&#10;        fy_display = unit_manager.ureg.Quantity(fy_display, INTERNAL_FORCE_UNIT).to(force_unit).magnitude&#10;        mz_display = unit_manager.ureg.Quantity(mz_display, INTERNAL_MOMENT_UNIT).to(moment_unit).magnitude&#10;    except:&#10;        pass&#10;    &#10;    # Create load case string&#10;    load_case_str = f&quot; ({load_combo_name})&quot; if load_combo_name else &quot;&quot;&#10;    &#10;    print(f&quot;Node {node_uid} load{load_case_str}: &quot;&#10;          f&quot;Fx={fx_display:.4g} {force_unit}, &quot;&#10;          f&quot;Fy={fy_display:.4g} {force_unit}, &quot;&#10;          f&quot;Mz={mz_display:.4g} {moment_unit}&quot;)&#10;&#10;def display_node_displacement_in_units(displacement, node_uid, length_unit=None,&#10;                                     load_combo_name=None, units_system=None):&#10;    &quot;&quot;&quot;&#10;    Display nodal displacements with appropriate units.&#10;    &#10;    Parameters&#10;    ----------&#10;    displacement : list or ndarray&#10;        Vector of [ux, uy, rz]&#10;    node_uid : int&#10;        Node ID&#10;    length_unit : str, optional&#10;        Length unit (takes precedence over units_system)&#10;    load_combo_name : str, optional&#10;        Name of load combination&#10;    units_system : dict, optional&#10;        Dictionary containing unit definitions (e.g., SI_UNITS)&#10;    &quot;&quot;&quot;&#10;    # First try specific units, then fall back to units_system if available&#10;    length_unit = length_unit or (units_system.get(&quot;length&quot;) if units_system else &quot;m&quot;)&#10;    &#10;    # Get unit registry&#10;    ureg = get_unit_registry()&#10;    &#10;    # Convert displacement vector to display units&#10;    ux_display = displacement[0]&#10;    uy_display = displacement[1]&#10;    rz_display = displacement[2]  # Rotation remains in radians&#10;    &#10;    try:&#10;        # Try to convert with pint if needed&#10;        ux_display = unit_manager.ureg.Quantity(ux_display, INTERNAL_LENGTH_UNIT).to(length_unit).magnitude&#10;        uy_display = unit_manager.ureg.Quantity(uy_display, INTERNAL_LENGTH_UNIT).to(length_unit).magnitude&#10;    except:&#10;        pass&#10;    &#10;    # Create load case string&#10;    load_case_str = f&quot; ({load_combo_name})&quot; if load_combo_name else &quot;&quot;&#10;    &#10;    print(f&quot;Node {node_uid} displacement{load_case_str}: &quot;&#10;          f&quot;ux={ux_display:.6g} {length_unit}, &quot;&#10;          f&quot;uy={uy_display:.6g} {length_unit}, &quot;&#10;          f&quot;rz={rz_display:.6g} rad&quot;)&#10;&#10;def display_member_forces_in_units(forces, member_uid, force_unit=None, length_unit=None,&#10;                                 load_combo_name=None, units_system=None, location=None):&#10;    &quot;&quot;&quot;&#10;    Display member end forces with appropriate units.&#10;    &#10;    Parameters&#10;    ----------&#10;    forces : list or ndarray&#10;        Vector of [Fx1, Fy1, Mz1, Fx2, Fy2, Mz2]&#10;    member_uid : int&#10;        Member ID&#10;    force_unit : str, optional&#10;        Force unit (takes precedence over units_system)&#10;    length_unit : str, optional&#10;        Length unit (takes precedence over units_system)&#10;    load_combo_name : str, optional&#10;        Name of load combination&#10;    units_system : dict, optional&#10;        Dictionary containing unit definitions (e.g., SI_UNITS)&#10;    location : str, optional&#10;        Location description (e.g., &quot;at x=2.5m&quot;)&#10;    &quot;&quot;&quot;&#10;    # First try specific units, then fall back to units_system if available&#10;    force_unit = force_unit or (units_system.get(&quot;force&quot;) if units_system else &quot;N&quot;)&#10;    length_unit = length_unit or (units_system.get(&quot;length&quot;) if units_system else &quot;m&quot;)&#10;    &#10;    moment_unit = f&quot;{force_unit}*{length_unit}&quot;&#10;    &#10;    from pyMAOS.units_mod import ureg&#10;    &#10;    # Convert force values to display units&#10;    display_forces = []&#10;    for i, f in enumerate(forces):&#10;        if i % 3 == 2:  # Every 3rd value is a moment&#10;            try:&#10;                display_forces.append(unit_manager.ureg.Quantity(f, &quot;N*m&quot;).to(moment_unit).magnitude)&#10;            except:&#10;                display_forces.append(f)&#10;        else:  # Other values are forces&#10;            try:&#10;                display_forces.append(unit_manager.ureg.Quantity(f, &quot;N&quot;).to(force_unit).magnitude)&#10;            except:&#10;                display_forces.append(f)&#10;    &#10;    # Create location string&#10;    location_str = f&quot; {location}&quot; if location else &quot;&quot;&#10;    &#10;    # Create load case string&#10;    load_case_str = f&quot; ({load_combo_name})&quot; if load_combo_name else &quot;&quot;&#10;    &#10;    print(f&quot;Member {member_uid}{location_str} forces{load_case_str}:&quot;)&#10;    &#10;    # For standard beam/frame with 6 components&#10;    if len(display_forces) &gt;= 6:&#10;        print(f&quot;  i-node: Fx={display_forces[0]:12.4g} {force_unit}, &quot;&#10;              f&quot;Fy={display_forces[1]:12.4g} {force_unit}, &quot;&#10;              f&quot;Mz={display_forces[2]:12.4g} {moment_unit}&quot;)&#10;        print(f&quot;  j-node: Fx={display_forces[3]:12.4g} {force_unit}, &quot;&#10;              f&quot;Fy={display_forces[4]:12.4g} {force_unit}, &quot;&#10;              f&quot;Mz={display_forces[5]:12.4g} {moment_unit}&quot;)&#10;    else:&#10;        # For other element types, just print all components&#10;        components = [f&quot;{v:12.4g}&quot; for v in display_forces]&#10;        print(f&quot;  Forces: {', '.join(components)}&quot;)&#10;&#10;&#10;import pint&#10;from typing import List, Any, Union&#10;&#10;&#10;def print_quantity_nested_list(data, indent=0, precision=4, width=15, simplify_units=True):&#10;    &quot;&quot;&quot;&#10;    Print nested lists containing pint.Quantity objects with simplified units.&#10;&#10;    Parameters&#10;    ----------&#10;    data : Any&#10;        The data structure to print&#10;    indent : int&#10;        Current indentation level&#10;    precision : int&#10;        Decimal places to display&#10;    width : int&#10;        Minimum field width&#10;    simplify_units : bool&#10;        Whether to simplify units using to_reduced_units()&#10;    &quot;&quot;&quot;&#10;    if isinstance(data, pint.Quantity):&#10;        # Simplify units if requested&#10;        if simplify_units:&#10;            data = data.to_reduced_units()&#10;        formatted = f&quot;{data.magnitude:.{precision}g} {data.units}&quot;&#10;        print(formatted.ljust(width), end=&quot;&quot;)&#10;    elif isinstance(data, list):&#10;        # Handle lists (similar to your original implementation)&#10;        if not data:&#10;            print(&quot;[]&quot;)&#10;            return&#10;&#10;        all_simple = all(not isinstance(x, list) for x in data)&#10;        if all_simple and len(data) &lt;= 4:&#10;            print(&quot;[&quot;, end=&quot;&quot;)&#10;            for i, item in enumerate(data):&#10;                print_quantity_nested_list(item, indent, precision, width=0, simplify_units=simplify_units)&#10;                if i &lt; len(data) - 1:&#10;                    print(&quot;, &quot;, end=&quot;&quot;)&#10;            print(&quot;]&quot;)&#10;        else:&#10;            print(&quot;[&quot;)&#10;            for i, item in enumerate(data):&#10;                print(&quot; &quot; * (indent + 2), end=&quot;&quot;)&#10;                print_quantity_nested_list(item, indent + 2, precision, width, simplify_units=simplify_units)&#10;                if i &lt; len(data) - 1:&#10;                    print(&quot; &quot; * indent + &quot;,&quot;)&#10;                else:&#10;                    print(&quot;&quot;)&#10;            print(&quot; &quot; * indent + &quot;]&quot;, end=&quot;&quot;)&#10;            if indent==0:&#10;                print()&#10;    else:&#10;        # Handle non-quantity, non-list values&#10;        formatted = f&quot;{data:.{precision}g}&quot; if isinstance(data, (int, float)) else str(data)&#10;        print(formatted.ljust(width), end=&quot;&quot;)&#10;&#10;def print_quantity_list(data: List[Union[pint.Quantity, Any]], precision=4, width=15):&#10;    &quot;&quot;&quot;&#10;    Print a list of pint.Quantity objects or other values in a formatted manner.&#10;&#10;    Parameters&#10;    ----------&#10;    data : List[Union[pint.Quantity, Any]]&#10;        List containing pint.Quantity objects or other values&#10;    precision : int&#10;        Number of decimal places to display for numerical values&#10;    width : int&#10;        Minimum width for each value field&#10;    &quot;&quot;&quot;&#10;    print(&quot;[&quot;, end=&quot;&quot;)&#10;    for i, item in enumerate(data):&#10;        print_quantity_nested_list(item, indent=0, precision=precision, width=width)&#10;        if i &lt; len(data) - 1:&#10;            print(&quot;, &quot;, end=&quot;&quot;)&#10;    print(&quot;]&quot;)  # Close the list&#10;&#10;def print_quantity(data: Union[pint.Quantity, List[Union[pint.Quantity, Any]]],&#10;                   precision=4, width=15):&#10;    &quot;&quot;&quot;&#10;    Print a pint.Quantity or a list of pint.Quantity objects in a formatted manner.&#10;&#10;    Parameters&#10;    ----------&#10;    data : Union[pint.Quantity, List[Union[pint.Quantity, Any]]]&#10;        The data to print (can be a single Quantity or a list)&#10;    precision : int&#10;        Number of decimal places to display for numerical values&#10;    width : int&#10;        Minimum width for each value field&#10;    &quot;&quot;&quot;&#10;    if isinstance(data, list):&#10;        print_quantity_list(data, precision, width)&#10;    else:&#10;        print_quantity_nested_list(data, indent=0, precision=precision, width=width)&#10;    print()  # Newline at the end&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Example usage&#10;    ureg = get_unit_registry()&#10;&#10;    # Create some example quantities&#10;    q1 = ureg.Quantity(5.123456, &quot;m&quot;)&#10;    q2 = ureg.Quantity(10.987654, &quot;N&quot;)&#10;    q3 = ureg.Quantity(3.14159, &quot;rad&quot;)&#10;&#10;    # Print a single quantity&#10;    print_quantity(q1, precision=2)&#10;&#10;    # Print a list of quantities&#10;    print_quantity([q1, q2, q3], precision=2)&#10;&#10;    # Print nested lists with quantities&#10;    nested_data = [[q1, [q2, q3]], [q3, q1]]&#10;    print_quantity(nested_data, precision=2)&#10;&#10;    # Example for using the custom formatter&#10;    def example():&#10;        import pint&#10;        ureg = pint.UnitRegistry()&#10;&#10;        # Example similar to Dy structure in your code&#10;        Dy = [&#10;            [&#10;                [0 * ureg.meter, 5.3 * ureg.newton * ureg.meter, 1.2 * ureg.newton],&#10;                [0 * ureg.meter, 3.6 * ureg.meter]&#10;            ],&#10;            [&#10;                [2.1 * ureg.meter, 7.8 * ureg.newton * ureg.meter, 3.4 * ureg.newton],&#10;                [3.6 * ureg.meter, 5.0 * ureg.meter]&#10;            ]&#10;        ]&#10;&#10;        print(&quot;Formatted output:&quot;)&#10;        print_quantity_nested_list(Dy)&#10;&#10;        # You can adjust precision and width&#10;        print(&quot;\nWith custom precision and width:&quot;)&#10;        print_quantity_nested_list(Dy, precision=2, width=20)&#10;    example()&#10;&#10;    def print_quantity_nested_list(nested_list, indent=0, indent_step=2):&#10;        &quot;&quot;&quot;&#10;        Print a nested list of quantities using str() method for each Quantity object.&#10;&#10;        Parameters:&#10;        -----------&#10;        nested_list : list&#10;            The nested list containing Quantity objects&#10;        indent : int&#10;            Current indentation level&#10;        indent_step : int&#10;            Number of spaces for each indentation level&#10;        &quot;&quot;&quot;&#10;        if isinstance(nested_list, list):&#10;            print(&quot; &quot; * indent + &quot;[&quot;)&#10;            for item in nested_list:&#10;                print_quantity_nested_list(item, indent + indent_step, indent_step)&#10;            print(&quot; &quot; * indent + &quot;]&quot;)&#10;        else:&#10;            # For quantity objects or other values&#10;            print(&quot; &quot; * indent + str(nested_list) + &quot;,&quot;)&#10;&#10;    # Usage example&#10;    print(&quot;Vy:&quot;)&#10;    print_quantity_nested_list(Vy)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Utilities for displaying structural engineering values with appropriate units.&#10;&quot;&quot;&quot;&#10;import numpy as np&#10;# from pyMAOS.units_mod import ureg  # Replace this import&#10;import pyMAOS&#10;# Replace any direct ureg usage with unit_manager.ureg&#10;Q_ = pyMAOS.unit_manager.ureg.Quantity&#10;&#10;def get_unit_registry():&#10;    &quot;&quot;&quot;Get or create a unit registry for conversions&quot;&quot;&quot;&#10;    try:&#10;        import pyMAOS&#10;        return pyMAOS.unit_manager.ureg&#10;    except ImportError:&#10;        from pint import UnitRegistry&#10;        return UnitRegistry()&#10;&#10;def display_node_load_vector_in_units(load_vector, node_uid, force_unit=None, length_unit=None, &#10;                                     load_combo_name=None, units_system=None):&#10;    &quot;&quot;&quot;&#10;    Display a nodal load vector with appropriate units.&#10;    &#10;    Parameters&#10;    ----------&#10;    load_vector : list or ndarray&#10;        Vector of [Fx, Fy, Mz]&#10;    node_uid : int&#10;        Node ID&#10;    force_unit : str, optional&#10;        Force unit (takes precedence over units_system)&#10;    length_unit : str, optional&#10;        Length unit (takes precedence over units_system)&#10;    load_combo_name : str, optional&#10;        Name of load combination&#10;    units_system : dict, optional&#10;        Dictionary containing unit definitions (e.g., SI_UNITS)&#10;    &quot;&quot;&quot;&#10;    # First try specific units, then fall back to units_system if available&#10;    force_unit = force_unit or (units_system.get(&quot;force&quot;) if units_system else pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;    length_unit = length_unit or (units_system.get(&quot;length&quot;) if units_system else pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT)&#10;    &#10;    moment_unit = f&quot;{force_unit}*{length_unit}&quot;&#10;    &#10;    # Get unit registry&#10;    #from pyMAOS.units_mod import unit_manager&#10;    &#10;    # Convert load vector to display units&#10;    fx_display = load_vector[0]&#10;    fy_display = load_vector[1]&#10;    mz_display = load_vector[2]&#10;    &#10;    try:&#10;        # Try to convert with pint if needed&#10;        fx_display = pyMAOS.unit_manager.ureg.Quantity(fx_display, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT).to(force_unit).magnitude&#10;        fy_display = pyMAOS.unit_manager.ureg.Quantity(fy_display, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT).to(force_unit).magnitude&#10;        mz_display = pyMAOS.unit_manager.ureg.Quantity(mz_display, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT).to(moment_unit).magnitude&#10;    except:&#10;        pass&#10;    &#10;    # Create load case string&#10;    load_case_str = f&quot; ({load_combo_name})&quot; if load_combo_name else &quot;&quot;&#10;    &#10;    print(f&quot;Node {node_uid} load{load_case_str}: &quot;&#10;          f&quot;Fx={fx_display:.4g} {force_unit}, &quot;&#10;          f&quot;Fy={fy_display:.4g} {force_unit}, &quot;&#10;          f&quot;Mz={mz_display:.4g} {moment_unit}&quot;)&#10;&#10;def display_node_displacement_in_units(displacement, node_uid, length_unit=None,&#10;                                     load_combo_name=None, units_system=None):&#10;    &quot;&quot;&quot;&#10;    Display nodal displacements with appropriate units.&#10;    &#10;    Parameters&#10;    ----------&#10;    displacement : list or ndarray&#10;        Vector of [ux, uy, rz]&#10;    node_uid : int&#10;        Node ID&#10;    length_unit : str, optional&#10;        Length unit (takes precedence over units_system)&#10;    load_combo_name : str, optional&#10;        Name of load combination&#10;    units_system : dict, optional&#10;        Dictionary containing unit definitions (e.g., SI_UNITS)&#10;    &quot;&quot;&quot;&#10;    # First try specific units, then fall back to units_system if available&#10;    length_unit = length_unit or (units_system.get(&quot;length&quot;) if units_system else &quot;m&quot;)&#10;    &#10;    # Get unit registry&#10;    ureg = get_unit_registry()&#10;    &#10;    # Convert displacement vector to display units&#10;    ux_display = displacement[0]&#10;    uy_display = displacement[1]&#10;    rz_display = displacement[2]  # Rotation remains in radians&#10;    &#10;    try:&#10;        # Try to convert with pint if needed&#10;        ux_display = pyMAOS.unit_manager.ureg.Quantity(ux_display, pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT).to(length_unit).magnitude&#10;        uy_display = pyMAOS.unit_manager.ureg.Quantity(uy_display, pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT).to(length_unit).magnitude&#10;    except:&#10;        pass&#10;    &#10;    # Create load case string&#10;    load_case_str = f&quot; ({load_combo_name})&quot; if load_combo_name else &quot;&quot;&#10;    &#10;    print(f&quot;Node {node_uid} displacement{load_case_str}: &quot;&#10;          f&quot;ux={ux_display:.6g} {length_unit}, &quot;&#10;          f&quot;uy={uy_display:.6g} {length_unit}, &quot;&#10;          f&quot;rz={rz_display:.6g} rad&quot;)&#10;&#10;def display_member_forces_in_units(forces, member_uid, force_unit=None, length_unit=None,&#10;                                 load_combo_name=None, units_system=None, location=None):&#10;    &quot;&quot;&quot;&#10;    Display member end forces with appropriate units.&#10;    &#10;    Parameters&#10;    ----------&#10;    forces : list or ndarray&#10;        Vector of [Fx1, Fy1, Mz1, Fx2, Fy2, Mz2]&#10;    member_uid : int&#10;        Member ID&#10;    force_unit : str, optional&#10;        Force unit (takes precedence over units_system)&#10;    length_unit : str, optional&#10;        Length unit (takes precedence over units_system)&#10;    load_combo_name : str, optional&#10;        Name of load combination&#10;    units_system : dict, optional&#10;        Dictionary containing unit definitions (e.g., SI_UNITS)&#10;    location : str, optional&#10;        Location description (e.g., &quot;at x=2.5m&quot;)&#10;    &quot;&quot;&quot;&#10;    # First try specific units, then fall back to units_system if available&#10;    force_unit = force_unit or (units_system.get(&quot;force&quot;) if units_system else &quot;N&quot;)&#10;    length_unit = length_unit or (units_system.get(&quot;length&quot;) if units_system else &quot;m&quot;)&#10;    &#10;    moment_unit = f&quot;{force_unit}*{length_unit}&quot;&#10;    &#10;    from pyMAOS.units_mod import ureg&#10;    &#10;    # Convert force values to display units&#10;    display_forces = []&#10;    for i, f in enumerate(forces):&#10;        if i % 3 == 2:  # Every 3rd value is a moment&#10;            try:&#10;                display_forces.append(pyMAOS.unit_manager.ureg.Quantity(f, &quot;N*m&quot;).to(moment_unit).magnitude)&#10;            except:&#10;                display_forces.append(f)&#10;        else:  # Other values are forces&#10;            try:&#10;                display_forces.append(pyMAOS.unit_manager.ureg.Quantity(f, &quot;N&quot;).to(force_unit).magnitude)&#10;            except:&#10;                display_forces.append(f)&#10;    &#10;    # Create location string&#10;    location_str = f&quot; {location}&quot; if location else &quot;&quot;&#10;    &#10;    # Create load case string&#10;    load_case_str = f&quot; ({load_combo_name})&quot; if load_combo_name else &quot;&quot;&#10;    &#10;    print(f&quot;Member {member_uid}{location_str} forces{load_case_str}:&quot;)&#10;    &#10;    # For standard beam/frame with 6 components&#10;    if len(display_forces) &gt;= 6:&#10;        print(f&quot;  i-node: Fx={display_forces[0]:12.4g} {force_unit}, &quot;&#10;              f&quot;Fy={display_forces[1]:12.4g} {force_unit}, &quot;&#10;              f&quot;Mz={display_forces[2]:12.4g} {moment_unit}&quot;)&#10;        print(f&quot;  j-node: Fx={display_forces[3]:12.4g} {force_unit}, &quot;&#10;              f&quot;Fy={display_forces[4]:12.4g} {force_unit}, &quot;&#10;              f&quot;Mz={display_forces[5]:12.4g} {moment_unit}&quot;)&#10;    else:&#10;        # For other element types, just print all components&#10;        components = [f&quot;{v:12.4g}&quot; for v in display_forces]&#10;        print(f&quot;  Forces: {', '.join(components)}&quot;)&#10;&#10;&#10;import pint&#10;from typing import List, Any, Union&#10;&#10;&#10;def print_quantity_nested_list(data, indent=0, precision=4, width=15, simplify_units=True):&#10;    &quot;&quot;&quot;&#10;    Print nested lists containing pint.Quantity objects with simplified units.&#10;&#10;    Parameters&#10;    ----------&#10;    data : Any&#10;        The data structure to print&#10;    indent : int&#10;        Current indentation level&#10;    precision : int&#10;        Decimal places to display&#10;    width : int&#10;        Minimum field width&#10;    simplify_units : bool&#10;        Whether to simplify units using to_reduced_units()&#10;    &quot;&quot;&quot;&#10;    if isinstance(data, pint.Quantity):&#10;        # Simplify units if requested&#10;        if simplify_units:&#10;            data = data.to_reduced_units()&#10;        formatted = f&quot;{data.magnitude:.{precision}g} {data.units}&quot;&#10;        print(formatted.ljust(width), end=&quot;&quot;)&#10;    elif isinstance(data, list):&#10;        # Handle lists (similar to your original implementation)&#10;        if not data:&#10;            print(&quot;[]&quot;)&#10;            return&#10;&#10;        all_simple = all(not isinstance(x, list) for x in data)&#10;        if all_simple and len(data) &lt;= 4:&#10;            print(&quot;[&quot;, end=&quot;&quot;)&#10;            for i, item in enumerate(data):&#10;                print_quantity_nested_list(item, indent, precision, width=0, simplify_units=simplify_units)&#10;                if i &lt; len(data) - 1:&#10;                    print(&quot;, &quot;, end=&quot;&quot;)&#10;            print(&quot;]&quot;)&#10;        else:&#10;            print(&quot;[&quot;)&#10;            for i, item in enumerate(data):&#10;                print(&quot; &quot; * (indent + 2), end=&quot;&quot;)&#10;                print_quantity_nested_list(item, indent + 2, precision, width, simplify_units=simplify_units)&#10;                if i &lt; len(data) - 1:&#10;                    print(&quot; &quot; * indent + &quot;,&quot;)&#10;                else:&#10;                    print(&quot;&quot;)&#10;            print(&quot; &quot; * indent + &quot;]&quot;, end=&quot;&quot;)&#10;            if indent==0:&#10;                print()&#10;    else:&#10;        # Handle non-quantity, non-list values&#10;        formatted = f&quot;{data:.{precision}g}&quot; if isinstance(data, (int, float)) else str(data)&#10;        print(formatted.ljust(width), end=&quot;&quot;)&#10;&#10;def print_quantity_list(data: List[Union[pint.Quantity, Any]], precision=4, width=15):&#10;    &quot;&quot;&quot;&#10;    Print a list of pint.Quantity objects or other values in a formatted manner.&#10;&#10;    Parameters&#10;    ----------&#10;    data : List[Union[pint.Quantity, Any]]&#10;        List containing pint.Quantity objects or other values&#10;    precision : int&#10;        Number of decimal places to display for numerical values&#10;    width : int&#10;        Minimum width for each value field&#10;    &quot;&quot;&quot;&#10;    print(&quot;[&quot;, end=&quot;&quot;)&#10;    for i, item in enumerate(data):&#10;        print_quantity_nested_list(item, indent=0, precision=precision, width=width)&#10;        if i &lt; len(data) - 1:&#10;            print(&quot;, &quot;, end=&quot;&quot;)&#10;    print(&quot;]&quot;)  # Close the list&#10;&#10;def print_quantity(data: Union[pint.Quantity, List[Union[pint.Quantity, Any]]],&#10;                   precision=4, width=15):&#10;    &quot;&quot;&quot;&#10;    Print a pint.Quantity or a list of pint.Quantity objects in a formatted manner.&#10;&#10;    Parameters&#10;    ----------&#10;    data : Union[pint.Quantity, List[Union[pint.Quantity, Any]]]&#10;        The data to print (can be a single Quantity or a list)&#10;    precision : int&#10;        Number of decimal places to display for numerical values&#10;    width : int&#10;        Minimum width for each value field&#10;    &quot;&quot;&quot;&#10;    if isinstance(data, list):&#10;        print_quantity_list(data, precision, width)&#10;    else:&#10;        print_quantity_nested_list(data, indent=0, precision=precision, width=width)&#10;    print()  # Newline at the end&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Example usage&#10;    ureg = get_unit_registry()&#10;&#10;    # Create some example quantities&#10;    q1 = ureg.Quantity(5.123456, &quot;m&quot;)&#10;    q2 = ureg.Quantity(10.987654, &quot;N&quot;)&#10;    q3 = ureg.Quantity(3.14159, &quot;rad&quot;)&#10;&#10;    # Print a single quantity&#10;    print_quantity(q1, precision=2)&#10;&#10;    # Print a list of quantities&#10;    print_quantity([q1, q2, q3], precision=2)&#10;&#10;    # Print nested lists with quantities&#10;    nested_data = [[q1, [q2, q3]], [q3, q1]]&#10;    print_quantity(nested_data, precision=2)&#10;&#10;    # Example for using the custom formatter&#10;    def example():&#10;        import pint&#10;        ureg = pint.UnitRegistry()&#10;&#10;        # Example similar to Dy structure in your code&#10;        Dy = [&#10;            [&#10;                [0 * ureg.meter, 5.3 * ureg.newton * ureg.meter, 1.2 * ureg.newton],&#10;                [0 * ureg.meter, 3.6 * ureg.meter]&#10;            ],&#10;            [&#10;                [2.1 * ureg.meter, 7.8 * ureg.newton * ureg.meter, 3.4 * ureg.newton],&#10;                [3.6 * ureg.meter, 5.0 * ureg.meter]&#10;            ]&#10;        ]&#10;&#10;        print(&quot;Formatted output:&quot;)&#10;        print_quantity_nested_list(Dy)&#10;&#10;        # You can adjust precision and width&#10;        print(&quot;\nWith custom precision and width:&quot;)&#10;        print_quantity_nested_list(Dy, precision=2, width=20)&#10;    example()&#10;&#10;    def print_quantity_nested_list(nested_list, indent=0, indent_step=2):&#10;        &quot;&quot;&quot;&#10;        Print a nested list of quantities using str() method for each Quantity object.&#10;&#10;        Parameters:&#10;        -----------&#10;        nested_list : list&#10;            The nested list containing Quantity objects&#10;        indent : int&#10;            Current indentation level&#10;        indent_step : int&#10;            Number of spaces for each indentation level&#10;        &quot;&quot;&quot;&#10;        if isinstance(nested_list, list):&#10;            print(&quot; &quot; * indent + &quot;[&quot;)&#10;            for item in nested_list:&#10;                print_quantity_nested_list(item, indent + indent_step, indent_step)&#10;            print(&quot; &quot; * indent + &quot;]&quot;)&#10;        else:&#10;            # For quantity objects or other values&#10;            print(&quot; &quot; * indent + str(nested_list) + &quot;,&quot;)&#10;&#10;    # Usage example&#10;    print(&quot;Vy:&quot;)&#10;    print_quantity_nested_list(Vy)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/elements.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/elements.py" />
              <option name="originalContent" value="import numpy as np&#10;from abc import ABC, abstractmethod&#10;&#10;from numpy import ndarray&#10;&#10;import pyMAOS.loading as loadtypes&#10;import quantity_utils&#10;import pyMAOS&#10;&#10;# In structural analysis, hinges in frame elements (like beams and columns) serve a distinct purpose from node restraints. Here's what they do:&#10;# Node restraints (rx, ry, rz) control whether a node can move or rotate in the global coordinate system. These apply to the node itself.&#10;# Member hinges, however, create a release condition at the connection between a member and a node, allowing the member to rotate independently of the node's rotation. This is useful for modeling:&#10;# 1.&#9;Pin connections where moment cannot be transferred between members&#10;# 2.&#9;Partially fixed connections with limited moment transfer&#10;# 3.&#9;Construction details like simple beam-to-column connections&#10;# 4.&#9;Plastic hinge formation in advanced analysis&#10;# The question mentions &quot;node hinges&quot; but the code actually deals with member end hinges (as seen in the debug output where it prints element.hinges). These allow accurate modeling of connection behavior, which is essential for proper force distribution in the structure.&#10;# The comment about redundancy with restraints suggests there might be some confusion about the distinct roles of these features - restraints control global node behavior while hinges control member-to-node connectivity.&#10;&#10;class Element(ABC):&#10;    &quot;&quot;&quot;Base class for structural elements&quot;&quot;&quot;&#10;    &#10;    def __init__(self, uid, inode, jnode, material, section):&#10;        self.uid = uid&#10;        self.inode = inode&#10;        self.jnode = jnode&#10;        self.material = material&#10;        self.section = section&#10;        self.end_forces_local = {}&#10;        self.end_forces_global = {}&#10;        self._stations = False&#10;        self.type = &quot;GENERIC&quot;  # Default type, will be overridden by derived classes&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the element&quot;&quot;&quot;&#10;        return (f&quot;{self.type} Element {self.uid}: &quot;&#10;                f&quot;Nodes({self.inode.uid}-&gt;{self.jnode.uid}), &quot;&#10;                f&quot;{self.material}, {self.section}&quot;)&#10;    &#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return developer representation of the element&quot;&quot;&quot;&#10;        return (f&quot;Element(uid={self.uid}, type={self.type}, inode={self.inode.uid}, jnode={self.jnode.uid}, material={self.material.uid}, section={self.section.uid})&quot;)&#10;&#10;    @property&#10;    def length(self):&#10;        &quot;&quot;&quot;Calculate member length from the i and j nodes&quot;&quot;&quot;&#10;        return self.inode.distance(self.jnode)&#10;        &#10;    def set_rotation_matrix(self) -&gt; np.matrix:&#10;        &quot;&quot;&quot;Create transformation matrix from local to global coordinates&#10;    &#10;        Returns&#10;        -------&#10;        np.matrix&#10;            6x6 transformation matrix of float type for converting between &#10;            local and global coordinate systems&#10;        &quot;&quot;&quot;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        T = np.matrix([&#10;            [c, s, 0, 0, 0, 0],&#10;            [-s, c, 0, 0, 0, 0],&#10;            [0, 0, 1, 0, 0, 0],&#10;            [0, 0, 0, c, s, 0],&#10;            [0, 0, 0, -s, c, 0],&#10;            [0, 0, 0, 0, 0, 1],&#10;        ], dtype=np.float64)&#10;        self.rotation_matrix = T&#10;        return T&#10;&#10;    @abstractmethod&#10;    def k(self) -&gt; np.matrix:&#10;        &quot;&quot;&quot;Calculate the local stiffness matrix for the element.&#10;    &#10;        This method must be implemented by all derived classes.&#10;    &#10;        Returns&#10;        -------&#10;        numpy.matrix&#10;            The local stiffness matrix&#10;        &quot;&quot;&quot;&#10;        pass&#10;    # def k_with_units(self):&#10;    #     &quot;&quot;&quot;Calculate the local stiffness matrix with units&quot;&quot;&quot;&#10;    #     k = self.k()&#10;    #     # This is a placeholder implementation. Actual unit handling would depend on the specific units used in the analysis.&#10;    #     # For example, you might convert the matrix to a specific unit system here.&#10;    #     return k&#10;    def kglobal(self):&#10;        &quot;&quot;&quot;Calculate the global stiffness matrix for the element&#10;&#10;        Transforms the local stiffness matrix to global coordinates using&#10;        the transformation matrix T: kglobal = T^T * klocal * T&#10;&#10;        Returns&#10;        -------&#10;        ndarray&#10;            Element stiffness matrix in global coordinates&#10;        &quot;&quot;&quot;&#10;        # Get transformation matrix&#10;        T = self.set_rotation_matrix()&#10;&#10;        local_k = self.k()&#10;        localk_float64 = quantity_array_to_float64(local_k)&#10;        # Perform the transformation while preserving units&#10;        from numpy import linalg&#10;        # Transform local stiffness to global coordinates efficiently&#10;        globalk_float64 = linalg.multi_dot([T.T, localk_float64, T])&#10;&#10;        print(f&quot;DEBUG: Element {self.uid} global stiffness matrix created with shape {globalk_float64.shape}&quot;)&#10;&#10;        print(f&quot;Element {self.uid} global stiffness matrix created with shape {globalk_float64.shape}&quot;)&#10;&#10;        return globalk_float64&#10;&#10;    def display_stiffness_matrix_in_units(self):&#10;        &quot;&quot;&quot;Display the stiffness matrix with appropriate units notation.&quot;&quot;&quot;&#10;        # This is a placeholder implementation. Actual unit handling would depend on the specific units used in the analysis.&#10;        k_with_units = self.k_with_units()&#10;        print(f&quot;Stiffness Matrix for Element {self.uid}:\n&quot;)&#10;        print(k_with_units)&#10;&#10;    def set_displacement_global(self, load_case):&#10;        &quot;&quot;&quot;Get global nodal displacement vector for the element&quot;&quot;&quot;&#10;&#10;        iD = self.inode.displacements[load_case]; print(f&quot;iD: {iD}&quot;)&#10;        jD = self.jnode.displacements[load_case]; print(f&quot;jD: {jD}&quot;)&#10;&#10;        # Convert each QuantityArray to numpy arrays of Quantities&#10;        # from pyMAOS.quantity_utils import quantity_array_to_numpy&#10;        # iD_array = quantity_array_to_numpy(iD)&#10;        # jD_array = quantity_array_to_numpy(jD)&#10;&#10;        # Now you can create a combined displacement vector&#10;        self.displacement_global = np.concatenate([iD, jD])&#10;        return self.displacement_global&#10;&#10;    def set_displacement_local(self, load_case):&#10;        &quot;&quot;&quot;Calculate local displacement vector&quot;&quot;&quot;&#10;        elem_global_displacement = self.set_displacement_global(load_case)&#10;        from pyMAOS import quantity_utils&#10;        from numpy import linalg&#10;        from pyMAOS.quantity_utils import quantity_array_to_float64&#10;        self.displacement_local = np.dot(self.set_rotation_matrix(), convert_array_to_float64(elem_global_displacement))&#10;      &#10;        return self.displacement_local&#10;&#10;    def stations(self, num_stations=10):&#10;        &quot;&quot;&quot;Define calculation points along the element&quot;&quot;&quot;&#10;        # This is a basic implementation - derived classes may override&#10;        eta = [0 + i * (1 / num_stations) for i in range(num_stations + 1)]&#10;        stations = [self.length * i for i in eta]&#10;        &#10;        # Make sure the first and last stations do not exceed the beam&#10;        if stations[0] &lt; 0:&#10;            stations[0] = 0&#10;        if stations[-1] &gt; self.length:&#10;            stations[-1] = self.length&#10;&#10;        # Remove duplicate locations&#10;        self.calcstations = sorted(set(stations))&#10;        self._stations = True&#10;&#10;    def set_structure(self, structure):&#10;        &quot;&quot;&quot;Attach reference to parent structure for unit access&quot;&quot;&quot;&#10;        self.structure = structure&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;from abc import ABC, abstractmethod&#10;&#10;from numpy import ndarray&#10;&#10;import pyMAOS.loading as loadtypes&#10;import quantity_utils&#10;import pyMAOS&#10;&#10;# In structural analysis, hinges in frame elements (like beams and columns) serve a distinct purpose from node restraints. Here's what they do:&#10;# Node restraints (rx, ry, rz) control whether a node can move or rotate in the global coordinate system. These apply to the node itself.&#10;# Member hinges, however, create a release condition at the connection between a member and a node, allowing the member to rotate independently of the node's rotation. This is useful for modeling:&#10;# 1.&#9;Pin connections where moment cannot be transferred between members&#10;# 2.&#9;Partially fixed connections with limited moment transfer&#10;# 3.&#9;Construction details like simple beam-to-column connections&#10;# 4.&#9;Plastic hinge formation in advanced analysis&#10;# The question mentions &quot;node hinges&quot; but the code actually deals with member end hinges (as seen in the debug output where it prints element.hinges). These allow accurate modeling of connection behavior, which is essential for proper force distribution in the structure.&#10;# The comment about redundancy with restraints suggests there might be some confusion about the distinct roles of these features - restraints control global node behavior while hinges control member-to-node connectivity.&#10;&#10;class Element(ABC):&#10;    &quot;&quot;&quot;Base class for structural elements&quot;&quot;&quot;&#10;    &#10;    def __init__(self, uid, inode, jnode, material, section):&#10;        self.uid = uid&#10;        self.inode = inode&#10;        self.jnode = jnode&#10;        self.material = material&#10;        self.section = section&#10;        self.end_forces_local = {}&#10;        self.end_forces_global = {}&#10;        self._stations = False&#10;        self.type = &quot;GENERIC&quot;  # Default type, will be overridden by derived classes&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the element&quot;&quot;&quot;&#10;        return (f&quot;{self.type} Element {self.uid}: &quot;&#10;                f&quot;Nodes({self.inode.uid}-&gt;{self.jnode.uid}), &quot;&#10;                f&quot;{self.material}, {self.section}&quot;)&#10;    &#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return developer representation of the element&quot;&quot;&quot;&#10;        return (f&quot;Element(uid={self.uid}, type={self.type}, inode={self.inode.uid}, jnode={self.jnode.uid}, material={self.material.uid}, section={self.section.uid})&quot;)&#10;&#10;    @property&#10;    def length(self):&#10;        &quot;&quot;&quot;Calculate member length from the i and j nodes&quot;&quot;&quot;&#10;        return self.inode.distance(self.jnode)&#10;        &#10;    def set_rotation_matrix(self) -&gt; np.matrix:&#10;        &quot;&quot;&quot;Create transformation matrix from local to global coordinates&#10;    &#10;        Returns&#10;        -------&#10;        np.matrix&#10;            6x6 transformation matrix of float type for converting between &#10;            local and global coordinate systems&#10;        &quot;&quot;&quot;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        T = np.matrix([&#10;            [c, s, 0, 0, 0, 0],&#10;            [-s, c, 0, 0, 0, 0],&#10;            [0, 0, 1, 0, 0, 0],&#10;            [0, 0, 0, c, s, 0],&#10;            [0, 0, 0, -s, c, 0],&#10;            [0, 0, 0, 0, 0, 1],&#10;        ], dtype=np.float64)&#10;        self.rotation_matrix = T&#10;        return T&#10;&#10;    @abstractmethod&#10;    def k(self) -&gt; np.matrix:&#10;        &quot;&quot;&quot;Calculate the local stiffness matrix for the element.&#10;    &#10;        This method must be implemented by all derived classes.&#10;    &#10;        Returns&#10;        -------&#10;        numpy.matrix&#10;            The local stiffness matrix&#10;        &quot;&quot;&quot;&#10;        pass&#10;    # def k_with_units(self):&#10;    #     &quot;&quot;&quot;Calculate the local stiffness matrix with units&quot;&quot;&quot;&#10;    #     k = self.k()&#10;    #     # This is a placeholder implementation. Actual unit handling would depend on the specific units used in the analysis.&#10;    #     # For example, you might convert the matrix to a specific unit system here.&#10;    #     return k&#10;    def kglobal(self):&#10;        &quot;&quot;&quot;Calculate the global stiffness matrix for the element&#10;&#10;        Transforms the local stiffness matrix to global coordinates using&#10;        the transformation matrix T: kglobal = T^T * klocal * T&#10;&#10;        Returns&#10;        -------&#10;        ndarray&#10;            Element stiffness matrix in global coordinates&#10;        &quot;&quot;&quot;&#10;        # Get transformation matrix&#10;        T = self.set_rotation_matrix()&#10;&#10;        local_k = self.k()&#10;        localk_float64 = quantity_utils.quantity_array_to_numpy(local_k)&#10;        # Perform the transformation while preserving units&#10;        from numpy import linalg&#10;        # Transform local stiffness to global coordinates efficiently&#10;        globalk_float64 = linalg.multi_dot([T.T, localk_float64, T])&#10;&#10;        print(f&quot;DEBUG: Element {self.uid} global stiffness matrix created with shape {globalk_float64.shape}&quot;)&#10;&#10;        print(f&quot;Element {self.uid} global stiffness matrix created with shape {globalk_float64.shape}&quot;)&#10;&#10;        return globalk_float64&#10;&#10;    def display_stiffness_matrix_in_units(self):&#10;        &quot;&quot;&quot;Display the stiffness matrix with appropriate units notation.&quot;&quot;&quot;&#10;        # This is a placeholder implementation. Actual unit handling would depend on the specific units used in the analysis.&#10;        k_with_units = self.k_with_units()&#10;        print(f&quot;Stiffness Matrix for Element {self.uid}:\n&quot;)&#10;        print(k_with_units)&#10;&#10;    def set_displacement_global(self, load_case):&#10;        &quot;&quot;&quot;Get global nodal displacement vector for the element&quot;&quot;&quot;&#10;&#10;        iD = self.inode.displacements[load_case]; print(f&quot;iD: {iD}&quot;)&#10;        jD = self.jnode.displacements[load_case]; print(f&quot;jD: {jD}&quot;)&#10;&#10;        # Convert each QuantityArray to numpy arrays of Quantities&#10;        # from pyMAOS.quantity_utils import quantity_array_to_numpy&#10;        # iD_array = quantity_array_to_numpy(iD)&#10;        # jD_array = quantity_array_to_numpy(jD)&#10;&#10;        # Now you can create a combined displacement vector&#10;        self.displacement_global = np.concatenate([iD, jD])&#10;        return self.displacement_global&#10;&#10;    def set_displacement_local(self, load_case):&#10;        &quot;&quot;&quot;Calculate local displacement vector&quot;&quot;&quot;&#10;        elem_global_displacement = self.set_displacement_global(load_case)&#10;        from numpy import linalg&#10;        from pyMAOS.quantity_utils import convert_array_to_float64&#10;        self.displacement_local = np.dot(self.set_rotation_matrix(), convert_array_to_float64(elem_global_displacement))&#10;      &#10;        return self.displacement_local&#10;&#10;    def stations(self, num_stations=10):&#10;        &quot;&quot;&quot;Define calculation points along the element&quot;&quot;&quot;&#10;        # This is a basic implementation - derived classes may override&#10;        eta = [0 + i * (1 / num_stations) for i in range(num_stations + 1)]&#10;        stations = [self.length * i for i in eta]&#10;        &#10;        # Make sure the first and last stations do not exceed the beam&#10;        if stations[0] &lt; 0:&#10;            stations[0] = 0&#10;        if stations[-1] &gt; self.length:&#10;            stations[-1] = self.length&#10;&#10;        # Remove duplicate locations&#10;        self.calcstations = sorted(set(stations))&#10;        self._stations = True&#10;&#10;    def set_structure(self, structure):&#10;        &quot;&quot;&quot;Attach reference to parent structure for unit access&quot;&quot;&quot;&#10;        self.structure = structure" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/frame2d.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/frame2d.py" />
              <option name="originalContent" value="# import os&#10;import sys&#10;import pint&#10;import numpy as np&#10;&#10;from pyMAOS.display_utils import display_node_load_vector_in_units&#10;import pyMAOS.loading as loadtypes&#10;from pyMAOS.elements import Element&#10;&#10;import pyMAOS&#10;from pyMAOS import unit_manager&#10;&#10;&#10;# Create unit registry&#10;# from pyMAOS.units_mod import ureg&#10;Q_ = pyMAOS.unit_manager.ureg.Quantity&#10;&#10;def convert_to_quantity(value, unit_str):&#10;    &quot;&quot;&quot;Convert a value to a quantity with units if it's not already one&quot;&quot;&quot;&#10;    if isinstance(value, pint.Quantity):&#10;        return value&#10;    return Q_(value, unit_str)&#10;&#10;class R2Frame(Element):&#10;    # Class-level flag to control plotting for all instances&#10;    plot_enabled = False&#10;&#10;    def __init__(self, uid, inode, jnode, material, section):&#10;        super().__init__(uid, inode, jnode, material, section)&#10;        self.type = &quot;FRAME&quot;&#10;        self.hinges = [0, 0]&#10;        self.loads = []&#10;        self.fixed_end_forces_local = {}&#10;        self.fixed_end_forces_global = {}&#10;        self.rotation_matrix=[]&#10;        self.end_forces_global={}&#10;        self.end_forces_local={}&#10;&#10;&#10;        # Instance-level flag that can override the class setting&#10;        self._plot_enabled = None  # None means use the class setting&#10;&#10;        # Internal Functions&#10;        # Dictionary key for each combination&#10;        self.Wx = {}&#10;        self.Wy = {}&#10;        self.A = {}&#10;        self.Vy = {}&#10;        self.Mz = {}&#10;        self.Sz = {}&#10;        self.Dx = {}&#10;        self.Dy = {}&#10;&#10;        # Flags&#10;        self._loaded = False&#10;&#10;        # Validate hinges after initialization&#10;        self.validate_hinges()&#10;&#10;    @property&#10;    def plot_enabled(self):&#10;        &quot;&quot;&quot;Get the plot enabled state for this instance.&quot;&quot;&quot;&#10;        if self._plot_enabled is None:&#10;            return R2Frame.plot_enabled&#10;        return self._plot_enabled&#10;&#10;    @plot_enabled.setter&#10;    def plot_enabled(self, value):&#10;        &quot;&quot;&quot;Set the plot enabled state for this instance.&quot;&quot;&quot;&#10;        self._plot_enabled = bool(value)&#10;&#10;    def set_plotting(self, enabled=True):&#10;        &quot;&quot;&quot;Enable or disable plotting for this element.&quot;&quot;&quot;&#10;        self._plot_enabled = bool(enabled)&#10;        return self  # Allow chaining&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the frame element including hinge status&quot;&quot;&quot;&#10;        base_str = super().__str__()&#10;        hinge_info = &quot;&quot;&#10;    &#10;        if self.hinges[0] == 1 and self.hinges[1] == 1:&#10;            hinge_info = &quot;, Hinges: Both ends&quot;&#10;        elif self.hinges[0] == 1:&#10;            hinge_info = &quot;, Hinge: Start node&quot;&#10;        elif self.hinges[1] == 1:&#10;            hinge_info = &quot;, Hinge: End node&quot;&#10;        &#10;        return base_str + hinge_info&#10;&#10;    def hinge_i(self):&#10;        &quot;&quot;&quot;Apply a moment release (hinge) at the start node of the frame element&#10;        &#10;        Creates a rotational release at the i-node connection, which prevents &#10;        moment transfer between the element and the node. The hinge status is &#10;        validated to ensure it doesn't conflict with node restraints.&#10;        &#10;        Notes&#10;        -----&#10;        Hinges create pin connections that allow free rotation at element ends.&#10;        This affects the stiffness matrix and the distribution of forces in the element.&#10;        &quot;&quot;&quot;&#10;        self.hinges[0] = 1&#10;        self.validate_hinges()&#10;&#10;    def hinge_j(self):&#10;        &quot;&quot;&quot;Apply a moment release (hinge) at the end node of the frame element&#10;        &#10;        Creates a rotational release at the j-node connection, which prevents&#10;        moment transfer between the element and the node. The hinge status is&#10;        validated to ensure it doesn't conflict with node restraints.&#10;        &#10;        Notes&#10;        -----&#10;        Hinges create pin connections that allow free rotation at element ends.&#10;        This affects the stiffness matrix and the distribution of forces in the element.&#10;        &quot;&quot;&quot;&#10;        self.hinges[1] = 1&#10;        self.validate_hinges()&#10;&#10;    def fix_i(self):&#10;        &quot;&quot;&quot;Remove hinge at the start node of the frame element&#10;        &#10;        Restores full moment continuity between the element and its i-node.&#10;        This allows moment transfer at the connection.&#10;        &quot;&quot;&quot;&#10;        self.hinges[0] = 0&#10;&#10;    def fix_j(self):&#10;        &quot;&quot;&quot;Remove hinge at the end node of the frame element&#10;        &#10;        Restores full moment continuity between the element and its j-node.&#10;        This allows moment transfer at the connection.&#10;        &quot;&quot;&quot;&#10;        self.hinges[1] = 0&#10;&#10;    # def _parse_load_value(self, load_value):&#10;    #     &quot;&quot;&quot;&#10;    #     Parse a load value that may be a float or string with units.&#10;    #&#10;    #     Parameters&#10;    #     ----------&#10;    #     load_value : float or str&#10;    #         Load value, either as a number or string with units (e.g., &quot;50kip&quot;, &quot;100kN&quot;)&#10;    #&#10;    #     Returns&#10;    #     -------&#10;    #     float&#10;    #         Load value in SI units (Newtons for forces, Newton-meters for moments)&#10;    #     &quot;&quot;&quot;&#10;    #     # If it's already a number, return it as-is (assume SI units)&#10;    #     if isinstance(load_value, (int, float)):&#10;    #         return float(load_value)&#10;    #&#10;    #     # If it's a string, try to parse units&#10;    #     if isinstance(load_value, str):&#10;    #         try:&#10;    #             # Import the parse function from units_mod&#10;    #             from pyMAOS.units_mod import parse_value_with_units&#10;    #             import pint&#10;    #&#10;    #             # Parse the load string&#10;    #             parsed_value = parse_value_with_units(load_value)&#10;    #&#10;    #             # If it has units, convert to SI units&#10;    #             if isinstance(parsed_value, pint.Quantity):&#10;    #                 try:&#10;    #                     # Try to convert to force units (Newtons) first&#10;    #                     force_value = parsed_value.to('N').magnitude&#10;    #                     return float(force_value)&#10;    #                 except Exception:&#10;    #                     try:&#10;    #                         # If that fails, try moment units (Newton-meters)&#10;    #                         moment_value = parsed_value.to('N*m').magnitude&#10;    #                         return float(moment_value)&#10;    #                     except Exception as e:&#10;    #                         print(f&quot;Warning: Could not convert '{load_value}' to SI units (N or N*m): {e}&quot;)&#10;    #                         # Fall back to magnitude if conversion fails&#10;    #                         return float(parsed_value.magnitude)&#10;    #             else:&#10;    #                 # No units, just return the numeric value&#10;    #                 return float(parsed_value)&#10;    #&#10;    #         except Exception as e:&#10;    #             print(f&quot;Warning: Could not parse load value '{load_value}': {e}&quot;)&#10;    #             # Try to convert directly to float as fallback&#10;    #             try:&#10;    #                 return float(load_value)&#10;    #             except Exception:&#10;    #                 raise ValueError(f&quot;Could not parse load value: {load_value}&quot;)&#10;    #&#10;    #     # If we get here, something unexpected happened&#10;    #     raise ValueError(f&quot;Unsupported load value type: {type(load_value)}&quot;)&#10;&#10;    # def _parse_position_value(self, position_value):&#10;    #     &quot;&quot;&quot;&#10;    #     Parse a position value that may be a float or string with units.&#10;    #&#10;    #     Parameters&#10;    #     ----------&#10;    #     position_value : float or str&#10;    #         Position value, either as a number or string with units (e.g., &quot;10ft&quot;, &quot;3m&quot;)&#10;    #&#10;    #     Returns&#10;    #     -------&#10;    #     float&#10;    #         Position value in SI units (meters)&#10;    #     &quot;&quot;&quot;&#10;    #     # If it's already a number, return it as-is (assume SI units)&#10;    #     if isinstance(position_value, (int, float)):&#10;    #         return float(position_value)&#10;    #&#10;    #     # If it's a string, try to parse units&#10;    #     if isinstance(position_value, str):&#10;    #         try:&#10;    #             # Import the parse function from units_mod&#10;    #             from pyMAOS.units_mod import parse_value_with_units&#10;    #             import pint&#10;    #&#10;    #             # Parse the position string&#10;    #             parsed_value = parse_value_with_units(position_value)&#10;    #&#10;    #             # If it has units, convert to SI units (meters)&#10;    #             if isinstance(parsed_value, pint.Quantity):&#10;    #                 try:&#10;    #                     # Convert to length units (meters)&#10;    #                     length_value = parsed_value.to('m').magnitude&#10;    #                     return float(length_value)&#10;    #                 except Exception as e:&#10;    #                     print(f&quot;Warning: Could not convert '{position_value}' to meters: {e}&quot;)&#10;    #                     # Fall back to magnitude if conversion fails&#10;    #                     return float(parsed_value.magnitude)&#10;    #             else:&#10;    #                 # No units, just return the numeric value&#10;    #                 return float(parsed_value)&#10;    #&#10;    #         except Exception as e:&#10;    #             print(f&quot;Warning: Could not parse position value '{position_value}': {e}&quot;)&#10;    #             # Try to convert directly to float as fallback&#10;    #             try:&#10;    #                 return float(position_value)&#10;    #             except Exception:&#10;    #                 raise ValueError(f&quot;Could not parse position value: {position_value}&quot;)&#10;    #&#10;    #     # If we get here, something unexpected happened&#10;    #     raise ValueError(f&quot;Unsupported position value type: {type(position_value)}&quot;)&#10;&#10;    def add_point_load(self, p: pint.Quantity, a: pint.Quantity, case=&quot;D&quot;, direction=&quot;y&quot;, location_percent=False):&#10;        &quot;&quot;&quot;Add a concentrated point load to the frame element&#10;        &#10;        Parameters&#10;        ----------&#10;        p : float or str&#10;            Magnitude of the point load. Can be numeric or string with units (e.g., &quot;50kip&quot;, &quot;100kN&quot;)&#10;        a : float or str&#10;            Position along the element where the load is applied. Can be numeric or string with units (e.g., &quot;10ft&quot;, &quot;3m&quot;)&#10;            If location_percent is True, this is a percentage (0-100)&#10;        case : str, optional&#10;            Load case identifier, default is &quot;D&quot; (dead load)&#10;        direction : str, optional&#10;            Direction of the load: &quot;x&quot;, &quot;y&quot;, &quot;X&quot;, or &quot;Y&quot;, default is &quot;y&quot;&#10;            Lowercase indicates local axes, uppercase indicates global axes&#10;            &quot;xx&quot; for axial load in local x direction&#10;        location_percent : bool, optional&#10;            If True, 'a' is interpreted as percentage of element length&#10;            &#10;        Returns&#10;        -------&#10;        None&#10;        &#10;        Notes&#10;        -----&#10;        For global loads (X, Y), the load is transformed into local components&#10;        and stored as two separate loads (axial and transverse)&#10;        &quot;&quot;&quot;&#10;        # Parse the load magnitude with units&#10;        # p = self._parse_load_value(p)&#10;        #&#10;        # # Parse the position with units (unless it's a percentage)&#10;        # if location_percent:&#10;        #     # For percentages, convert to decimal and multiply by length&#10;        #     a = float(a) / 100 * self.length&#10;        # # else:&#10;        # #     a = self._parse_position_value(a)&#10;            &#10;        if direction == &quot;Y&quot; or direction == &quot;X&quot;:&#10;            # Load is applied in the global axis&#10;&#10;            c = (self.jnode.x - self.inode.x) / self.length&#10;            s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;            if direction == &quot;Y&quot;:&#10;                pyy = c * p&#10;                pxx = s * p&#10;            else:&#10;                pyy = -1 * s * p&#10;                pxx = c * p&#10;            loadx=loadtypes.R2_Axial_Load(pxx, a, self, loadcase=case)&#10;            loady=loadtypes.R2_Point_Load(pyy, a, self, loadcase=case)&#10;            self.loads.append(loadx)&#10;            self.loads.append(loady)&#10;        else:&#10;            # Load is applied in the local member axis&#10;&#10;            if direction == &quot;xx&quot;:&#10;                load=loadtypes.R2_Axial_Load(p, a, self, loadcase=case)&#10;                self.loads.append(load)&#10;            else:&#10;                load=loadtypes.R2_Point_Load(p, a, self, loadcase=case)&#10;                self.loads.append(load)&#10;&#10;            # Only plot if plotting is enabled&#10;            if self.plot_enabled:&#10;                fig = load.plot_all_ppoly_functions()&#10;                fig.show()  # If you want to display immediately&#10;&#10;        self._stations = False&#10;        self._loaded = True&#10;&#10;    def add_distributed_load(&#10;        self,&#10;        wi: pint.Quantity,&#10;        wj: pint.Quantity,&#10;        a: pint.Quantity,&#10;        b: pint.Quantity,&#10;        case: str = &quot;D&quot;,&#10;        direction: str = &quot;y&quot;,&#10;        location_percent: bool = False,&#10;        projected: bool = False&#10;    ):&#10;        &quot;&quot;&quot;Add a distributed load to the frame element&#10;        &#10;        Parameters&#10;        ----------&#10;        wi : float or str&#10;            Starting intensity of the distributed load. Can be numeric or string with units (e.g., &quot;0.5kip/in&quot;, &quot;10kN/m&quot;)&#10;        wj : float or str&#10;            Ending intensity of the distributed load. Can be numeric or string with units (e.g., &quot;0.5kip/in&quot;, &quot;10kN/m&quot;)&#10;        a : float or str&#10;            Starting position of the distributed load. Can be numeric or string with units (e.g., &quot;0ft&quot;, &quot;0m&quot;)&#10;        b : float or str&#10;            Ending position of the distributed load. Can be numeric or string with units (e.g., &quot;10ft&quot;, &quot;3m&quot;)&#10;        case : str, optional&#10;            Load case identifier, default is &quot;D&quot; (dead load)&#10;        direction : str, optional&#10;            Load direction: &quot;x&quot;, &quot;y&quot;, &quot;X&quot;, or &quot;Y&quot;, default is &quot;y&quot;&#10;            Lowercase indicates local axes, uppercase indicates global axes&#10;        location_percent : bool, optional&#10;            If True, a and b are interpreted as percentages of element length&#10;        projected : bool, optional&#10;            If True, load intensity is based on projected length&#10;            &#10;        Notes&#10;        -----&#10;        For global loads (X, Y), the load is transformed into local components&#10;        and stored as two separate loads&#10;        &quot;&quot;&quot;&#10;&#10;        # Parse the positions with units (unless they're percentages)&#10;        if location_percent:&#10;            a = (float(a) / 100) * self.length&#10;            b = (float(b) / 100) * self.length&#10;            &#10;        if direction == &quot;Y&quot; or direction == &quot;X&quot;:&#10;            # Load is applied in the global axis&#10;&#10;            c = (self.jnode.x - self.inode.x) / self.length&#10;            s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;            if direction == &quot;Y&quot;:&#10;                if projected:&#10;                    wi = c * wi&#10;                    wj = c * wj&#10;&#10;                wyyi = c * wi&#10;                wyyj = c * wj&#10;                wxxi = s * wi&#10;                wxxj = s * wj&#10;            else:&#10;                if projected:&#10;                    wi = s * wi&#10;                    wj = s * wj&#10;&#10;                wyyi = -1 * s * wi&#10;                wyyj = -1 * s * wj&#10;                wxxi = c * wi&#10;                wxxj = c * wj&#10;            if abs(wxxi.magnitude) &gt; 1e-10 or abs(wxxj.magnitude) &gt; 1e-10:  # Only add if at least one component is non-zero&#10;                load=loadtypes.R2_Axial_Linear_Load(wxxi, wxxj, a, b, self, loadcase=case); print(load)&#10;                self.loads.append(load)&#10;            if abs(wyyi.magnitude) &gt; 1e-10 or abs(wyyj.magnitude) &gt; 1e-10:  # Also check transverse load&#10;                load=loadtypes.LinearLoadXY(wyyi, wyyj, a, b, self, loadcase=case); print(load)&#10;                load.print_detailed_analysis()&#10;                if self.plot_enabled:&#10;                    load.plot_all_functions()&#10;                print(load)&#10;                self.loads.append(load)&#10;        else:&#10;            # Load is applied in the local member axis&#10;&#10;            if direction == &quot;xx&quot;:&#10;                load=loadtypes.R2_Axial_Linear_Load(wi, wj, a, b, self, loadcase=case); print(load)&#10;                load.print_detailed_analysis()&#10;                self.loads.append(load)&#10;            else:&#10;                if projected:&#10;                    wi = (self.jnode.x - self.inode.x) * wi / self.length&#10;                    wj = (self.jnode.x - self.inode.x) * wj / self.length&#10;                load = loadtypes.LinearLoadXY(wi, wj, a, b, self, loadcase=case); print(load)&#10;                load.print_detailed_analysis()&#10;                if self.plot_enabled:&#10;                    load.plot_all_functions()&#10;                self.loads.append(load)&#10;&#10;        self._stations = False&#10;        self._loaded = True&#10;&#10;    def _parse_distributed_load_value(self, load_value):&#10;        &quot;&quot;&quot;&#10;        Parse a distributed load value that may be a float or string with units.&#10;        &#10;        Parameters&#10;        ----------&#10;        load_value : float or str&#10;            Distributed load value, either as a number or string with units (e.g., &quot;0.5kip/in&quot;, &quot;10kN/m&quot;)&#10;            &#10;        Returns&#10;        -------&#10;        float&#10;            Distributed load value in SI units (N/m)&#10;        &quot;&quot;&quot;&#10;        # If it's already a number, return it as-is (assume SI units)&#10;        if isinstance(load_value, (int, float)):&#10;            return float(load_value)&#10;        &#10;        # If it's a string, try to parse units&#10;        if isinstance(load_value, str):&#10;            try:&#10;                # Import the parse function from units_mod&#10;                from pyMAOS.pymaos_units import parse_value_with_units&#10;                import pint&#10;                &#10;                # Parse the distributed load string&#10;                parsed_value = parse_value_with_units(load_value)&#10;                &#10;                # If it has units, convert to SI units (N/m)&#10;                if isinstance(parsed_value, pint.Quantity):&#10;                    try:&#10;                        # Convert to distributed load units (N/m)&#10;                        distributed_load_value = parsed_value.to('N/m').magnitude&#10;                        return float(distributed_load_value)&#10;                    except Exception as e:&#10;                        print(f&quot;Warning: Could not convert '{load_value}' to N/m: {e}&quot;)&#10;                        # Fall back to magnitude if conversion fails&#10;                        return float(parsed_value.magnitude)&#10;                else:&#10;                    # No units, just return the numeric value&#10;                    return float(parsed_value)&#10;                    &#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not parse distributed load value '{load_value}': {e}&quot;)&#10;                # Try to convert directly to float as fallback&#10;                try:&#10;                    return float(load_value)&#10;                except Exception:&#10;                    raise ValueError(f&quot;Could not parse distributed load value: {load_value}&quot;)&#10;        &#10;        # If we get here, something unexpected happened&#10;        raise ValueError(f&quot;Unsupported distributed load value type: {type(load_value)}&quot;)&#10;&#10;    def add_moment_load(self, m: pint.Quantity, a: pint.Quantity, case=&quot;D&quot;, location_percent=False):&#10;        &quot;&quot;&quot;Add a concentrated moment to the frame element&#10;        &#10;        Parameters&#10;        ----------&#10;        m : float or str&#10;            Magnitude of the moment (positive according to right-hand rule). Can be numeric or string with units (e.g., &quot;500kip*ft&quot;, &quot;1000kN*m&quot;)&#10;        a : float or str&#10;            Position along the element where the moment is applied. Can be numeric or string with units (e.g., &quot;5ft&quot;, &quot;1.5m&quot;)&#10;            If location_percent is True, this is a percentage (0-100)&#10;        case : str&#10;            Load case identifier (e.g., &quot;D&quot; for dead load, &quot;L&quot; for live load)&#10;        location_percent : bool, optional&#10;            If True, 'a' is interpreted as percentage of element length, default is False&#10;            &#10;        Returns&#10;        -------&#10;        None&#10;        &#10;        Notes&#10;        -----&#10;        Positive moments follow the right-hand rule convention (counterclockwise).&#10;        The moment is applied in the local coordinate system of the element.&#10;        &quot;&quot;&quot;&#10;        # Parse the moment magnitude with units&#10;        # m = self._parse_load_value(m)  # Works for both forces and moments&#10;        #&#10;        # # Parse the position with units (unless it's a percentage)&#10;        # if location_percent:&#10;        #     a = (float(a) / 100) * self.length&#10;        # else:&#10;        #     a = self._parse_position_value(a)&#10;            &#10;        self.loads.append(loadtypes.R2_Point_Moment(m, a, self, loadcase=case))&#10;&#10;        self._stations = False&#10;        self._loaded = True&#10;&#10;    def FEF(self, load_combination):&#10;        &quot;&quot;&quot;Calculate Fixed End Forces for the element under the given load combination&#10;        &#10;        Fixed End Forces (FEF) represent the equivalent nodal forces due to member loads.&#10;        These are the forces needed at the element ends to maintain equilibrium when &#10;        the element is subjected to distributed loads, point loads, or moments applied&#10;        along its length.&#10;        &#10;        The method processes all loads assigned to the element, applies the appropriate&#10;        load factors from the load combination, and combines them into a single force vector.&#10;        &#10;        If element has hinges, the fixed end forces are modified to account for the releases.&#10;        &#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination object containing load case factors&#10;            &#10;        Returns&#10;        -------&#10;        numpy.ndarray&#10;            6-element vector of fixed end forces in local coordinates:&#10;            [Fi_x, Fi_y, Mi_z, Fj_x, Fj_y, Mj_z]&#10;            where i = start node, j = end node, and x,y,z are local coordinates&#10;        &quot;&quot;&quot;&#10;        # Initialize fixed end forces vector&#10;        from pyMAOS import INTERNAL_FORCE_UNIT, INTERNAL_MOMENT_UNIT&#10;        zero_force=pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;        zero_moment=pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;        fef = np.array([zero_force,zero_force,zero_moment,zero_force,zero_force,zero_moment], dtype=object)&#10;        # Process each load applied to the element&#10;        print(f&quot;Processing {len(self.loads)} loads on element {self.uid}:&quot;, file=sys.stdout)&#10;        for load_idx, load in enumerate(self.loads):&#10;            print(f&quot;  Load {load_idx}: {load.kind} (case '{load.loadcase}')&quot;, file=sys.stdout)&#10;            load_case = load.loadcase&#10;            load_factor = load_combination.factors.get(load_case, 0)&#10;            &#10;            # Skip loads that don't contribute to this combination&#10;            if load_factor == 0:&#10;                print(f&quot;  Load {load_idx}: {load.kind} (case '{load_case}') - skipped (factor=0)&quot;, file=sys.stdout)&#10;                continue&#10;                &#10;            # Calculate FEF contribution from this load&#10;            load_fef = load.FEF()&#10;&#10;            from pyMAOS.pymaos_units import array_convert_to_unit_system&#10;            _ = array_convert_to_unit_system(load_fef, &quot;imperial&quot;)&#10;&#10;            factored_fef = np.array([load_factor * f for f in load_fef], dtype=object)&#10;            # print(factored_fef)  # Shows scaled quantities with preserved units&#10;&#10;            # print(f&quot;Element {self.uid} load idx {load_idx}: {load.kind} (case '{load_case}', factor={load_factor})&quot;, file=sys.stdout)&#10;            # print(f&quot;    Raw FEF:\n{load_fef}&quot;, file=sys.stdout)&#10;            # print(f&quot;    Factored:\n{factored_fef}&quot;, file=sys.stdout)&#10;&#10;            # Add to total FEF&#10;            fef = fef + factored_fef&#10;&#10;        from pyMAOS.pymaos_units import array_convert_to_unit_system&#10;&#10;&#10;&#10;        # Handle hinge conditions - these modify the fixed end forces for partial releases&#10;        if self.hinges == [1, 0]:  # Hinge at start node&#10;            Mi = fef[2]&#10;            L = self.length&#10;&#10;            print(f&quot;  Applying hinge at start node - redistributing moment Mi={Mi}&quot;, file=sys.stdout)&#10;            fef[1] = fef[1] - ((3 / (2 * L)) * Mi)&#10;            fef[2] = zero_moment # Zero moment at hinge&#10;            fef[4] = fef[4] + ((3 / (2 * L)) * Mi)&#10;            fef[5] = fef[5] - (Mi / 2)&#10;            &#10;        elif self.hinges == [0, 1]:  # Hinge at end node&#10;            Mj = fef[5]&#10;            L = self.length&#10;&#10;            print(f&quot;  Applying hinge at end node - redistributing moment Mj={Mj}&quot;, file=sys.stdout)&#10;            fef[1] = fef[1] - ((3 / (2 * L)) * Mj)&#10;            fef[2] = fef[2] - (Mj / 2)&#10;            fef[4] = fef[4] + ((3 / (2 * L)) * Mj)&#10;            fef[5] = zero_moment  # Zero moment at hinge&#10;            &#10;        elif self.hinges == [1, 1]:  # Hinges at both nodes&#10;            Mi = fef[2]&#10;            Mj = fef[5]&#10;            L = self.length&#10;&#10;            print(f&quot;  Applying hinges at both nodes - redistributing moments Mi={Mi}, Mj={Mj}&quot;, file=sys.stdout)&#10;            fef[1] = fef[1] - ((Mj + Mi) / L)&#10;            fef[2] = zero_moment  # Zero moment at hinge&#10;            fef[4] = fef[4] + ((Mj + Mi) / L)&#10;            fef[5] = zero_moment  # Zero moment at hinge&#10;&#10;        print(f&quot;  Final FEF for element {self.uid}:\n{fef}&quot;, file=sys.stdout)&#10;        # display_node_load_vector_in_units(fef[0:3], self.inode.uid,&#10;        #                                   force_unit=self.structure.units['force'],&#10;        #                                   length_unit=self.structure.units['distance'],&#10;        #                                   load_combo_name=None)&#10;        # display_node_load_vector_in_units(fef[3:6], self.jnode.uid,&#10;        #                                   force_unit=self.structure.units['force'],&#10;        #                                   length_unit=self.structure.units['distance'],&#10;        #                                   load_combo_name=None)&#10;        return fef&#10;&#10;    def FEFglobal(self, load_combination):&#10;        &quot;&quot;&quot;&#10;        Transform fixed end forces from local to global coordinates.&#10;        &quot;&quot;&quot;&#10;        # Get fixed end forces in local coordinates&#10;        local_fef = self.FEF(load_combination)&#10;        # fef = np.transpose(fef)&#10;        # print(f&quot;DEBUG: FEF in local coordinates: {fef}&quot;)&#10;&#10;        # Get transformation matrix&#10;        rotation_matrix = self.set_rotation_matrix()&#10;&#10;        # Check if we're dealing with quantities with units&#10;        if isinstance(local_fef[0], pint.Quantity):&#10;            # Store units for each component&#10;            fef_units = [f.units for f in local_fef]&#10;&#10;            # Extract magnitudes for calculation&#10;            fef_magnitudes = np.array([f.magnitude for f in local_fef], dtype=np.float64)&#10;&#10;            # Perform the transformation with magnitudes only&#10;            import scipy.linalg as sla&#10;            elem_global_fef_magnitudes = sla.blas.dgemv(1.0, rotation_matrix.T, fef_magnitudes); print(elem_global_fef_magnitudes)&#10;            # print(f&quot;DEBUG: Using scipy.linalg.blas: {result_magnitudes.shape}&quot;)&#10;            # print(f&quot;DEBUG: Result magnitudes: {result_magnitudes}&quot;)&#10;            # Reattach original units&#10;            elem_global_fef = np.array([unit_manager.ureg.Quantity(mag, unit)&#10;                              for mag, unit in zip(elem_global_fef_magnitudes, fef_units)],&#10;                             dtype=object)&#10;            from pymaos_units import array_convert_to_unit_system&#10;            print(f&quot;FEFglobal for element {self.uid}:&quot;); _ = array_convert_to_unit_system(elem_global_fef, &quot;imperial&quot;)&#10;&#10;        else:&#10;            # If no units, proceed with standard matrix multiplication&#10;            elem_global_fef=np.matmul(np.transpose(rotation_matrix), local_fef)&#10;&#10;        self.fixed_end_forces_global[load_combination.name]=elem_global_fef&#10;        return elem_global_fef&#10;&#10;    def k(self, **kwargs):&#10;        &quot;&quot;&quot;Calculate the local stiffness matrix for the frame element&#10;        &#10;        Creates a 6x6 stiffness matrix with appropriate modifications&#10;        for hinges if present. The stiffness matrix includes terms for&#10;        axial, shear, and bending behavior.&#10;        &#10;              [ EA/L       0         0      -EA/L       0         0     ]&#10;              [   0     12EI/L   6EI/L      0      -12EI/L   6EI/L ]&#10;        [k] = [   0     6EI/L    4EI/L       0      -6EI/L    2EI/L  ]&#10;              [-EA/L       0         0       EA/L       0         0     ]&#10;              [   0    -12EI/L  -6EI/L      0       12EI/L  -6EI/L ]&#10;              [   0     6EI/L    2EI/L       0      -6EI/L    4EI/L  ]&#10;&#10;        Different matrices are used depending on hinge configuration:&#10;        - No hinges: Standard beam element&#10;        - Hinge at i-end: Modified for released moment at i&#10;        - Hinge at j-end: Modified for released moment at j&#10;        - Hinges at both ends: Truss-like behavior with no moment transfer&#10;        &#10;        Returns&#10;        -------&#10;        numpy.matrix&#10;            6x6 local stiffness matrix for the frame element&#10;        &quot;&quot;&quot;&#10;        E: pint.Quantity = self.material.E&#10;        Ixx = self.section.Ixx&#10;        A = self.section.Area&#10;        L = self.length&#10;&#10;        # Initialize matrix with zeros&#10;        k = np.zeros((6, 6), dtype=object)&#10;&#10;        # Common terms&#10;        AE_L = A * E / L&#10;&#10;        # Axial terms (common to all hinge configurations)&#10;        k[0, 0] = AE_L&#10;        k[3, 3] = AE_L&#10;        k[0, 3] = -AE_L&#10;        k[3, 0] = -AE_L&#10;&#10;        EI = E * Ixx&#10;        EI_L = EI / L&#10;        EI_L2 = EI_L / L&#10;        EI_L3 = EI_L2 / L&#10;&#10;        # Apply appropriate bending terms based on hinge configuration&#10;        if self.hinges == [1, 1]:  # Both ends hinged - only axial stiffness&#10;            pass  # No additional terms needed&#10;&#10;        elif self.hinges == [1, 0]:  # Hinge at i-end&#10;            k[1, 1] = 3 * EI_L3&#10;            k[4, 4] = 3 * EI_L3&#10;            k[1, 4] = -3 * EI_L3&#10;            k[4, 1] = -3 * EI_L3&#10;            k[1, 5] = 3 * EI_L2&#10;            k[5, 1] = 3 * EI_L2&#10;            k[4, 5] = -3 * EI_L2&#10;            k[5, 4] = -3 * EI_L2&#10;            k[5, 5] = 3 * EI_L&#10;&#10;        elif self.hinges == [0, 1]:  # Hinge at j-end&#10;            k[1, 1] = 3 * EI_L3&#10;            k[4, 4] = 3 * EI_L3&#10;            k[1, 2] = 3 * EI_L2&#10;            k[2, 1] = 3 * EI_L2&#10;            k[1, 4] = -3 * EI_L3&#10;            k[4, 1] = -3 * EI_L3&#10;            k[2, 4] = -3 * EI_L2&#10;            k[4, 2] = -3 * EI_L2&#10;            k[2, 2] = 3 * EI_L&#10;&#10;        else:  # No hinges - standard beam element&#10;            k[1, 1] = 12 * EI_L3&#10;            k[4, 4] = 12 * EI_L3&#10;            k[1, 2] = 6 * EI_L2&#10;            k[2, 1] = 6 * EI_L2&#10;            k[1, 4] = -12 * EI_L3&#10;            k[4, 1] = -12 * EI_L3&#10;            k[1, 5] = 6 * EI_L2&#10;            k[5, 1] = 6 * EI_L2&#10;            k[2, 2] = 4 * EI_L&#10;            k[2, 4] = -6 * EI_L2&#10;            k[4, 2] = -6 * EI_L2&#10;            k[2, 5] = 2 * EI_L&#10;            k[5, 2] = 2 * EI_L&#10;            k[4, 5] = -6 * EI_L2&#10;            k[5, 4] = -6 * EI_L2&#10;            k[5, 5] = 4 * EI_L&#10;&#10;        print(f&quot;Local stiffness matrix for element {self.uid} with hinges {self.hinges}:&quot;,)&#10;        # local_stiffness_matrix = np.matrix(k)&#10;        # print(f&quot;Local stiffness matrix for element {self.uid}:\n{local_stiffness_matrix}&quot;)&#10;&#10;        # # First try to get units from element's structure&#10;        # units_dict = None&#10;        #&#10;        # # Option 1: Check if element has direct reference to structure with units&#10;        # if hasattr(self, 'structure') and hasattr(self.structure, 'units'):&#10;        #     units_dict = self.structure.units&#10;        # else:            # Option 2: Use unit manager to get current units&#10;        #     &#10;        #     units_dict = unit_manager.get_current_units()&#10;        # # Get current unit system directly from the manager&#10;        #&#10;        # print(f&quot;Local stiffness matrix for element {self.uid}:{self.k_with_units()}\n&quot;)&#10;        #&#10;        # # self.display_stiffness_matrix_in_units(local_stiffness_matrix, units_dict)&#10;&#10;        return k&#10;&#10;    def Flocal(self, load_combination):&#10;        &quot;&quot;&quot;Calculate element end forces in the local coordinate system&#10;        &#10;        Computes the end forces by combining:&#10;        1. Forces due to nodal displacements (k*d)&#10;        2. Fixed end forces due to applied loads&#10;        &#10;        The result is stored in the end_forces_local dictionary.&#10;        &#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to calculate forces&#10;            &#10;        Notes&#10;        -----&#10;        This method calculates internal member forces in the element's local &#10;        coordinate system, which is oriented along the member's axis.&#10;        &quot;&quot;&quot;&#10;        Dlocal = self.set_displacement_local(load_combination.name)&#10;        Qf = np.reshape(self.FEF(load_combination), (-1, 1))&#10;        k = self.k()&#10;        k_with_units=self.k_with_units()&#10;        print(f&quot;Local stiffness matrix for element {self.uid} under load combination '{load_combination.name}':\n{k_with_units}&quot;)&#10;        FL = np.matmul(self.k(), Dlocal.T)&#10;&#10;        self.end_forces_local[load_combination.name] = FL + Qf&#10;&#10;    def set_end_forces_global(self, load_combination):&#10;        &quot;&quot;&quot;Calculate element end forces in the global coordinate system&#10;        &#10;        Computes the global end forces by combining:&#10;        1. Forces due to nodal displacements (KG*D)&#10;        2. Fixed end forces transformed to global coordinates&#10;        &#10;        The result is stored in the end_forces_global dictionary.&#10;        This method also updates the local end forces by calling Flocal().&#10;        &#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to calculate forces&#10;            &#10;        Returns&#10;        -------&#10;        numpy.ndarray&#10;            6-element vector of end forces in global coordinates:&#10;            [Fi_x, Fi_y, Mi_z, Fj_x, Fj_y, Mj_z]&#10;            where i = start node, j = end node&#10;        &quot;&quot;&quot;&#10;&#10;        print(f&quot;Calculating global displacements for element {self.uid} under load combination '{load_combination.name}'&quot;)&#10;        Dglobal = self.set_displacement_global(load_combination.name)&#10;&#10;        # global stiffness matrix&#10;        KG = self.kglobal()&#10;&#10;        # Replace np.matmul with scipy.linalg.blas.dgemv for proper vector handling&#10;        import scipy.linalg as sla&#10;&#10;        # Check if we're dealing with quantities with units&#10;        if True or isinstance(Dglobal[0], pint.Quantity):&#10;            # Store units for calculation&#10;            from pyMAOS.quantity_utils import quantity_array_to_float64, extract_units_from_quantities&#10;            dglobal_units=extract_units_from_quantities(Dglobal)&#10;&#10;            # Extract magnitudes for calculation&#10;            kg_magnitudes = quantity_array_to_float64(KG)&#10;            dglobal_magnitudes = quantity_array_to_float64(Dglobal)&#10;&#10;            # Perform matrix-vector multiplication with SciPy BLAS&#10;            result_magnitudes = sla.blas.dgemv(1.0, kg_magnitudes, dglobal_magnitudes)&#10;            print(f&quot;DEBUG: Using scipy.linalg.blas for matrix-vector multiplication: shape={result_magnitudes.shape}&quot;)&#10;            import pyMAOS.pymaos_units&#10;            &#10;            from importlib import reload&#10;            reload(pyMAOS.pymaos_units)&#10;            dglobal_units_conjugate=unit_manager.get_conjugate_units_array(dglobal_units)&#10;            # Reattach units to result&#10;            tmp_list=[unit_manager.ureg.Quantity(mag, unit)&#10;                           for mag, unit in zip(result_magnitudes, dglobal_units_conjugate)]&#10;            FG = np.array(tmp_list,dtype=object)&#10;        else:&#10;            # For non-quantity arrays, use scipy.linalg.blas directly&#10;            FG = sla.blas.dgemv(1.0, KG, Dglobal)&#10;&#10;        print(f&quot;Global end forces for element {self.uid} under load combination '{load_combination.name}':\n{FG}&quot;)&#10;&#10;        # Store the global end forces&#10;        # if not hasattr(self, 'end_forces_global'):&#10;        #     self.end_forces_global = {}&#10;        # print(&quot;FG:&quot;, FG, sep=&quot;\n&quot;)&#10;&#10;        if not load_combination.name in self.fixed_end_forces_global.keys():&#10;            fefg = self.FEFglobal(load_combination)&#10;        else:&#10;            fefg=self.fixed_end_forces_global[load_combination.name]&#10;        print(&quot;Qfg:&quot;, fefg, sep=&quot;\n&quot;)&#10;        print(f&quot;Global fixed end forces for element {self.uid} under load combination '{load_combination.name}':\n{fefg}&quot;)&#10;&#10;        # Combine global end forces with fixed end forces&#10;&#10;        from pyMAOS.quantity_utils import add_arrays_with_units&#10;&#10;        # Element-wise addition with proper unit handling&#10;        ret_val = add_arrays_with_units(FG, fefg)&#10;        print(f&quot;DEBUG: element {self.uid} ret_val={ret_val}&quot;)&#10;        self.end_forces_global[load_combination.name] = ret_val&#10;&#10;        # print(f&quot;End forces in local coordinates for element {self.uid} under load combination '{load_combination.name}':\n{self.end_forces_local.get(load_combination.name, 'Not calculated')}&quot;)&#10;        # self.Flocal(load_combination)&#10;&#10;        return self.end_forces_global[load_combination.name]&#10;&#10;    def stations(self, num_stations=10):&#10;        &quot;&quot;&quot;&#10;        Define evenly distributed points along the member to compute internal&#10;        actions. Additional points are generated for load application points.&#10;&#10;        This also generates a reduced set of points for use in the max/min&#10;        internal action functions.&#10;&#10;        :param num_stations: _description_, defaults to 10&#10;        :type num_stations: int, optional&#10;        &quot;&quot;&quot;&#10;&#10;        # parametric list of stations between 0 and 1'&#10;        eta = [0 + i * (1 / num_stations) for i in range(num_stations + 1)]&#10;&#10;        stations = [self.length * i for i in eta]&#10;        max_stations = [0, self.length]&#10;&#10;        if self._loaded:&#10;            extra_stations = []&#10;&#10;            for load in self.loads:&#10;                if (&#10;                    load.kind == &quot;POINT&quot;&#10;                    or load.kind == &quot;MOMENT&quot;&#10;                    or load.kind == &quot;AXIAL_POINT&quot;&#10;                ):&#10;                    b = min(self.length, load.a + 0.001)&#10;                    c = max(0, load.a - 0.001)&#10;                    extra_stations.extend([c, load.a, b])&#10;                    max_stations.extend([c, load.a, b])&#10;&#10;                elif load.kind == &quot;LINE&quot; or load.kind == &quot;AXIAL_LINE&quot;:&#10;                    c = min(self.length, load.b + 0.001)&#10;                    d = max(0, load.a - 0.001)&#10;                    extra_stations.extend([d, load.a, load.b, c])&#10;                    max_stations.extend([d, load.a, load.b, c])&#10;                else:&#10;                    pass&#10;&#10;            stations.extend(extra_stations)&#10;&#10;        stations.sort()&#10;        max_stations.sort()&#10;&#10;        # Make sure the first and last stations do not exceed the beam&#10;&#10;        if stations[0] &lt; 0:&#10;            stations[0] = 0&#10;&#10;        if stations[-1] &gt; self.length:&#10;            stations[-1] = self.length&#10;        &#10;        if max_stations[0] &lt; 0:&#10;            max_stations[0] = 0&#10;&#10;        if max_stations[-1] &gt; self.length:&#10;            max_stations[-1] = self.length&#10;&#10;        # Remove duplicate locations&#10;        self.calcstations = sorted(set(stations))&#10;        self.maxstations = sorted((set(max_stations)))&#10;&#10;        self._stations = True&#10;&#10;    def generate_Loading_function(self, load_combination):&#10;        &quot;&quot;&quot;Generate piecewise polynomial functions representing distributed loads&#10;    &#10;        Creates and stores piecewise polynomial functions for loads in both the x and y&#10;        directions by combining the load contributions from all applied loads that are&#10;        active in the specified load combination.&#10;    &#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to generate the loading functions&#10;        &#10;        Notes&#10;        -----&#10;        The resulting functions are stored in the instance dictionaries `self.Wx` &#10;        and `self.Wy` using the load combination name as the key. These functions &#10;        represent the applied load distribution before integration into shear, &#10;        moment, and deflection functions.&#10;    &#10;        Each load's contribution is scaled by its corresponding factor from the&#10;        load combination. Inactive loads (with factor=0) are skipped.&#10;    &#10;        These functions are primarily used for:&#10;        1. Visualization of applied loads&#10;        2. Input for generating internal force functions&#10;        3. Integration to produce shear, moment and deflection functions&#10;        &quot;&quot;&quot;&#10;        wy = loadtypes.PiecewisePolynomial()&#10;        wx = loadtypes.PiecewisePolynomial()&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;&#10;                if load_factor != 0:&#10;                    wx = wx.combine(load.Wx, 1, load_factor)&#10;                    wy = wy.combine(load.Wy, 1, load_factor)&#10;&#10;        self.Wx[load_combination.name] = wx&#10;        self.Wy[load_combination.name] = wy&#10;&#10;    def generate_Axial_function(self, load_combination):&#10;        empty_f = np.zeros((6, 1))&#10;&#10;        Fendlocal = self.end_forces_local.get(load_combination.name, empty_f)&#10;&#10;        # Empty Piecewise functions to build the total function from the loading&#10;        ax = loadtypes.PiecewisePolynomial()&#10;&#10;        # Create &quot;loads&quot; from the end forces and combine with dx and dy&#10;        fxi = loadtypes.R2_Axial_Load(Fendlocal[0, 0], 0, self)&#10;        fyi = loadtypes.R2_Point_Load(Fendlocal[1, 0], 0, self)&#10;        mzi = loadtypes.R2_Point_Moment(Fendlocal[2, 0], 0, self)&#10;        fxj = loadtypes.R2_Axial_Load(Fendlocal[3, 0], self.length, self)&#10;        fyj = loadtypes.R2_Point_Load(Fendlocal[4, 0], self.length, self)&#10;        mzj = loadtypes.R2_Point_Moment(Fendlocal[5, 0], self.length, self)&#10;&#10;        ax = ax.combine(fxi.Ax, 1, 1)&#10;        ax = ax.combine(fyi.Ax, 1, 1)&#10;        ax = ax.combine(mzi.Ax, 1, 1)&#10;        ax = ax.combine(fxj.Ax, 1, 1)&#10;        ax = ax.combine(fyj.Ax, 1, 1)&#10;        ax = ax.combine(mzj.Ax, 1, 1)&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;&#10;                if load_factor != 0:&#10;                    ax = ax.combine(load.Ax, 1, load_factor)&#10;&#10;        self.A[load_combination.name] = ax&#10;&#10;    def generate_Vy_function(self, load_combination):&#10;        empty_f = np.zeros((6, 1))&#10;&#10;        Fendlocal = self.end_forces_local.get(load_combination.name, empty_f)&#10;&#10;        # Empty Piecewise functions to build the total function from the loading&#10;        vy = loadtypes.PiecewisePolynomial()&#10;&#10;        # Create &quot;loads&quot; from the end forces and combine with dx and dy&#10;        fxi = loadtypes.R2_Axial_Load(Fendlocal[0, 0], 0, self)&#10;        fyi = loadtypes.R2_Point_Load(Fendlocal[1, 0], 0, self)&#10;        mzi = loadtypes.R2_Point_Moment(Fendlocal[2, 0], 0, self)&#10;        fxj = loadtypes.R2_Axial_Load(Fendlocal[3, 0], self.length, self)&#10;        fyj = loadtypes.R2_Point_Load(Fendlocal[4, 0], self.length, self)&#10;        mzj = loadtypes.R2_Point_Moment(Fendlocal[5, 0], self.length, self)&#10;&#10;        vy = vy.combine(fxi.Vy, 1, 1)&#10;        vy = vy.combine(fyi.Vy, 1, 1)&#10;        vy = vy.combine(mzi.Vy, 1, 1)&#10;        vy = vy.combine(fxj.Vy, 1, 1)&#10;        vy = vy.combine(fyj.Vy, 1, 1)&#10;        vy = vy.combine(mzj.Vy, 1, 1)&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;                if load_factor != 0:&#10;                    vy = vy.combine(load.Vy, 1, load_factor)&#10;&#10;        self.Vy[load_combination.name] = vy&#10;&#10;    def generate_Mz_function(self, load_combination):&#10;        empty_f = np.zeros((6, 1))&#10;&#10;        Fendlocal = self.end_forces_local.get(load_combination.name, empty_f)&#10;&#10;        # Empty Piecewise functions to build the total function from the loading&#10;        Mzx = loadtypes.PiecewisePolynomial()&#10;&#10;        # Create &quot;loads&quot; from the end forces and combine with dx and dy&#10;        fxi = loadtypes.R2_Axial_Load(Fendlocal[0, 0], 0, self)&#10;        fyi = loadtypes.R2_Point_Load(Fendlocal[1, 0], 0, self)&#10;        mzi = loadtypes.R2_Point_Moment(Fendlocal[2, 0], 0, self)&#10;        fxj = loadtypes.R2_Axial_Load(Fendlocal[3, 0], self.length, self)&#10;        fyj = loadtypes.R2_Point_Load(Fendlocal[4, 0], self.length, self)&#10;        mzj = loadtypes.R2_Point_Moment(Fendlocal[5, 0], self.length, self)&#10;&#10;        Mzx = Mzx.combine(fxi.Mz, 1, 1)&#10;        Mzx = Mzx.combine(fyi.Mz, 1, 1)&#10;        Mzx = Mzx.combine(mzi.Mz, 1, 1)&#10;        Mzx = Mzx.combine(fxj.Mz, 1, 1)&#10;        Mzx = Mzx.combine(fyj.Mz, 1, 1)&#10;        Mzx = Mzx.combine(mzj.Mz, 1, 1)&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;                if load_factor != 0:&#10;                    Mzx = Mzx.combine(load.Mz, 1, load_factor)&#10;&#10;        self.Mz[load_combination.name] = Mzx&#10;&#10;    def generate_Sz_function(self, load_combination):&#10;        empty_f = np.zeros((6, 1))&#10;&#10;        Fendlocal = self.end_forces_local.get(load_combination.name, empty_f)&#10;&#10;        # Empty Piecwise functions to build the total function from the loading&#10;        Szx = loadtypes.PiecewisePolynomial()&#10;&#10;        # Create &quot;loads&quot; from the end forces and combine with dx and dy&#10;        fxi = loadtypes.R2_Axial_Load(Fendlocal[0, 0], 0, self)&#10;        fyi = loadtypes.R2_Point_Load(Fendlocal[1, 0], 0, self)&#10;        mzi = loadtypes.R2_Point_Moment(Fendlocal[2, 0], 0, self)&#10;        fxj = loadtypes.R2_Axial_Load(Fendlocal[3, 0], self.length, self)&#10;        fyj = loadtypes.R2_Point_Load(Fendlocal[4, 0], self.length, self)&#10;        mzj = loadtypes.R2_Point_Moment(Fendlocal[5, 0], self.length, self)&#10;&#10;        Szx = Szx.combine(fxi.Sz, 1, 1)&#10;        Szx = Szx.combine(fyi.Sz, 1, 1)&#10;        Szx = Szx.combine(mzi.Sz, 1, 1)&#10;        Szx = Szx.combine(fxj.Sz, 1, 1)&#10;        Szx = Szx.combine(fyj.Sz, 1, 1)&#10;        Szx = Szx.combine(mzj.Sz, 1, 1)&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;                if load_factor != 0:&#10;                    Szx = Szx.combine(load.Sz, 1, load_factor)&#10;&#10;        self.Sz[load_combination.name] = Szx&#10;&#10;    def generate_DxDy_function(self, load_combination):&#10;        &quot;&quot;&quot;&#10;        Generate the piecewise displacement functions for the local x and y &#10;        axis. !!Note the nodal displacements are not included in these functions.&#10;&#10;        :param load_combination: load combination element&#10;        :type load_combination: _type_&#10;        &quot;&quot;&quot;&#10;&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        empty_f = np.zeros((6, 1))&#10;&#10;        Fendlocal = self.end_forces_local.get(load_combination.name, empty_f)&#10;&#10;        # Empty Piecwise functions to build the total function from the loading&#10;        dx = loadtypes.PiecewisePolynomial()&#10;        dy = loadtypes.PiecewisePolynomial()&#10;&#10;        # Create &quot;loads&quot; from the end forces and combine with dx and dy&#10;        fxi = loadtypes.R2_Axial_Load(Fendlocal[0, 0], 0, self)&#10;        fyi = loadtypes.R2_Point_Load(Fendlocal[1, 0], 0, self)&#10;        mzi = loadtypes.R2_Point_Moment(Fendlocal[2, 0], 0, self)&#10;        fxj = loadtypes.R2_Axial_Load(Fendlocal[3, 0], self.length, self)&#10;        fyj = loadtypes.R2_Point_Load(Fendlocal[4, 0], self.length, self)&#10;        mzj = loadtypes.R2_Point_Moment(Fendlocal[5, 0], self.length, self)&#10;&#10;        dx = dx.combine(fxi.Dx, 1, 1)&#10;        dy = dy.combine(fyi.Dy, 1, 1)&#10;        dy = dy.combine(mzi.Dy, 1, 1)&#10;        dx = dx.combine(fxj.Dx, 1, 1)&#10;        dy = dy.combine(fyj.Dy, 1, 1)&#10;        dy = dy.combine(mzj.Dy, 1, 1)&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;&#10;                if load_factor != 0:&#10;                    dx = dx.combine(load.Dx, 1, load_factor)&#10;                    dy = dy.combine(load.Dy, 1, load_factor)&#10;&#10;        self.Dx[load_combination.name] = dx&#10;        self.Dy[load_combination.name] = dy&#10;&#10;    def Wxlocal_plot(self, load_combination, scale=1, ptloadscale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        wx = self.Wx.get(load_combination.name, None)&#10;&#10;        if wx is None:&#10;            self.generate_Loading_function(load_combination)&#10;            wx = self.Wx.get(load_combination.name, None)&#10;&#10;        wxlocal_span = np.zeros((len(self.calcstations), 2))&#10;&#10;        for i, x in enumerate(self.calcstations):&#10;            w = wx.evaluate(x)&#10;&#10;            wp = 0&#10;&#10;            for load in self.loads:&#10;                if load.kind == &quot;AXIAL_POINT&quot;:&#10;                    if load.a == x:&#10;                        load_factor = load_combination.factors.get(load.loadcase, 0)&#10;                        wp += load_factor * load.p&#10;&#10;            wxlocal_span[i, 0] = x&#10;            wxlocal_span[i, 1] = w * scale + (wp * ptloadscale)&#10;&#10;        return wxlocal_span&#10;&#10;    def Wxglobal_plot(self, load_combination, scale=1, ptloadscale=1):&#10;        wxlocal_plot = self.Wxlocal_plot(&#10;            load_combination, scale=scale, ptloadscale=ptloadscale&#10;        )&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        wxglobal_plot = np.matmul(wxlocal_plot, R)&#10;&#10;        return wxglobal_plot&#10;&#10;    def Wylocal_plot(self, load_combination, scale=1, ptloadscale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        wy = self.Wy.get(load_combination.name, None)&#10;&#10;        if wy is None:&#10;            self.generate_Loading_function(load_combination)&#10;            wy = self.Wy.get(load_combination.name, None)&#10;&#10;        wylocal_span = np.zeros((len(self.calcstations), 2))&#10;&#10;        for i, x in enumerate(self.calcstations):&#10;            w = wy.evaluate(x)&#10;&#10;            wp = 0&#10;&#10;            for load in self.loads:&#10;                if load.kind == &quot;POINT&quot;:&#10;                    if load.a == x:&#10;                        load_factor = load_combination.factors.get(load.loadcase, 0)&#10;                        wp += load_factor * load.p&#10;&#10;            wylocal_span[i, 0] = x&#10;            wylocal_span[i, 1] = (w * scale) + (wp * ptloadscale)&#10;&#10;        return wylocal_span&#10;&#10;    def Wyglobal_plot(self, load_combination, scale=1, ptloadscale=1):&#10;        wylocal_plot = self.Wylocal_plot(&#10;            load_combination, scale=scale, ptloadscale=ptloadscale&#10;        )&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        wyglobal_plot = np.matmul(wylocal_plot, R)&#10;&#10;        return wyglobal_plot&#10;&#10;    def Alocal_plot(self, load_combination, scale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        ax = self.A.get(load_combination.name, None)&#10;&#10;        if ax is None:&#10;            self.generate_Axial_function(load_combination)&#10;            ax = self.A.get(load_combination.name, None)&#10;&#10;        axlocal_span = np.zeros((len(self.calcstations), 2))&#10;&#10;        for i, x in enumerate(self.calcstations):&#10;            a = ax.evaluate(x)&#10;&#10;            axlocal_span[i, 0] = x&#10;            axlocal_span[i, 1] = a * scale&#10;&#10;        return axlocal_span&#10;&#10;    def Aglobal_plot(self, load_combination, scale):&#10;        axlocal_plot = self.Alocal_plot(load_combination, scale=scale)&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        axglobal_plot = np.matmul(axlocal_plot, R)&#10;&#10;        return axglobal_plot&#10;&#10;    def Vlocal_plot(self, load_combination, scale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        vy = self.Vy.get(load_combination.name, None)&#10;&#10;        if vy is None:&#10;            self.generate_Vy_function(load_combination)&#10;            vy = self.Vy.get(load_combination.name, None)&#10;&#10;        vlocal_span = np.zeros((len(self.calcstations), 2))&#10;&#10;        for i, x in enumerate(self.calcstations):&#10;            v = vy.evaluate(x)&#10;&#10;            vlocal_span[i, 0] = x&#10;            vlocal_span[i, 1] = v * scale&#10;&#10;        return vlocal_span&#10;&#10;    def Vglobal_plot(self, load_combination, scale):&#10;        vlocal_plot = self.Vlocal_plot(load_combination, scale=scale)&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        vglobal_plot = np.matmul(vlocal_plot, R)&#10;&#10;        return vglobal_plot&#10;&#10;    def Mlocal_plot(self, load_combination, scale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        mzx = self.Mz.get(load_combination.name, None)&#10;&#10;        if mzx is None:&#10;            self.generate_Mz_function(load_combination)&#10;            mzx = self.Mz.get(load_combination.name, None)&#10;&#10;        # Get the Roots of the shear function for the current combo&#10;        vy = self.Vy.get(load_combination.name, None)&#10;&#10;        if vy is None:&#10;            self.generate_Vy_function(load_combination)&#10;            vy = self.Vy.get(load_combination.name, None)&#10;&#10;        shear_roots = vy.roots()&#10;        # Generate a new station list including the roots&#10;        stations = sorted(set(self.calcstations + shear_roots))&#10;&#10;        mlocal_span = np.zeros((len(stations), 2))&#10;&#10;        for i, x in enumerate(stations):&#10;            m = mzx.evaluate(x)&#10;&#10;            mlocal_span[i, 0] = x&#10;            mlocal_span[i, 1] = m * scale&#10;&#10;        return mlocal_span&#10;&#10;    def Mglobal_plot(self, load_combination, scale):&#10;        mlocal_plot = self.Mlocal_plot(load_combination, scale=scale)&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        mglobal_plot = np.matmul(mlocal_plot, R)&#10;&#10;        return mglobal_plot&#10;&#10;    def Slocal_plot(self, load_combination, scale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        Szx = self.Sz.get(load_combination.name, None)&#10;&#10;        if Szx is None:&#10;            self.generate_Sz_function(load_combination)&#10;            Szx = self.Sz.get(load_combination.name, None)&#10;&#10;        slocal_span = np.zeros((len(self.calcstations), 2))&#10;        # slope adjustment for end displacements&#10;        Dlocal = self.set_displacement_local(load_combination)&#10;&#10;        sadjust = (Dlocal[0, 4] - Dlocal[0, 1]) / self.length&#10;&#10;        for i, x in enumerate(self.calcstations):&#10;            s = Szx.evaluate(x)&#10;&#10;            slocal_span[i, 0] = x&#10;            slocal_span[i, 1] = (s + sadjust) * scale&#10;&#10;        return slocal_span&#10;&#10;    def Sglobal_plot(self, load_combination, scale):&#10;        slocal_plot = self.Slocal_plot(load_combination, scale=scale)&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        sglobal_plot = np.matmul(slocal_plot, R)&#10;&#10;        return sglobal_plot&#10;&#10;    def Dlocal_plot(self, load_combination, scale=1):&#10;        dx = self.Dx.get(load_combination.name, None)&#10;        dy = self.Dy.get(load_combination.name, None)&#10;&#10;        if dx is None or dy is None:&#10;            self.generate_DxDy_function(load_combination)&#10;            dx = self.Dx.get(load_combination.name, None)&#10;            dy = self.Dy.get(load_combination.name, None)&#10;&#10;        Dlocal = self.set_displacement_local(load_combination)&#10;&#10;        # Parametric Functions defining a linear relationship for deflection&#10;        # in each axis based on the Ux and Uy nodal displacements&#10;        Dx = lambda x: Dlocal[0, 0] + (x / self.length) * (Dlocal[0, 3] - Dlocal[0, 0])&#10;        Dy = lambda x: Dlocal[0, 1] + (x / self.length) * (Dlocal[0, 4] - Dlocal[0, 1])&#10;&#10;        # Get the Roots of the slope function for the current combo&#10;        sz = self.Sz.get(load_combination.name, None)&#10;&#10;        if sz is None:&#10;            self.generate_Sz_function(load_combination)&#10;            sz = self.Sz.get(load_combination.name, None)&#10;&#10;        slope_roots = sz.roots()&#10;        # Generate a new station list including the roots&#10;        stations = sorted(set(self.calcstations + slope_roots))&#10;&#10;        dlocal_span = np.zeros((len(stations), 2))&#10;&#10;        for i, x in enumerate(stations):&#10;            dxl = dx.evaluate(x) + Dx(0)&#10;            dyl = dy.evaluate(x) + Dy(x)&#10;&#10;            dlocal_span[i, 0] = x + (dxl * scale)&#10;            dlocal_span[i, 1] = dyl * scale&#10;&#10;        return dlocal_span&#10;&#10;    def Dglobal_plot(self, load_combination, scale=1):&#10;        dlocal_plot = self.Dlocal_plot(load_combination, scale=scale)&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        dglobal_plot = np.matmul(dlocal_plot, R)&#10;&#10;        return dglobal_plot&#10;    &#10;    def Mzextremes(self, load_combination):&#10;        &quot;&quot;&quot;Find maximum and minimum bending moment values along the element&#10;    &#10;        Calculates the extreme moment values by:&#10;        1. Evaluating the moment at predefined stations along the element&#10;        2. Finding zeros of the shear force function (where moment extremes occur)&#10;        3. Checking moment values at all critical points&#10;    &#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to calculate extreme moments&#10;        &#10;        Returns&#10;        -------&#10;        dict&#10;            Dictionary containing extreme moment values and their locations:&#10;            - 'MaxM': [position, value] - Maximum positive moment&#10;            - 'MinM': [position, value] - Maximum negative moment&#10;        &#10;        Notes&#10;        -----&#10;        This method is crucial for structural design as the extreme moment values&#10;        are needed for member capacity checks. The zeros of the shear function&#10;        are included as these are the locations where moments reach local extremes.&#10;        &quot;&quot;&quot;&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        mzx = self.Mz.get(load_combination.name, None)&#10;&#10;        if mzx is None:&#10;            self.generate_Mz_function(load_combination)&#10;            mzx = self.Mz.get(load_combination.name, None)&#10;&#10;        # Get the Roots of the shear force function for the current combo&#10;        vy = self.Vy.get(load_combination.name, None)&#10;&#10;        if vy is None:&#10;            self.generate_Vy_function(load_combination)&#10;            vy = self.Vy.get(load_combination.name, None)&#10;&#10;        shear_roots = vy.roots()&#10;        # Generate a new station list including the roots&#10;        stations = sorted(set(self.maxstations + shear_roots))&#10;        maxM = [0,0]&#10;        minM = [0,0]&#10;&#10;        for x in stations:&#10;            m = mzx.evaluate(x)&#10;            maxM[1] = max(maxM[1],m)&#10;            minM[1] = min(minM[1],m)&#10;            if maxM[1] == m:&#10;                maxM[0] = x&#10;            if minM[1] == m:&#10;                minM[0] = x&#10;        &#10;        return {&quot;MaxM&quot;:maxM,&quot;MinM&quot;:minM}&#10;&#10;    def validate_hinges(self):&#10;        &quot;&quot;&quot;&#10;        Validates that hinges are correctly applied based on the node restraints.&#10;        Raises an error if there is a conflict.&#10;        &quot;&quot;&quot;&#10;        # Check i-node (start node)&#10;        if self.hinges[0] == 1 and self.inode.restraints[2] == 1:&#10;            raise ValueError(&#10;                f&quot;Conflict: Hinge applied at i-node (UID: {self.inode.uid}) of frame (UID: {self.uid}), &quot;&#10;                f&quot;but the node is rotationally restrained (Rz = 1).&quot;&#10;            )&#10;&#10;        # Check j-node (end node)&#10;        if self.hinges[1] == 1 and self.jnode.restraints[2] == 1:&#10;            raise ValueError(&#10;                f&quot;Conflict: Hinge applied at j-node (UID: {self.jnode.uid}) of frame (UID: {self.uid}), &quot;&#10;                f&quot;but the node is rotationally restrained (Rz = 1).&quot;&#10;            )&#10;&#10;    @property&#10;    def has_distributed_loads(self):&#10;        &quot;&quot;&quot;Check if element has any distributed loads applied&quot;&quot;&quot;&#10;        return any(load.kind == &quot;LINE&quot; or load.kind == &quot;AXIAL_LINE&quot; for load in self.loads) if self.loads else False&#10;" />
              <option name="updatedContent" value="# import os&#10;import sys&#10;import pint&#10;import numpy as np&#10;&#10;from pyMAOS.display_utils import display_node_load_vector_in_units&#10;import pyMAOS.loading as loadtypes&#10;from pyMAOS.elements import Element&#10;&#10;import pyMAOS&#10;from pyMAOS import unit_manager&#10;&#10;&#10;# Create unit registry&#10;# from pyMAOS.units_mod import ureg&#10;Q_ = pyMAOS.unit_manager.ureg.Quantity&#10;&#10;def convert_to_quantity(value, unit_str):&#10;    &quot;&quot;&quot;Convert a value to a quantity with units if it's not already one&quot;&quot;&quot;&#10;    if isinstance(value, pint.Quantity):&#10;        return value&#10;    return Q_(value, unit_str)&#10;&#10;class R2Frame(Element):&#10;    # Class-level flag to control plotting for all instances&#10;    plot_enabled = False&#10;&#10;    def __init__(self, uid, inode, jnode, material, section):&#10;        super().__init__(uid, inode, jnode, material, section)&#10;        self.type = &quot;FRAME&quot;&#10;        self.hinges = [0, 0]&#10;        self.loads = []&#10;        self.fixed_end_forces_local = {}&#10;        self.fixed_end_forces_global = {}&#10;        self.rotation_matrix=[]&#10;        self.end_forces_global={}&#10;        self.end_forces_local={}&#10;&#10;&#10;        # Instance-level flag that can override the class setting&#10;        self._plot_enabled = None  # None means use the class setting&#10;&#10;        # Internal Functions&#10;        # Dictionary key for each combination&#10;        self.Wx = {}&#10;        self.Wy = {}&#10;        self.A = {}&#10;        self.Vy = {}&#10;        self.Mz = {}&#10;        self.Sz = {}&#10;        self.Dx = {}&#10;        self.Dy = {}&#10;&#10;        # Flags&#10;        self._loaded = False&#10;&#10;        # Validate hinges after initialization&#10;        self.validate_hinges()&#10;&#10;    @property&#10;    def plot_enabled(self):&#10;        &quot;&quot;&quot;Get the plot enabled state for this instance.&quot;&quot;&quot;&#10;        if self._plot_enabled is None:&#10;            return R2Frame.plot_enabled&#10;        return self._plot_enabled&#10;&#10;    @plot_enabled.setter&#10;    def plot_enabled(self, value):&#10;        &quot;&quot;&quot;Set the plot enabled state for this instance.&quot;&quot;&quot;&#10;        self._plot_enabled = bool(value)&#10;&#10;    def set_plotting(self, enabled=True):&#10;        &quot;&quot;&quot;Enable or disable plotting for this element.&quot;&quot;&quot;&#10;        self._plot_enabled = bool(enabled)&#10;        return self  # Allow chaining&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the frame element including hinge status&quot;&quot;&quot;&#10;        base_str = super().__str__()&#10;        hinge_info = &quot;&quot;&#10;    &#10;        if self.hinges[0] == 1 and self.hinges[1] == 1:&#10;            hinge_info = &quot;, Hinges: Both ends&quot;&#10;        elif self.hinges[0] == 1:&#10;            hinge_info = &quot;, Hinge: Start node&quot;&#10;        elif self.hinges[1] == 1:&#10;            hinge_info = &quot;, Hinge: End node&quot;&#10;        &#10;        return base_str + hinge_info&#10;&#10;    def hinge_i(self):&#10;        &quot;&quot;&quot;Apply a moment release (hinge) at the start node of the frame element&#10;        &#10;        Creates a rotational release at the i-node connection, which prevents &#10;        moment transfer between the element and the node. The hinge status is &#10;        validated to ensure it doesn't conflict with node restraints.&#10;        &#10;        Notes&#10;        -----&#10;        Hinges create pin connections that allow free rotation at element ends.&#10;        This affects the stiffness matrix and the distribution of forces in the element.&#10;        &quot;&quot;&quot;&#10;        self.hinges[0] = 1&#10;        self.validate_hinges()&#10;&#10;    def hinge_j(self):&#10;        &quot;&quot;&quot;Apply a moment release (hinge) at the end node of the frame element&#10;        &#10;        Creates a rotational release at the j-node connection, which prevents&#10;        moment transfer between the element and the node. The hinge status is&#10;        validated to ensure it doesn't conflict with node restraints.&#10;        &#10;        Notes&#10;        -----&#10;        Hinges create pin connections that allow free rotation at element ends.&#10;        This affects the stiffness matrix and the distribution of forces in the element.&#10;        &quot;&quot;&quot;&#10;        self.hinges[1] = 1&#10;        self.validate_hinges()&#10;&#10;    def fix_i(self):&#10;        &quot;&quot;&quot;Remove hinge at the start node of the frame element&#10;        &#10;        Restores full moment continuity between the element and its i-node.&#10;        This allows moment transfer at the connection.&#10;        &quot;&quot;&quot;&#10;        self.hinges[0] = 0&#10;&#10;    def fix_j(self):&#10;        &quot;&quot;&quot;Remove hinge at the end node of the frame element&#10;        &#10;        Restores full moment continuity between the element and its j-node.&#10;        This allows moment transfer at the connection.&#10;        &quot;&quot;&quot;&#10;        self.hinges[1] = 0&#10;&#10;    # def _parse_load_value(self, load_value):&#10;    #     &quot;&quot;&quot;&#10;    #     Parse a load value that may be a float or string with units.&#10;    #&#10;    #     Parameters&#10;    #     ----------&#10;    #     load_value : float or str&#10;    #         Load value, either as a number or string with units (e.g., &quot;50kip&quot;, &quot;100kN&quot;)&#10;    #&#10;    #     Returns&#10;    #     -------&#10;    #     float&#10;    #         Load value in SI units (Newtons for forces, Newton-meters for moments)&#10;    #     &quot;&quot;&quot;&#10;    #     # If it's already a number, return it as-is (assume SI units)&#10;    #     if isinstance(load_value, (int, float)):&#10;    #         return float(load_value)&#10;    #&#10;    #     # If it's a string, try to parse units&#10;    #     if isinstance(load_value, str):&#10;    #         try:&#10;    #             # Import the parse function from units_mod&#10;    #             from pyMAOS.units_mod import parse_value_with_units&#10;    #             import pint&#10;    #&#10;    #             # Parse the load string&#10;    #             parsed_value = parse_value_with_units(load_value)&#10;    #&#10;    #             # If it has units, convert to SI units&#10;    #             if isinstance(parsed_value, pint.Quantity):&#10;    #                 try:&#10;    #                     # Try to convert to force units (Newtons) first&#10;    #                     force_value = parsed_value.to('N').magnitude&#10;    #                     return float(force_value)&#10;    #                 except Exception:&#10;    #                     try:&#10;    #                         # If that fails, try moment units (Newton-meters)&#10;    #                         moment_value = parsed_value.to('N*m').magnitude&#10;    #                         return float(moment_value)&#10;    #                     except Exception as e:&#10;    #                         print(f&quot;Warning: Could not convert '{load_value}' to SI units (N or N*m): {e}&quot;)&#10;    #                         # Fall back to magnitude if conversion fails&#10;    #                         return float(parsed_value.magnitude)&#10;    #             else:&#10;    #                 # No units, just return the numeric value&#10;    #                 return float(parsed_value)&#10;    #&#10;    #         except Exception as e:&#10;    #             print(f&quot;Warning: Could not parse load value '{load_value}': {e}&quot;)&#10;    #             # Try to convert directly to float as fallback&#10;    #             try:&#10;    #                 return float(load_value)&#10;    #             except Exception:&#10;    #                 raise ValueError(f&quot;Could not parse load value: {load_value}&quot;)&#10;    #&#10;    #     # If we get here, something unexpected happened&#10;    #     raise ValueError(f&quot;Unsupported load value type: {type(load_value)}&quot;)&#10;&#10;    # def _parse_position_value(self, position_value):&#10;    #     &quot;&quot;&quot;&#10;    #     Parse a position value that may be a float or string with units.&#10;    #&#10;    #     Parameters&#10;    #     ----------&#10;    #     position_value : float or str&#10;    #         Position value, either as a number or string with units (e.g., &quot;10ft&quot;, &quot;3m&quot;)&#10;    #&#10;    #     Returns&#10;    #     -------&#10;    #     float&#10;    #         Position value in SI units (meters)&#10;    #     &quot;&quot;&quot;&#10;    #     # If it's already a number, return it as-is (assume SI units)&#10;    #     if isinstance(position_value, (int, float)):&#10;    #         return float(position_value)&#10;    #&#10;    #     # If it's a string, try to parse units&#10;    #     if isinstance(position_value, str):&#10;    #         try:&#10;    #             # Import the parse function from units_mod&#10;    #             from pyMAOS.units_mod import parse_value_with_units&#10;    #             import pint&#10;    #&#10;    #             # Parse the position string&#10;    #             parsed_value = parse_value_with_units(position_value)&#10;    #&#10;    #             # If it has units, convert to SI units (meters)&#10;    #             if isinstance(parsed_value, pint.Quantity):&#10;    #                 try:&#10;    #                     # Convert to length units (meters)&#10;    #                     length_value = parsed_value.to('m').magnitude&#10;    #                     return float(length_value)&#10;    #                 except Exception as e:&#10;    #                     print(f&quot;Warning: Could not convert '{position_value}' to meters: {e}&quot;)&#10;    #                     # Fall back to magnitude if conversion fails&#10;    #                     return float(parsed_value.magnitude)&#10;    #             else:&#10;    #                 # No units, just return the numeric value&#10;    #                 return float(parsed_value)&#10;    #&#10;    #         except Exception as e:&#10;    #             print(f&quot;Warning: Could not parse position value '{position_value}': {e}&quot;)&#10;    #             # Try to convert directly to float as fallback&#10;    #             try:&#10;    #                 return float(position_value)&#10;    #             except Exception:&#10;    #                 raise ValueError(f&quot;Could not parse position value: {position_value}&quot;)&#10;    #&#10;    #     # If we get here, something unexpected happened&#10;    #     raise ValueError(f&quot;Unsupported position value type: {type(position_value)}&quot;)&#10;&#10;    def add_point_load(self, p: pint.Quantity, a: pint.Quantity, case=&quot;D&quot;, direction=&quot;y&quot;, location_percent=False):&#10;        &quot;&quot;&quot;Add a concentrated point load to the frame element&#10;        &#10;        Parameters&#10;        ----------&#10;        p : float or str&#10;            Magnitude of the point load. Can be numeric or string with units (e.g., &quot;50kip&quot;, &quot;100kN&quot;)&#10;        a : float or str&#10;            Position along the element where the load is applied. Can be numeric or string with units (e.g., &quot;10ft&quot;, &quot;3m&quot;)&#10;            If location_percent is True, this is a percentage (0-100)&#10;        case : str, optional&#10;            Load case identifier, default is &quot;D&quot; (dead load)&#10;        direction : str, optional&#10;            Direction of the load: &quot;x&quot;, &quot;y&quot;, &quot;X&quot;, or &quot;Y&quot;, default is &quot;y&quot;&#10;            Lowercase indicates local axes, uppercase indicates global axes&#10;            &quot;xx&quot; for axial load in local x direction&#10;        location_percent : bool, optional&#10;            If True, 'a' is interpreted as percentage of element length&#10;            &#10;        Returns&#10;        -------&#10;        None&#10;        &#10;        Notes&#10;        -----&#10;        For global loads (X, Y), the load is transformed into local components&#10;        and stored as two separate loads (axial and transverse)&#10;        &quot;&quot;&quot;&#10;        # Parse the load magnitude with units&#10;        # p = self._parse_load_value(p)&#10;        #&#10;        # # Parse the position with units (unless it's a percentage)&#10;        # if location_percent:&#10;        #     # For percentages, convert to decimal and multiply by length&#10;        #     a = float(a) / 100 * self.length&#10;        # # else:&#10;        # #     a = self._parse_position_value(a)&#10;            &#10;        if direction == &quot;Y&quot; or direction == &quot;X&quot;:&#10;            # Load is applied in the global axis&#10;&#10;            c = (self.jnode.x - self.inode.x) / self.length&#10;            s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;            if direction == &quot;Y&quot;:&#10;                pyy = c * p&#10;                pxx = s * p&#10;            else:&#10;                pyy = -1 * s * p&#10;                pxx = c * p&#10;            loadx=loadtypes.R2_Axial_Load(pxx, a, self, loadcase=case)&#10;            loady=loadtypes.R2_Point_Load(pyy, a, self, loadcase=case)&#10;            self.loads.append(loadx)&#10;            self.loads.append(loady)&#10;        else:&#10;            # Load is applied in the local member axis&#10;&#10;            if direction == &quot;xx&quot;:&#10;                load=loadtypes.R2_Axial_Load(p, a, self, loadcase=case)&#10;                self.loads.append(load)&#10;            else:&#10;                load=loadtypes.R2_Point_Load(p, a, self, loadcase=case)&#10;                self.loads.append(load)&#10;&#10;            # Only plot if plotting is enabled&#10;            if self.plot_enabled:&#10;                fig = load.plot_all_ppoly_functions()&#10;                fig.show()  # If you want to display immediately&#10;&#10;        self._stations = False&#10;        self._loaded = True&#10;&#10;    def add_distributed_load(&#10;        self,&#10;        wi: pint.Quantity,&#10;        wj: pint.Quantity,&#10;        a: pint.Quantity,&#10;        b: pint.Quantity,&#10;        case: str = &quot;D&quot;,&#10;        direction: str = &quot;y&quot;,&#10;        location_percent: bool = False,&#10;        projected: bool = False&#10;    ):&#10;        &quot;&quot;&quot;Add a distributed load to the frame element&#10;        &#10;        Parameters&#10;        ----------&#10;        wi : float or str&#10;            Starting intensity of the distributed load. Can be numeric or string with units (e.g., &quot;0.5kip/in&quot;, &quot;10kN/m&quot;)&#10;        wj : float or str&#10;            Ending intensity of the distributed load. Can be numeric or string with units (e.g., &quot;0.5kip/in&quot;, &quot;10kN/m&quot;)&#10;        a : float or str&#10;            Starting position of the distributed load. Can be numeric or string with units (e.g., &quot;0ft&quot;, &quot;0m&quot;)&#10;        b : float or str&#10;            Ending position of the distributed load. Can be numeric or string with units (e.g., &quot;10ft&quot;, &quot;3m&quot;)&#10;        case : str, optional&#10;            Load case identifier, default is &quot;D&quot; (dead load)&#10;        direction : str, optional&#10;            Load direction: &quot;x&quot;, &quot;y&quot;, &quot;X&quot;, or &quot;Y&quot;, default is &quot;y&quot;&#10;            Lowercase indicates local axes, uppercase indicates global axes&#10;        location_percent : bool, optional&#10;            If True, a and b are interpreted as percentages of element length&#10;        projected : bool, optional&#10;            If True, load intensity is based on projected length&#10;            &#10;        Notes&#10;        -----&#10;        For global loads (X, Y), the load is transformed into local components&#10;        and stored as two separate loads&#10;        &quot;&quot;&quot;&#10;&#10;        # Parse the positions with units (unless they're percentages)&#10;        if location_percent:&#10;            a = (float(a) / 100) * self.length&#10;            b = (float(b) / 100) * self.length&#10;            &#10;        if direction == &quot;Y&quot; or direction == &quot;X&quot;:&#10;            # Load is applied in the global axis&#10;&#10;            c = (self.jnode.x - self.inode.x) / self.length&#10;            s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;            if direction == &quot;Y&quot;:&#10;                if projected:&#10;                    wi = c * wi&#10;                    wj = c * wj&#10;&#10;                wyyi = c * wi&#10;                wyyj = c * wj&#10;                wxxi = s * wi&#10;                wxxj = s * wj&#10;            else:&#10;                if projected:&#10;                    wi = s * wi&#10;                    wj = s * wj&#10;&#10;                wyyi = -1 * s * wi&#10;                wyyj = -1 * s * wj&#10;                wxxi = c * wi&#10;                wxxj = c * wj&#10;            if abs(wxxi.magnitude) &gt; 1e-10 or abs(wxxj.magnitude) &gt; 1e-10:  # Only add if at least one component is non-zero&#10;                load=loadtypes.R2_Axial_Linear_Load(wxxi, wxxj, a, b, self, loadcase=case); print(load)&#10;                self.loads.append(load)&#10;            if abs(wyyi.magnitude) &gt; 1e-10 or abs(wyyj.magnitude) &gt; 1e-10:  # Also check transverse load&#10;                load=loadtypes.LinearLoadXY(wyyi, wyyj, a, b, self, loadcase=case); print(load)&#10;                load.print_detailed_analysis()&#10;                if self.plot_enabled:&#10;                    load.plot_all_functions()&#10;                print(load)&#10;                self.loads.append(load)&#10;        else:&#10;            # Load is applied in the local member axis&#10;&#10;            if direction == &quot;xx&quot;:&#10;                load=loadtypes.R2_Axial_Linear_Load(wi, wj, a, b, self, loadcase=case); print(load)&#10;                load.print_detailed_analysis()&#10;                self.loads.append(load)&#10;            else:&#10;                if projected:&#10;                    wi = (self.jnode.x - self.inode.x) * wi / self.length&#10;                    wj = (self.jnode.x - self.inode.x) * wj / self.length&#10;                load = loadtypes.LinearLoadXY(wi, wj, a, b, self, loadcase=case); print(load)&#10;                load.print_detailed_analysis()&#10;                if self.plot_enabled:&#10;                    load.plot_all_functions()&#10;                self.loads.append(load)&#10;&#10;        self._stations = False&#10;        self._loaded = True&#10;&#10;    def _parse_distributed_load_value(self, load_value):&#10;        &quot;&quot;&quot;&#10;        Parse a distributed load value that may be a float or string with units.&#10;        &#10;        Parameters&#10;        ----------&#10;        load_value : float or str&#10;            Distributed load value, either as a number or string with units (e.g., &quot;0.5kip/in&quot;, &quot;10kN/m&quot;)&#10;            &#10;        Returns&#10;        -------&#10;        float&#10;            Distributed load value in SI units (N/m)&#10;        &quot;&quot;&quot;&#10;        # If it's already a number, return it as-is (assume SI units)&#10;        if isinstance(load_value, (int, float)):&#10;            return float(load_value)&#10;        &#10;        # If it's a string, try to parse units&#10;        if isinstance(load_value, str):&#10;            try:&#10;                # Import the parse function from units_mod&#10;                from pyMAOS.pymaos_units import parse_value_with_units&#10;                import pint&#10;                &#10;                # Parse the distributed load string&#10;                parsed_value = parse_value_with_units(load_value)&#10;                &#10;                # If it has units, convert to SI units (N/m)&#10;                if isinstance(parsed_value, pint.Quantity):&#10;                    try:&#10;                        # Convert to distributed load units (N/m)&#10;                        distributed_load_value = parsed_value.to('N/m').magnitude&#10;                        return float(distributed_load_value)&#10;                    except Exception as e:&#10;                        print(f&quot;Warning: Could not convert '{load_value}' to N/m: {e}&quot;)&#10;                        # Fall back to magnitude if conversion fails&#10;                        return float(parsed_value.magnitude)&#10;                else:&#10;                    # No units, just return the numeric value&#10;                    return float(parsed_value)&#10;                    &#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not parse distributed load value '{load_value}': {e}&quot;)&#10;                # Try to convert directly to float as fallback&#10;                try:&#10;                    return float(load_value)&#10;                except Exception:&#10;                    raise ValueError(f&quot;Could not parse distributed load value: {load_value}&quot;)&#10;        &#10;        # If we get here, something unexpected happened&#10;        raise ValueError(f&quot;Unsupported distributed load value type: {type(load_value)}&quot;)&#10;&#10;    def add_moment_load(self, m: pint.Quantity, a: pint.Quantity, case=&quot;D&quot;, location_percent=False):&#10;        &quot;&quot;&quot;Add a concentrated moment to the frame element&#10;        &#10;        Parameters&#10;        ----------&#10;        m : float or str&#10;            Magnitude of the moment (positive according to right-hand rule). Can be numeric or string with units (e.g., &quot;500kip*ft&quot;, &quot;1000kN*m&quot;)&#10;        a : float or str&#10;            Position along the element where the moment is applied. Can be numeric or string with units (e.g., &quot;5ft&quot;, &quot;1.5m&quot;)&#10;            If location_percent is True, this is a percentage (0-100)&#10;        case : str&#10;            Load case identifier (e.g., &quot;D&quot; for dead load, &quot;L&quot; for live load)&#10;        location_percent : bool, optional&#10;            If True, 'a' is interpreted as percentage of element length, default is False&#10;            &#10;        Returns&#10;        -------&#10;        None&#10;        &#10;        Notes&#10;        -----&#10;        Positive moments follow the right-hand rule convention (counterclockwise).&#10;        The moment is applied in the local coordinate system of the element.&#10;        &quot;&quot;&quot;&#10;        # Parse the moment magnitude with units&#10;        # m = self._parse_load_value(m)  # Works for both forces and moments&#10;        #&#10;        # # Parse the position with units (unless it's a percentage)&#10;        # if location_percent:&#10;        #     a = (float(a) / 100) * self.length&#10;        # else:&#10;        #     a = self._parse_position_value(a)&#10;            &#10;        self.loads.append(loadtypes.R2_Point_Moment(m, a, self, loadcase=case))&#10;&#10;        self._stations = False&#10;        self._loaded = True&#10;&#10;    def FEF(self, load_combination):&#10;        &quot;&quot;&quot;Calculate Fixed End Forces for the element under the given load combination&#10;        &#10;        Fixed End Forces (FEF) represent the equivalent nodal forces due to member loads.&#10;        These are the forces needed at the element ends to maintain equilibrium when &#10;        the element is subjected to distributed loads, point loads, or moments applied&#10;        along its length.&#10;        &#10;        The method processes all loads assigned to the element, applies the appropriate&#10;        load factors from the load combination, and combines them into a single force vector.&#10;        &#10;        If element has hinges, the fixed end forces are modified to account for the releases.&#10;        &#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination object containing load case factors&#10;            &#10;        Returns&#10;        -------&#10;        numpy.ndarray&#10;            6-element vector of fixed end forces in local coordinates:&#10;            [Fi_x, Fi_y, Mi_z, Fj_x, Fj_y, Mj_z]&#10;            where i = start node, j = end node, and x,y,z are local coordinates&#10;        &quot;&quot;&quot;&#10;        # Initialize fixed end forces vector&#10;        from pyMAOS import INTERNAL_FORCE_UNIT, INTERNAL_MOMENT_UNIT&#10;        zero_force=pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;        zero_moment=pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;        fef = np.array([zero_force,zero_force,zero_moment,zero_force,zero_force,zero_moment], dtype=object)&#10;        # Process each load applied to the element&#10;        print(f&quot;Processing {len(self.loads)} loads on element {self.uid}:&quot;, file=sys.stdout)&#10;        for load_idx, load in enumerate(self.loads):&#10;            print(f&quot;  Load {load_idx}: {load.kind} (case '{load.loadcase}')&quot;, file=sys.stdout)&#10;            load_case = load.loadcase&#10;            load_factor = load_combination.factors.get(load_case, 0)&#10;            &#10;            # Skip loads that don't contribute to this combination&#10;            if load_factor == 0:&#10;                print(f&quot;  Load {load_idx}: {load.kind} (case '{load_case}') - skipped (factor=0)&quot;, file=sys.stdout)&#10;                continue&#10;                &#10;            # Calculate FEF contribution from this load&#10;            load_fef = load.FEF()&#10;&#10;            from pyMAOS.pymaos_units import array_convert_to_unit_system&#10;            _ = array_convert_to_unit_system(load_fef, &quot;imperial&quot;)&#10;&#10;            factored_fef = np.array([load_factor * f for f in load_fef], dtype=object)&#10;            # print(factored_fef)  # Shows scaled quantities with preserved units&#10;&#10;            # print(f&quot;Element {self.uid} load idx {load_idx}: {load.kind} (case '{load_case}', factor={load_factor})&quot;, file=sys.stdout)&#10;            # print(f&quot;    Raw FEF:\n{load_fef}&quot;, file=sys.stdout)&#10;            # print(f&quot;    Factored:\n{factored_fef}&quot;, file=sys.stdout)&#10;&#10;            # Add to total FEF&#10;            fef = fef + factored_fef&#10;&#10;        from pyMAOS.pymaos_units import array_convert_to_unit_system&#10;&#10;&#10;&#10;        # Handle hinge conditions - these modify the fixed end forces for partial releases&#10;        if self.hinges == [1, 0]:  # Hinge at start node&#10;            Mi = fef[2]&#10;            L = self.length&#10;&#10;            print(f&quot;  Applying hinge at start node - redistributing moment Mi={Mi}&quot;, file=sys.stdout)&#10;            fef[1] = fef[1] - ((3 / (2 * L)) * Mi)&#10;            fef[2] = zero_moment # Zero moment at hinge&#10;            fef[4] = fef[4] + ((3 / (2 * L)) * Mi)&#10;            fef[5] = fef[5] - (Mi / 2)&#10;            &#10;        elif self.hinges == [0, 1]:  # Hinge at end node&#10;            Mj = fef[5]&#10;            L = self.length&#10;&#10;            print(f&quot;  Applying hinge at end node - redistributing moment Mj={Mj}&quot;, file=sys.stdout)&#10;            fef[1] = fef[1] - ((3 / (2 * L)) * Mj)&#10;            fef[2] = fef[2] - (Mj / 2)&#10;            fef[4] = fef[4] + ((3 / (2 * L)) * Mj)&#10;            fef[5] = zero_moment  # Zero moment at hinge&#10;            &#10;        elif self.hinges == [1, 1]:  # Hinges at both nodes&#10;            Mi = fef[2]&#10;            Mj = fef[5]&#10;            L = self.length&#10;&#10;            print(f&quot;  Applying hinges at both nodes - redistributing moments Mi={Mi}, Mj={Mj}&quot;, file=sys.stdout)&#10;            fef[1] = fef[1] - ((Mj + Mi) / L)&#10;            fef[2] = zero_moment  # Zero moment at hinge&#10;            fef[4] = fef[4] + ((Mj + Mi) / L)&#10;            fef[5] = zero_moment  # Zero moment at hinge&#10;&#10;        print(f&quot;  Final FEF for element {self.uid}:\n{fef}&quot;, file=sys.stdout)&#10;        # display_node_load_vector_in_units(fef[0:3], self.inode.uid,&#10;        #                                   force_unit=self.structure.units['force'],&#10;        #                                   length_unit=self.structure.units['distance'],&#10;        #                                   load_combo_name=None)&#10;        # display_node_load_vector_in_units(fef[3:6], self.jnode.uid,&#10;        #                                   force_unit=self.structure.units['force'],&#10;        #                                   length_unit=self.structure.units['distance'],&#10;        #                                   load_combo_name=None)&#10;        return fef&#10;&#10;    def FEFglobal(self, load_combination):&#10;        &quot;&quot;&quot;&#10;        Transform fixed end forces from local to global coordinates.&#10;        &quot;&quot;&quot;&#10;        # Get fixed end forces in local coordinates&#10;        local_fef = self.FEF(load_combination)&#10;        # fef = np.transpose(fef)&#10;        # print(f&quot;DEBUG: FEF in local coordinates: {fef}&quot;)&#10;&#10;        # Get transformation matrix&#10;        rotation_matrix = self.set_rotation_matrix()&#10;&#10;        # Check if we're dealing with quantities with units&#10;        if isinstance(local_fef[0], pint.Quantity):&#10;            # Store units for each component&#10;            fef_units = [f.units for f in local_fef]&#10;&#10;            # Extract magnitudes for calculation&#10;            fef_magnitudes = np.array([f.magnitude for f in local_fef], dtype=np.float64)&#10;&#10;            # Perform the transformation with magnitudes only&#10;            import scipy.linalg as sla&#10;            elem_global_fef_magnitudes = sla.blas.dgemv(1.0, rotation_matrix.T, fef_magnitudes); print(elem_global_fef_magnitudes)&#10;            # print(f&quot;DEBUG: Using scipy.linalg.blas: {result_magnitudes.shape}&quot;)&#10;            # print(f&quot;DEBUG: Result magnitudes: {result_magnitudes}&quot;)&#10;            # Reattach original units&#10;            elem_global_fef = np.array([unit_manager.ureg.Quantity(mag, unit)&#10;                              for mag, unit in zip(elem_global_fef_magnitudes, fef_units)],&#10;                             dtype=object)&#10;            from pymaos_units import array_convert_to_unit_system&#10;            print(f&quot;FEFglobal for element {self.uid}:&quot;); _ = array_convert_to_unit_system(elem_global_fef, &quot;imperial&quot;)&#10;&#10;        else:&#10;            # If no units, proceed with standard matrix multiplication&#10;            elem_global_fef=np.matmul(np.transpose(rotation_matrix), local_fef)&#10;&#10;        self.fixed_end_forces_global[load_combination.name]=elem_global_fef&#10;        return elem_global_fef&#10;&#10;    def k(self, **kwargs):&#10;        &quot;&quot;&quot;Calculate the local stiffness matrix for the frame element&#10;        &#10;        Creates a 6x6 stiffness matrix with appropriate modifications&#10;        for hinges if present. The stiffness matrix includes terms for&#10;        axial, shear, and bending behavior.&#10;        &#10;              [ EA/L       0         0      -EA/L       0         0     ]&#10;              [   0     12EI/L   6EI/L      0      -12EI/L   6EI/L ]&#10;        [k] = [   0     6EI/L    4EI/L       0      -6EI/L    2EI/L  ]&#10;              [-EA/L       0         0       EA/L       0         0     ]&#10;              [   0    -12EI/L  -6EI/L      0       12EI/L  -6EI/L ]&#10;              [   0     6EI/L    2EI/L       0      -6EI/L    4EI/L  ]&#10;&#10;        Different matrices are used depending on hinge configuration:&#10;        - No hinges: Standard beam element&#10;        - Hinge at i-end: Modified for released moment at i&#10;        - Hinge at j-end: Modified for released moment at j&#10;        - Hinges at both ends: Truss-like behavior with no moment transfer&#10;        &#10;        Returns&#10;        -------&#10;        numpy.matrix&#10;            6x6 local stiffness matrix for the frame element&#10;        &quot;&quot;&quot;&#10;        E: pint.Quantity = self.material.E&#10;        Ixx = self.section.Ixx&#10;        A = self.section.Area&#10;        L = self.length&#10;&#10;        # Initialize matrix with zeros&#10;        k = np.zeros((6, 6), dtype=object)&#10;&#10;        # Common terms&#10;        AE_L = A * E / L&#10;&#10;        # Axial terms (common to all hinge configurations)&#10;        k[0, 0] = AE_L&#10;        k[3, 3] = AE_L&#10;        k[0, 3] = -AE_L&#10;        k[3, 0] = -AE_L&#10;&#10;        EI = E * Ixx&#10;        EI_L = EI / L&#10;        EI_L2 = EI_L / L&#10;        EI_L3 = EI_L2 / L&#10;&#10;        # Apply appropriate bending terms based on hinge configuration&#10;        if self.hinges == [1, 1]:  # Both ends hinged - only axial stiffness&#10;            pass  # No additional terms needed&#10;&#10;        elif self.hinges == [1, 0]:  # Hinge at i-end&#10;            k[1, 1] = 3 * EI_L3&#10;            k[4, 4] = 3 * EI_L3&#10;            k[1, 4] = -3 * EI_L3&#10;            k[4, 1] = -3 * EI_L3&#10;            k[1, 5] = 3 * EI_L2&#10;            k[5, 1] = 3 * EI_L2&#10;            k[4, 5] = -3 * EI_L2&#10;            k[5, 4] = -3 * EI_L2&#10;            k[5, 5] = 3 * EI_L&#10;&#10;        elif self.hinges == [0, 1]:  # Hinge at j-end&#10;            k[1, 1] = 3 * EI_L3&#10;            k[4, 4] = 3 * EI_L3&#10;            k[1, 2] = 3 * EI_L2&#10;            k[2, 1] = 3 * EI_L2&#10;            k[1, 4] = -3 * EI_L3&#10;            k[4, 1] = -3 * EI_L3&#10;            k[2, 4] = -3 * EI_L2&#10;            k[4, 2] = -3 * EI_L2&#10;            k[2, 2] = 3 * EI_L&#10;&#10;        else:  # No hinges - standard beam element&#10;            k[1, 1] = 12 * EI_L3&#10;            k[4, 4] = 12 * EI_L3&#10;            k[1, 2] = 6 * EI_L2&#10;            k[2, 1] = 6 * EI_L2&#10;            k[1, 4] = -12 * EI_L3&#10;            k[4, 1] = -12 * EI_L3&#10;            k[1, 5] = 6 * EI_L2&#10;            k[5, 1] = 6 * EI_L2&#10;            k[2, 2] = 4 * EI_L&#10;            k[2, 4] = -6 * EI_L2&#10;            k[4, 2] = -6 * EI_L2&#10;            k[2, 5] = 2 * EI_L&#10;            k[5, 2] = 2 * EI_L&#10;            k[4, 5] = -6 * EI_L2&#10;            k[5, 4] = -6 * EI_L2&#10;            k[5, 5] = 4 * EI_L&#10;&#10;        print(f&quot;Local stiffness matrix for element {self.uid} with hinges {self.hinges}:&quot;,)&#10;        # local_stiffness_matrix = np.matrix(k)&#10;        # print(f&quot;Local stiffness matrix for element {self.uid}:\n{local_stiffness_matrix}&quot;)&#10;&#10;        # # First try to get units from element's structure&#10;        # units_dict = None&#10;        #&#10;        # # Option 1: Check if element has direct reference to structure with units&#10;        # if hasattr(self, 'structure') and hasattr(self.structure, 'units'):&#10;        #     units_dict = self.structure.units&#10;        # else:            # Option 2: Use unit manager to get current units&#10;        #     &#10;        #     units_dict = unit_manager.get_current_units()&#10;        # # Get current unit system directly from the manager&#10;        #&#10;        # print(f&quot;Local stiffness matrix for element {self.uid}:{self.k_with_units()}\n&quot;)&#10;        #&#10;        # # self.display_stiffness_matrix_in_units(local_stiffness_matrix, units_dict)&#10;&#10;        return k&#10;&#10;    def Flocal(self, load_combination):&#10;        &quot;&quot;&quot;Calculate element end forces in the local coordinate system&#10;        &#10;        Computes the end forces by combining:&#10;        1. Forces due to nodal displacements (k*d)&#10;        2. Fixed end forces due to applied loads&#10;        &#10;        The result is stored in the end_forces_local dictionary.&#10;        &#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to calculate forces&#10;            &#10;        Notes&#10;        -----&#10;        This method calculates internal member forces in the element's local &#10;        coordinate system, which is oriented along the member's axis.&#10;        &quot;&quot;&quot;&#10;        Dlocal = self.set_displacement_local(load_combination.name)&#10;        Qf = np.reshape(self.FEF(load_combination), (-1, 1))&#10;        k = self.k()&#10;        k_with_units=self.k_with_units()&#10;        print(f&quot;Local stiffness matrix for element {self.uid} under load combination '{load_combination.name}':\n{k_with_units}&quot;)&#10;        FL = np.matmul(self.k(), Dlocal.T)&#10;&#10;        self.end_forces_local[load_combination.name] = FL + Qf&#10;&#10;    def set_end_forces_global(self, load_combination):&#10;        &quot;&quot;&quot;Calculate element end forces in the global coordinate system&#10;        &#10;        Computes the global end forces by combining:&#10;        1. Forces due to nodal displacements (KG*D)&#10;        2. Fixed end forces transformed to global coordinates&#10;        &#10;        The result is stored in the end_forces_global dictionary.&#10;        This method also updates the local end forces by calling Flocal().&#10;        &#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to calculate forces&#10;            &#10;        Returns&#10;        -------&#10;        numpy.ndarray&#10;            6-element vector of end forces in global coordinates:&#10;            [Fi_x, Fi_y, Mi_z, Fj_x, Fj_y, Mj_z]&#10;            where i = start node, j = end node&#10;        &quot;&quot;&quot;&#10;&#10;        print(f&quot;Calculating global displacements for element {self.uid} under load combination '{load_combination.name}'&quot;)&#10;        Dglobal = self.set_displacement_global(load_combination.name)&#10;&#10;        # global stiffness matrix&#10;        KG = self.kglobal()&#10;&#10;        # Replace np.matmul with scipy.linalg.blas.dgemv for proper vector handling&#10;        import scipy.linalg as sla&#10;&#10;        # Check if we're dealing with quantities with units&#10;        if True or isinstance(Dglobal[0], pint.Quantity):&#10;            # Store units for calculation&#10;            from pyMAOS.quantity_utils import quantity_array_to_numpy, extract_units_from_quantities&#10;            dglobal_units = extract_units_from_quantities(Dglobal)&#10;&#10;            # Extract magnitudes for calculation&#10;            kg_magnitudes = quantity_array_to_numpy(KG)&#10;            dglobal_magnitudes = quantity_array_to_numpy(Dglobal)&#10;&#10;            # Perform matrix-vector multiplication with SciPy BLAS&#10;            result_magnitudes = sla.blas.dgemv(1.0, kg_magnitudes, dglobal_magnitudes)&#10;            print(f&quot;DEBUG: Using scipy.linalg.blas for matrix-vector multiplication: shape={result_magnitudes.shape}&quot;)&#10;            &#10;            dglobal_units_conjugate = unit_manager.get_conjugate_units_array(dglobal_units)&#10;            # Reattach units to result&#10;            tmp_list = [unit_manager.ureg.Quantity(mag, unit)&#10;                        for mag, unit in zip(result_magnitudes, dglobal_units_conjugate)]&#10;            FG = np.array(tmp_list, dtype=object)&#10;        else:&#10;            # For non-quantity arrays, use scipy.linalg.blas directly&#10;            FG = sla.blas.dgemv(1.0, KG, Dglobal)&#10;&#10;        print(f&quot;Global end forces for element {self.uid} under load combination '{load_combination.name}':\n{FG}&quot;)&#10;&#10;        # Store the global end forces&#10;        # if not hasattr(self, 'end_forces_global'):&#10;        #     self.end_forces_global = {}&#10;        # print(&quot;FG:&quot;, FG, sep=&quot;\n&quot;)&#10;&#10;        if not load_combination.name in self.fixed_end_forces_global.keys():&#10;            fefg = self.FEFglobal(load_combination)&#10;        else:&#10;            fefg=self.fixed_end_forces_global[load_combination.name]&#10;        print(&quot;Qfg:&quot;, fefg, sep=&quot;\n&quot;)&#10;        print(f&quot;Global fixed end forces for element {self.uid} under load combination '{load_combination.name}':\n{fefg}&quot;)&#10;&#10;        # Combine global end forces with fixed end forces&#10;&#10;        from pyMAOS.quantity_utils import add_arrays_with_units&#10;&#10;        # Element-wise addition with proper unit handling&#10;        ret_val = add_arrays_with_units(FG, fefg)&#10;        print(f&quot;DEBUG: element {self.uid} ret_val={ret_val}&quot;)&#10;        self.end_forces_global[load_combination.name] = ret_val&#10;&#10;        # print(f&quot;End forces in local coordinates for element {self.uid} under load combination '{load_combination.name}':\n{self.end_forces_local.get(load_combination.name, 'Not calculated')}&quot;)&#10;        # self.Flocal(load_combination)&#10;&#10;        return self.end_forces_global[load_combination.name]&#10;&#10;    def stations(self, num_stations=10):&#10;        &quot;&quot;&quot;&#10;        Define evenly distributed points along the member to compute internal&#10;        actions. Additional points are generated for load application points.&#10;&#10;        This also generates a reduced set of points for use in the max/min&#10;        internal action functions.&#10;&#10;        :param num_stations: _description_, defaults to 10&#10;        :type num_stations: int, optional&#10;        &quot;&quot;&quot;&#10;&#10;        # parametric list of stations between 0 and 1'&#10;        eta = [0 + i * (1 / num_stations) for i in range(num_stations + 1)]&#10;&#10;        stations = [self.length * i for i in eta]&#10;        max_stations = [0, self.length]&#10;&#10;        if self._loaded:&#10;            extra_stations = []&#10;&#10;            for load in self.loads:&#10;                if (&#10;                    load.kind == &quot;POINT&quot;&#10;                    or load.kind == &quot;MOMENT&quot;&#10;                    or load.kind == &quot;AXIAL_POINT&quot;&#10;                ):&#10;                    b = min(self.length, load.a + 0.001)&#10;                    c = max(0, load.a - 0.001)&#10;                    extra_stations.extend([c, load.a, b])&#10;                    max_stations.extend([c, load.a, b])&#10;&#10;                elif load.kind == &quot;LINE&quot; or load.kind == &quot;AXIAL_LINE&quot;:&#10;                    c = min(self.length, load.b + 0.001)&#10;                    d = max(0, load.a - 0.001)&#10;                    extra_stations.extend([d, load.a, load.b, c])&#10;                    max_stations.extend([d, load.a, load.b, c])&#10;                else:&#10;                    pass&#10;&#10;            stations.extend(extra_stations)&#10;&#10;        stations.sort()&#10;        max_stations.sort()&#10;&#10;        # Make sure the first and last stations do not exceed the beam&#10;&#10;        if stations[0] &lt; 0:&#10;            stations[0] = 0&#10;&#10;        if stations[-1] &gt; self.length:&#10;            stations[-1] = self.length&#10;        &#10;        if max_stations[0] &lt; 0:&#10;            max_stations[0] = 0&#10;&#10;        if max_stations[-1] &gt; self.length:&#10;            max_stations[-1] = self.length&#10;&#10;        # Remove duplicate locations&#10;        self.calcstations = sorted(set(stations))&#10;        self.maxstations = sorted((set(max_stations)))&#10;&#10;        self._stations = True&#10;&#10;    def generate_Loading_function(self, load_combination):&#10;        &quot;&quot;&quot;Generate piecewise polynomial functions representing distributed loads&#10;    &#10;        Creates and stores piecewise polynomial functions for loads in both the x and y&#10;        directions by combining the load contributions from all applied loads that are&#10;        active in the specified load combination.&#10;    &#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to generate the loading functions&#10;        &#10;        Notes&#10;        -----&#10;        The resulting functions are stored in the instance dictionaries `self.Wx` &#10;        and `self.Wy` using the load combination name as the key. These functions &#10;        represent the applied load distribution before integration into shear, &#10;        moment, and deflection functions.&#10;    &#10;        Each load's contribution is scaled by its corresponding factor from the&#10;        load combination. Inactive loads (with factor=0) are skipped.&#10;    &#10;        These functions are primarily used for:&#10;        1. Visualization of applied loads&#10;        2. Input for generating internal force functions&#10;        3. Integration to produce shear, moment and deflection functions&#10;        &quot;&quot;&quot;&#10;        wy = loadtypes.PiecewisePolynomial()&#10;        wx = loadtypes.PiecewisePolynomial()&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;&#10;                if load_factor != 0:&#10;                    wx = wx.combine(load.Wx, 1, load_factor)&#10;                    wy = wy.combine(load.Wy, 1, load_factor)&#10;&#10;        self.Wx[load_combination.name] = wx&#10;        self.Wy[load_combination.name] = wy&#10;&#10;    def generate_Axial_function(self, load_combination):&#10;        empty_f = np.zeros((6, 1))&#10;&#10;        Fendlocal = self.end_forces_local.get(load_combination.name, empty_f)&#10;&#10;        # Empty Piecewise functions to build the total function from the loading&#10;        ax = loadtypes.PiecewisePolynomial()&#10;&#10;        # Create &quot;loads&quot; from the end forces and combine with dx and dy&#10;        fxi = loadtypes.R2_Axial_Load(Fendlocal[0, 0], 0, self)&#10;        fyi = loadtypes.R2_Point_Load(Fendlocal[1, 0], 0, self)&#10;        mzi = loadtypes.R2_Point_Moment(Fendlocal[2, 0], 0, self)&#10;        fxj = loadtypes.R2_Axial_Load(Fendlocal[3, 0], self.length, self)&#10;        fyj = loadtypes.R2_Point_Load(Fendlocal[4, 0], self.length, self)&#10;        mzj = loadtypes.R2_Point_Moment(Fendlocal[5, 0], self.length, self)&#10;&#10;        ax = ax.combine(fxi.Ax, 1, 1)&#10;        ax = ax.combine(fyi.Ax, 1, 1)&#10;        ax = ax.combine(mzi.Ax, 1, 1)&#10;        ax = ax.combine(fxj.Ax, 1, 1)&#10;        ax = ax.combine(fyj.Ax, 1, 1)&#10;        ax = ax.combine(mzj.Ax, 1, 1)&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;&#10;                if load_factor != 0:&#10;                    ax = ax.combine(load.Ax, 1, load_factor)&#10;&#10;        self.A[load_combination.name] = ax&#10;&#10;    def generate_Vy_function(self, load_combination):&#10;        empty_f = np.zeros((6, 1))&#10;&#10;        Fendlocal = self.end_forces_local.get(load_combination.name, empty_f)&#10;&#10;        # Empty Piecewise functions to build the total function from the loading&#10;        vy = loadtypes.PiecewisePolynomial()&#10;&#10;        # Create &quot;loads&quot; from the end forces and combine with dx and dy&#10;        fxi = loadtypes.R2_Axial_Load(Fendlocal[0, 0], 0, self)&#10;        fyi = loadtypes.R2_Point_Load(Fendlocal[1, 0], 0, self)&#10;        mzi = loadtypes.R2_Point_Moment(Fendlocal[2, 0], 0, self)&#10;        fxj = loadtypes.R2_Axial_Load(Fendlocal[3, 0], self.length, self)&#10;        fyj = loadtypes.R2_Point_Load(Fendlocal[4, 0], self.length, self)&#10;        mzj = loadtypes.R2_Point_Moment(Fendlocal[5, 0], self.length, self)&#10;&#10;        vy = vy.combine(fxi.Vy, 1, 1)&#10;        vy = vy.combine(fyi.Vy, 1, 1)&#10;        vy = vy.combine(mzi.Vy, 1, 1)&#10;        vy = vy.combine(fxj.Vy, 1, 1)&#10;        vy = vy.combine(fyj.Vy, 1, 1)&#10;        vy = vy.combine(mzj.Vy, 1, 1)&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;                if load_factor != 0:&#10;                    vy = vy.combine(load.Vy, 1, load_factor)&#10;&#10;        self.Vy[load_combination.name] = vy&#10;&#10;    def generate_Mz_function(self, load_combination):&#10;        empty_f = np.zeros((6, 1))&#10;&#10;        Fendlocal = self.end_forces_local.get(load_combination.name, empty_f)&#10;&#10;        # Empty Piecewise functions to build the total function from the loading&#10;        Mzx = loadtypes.PiecewisePolynomial()&#10;&#10;        # Create &quot;loads&quot; from the end forces and combine with dx and dy&#10;        fxi = loadtypes.R2_Axial_Load(Fendlocal[0, 0], 0, self)&#10;        fyi = loadtypes.R2_Point_Load(Fendlocal[1, 0], 0, self)&#10;        mzi = loadtypes.R2_Point_Moment(Fendlocal[2, 0], 0, self)&#10;        fxj = loadtypes.R2_Axial_Load(Fendlocal[3, 0], self.length, self)&#10;        fyj = loadtypes.R2_Point_Load(Fendlocal[4, 0], self.length, self)&#10;        mzj = loadtypes.R2_Point_Moment(Fendlocal[5, 0], self.length, self)&#10;&#10;        Mzx = Mzx.combine(fxi.Mz, 1, 1)&#10;        Mzx = Mzx.combine(fyi.Mz, 1, 1)&#10;        Mzx = Mzx.combine(mzi.Mz, 1, 1)&#10;        Mzx = Mzx.combine(fxj.Mz, 1, 1)&#10;        Mzx = Mzx.combine(fyj.Mz, 1, 1)&#10;        Mzx = Mzx.combine(mzj.Mz, 1, 1)&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;                if load_factor != 0:&#10;                    Mzx = Mzx.combine(load.Mz, 1, load_factor)&#10;&#10;        self.Mz[load_combination.name] = Mzx&#10;&#10;    def generate_Sz_function(self, load_combination):&#10;        empty_f = np.zeros((6, 1))&#10;&#10;        Fendlocal = self.end_forces_local.get(load_combination.name, empty_f)&#10;&#10;        # Empty Piecwise functions to build the total function from the loading&#10;        Szx = loadtypes.PiecewisePolynomial()&#10;&#10;        # Create &quot;loads&quot; from the end forces and combine with dx and dy&#10;        fxi = loadtypes.R2_Axial_Load(Fendlocal[0, 0], 0, self)&#10;        fyi = loadtypes.R2_Point_Load(Fendlocal[1, 0], 0, self)&#10;        mzi = loadtypes.R2_Point_Moment(Fendlocal[2, 0], 0, self)&#10;        fxj = loadtypes.R2_Axial_Load(Fendlocal[3, 0], self.length, self)&#10;        fyj = loadtypes.R2_Point_Load(Fendlocal[4, 0], self.length, self)&#10;        mzj = loadtypes.R2_Point_Moment(Fendlocal[5, 0], self.length, self)&#10;&#10;        Szx = Szx.combine(fxi.Sz, 1, 1)&#10;        Szx = Szx.combine(fyi.Sz, 1, 1)&#10;        Szx = Szx.combine(mzi.Sz, 1, 1)&#10;        Szx = Szx.combine(fxj.Sz, 1, 1)&#10;        Szx = Szx.combine(fyj.Sz, 1, 1)&#10;        Szx = Szx.combine(mzj.Sz, 1, 1)&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;                if load_factor != 0:&#10;                    Szx = Szx.combine(load.Sz, 1, load_factor)&#10;&#10;        self.Sz[load_combination.name] = Szx&#10;&#10;    def generate_DxDy_function(self, load_combination):&#10;        &quot;&quot;&quot;&#10;        Generate the piecewise displacement functions for the local x and y &#10;        axis. !!Note the nodal displacements are not included in these functions.&#10;&#10;        :param load_combination: load combination element&#10;        :type load_combination: _type_&#10;        &quot;&quot;&quot;&#10;&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        empty_f = np.zeros((6, 1))&#10;&#10;        Fendlocal = self.end_forces_local.get(load_combination.name, empty_f)&#10;&#10;        # Empty Piecwise functions to build the total function from the loading&#10;        dx = loadtypes.PiecewisePolynomial()&#10;        dy = loadtypes.PiecewisePolynomial()&#10;&#10;        # Create &quot;loads&quot; from the end forces and combine with dx and dy&#10;        fxi = loadtypes.R2_Axial_Load(Fendlocal[0, 0], 0, self)&#10;        fyi = loadtypes.R2_Point_Load(Fendlocal[1, 0], 0, self)&#10;        mzi = loadtypes.R2_Point_Moment(Fendlocal[2, 0], 0, self)&#10;        fxj = loadtypes.R2_Axial_Load(Fendlocal[3, 0], self.length, self)&#10;        fyj = loadtypes.R2_Point_Load(Fendlocal[4, 0], self.length, self)&#10;        mzj = loadtypes.R2_Point_Moment(Fendlocal[5, 0], self.length, self)&#10;&#10;        dx = dx.combine(fxi.Dx, 1, 1)&#10;        dy = dy.combine(fyi.Dy, 1, 1)&#10;        dy = dy.combine(mzi.Dy, 1, 1)&#10;        dx = dx.combine(fxj.Dx, 1, 1)&#10;        dy = dy.combine(fyj.Dy, 1, 1)&#10;        dy = dy.combine(mzj.Dy, 1, 1)&#10;&#10;        # Combine Piecewise Deflection Functions of all of the loads&#10;        if self._loaded:&#10;            for load in self.loads:&#10;                load_factor = load_combination.factors.get(load.loadcase, 0)&#10;&#10;                if load_factor != 0:&#10;                    dx = dx.combine(load.Dx, 1, load_factor)&#10;                    dy = dy.combine(load.Dy, 1, load_factor)&#10;&#10;        self.Dx[load_combination.name] = dx&#10;        self.Dy[load_combination.name] = dy&#10;&#10;    def Wxlocal_plot(self, load_combination, scale=1, ptloadscale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        wx = self.Wx.get(load_combination.name, None)&#10;&#10;        if wx is None:&#10;            self.generate_Loading_function(load_combination)&#10;            wx = self.Wx.get(load_combination.name, None)&#10;&#10;        wxlocal_span = np.zeros((len(self.calcstations), 2))&#10;&#10;        for i, x in enumerate(self.calcstations):&#10;            w = wx.evaluate(x)&#10;&#10;            wp = 0&#10;&#10;            for load in self.loads:&#10;                if load.kind == &quot;AXIAL_POINT&quot;:&#10;                    if load.a == x:&#10;                        load_factor = load_combination.factors.get(load.loadcase, 0)&#10;                        wp += load_factor * load.p&#10;&#10;            wxlocal_span[i, 0] = x&#10;            wxlocal_span[i, 1] = w * scale + (wp * ptloadscale)&#10;&#10;        return wxlocal_span&#10;&#10;    def Wxglobal_plot(self, load_combination, scale=1, ptloadscale=1):&#10;        wxlocal_plot = self.Wxlocal_plot(&#10;            load_combination, scale=scale, ptloadscale=ptloadscale&#10;        )&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        wxglobal_plot = np.matmul(wxlocal_plot, R)&#10;&#10;        return wxglobal_plot&#10;&#10;    def Wylocal_plot(self, load_combination, scale=1, ptloadscale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        wy = self.Wy.get(load_combination.name, None)&#10;&#10;        if wy is None:&#10;            self.generate_Loading_function(load_combination)&#10;            wy = self.Wy.get(load_combination.name, None)&#10;&#10;        wylocal_span = np.zeros((len(self.calcstations), 2))&#10;&#10;        for i, x in enumerate(self.calcstations):&#10;            w = wy.evaluate(x)&#10;&#10;            wp = 0&#10;&#10;            for load in self.loads:&#10;                if load.kind == &quot;POINT&quot;:&#10;                    if load.a == x:&#10;                        load_factor = load_combination.factors.get(load.loadcase, 0)&#10;                        wp += load_factor * load.p&#10;&#10;            wylocal_span[i, 0] = x&#10;            wylocal_span[i, 1] = (w * scale) + (wp * ptloadscale)&#10;&#10;        return wylocal_span&#10;&#10;    def Wyglobal_plot(self, load_combination, scale=1, ptloadscale=1):&#10;        wylocal_plot = self.Wylocal_plot(&#10;            load_combination, scale=scale, ptloadscale=ptloadscale&#10;        )&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        wyglobal_plot = np.matmul(wylocal_plot, R)&#10;&#10;        return wyglobal_plot&#10;&#10;    def Alocal_plot(self, load_combination, scale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        ax = self.A.get(load_combination.name, None)&#10;&#10;        if ax is None:&#10;            self.generate_Axial_function(load_combination)&#10;            ax = self.A.get(load_combination.name, None)&#10;&#10;        axlocal_span = np.zeros((len(self.calcstations), 2))&#10;&#10;        for i, x in enumerate(self.calcstations):&#10;            a = ax.evaluate(x)&#10;&#10;            axlocal_span[i, 0] = x&#10;            axlocal_span[i, 1] = a * scale&#10;&#10;        return axlocal_span&#10;&#10;    def Aglobal_plot(self, load_combination, scale):&#10;        axlocal_plot = self.Alocal_plot(load_combination, scale=scale)&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        axglobal_plot = np.matmul(axlocal_plot, R)&#10;&#10;        return axglobal_plot&#10;&#10;    def Vlocal_plot(self, load_combination, scale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        vy = self.Vy.get(load_combination.name, None)&#10;&#10;        if vy is None:&#10;            self.generate_Vy_function(load_combination)&#10;            vy = self.Vy.get(load_combination.name, None)&#10;&#10;        vlocal_span = np.zeros((len(self.calcstations), 2))&#10;&#10;        for i, x in enumerate(self.calcstations):&#10;            v = vy.evaluate(x)&#10;&#10;            vlocal_span[i, 0] = x&#10;            vlocal_span[i, 1] = v * scale&#10;&#10;        return vlocal_span&#10;&#10;    def Vglobal_plot(self, load_combination, scale):&#10;        vlocal_plot = self.Vlocal_plot(load_combination, scale=scale)&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        vglobal_plot = np.matmul(vlocal_plot, R)&#10;&#10;        return vglobal_plot&#10;&#10;    def Mlocal_plot(self, load_combination, scale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        mzx = self.Mz.get(load_combination.name, None)&#10;&#10;        if mzx is None:&#10;            self.generate_Mz_function(load_combination)&#10;            mzx = self.Mz.get(load_combination.name, None)&#10;&#10;        # Get the Roots of the shear function for the current combo&#10;        vy = self.Vy.get(load_combination.name, None)&#10;&#10;        if vy is None:&#10;            self.generate_Vy_function(load_combination)&#10;            vy = self.Vy.get(load_combination.name, None)&#10;&#10;        shear_roots = vy.roots()&#10;        # Generate a new station list including the roots&#10;        stations = sorted(set(self.calcstations + shear_roots))&#10;&#10;        mlocal_span = np.zeros((len(stations), 2))&#10;&#10;        for i, x in enumerate(stations):&#10;            m = mzx.evaluate(x)&#10;&#10;            mlocal_span[i, 0] = x&#10;            mlocal_span[i, 1] = m * scale&#10;&#10;        return mlocal_span&#10;&#10;    def Mglobal_plot(self, load_combination, scale):&#10;        mlocal_plot = self.Mlocal_plot(load_combination, scale=scale)&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        mglobal_plot = np.matmul(mlocal_plot, R)&#10;&#10;        return mglobal_plot&#10;&#10;    def Slocal_plot(self, load_combination, scale=1):&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        Szx = self.Sz.get(load_combination.name, None)&#10;&#10;        if Szx is None:&#10;            self.generate_Sz_function(load_combination)&#10;            Szx = self.Sz.get(load_combination.name, None)&#10;&#10;        slocal_span = np.zeros((len(self.calcstations), 2))&#10;        # slope adjustment for end displacements&#10;        Dlocal = self.set_displacement_local(load_combination)&#10;&#10;        sadjust = (Dlocal[0, 4] - Dlocal[0, 1]) / self.length&#10;&#10;        for i, x in enumerate(self.calcstations):&#10;            s = Szx.evaluate(x)&#10;&#10;            slocal_span[i, 0] = x&#10;            slocal_span[i, 1] = (s + sadjust) * scale&#10;&#10;        return slocal_span&#10;&#10;    def Sglobal_plot(self, load_combination, scale):&#10;        slocal_plot = self.Slocal_plot(load_combination, scale=scale)&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        sglobal_plot = np.matmul(slocal_plot, R)&#10;&#10;        return sglobal_plot&#10;&#10;    def Dlocal_plot(self, load_combination, scale=1):&#10;        dx = self.Dx.get(load_combination.name, None)&#10;        dy = self.Dy.get(load_combination.name, None)&#10;&#10;        if dx is None or dy is None:&#10;            self.generate_DxDy_function(load_combination)&#10;            dx = self.Dx.get(load_combination.name, None)&#10;            dy = self.Dy.get(load_combination.name, None)&#10;&#10;        Dlocal = self.set_displacement_local(load_combination)&#10;&#10;        # Parametric Functions defining a linear relationship for deflection&#10;        # in each axis based on the Ux and Uy nodal displacements&#10;        Dx = lambda x: Dlocal[0, 0] + (x / self.length) * (Dlocal[0, 3] - Dlocal[0, 0])&#10;        Dy = lambda x: Dlocal[0, 1] + (x / self.length) * (Dlocal[0, 4] - Dlocal[0, 1])&#10;&#10;        # Get the Roots of the slope function for the current combo&#10;        sz = self.Sz.get(load_combination.name, None)&#10;&#10;        if sz is None:&#10;            self.generate_Sz_function(load_combination)&#10;            sz = self.Sz.get(load_combination.name, None)&#10;&#10;        slope_roots = sz.roots()&#10;        # Generate a new station list including the roots&#10;        stations = sorted(set(self.calcstations + slope_roots))&#10;&#10;        dlocal_span = np.zeros((len(stations), 2))&#10;&#10;        for i, x in enumerate(stations):&#10;            dxl = dx.evaluate(x) + Dx(0)&#10;            dyl = dy.evaluate(x) + Dy(x)&#10;&#10;            dlocal_span[i, 0] = x + (dxl * scale)&#10;            dlocal_span[i, 1] = dyl * scale&#10;&#10;        return dlocal_span&#10;&#10;    def Dglobal_plot(self, load_combination, scale=1):&#10;        dlocal_plot = self.Dlocal_plot(load_combination, scale=scale)&#10;&#10;        c = (self.jnode.x - self.inode.x) / self.length&#10;        s = (self.jnode.y - self.inode.y) / self.length&#10;&#10;        R = np.matrix([[c, s], [-s, c]])&#10;&#10;        dglobal_plot = np.matmul(dlocal_plot, R)&#10;&#10;        return dglobal_plot&#10;    &#10;    def Mzextremes(self, load_combination):&#10;        &quot;&quot;&quot;Find maximum and minimum bending moment values along the element&#10;    &#10;        Calculates the extreme moment values by:&#10;        1. Evaluating the moment at predefined stations along the element&#10;        2. Finding zeros of the shear force function (where moment extremes occur)&#10;        3. Checking moment values at all critical points&#10;    &#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to calculate extreme moments&#10;        &#10;        Returns&#10;        -------&#10;        dict&#10;            Dictionary containing extreme moment values and their locations:&#10;            - 'MaxM': [position, value] - Maximum positive moment&#10;            - 'MinM': [position, value] - Maximum negative moment&#10;        &#10;        Notes&#10;        -----&#10;        This method is crucial for structural design as the extreme moment values&#10;        are needed for member capacity checks. The zeros of the shear function&#10;        are included as these are the locations where moments reach local extremes.&#10;        &quot;&quot;&quot;&#10;        if not self._stations:&#10;            self.stations()&#10;&#10;        mzx = self.Mz.get(load_combination.name, None)&#10;&#10;        if mzx is None:&#10;            self.generate_Mz_function(load_combination)&#10;            mzx = self.Mz.get(load_combination.name, None)&#10;&#10;        # Get the Roots of the shear force function for the current combo&#10;        vy = self.Vy.get(load_combination.name, None)&#10;&#10;        if vy is None:&#10;            self.generate_Vy_function(load_combination)&#10;            vy = self.Vy.get(load_combination.name, None)&#10;&#10;        shear_roots = vy.roots()&#10;        # Generate a new station list including the roots&#10;        stations = sorted(set(self.maxstations + shear_roots))&#10;        maxM = [0,0]&#10;        minM = [0,0]&#10;&#10;        for x in stations:&#10;            m = mzx.evaluate(x)&#10;            maxM[1] = max(maxM[1],m)&#10;            minM[1] = min(minM[1],m)&#10;            if maxM[1] == m:&#10;                maxM[0] = x&#10;            if minM[1] == m:&#10;                minM[0] = x&#10;        &#10;        return {&quot;MaxM&quot;:maxM,&quot;MinM&quot;:minM}&#10;&#10;    def validate_hinges(self):&#10;        &quot;&quot;&quot;&#10;        Validates that hinges are correctly applied based on the node restraints.&#10;        Raises an error if there is a conflict.&#10;        &quot;&quot;&quot;&#10;        # Check i-node (start node)&#10;        if self.hinges[0] == 1 and self.inode.restraints[2] == 1:&#10;            raise ValueError(&#10;                f&quot;Conflict: Hinge applied at i-node (UID: {self.inode.uid}) of frame (UID: {self.uid}), &quot;&#10;                f&quot;but the node is rotationally restrained (Rz = 1).&quot;&#10;            )&#10;&#10;        # Check j-node (end node)&#10;        if self.hinges[1] == 1 and self.jnode.restraints[2] == 1:&#10;            raise ValueError(&#10;                f&quot;Conflict: Hinge applied at j-node (UID: {self.jnode.uid}) of frame (UID: {self.uid}), &quot;&#10;                f&quot;but the node is rotationally restrained (Rz = 1).&quot;&#10;            )&#10;&#10;    @property&#10;    def has_distributed_loads(self):&#10;        &quot;&quot;&quot;Check if element has any distributed loads applied&quot;&quot;&quot;&#10;        return any(load.kind == &quot;LINE&quot; or load.kind == &quot;AXIAL_LINE&quot; for load in self.loads) if self.loads else False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/load_frame_from_file.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/load_frame_from_file.py" />
              <option name="originalContent" value="from ast import Constant&#10;import os&#10;from os import path&#10;import sys&#10;&#10;import numpy as np&#10;from contextlib import redirect_stdout&#10;import pint&#10;&#10;from PyQt6 import QtQml  # Import the module without the non-existent kwargs&#10;from rx.subject.subject import Subject&#10;from rx import operators as ops&#10;import rx&#10;import logging  # Add logging module&#10;&#10;from pprint import pprint&#10;&#10;def is_class_imported(class_name):&#10;    &quot;&quot;&quot;&#10;    Check if a class has been imported in the current namespace&#10;    &#10;    Parameters&#10;    ----------&#10;    class_name : str&#10;        Name of the class to check&#10;        &#10;    Returns&#10;    -------&#10;    bool&#10;        True if class exists, False otherwise&#10;    &quot;&quot;&quot;&#10;    return class_name in globals() or class_name in locals()&#10;&#10;&#10;def check_class_exists(class_name):&#10;    &quot;&quot;&quot;Check if a class is available in the current namespace&quot;&quot;&quot;&#10;    try:&#10;        # Try to evaluate the class name&#10;        return eval(class_name) is not None&#10;    except (NameError, AttributeError):&#10;        return False&#10;&#10;&#10;def is_class_available_from_module(module_name, class_name):&#10;    &quot;&quot;&quot;Check if a class is available from a specific imported module&quot;&quot;&quot;&#10;    import sys&#10;&#10;    # Check if module is imported&#10;    if module_name not in sys.modules:&#10;        return False&#10;&#10;    # Get the module object&#10;    module = sys.modules[module_name]&#10;&#10;    # Check if class exists in module&#10;    return hasattr(module, class_name)&#10;&#10;&#10;def list_imported_classes(module_filter=None):&#10;    &quot;&quot;&quot;&#10;    List all classes that have been imported in the current Python script&#10;    &#10;    Parameters&#10;    ----------&#10;    module_filter : str or list of str, optional&#10;        Filter classes by module name prefix (e.g., 'pyMAOS' or ['pyMAOS', 'numpy'])&#10;        &#10;    Returns&#10;    -------&#10;    dict&#10;        Dictionary mapping class names to their module names&#10;    &quot;&quot;&quot;&#10;    import inspect&#10;    import sys&#10;&#10;    # Normalize filter to a list&#10;    if module_filter is None:&#10;        filters = None&#10;    elif isinstance(module_filter, str):&#10;        filters = [module_filter]&#10;    else:&#10;        filters = list(module_filter)&#10;&#10;    classes_dict = {}&#10;&#10;    # Check global namespace&#10;    for name, obj in globals().items():&#10;        if inspect.isclass(obj):&#10;            module = inspect.getmodule(obj)&#10;            if module:&#10;                module_name = module.__name__&#10;                if filters is None or any(module_name.startswith(m) for m in filters):&#10;                    classes_dict[name] = module_name&#10;&#10;    # Check modules in sys.modules&#10;    for module_name, module in sys.modules.items():&#10;        # Skip None modules or if filtering is active and module doesn't match&#10;        if module is None:&#10;            continue&#10;        if filters and not any(module_name.startswith(m) for m in filters):&#10;            continue&#10;&#10;        try:&#10;            for name, obj in inspect.getmembers(module, inspect.isclass):&#10;                # Only include if defined in this module (not imported into it)&#10;                if hasattr(obj, '__module__') and obj.__module__ == module_name:&#10;                    classes_dict[name] = module_name&#10;        except:&#10;            # Some modules might raise errors when inspected&#10;            raise Warning(f&quot;Could not inspect module {module_name}. It may not be a valid Python module or may not support introspection.&quot;)&#10;            pass&#10;&#10;    return classes_dict&#10;&#10;&#10;# Example usage:&#10;def print_imported_classes(module_filter=None):&#10;    &quot;&quot;&quot;Print imported classes in a formatted table&quot;&quot;&quot;&#10;    classes = list_imported_classes(module_filter)&#10;&#10;    print(f&quot;\n{'Class Name':&lt;30} | {'Module'}&quot;)&#10;    print(&quot;-&quot; * 60)&#10;&#10;    for name, module in sorted(classes.items()):&#10;        print(f&quot;{name:&lt;30} | {module}&quot;)&#10;&#10;    print(f&quot;\nTotal: {len(classes)} classes found&quot;)&#10;&#10;&#10;# Alternative: show all imported classes&#10;# print_imported_classes()&#10;&#10;from pyMAOS.logger import setup_logger&#10;&#10;# Import all unit-related functionality from units.py module&#10;from pyMAOS.units_mod import (&#10;    unit_manager,&#10;    # FORCE_UNIT, LENGTH_UNIT, MOMENT_UNIT, PRESSURE_UNIT, DISTRIBUTED_LOAD_UNIT,  # Display units&#10;    # INTERNAL_FORCE_UNIT, INTERNAL_LENGTH_UNIT, INTERNAL_MOMENT_UNIT, INTERNAL_PRESSURE_UNIT,  # Internal units&#10;    # INTERNAL_DISTRIBUTED_LOAD_UNIT, INTERNAL_PRESSURE_UNIT_EXPANDED,  # More internal units&#10;    update_units_from_json,  set_unit_system, INTERNAL_DISTRIBUTED_LOAD_UNIT  # Functions&#10;)&#10;&#10;# from pyMAOS.units_mod import SI_UNITS, IMPERIAL_UNITS, METRIC_KN_UNITS&#10;&#10;# Import other modules&#10;from pyMAOS.structure2d_plot import plot_structure_vtk&#10;from pyMAOS.node2d import R2Node&#10;from pyMAOS.frame2d import R2Frame&#10;from pyMAOS.material import LinearElasticMaterial as Material&#10;from pyMAOS.section import Section&#10;&#10;from pyMAOS.loadcombos import LoadCombo&#10;&#10;from pyMAOS.load_utils import LoadConverter&#10;&#10;default_scaling = {&#10;    &quot;axial_load&quot;: 100,&#10;    &quot;normal_load&quot;: 100,&#10;    &quot;point_load&quot;: 1,&#10;    &quot;axial&quot;: 2,&#10;    &quot;shear&quot;: 2,&#10;    &quot;moment&quot;: 0.1,&#10;    &quot;rotation&quot;: 5000,&#10;    &quot;displacement&quot;: 100,&#10;}&#10;&#10;&#10;def load_frame_from_file(filename, logger=None, schema_file=None, show_vtk=False):&#10;    &quot;&quot;&quot;&#10;    Reads a structural model from a JSON or YAML file and creates nodes and elements in SI units&#10;    &#10;    Parameters&#10;    ----------&#10;    filename : str&#10;        Path to the input file (JSON or YAML format)&#10;    logger : logging.Logger, optional&#10;        Logger object for output&#10;    schema_file : str, optional&#10;        Path to JSON schema for validation (only used for JSON files)&#10;    show_vtk : bool, optional&#10;        Whether to show VTK plot of the structure&#10;    &#10;    Returns&#10;    -------&#10;    tuple&#10;        (node_list, element_list) ready for structural analysis, all in SI units&#10;    &quot;&quot;&quot;&#10;&#10;    # Use print or logger.info based on what's available&#10;    def log(message):&#10;        if logger:&#10;            logger.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    # Import the unit_manager directly from the module&#10;    from pyMAOS.units_mod import unit_manager&#10;&#10;    log(f&quot;Using UnitManager registry with id: {id(unit_manager.ureg)}&quot;)&#10;        &#10;    # Check file extension to determine format&#10;    file_ext = os.path.splitext(filename)[1].lower()&#10;&#10;    # Create reactive subjects for key data&#10;    model_data = Subject()&#10;    nodes_subject = Subject()&#10;    elements_subject = Subject()&#10;    results_subject = Subject()&#10;&#10;    # Load data from file based on format&#10;    if file_ext in ['.yml', '.yaml']:&#10;        try:&#10;            import yaml&#10;            log(f&quot;Loading YAML file: {filename}&quot;)&#10;            with open(filename, 'r') as file:&#10;                data = yaml.safe_load(file)&#10;            log(&quot;YAML file loaded successfully&quot;)&#10;        except ImportError:&#10;            log(&quot;Error: PyYAML package not found. Install it using: pip install pyyaml&quot;)&#10;            raise&#10;        except Exception as e:&#10;            log(f&quot;Error loading YAML file: {e}&quot;)&#10;            raise&#10;    else:  # Default to JSON&#10;        log(f&quot;Loading JSON file: {filename}&quot;)&#10;        import json&#10;        # Validate JSON file if schema_file is provided&#10;        if schema_file:&#10;            try:&#10;                from pyMAOS.json_utils import validate_input_with_schema&#10;                validate_input_with_schema(filename, schema_file=schema_file)&#10;                log(&quot;JSON validation passed!&quot;)&#10;            except Exception as e:&#10;                log(f&quot;Warning: JSON validation failed: {e}&quot;)&#10;&#10;        # Load JSON data&#10;        with open(filename, 'r', encoding='utf-8') as file:&#10;            data = json.load(file)&#10;&#10;    # Process nodes - always convert to SI units (meters)&#10;    nodes_dict = {}&#10;    for node_data in data.get(&quot;nodes&quot;, []):&#10;        node_id = node_data[&quot;id&quot;]&#10;&#10;        # Use unit_manager to parse coordinates with potential units&#10;        x = unit_manager.parse_value(str(node_data[&quot;x&quot;]))&#10;        y = unit_manager.parse_value(str(node_data[&quot;y&quot;]))&#10;&#10;        # Convert to meters if units are specified&#10;        x_meters = x.to('m').magnitude if isinstance(x, pint.Quantity) else x&#10;        y_meters = y.to('m').magnitude if isinstance(y, pint.Quantity) else y&#10;&#10;        node = R2Node(node_id, x_meters, y_meters)&#10;        nodes_dict[node_id] = node&#10;&#10;    log(f&quot;Read {len(nodes_dict)} nodes.&quot;)&#10;    log(str(nodes_dict))&#10;&#10;    # Process supports&#10;    for support_data in data.get(&quot;supports&quot;, []):&#10;        node_id = support_data[&quot;node&quot;]&#10;        rx = support_data[&quot;rx&quot;]&#10;        ry = support_data[&quot;ry&quot;]&#10;        rz = support_data[&quot;rz&quot;]&#10;&#10;        if node_id in nodes_dict:&#10;            nodes_dict[node_id].restraints = [rx, ry, rz]&#10;            log(f&quot;Node {node_id} supports: rx={rx}, ry={ry}, rz={rz}&quot;)&#10;&#10;    # Process materials&#10;    materials_dict = {}&#10;    try:&#10;        materials_yml = os.path.join(os.path.dirname(filename), &quot;materials.yml&quot;)&#10;        if not os.path.exists(materials_yml):&#10;            materials_yml = os.path.join(&quot;materials.yml&quot;)&#10;&#10;        log(f&quot;Loading materials from: {materials_yml}&quot;)&#10;        with open(materials_yml, 'r') as file:&#10;            # Use unsafe_load to allow object instantiation&#10;            import yaml&#10;            materials_list = yaml.unsafe_load(file)&#10;&#10;        # Convert list to dictionary using uid as key&#10;        for material in materials_list:&#10;            materials_dict[material.uid] = material&#10;        log(f&quot;Loaded {len(materials_dict)} materials&quot;)&#10;    except Exception as e:&#10;        log(f&quot;Error loading materials: {e}&quot;)&#10;        raise&#10;&#10;    # Process sections&#10;    sections_dict = {}&#10;    try:&#10;        sections_yml = os.path.join(os.path.dirname(filename), &quot;sections.yml&quot;)&#10;        if not os.path.exists(sections_yml):&#10;            sections_yml = os.path.join(&quot;sections.yml&quot;)&#10;&#10;        log(f&quot;Loading sections from: {sections_yml}&quot;)&#10;        with open(sections_yml, 'r') as file:&#10;            # Use unsafe_load to allow object instantiation&#10;            sections_list = yaml.unsafe_load(file)&#10;&#10;        # Convert list to dictionary using uid as key&#10;        for section in sections_list:&#10;            sections_dict[section.uid] = section&#10;        log(f&quot;Loaded {len(sections_dict)} sections&quot;)&#10;    except Exception as e:&#10;        log(f&quot;Error loading sections: {e}&quot;)&#10;        raise&#10;&#10;    # Process members/elements&#10;    element_list = []&#10;    elements_dict = {}&#10;    for member_data in data.get(&quot;members&quot;, []):&#10;        member_id = member_data[&quot;id&quot;]&#10;        i_node = member_data[&quot;i_node&quot;]&#10;&#10;        inode=nodes_dict[i_node]&#10;        inode.is_inode_of_elem_ids.append(member_id)&#10;&#10;&#10;        j_node = member_data[&quot;j_node&quot;]&#10;        jnode = nodes_dict[j_node]&#10;        jnode.is_jnode_of_elem_ids.append(member_id)&#10;&#10;&#10;        mat_id = member_data[&quot;material&quot;]&#10;        sec_id = member_data[&quot;section&quot;]&#10;&#10;        # Create frame element&#10;        element = R2Frame(&#10;            uid=member_id,&#10;            inode=nodes_dict[i_node],&#10;            jnode=nodes_dict[j_node],&#10;            material=materials_dict[mat_id],&#10;            section=sections_dict[sec_id]&#10;        )&#10;        element_list.append(element)&#10;        elements_dict[member_id] = element&#10;&#10;        inode.is_inode_of_elems.append(element); jnode.is_inode_of_elems.append(element)&#10;&#10;    log(f&quot;Read {len(element_list)} elements.&quot;)&#10;&#10;    # Process joint loads - always convert to SI units&#10;    for joint_load in data.get(&quot;joint_loads&quot;, []):&#10;        node_id = joint_load[&quot;node&quot;]&#10;&#10;        # Parse forces with potential units&#10;        fx_with_units = unit_manager.parse_value(str(joint_load.get(&quot;fx&quot;, 0)))&#10;        fy_with_units = unit_manager.parse_value(str(joint_load.get(&quot;fy&quot;, 0)))&#10;        mz_with_units = unit_manager.parse_value(str(joint_load.get(&quot;mz&quot;, 0)))&#10;&#10;        # Convert to SI units (Newtons, Newton-meters)&#10;        fx = fx_with_units.to('N').magnitude if isinstance(fx_with_units, pint.Quantity) else fx_with_units&#10;        fy = fy_with_units.to('N').magnitude if isinstance(fy_with_units, pint.Quantity) else fy_with_units&#10;        mz = mz_with_units.to('N*m').magnitude if isinstance(mz_with_units, pint.Quantity) else mz_with_units&#10;&#10;        if node_id in nodes_dict:&#10;            # Store in SI units&#10;            nodes_dict[node_id].add_nodal_load(fx, fy, mz, &quot;D&quot;)&#10;            log(f&quot;Node {node_id} load: Fx={fx:.4g} N, Fy={fy:.4g} N, Mz={mz:.4g} N*m&quot;)&#10;&#10;    # Import the necessary load classes&#10;    from pyMAOS.loading import R2_Point_Load, LinearLoadXY, R2_Axial_Load, R2_Axial_Linear_Load, R2_Point_Moment&#10;&#10;    log(f&quot;\nProcessing {len(data.get('member_loads', []))} member loads:&quot;)&#10;&#10;    # Process member loads - always convert to SI units&#10;    for member_load in data.get(&quot;member_loads&quot;, []):&#10;&#10;        pprint(member_load)&#10;        element_id = member_load[&quot;member_uid&quot;]&#10;        load_type = member_load[&quot;load_type&quot;]&#10;&#10;        if element_id not in elements_dict:&#10;            log(f&quot;Warning: Member load specified for non-existent element {element_id}&quot;)&#10;            continue&#10;&#10;        element = elements_dict[element_id]&#10;        load_case = member_load.get(&quot;case&quot;, &quot;D&quot;)&#10;        direction = member_load.get(&quot;direction&quot;, &quot;Y&quot;).upper()&#10;&#10;        if load_type == 3:  # Distributed load&#10;            # Extract load intensity parameters with unit conversion&#10;            from pyMAOS.units_mod import INTERNAL_LENGTH_UNIT, INTERNAL_DISTRIBUTED_LOAD_UNIT&#10;            w1_with_units = unit_manager.parse_value(str(member_load.get(&quot;wi&quot;, 0))).to(INTERNAL_DISTRIBUTED_LOAD_UNIT)&#10;&#10;            if &quot;wj&quot; in member_load:&#10;                w2_with_units = unit_manager.parse_value(str(member_load[&quot;wj&quot;])).to(INTERNAL_DISTRIBUTED_LOAD_UNIT)&#10;            else:&#10;                w2_with_units = w1_with_units&#10;&#10;            # Get positions - check for percentage parameters first&#10;            if &quot;a_pct&quot; in member_load:&#10;                a_pct = float(member_load[&quot;a_pct&quot;])&#10;                a_with_units = a_pct / 100.0 * element.length&#10;                log(f&quot;  Using a_pct={a_pct}%  position a={a_with_units:.4f}&quot;)&#10;            else:&#10;                a_with_units = unit_manager.parse_value(str(member_load[&quot;a&quot;])).to(INTERNAL_LENGTH_UNIT)&#10;&#10;            if &quot;b_pct&quot; in member_load:&#10;                b_pct = float(member_load[&quot;b_pct&quot;])&#10;                b_with_units = b_pct / 100.0 * element.length&#10;                log(f&quot;  Using b_pct={b_pct}%  position b={b_with_units:.4f}&quot;)&#10;            else:&#10;                b_with_units = unit_manager.parse_value(member_load.get(&quot;b&quot;, element.length)).to(INTERNAL_LENGTH_UNIT)&#10;&#10;            element.add_distributed_load(w1_with_units, w2_with_units, a_with_units, b_with_units, load_case, direction=direction)&#10;&#10;        elif load_type == 1:  # Point load&#10;            # Parse force magnitude with unit conversion&#10;            from pyMAOS.units_mod import INTERNAL_LENGTH_UNIT, INTERNAL_FORCE_UNIT&#10;            p_with_units = unit_manager.parse_value(str(member_load.get(&quot;p&quot;, 0))).to(INTERNAL_FORCE_UNIT)&#10;            # Parse position - use percentage value if available&#10;            if &quot;a_pct&quot; in member_load:&#10;                a_pct = float(member_load[&quot;a_pct&quot;])&#10;                a_with_units = a_pct / 100.0 * element.length&#10;            else:&#10;                a_with_units = unit_manager.parse_value(str(member_load[&quot;a&quot;])).to(INTERNAL_LENGTH_UNIT)&#10;            if a_with_units &gt; element.length:&#10;                log(f&quot;Warning: Point load position {a_with_units} exceeds element length {element.length}. Clamping to length.&quot;)&#10;                a_with_units = element.length&#10;            # Remove b_with_units if it exists&#10;            if 'b_with_units' in locals():&#10;                del b_with_units&#10;&#10;            # Apply the load to the element with correct direction&#10;            if direction == &quot;X&quot;:&#10;                element.add_point_load(p_with_units, a_with_units, load_case, direction=&quot;xx&quot;)&#10;            else:&#10;                element.add_point_load(p_with_units, a_with_units, load_case)&#10;&#10;        elif load_type == 2:  # Point moment&#10;            # Parse moment magnitude with unit conversion&#10;            m_with_units = unit_manager.parse_value(str(member_load.get(&quot;m&quot;, 0)))&#10;&#10;            # Parse position - use percentage value if available&#10;            if &quot;a_pct&quot; in member_load:&#10;                a_pct = float(member_load[&quot;a_pct&quot;])&#10;                a = a_pct / 100.0 * element.length&#10;            else:&#10;                a = float(member_load.get(&quot;a&quot;, 0.0))&#10;&#10;            # Convert to SI units (Nm)&#10;            m = m_with_units.to('N*m').magnitude if isinstance(m_with_units, pint.Quantity) else m_with_units&#10;&#10;            # Log with SI units&#10;            log(f&quot;  Element {element_id}: Point moment m={m:.4g} Nm, position={a:.4f} m&quot;)&#10;&#10;            # Apply moment with SI units&#10;            element.add_point_moment(m, a, load_case)&#10;&#10;        elif load_type == 4:  # Axial load&#10;            # Parse axial load with unit conversion&#10;            p_with_units = unit_manager.parse_value(str(member_load.get(&quot;p&quot;, 0)))&#10;&#10;            # Convert to SI units (N)&#10;            p = p_with_units.to('N').magnitude if isinstance(p_with_units, pint.Quantity) else p_with_units&#10;&#10;            # Log with SI units&#10;            log(f&quot;  Element {element_id}: Axial load p={p:.4g} N&quot;)&#10;&#10;            # Apply the axial load&#10;            element.add_axial_load(p, load_case)&#10;&#10;        elif load_type == 5:  # Temperature load&#10;            delta_t = float(member_load.get(&quot;delta_t&quot;, 0))&#10;            alpha = float(member_load.get(&quot;alpha&quot;, 1.2e-5))&#10;&#10;            log(f&quot;  Element {element_id}: Temperature load T={delta_t}C, ={alpha}/C&quot;)&#10;&#10;            # Apply the temperature load if the element supports it&#10;            if hasattr(element, 'add_temperature_load'):&#10;                element.add_temperature_load(delta_t, alpha, load_case)&#10;            else:&#10;                log(f&quot;  Warning: Element {element_id} doesn't support temperature loads&quot;)&#10;&#10;        else:&#10;            log(f&quot;  Warning: Unsupported load type {load_type}&quot;)&#10;&#10;        # except Exception as e:&#10;        #     log(f&quot;Error processing member load: {e}&quot;)&#10;        #     log(f&quot;  Details: {type(e).__name__} - {str(e)}&quot;)&#10;&#10;    # Create final node list in sorted order&#10;    node_list = [nodes_dict[uid] for uid in sorted(nodes_dict)]&#10;&#10;    # Print node restraints&#10;    log(&quot;\n\n--- Node Restraints Summary ---&quot;)&#10;    log(&quot;Node ID  |  Ux  |  Uy  |  Rz&quot;)&#10;    log(&quot;-&quot; * 30)&#10;    for node in node_list:&#10;        rx, ry, rz = node.restraints&#10;        rx_status = &quot;Fixed&quot; if rx == 1 else &quot;Free&quot;&#10;        ry_status = &quot;Fixed&quot; if ry == 1 else &quot;Free&quot;&#10;        rz_status = &quot;Fixed&quot; if rz == 1 else &quot;Free&quot;&#10;        log(f&quot;Node {node.uid:2d}  |  {rx_status:5s} |  {ry_status:5s} |  {rz_status:5s}&quot;)&#10;&#10;    # Plot structure if requested&#10;    if show_vtk:&#10;        plot_structure_vtk(node_list, element_list, scaling=default_scaling)&#10;&#10;    return node_list, element_list&#10;&#10;def load_linear_load_reactively(element, member_load, logger=None):&#10;    &quot;&quot;&quot;Process linear load using reactive approach&quot;&quot;&quot;&#10;&#10;    # Use print or logger.info based on what's available&#10;    def log(message):&#10;        if logger:&#10;            logger.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    from pyMAOS.linear_load_reactive import LinearLoadReactive&#10;&#10;    # Create reactive load processor&#10;    load_processor = LinearLoadReactive()&#10;&#10;    # Extract load parameters&#10;    w1_with_units = unit_manager.parse_value(str(member_load.get(&quot;wi&quot;, 0)))&#10;    from pyMAOS.units_mod import INTERNAL_DISTRIBUTED_LOAD_UNIT&#10;    w1 = w1_with_units.to(INTERNAL_DISTRIBUTED_LOAD_UNIT).magnitude if isinstance(w1_with_units,&#10;                                                                                  pint.Quantity) else w1_with_units&#10;&#10;    if &quot;wj&quot; in member_load:&#10;        w2_with_units = unit_manager.parse_value(str(member_load[&quot;wj&quot;]))&#10;        w2 = w2_with_units.to(INTERNAL_DISTRIBUTED_LOAD_UNIT).magnitude if isinstance(w2_with_units,&#10;                                                                                      pint.Quantity) else w2_with_units&#10;    else:&#10;        w2 = w1&#10;&#10;    # Get positions - check for percentage parameters first&#10;    if &quot;a_pct&quot; in member_load:&#10;        a_pct = float(member_load[&quot;a_pct&quot;])&#10;        a = a_pct / 100.0 * element.length&#10;    else:&#10;        a = float(member_load.get(&quot;a&quot;, 0.0))&#10;&#10;    if &quot;b_pct&quot; in member_load:&#10;        b_pct = float(member_load[&quot;b_pct&quot;])&#10;        b = b_pct / 100.0 * element.length&#10;    else:&#10;        b = float(member_load.get(&quot;b&quot;, element.length))&#10;&#10;    # Set parameters in reactive system&#10;    load_processor.set_parameters(w1, w2, a, b, element.length)&#10;&#10;    # Subscribe to reactions and use them&#10;    load_processor.reactions.subscribe(&#10;        on_next=lambda reactions: log(f&quot;Calculated reactions: R_i={reactions[0]:.4f}, R_j={reactions[1]:.4f}&quot;)&#10;    )&#10;&#10;    # Subscribe to constants and use them for the element&#10;    load_processor.constants.pipe(ops.first()).subscribe(&#10;        on_next=lambda constants: element.add_distributed_load(&#10;            w1, w2, a, b, member_load.get(&quot;case&quot;, &quot;D&quot;),&#10;            direction=member_load.get(&quot;direction&quot;, &quot;Y&quot;).upper()&#10;        )&#10;    )&#10;&#10;&#10;from pyMAOS.export_utils import export_results_to_json&#10;from pyMAOS.units_mod import unit_manager&#10;&#10;# Example usage&#10;if __name__ == &quot;__main__&quot;:&#10;&#10;    # Show all pyMAOS classes&#10;    print_imported_classes('pyMAOS')&#10;    pprint(globals())&#10;    status = 0&#10;    import argparse&#10;&#10;    &quot;&quot;&quot;Command line interface for unit conversion.&quot;&quot;&quot;&#10;    parser = argparse.ArgumentParser(description=&quot;Convert JSON structural model to SI units&quot;)&#10;    parser.add_argument(&quot;input_file&quot;, help=&quot;Input JSON file path&quot;)&#10;    parser.add_argument(&quot;-w&quot;, &quot;--working_dir&quot;, default=None, help=&quot;Working directory for output files&quot;)&#10;    parser.add_argument(&quot;--units&quot;, choices=[&quot;si&quot;, &quot;imperial&quot;, &quot;metric_kn&quot;], default=&quot;imperial&quot;,&#10;                        help=&quot;Unit system to use (si, imperial, or metric_kn)&quot;)&#10;    parser.add_argument(&quot;--to&quot;, choices=[&quot;JSON&quot;, &quot;XLSX&quot;, &quot;BOTH&quot;], default=&quot;BOTH&quot;,&#10;                        help=&quot;Output format: JSON, XLSX, or BOTH (default)&quot;)&#10;    parser.add_argument(&quot;--vtk&quot;, action=&quot;store_true&quot;,&#10;                        help=&quot;Enable VTK visualization of the structure and results&quot;)&#10;    args = parser.parse_args()&#10;&#10;    # Use the directory of the input file as the working directory for all outputs&#10;    input_file = os.path.abspath(args.input_file)&#10;    if args.working_dir:&#10;        working_dir = args.working_dir&#10;        os.makedirs(working_dir, exist_ok=True)  # Create the directory if it doesn't exist&#10;    else:&#10;        working_dir = os.path.dirname(input_file) or os.path.curdir&#10;    # os.chdir(working_dir)  # Change to the working directory&#10;    print(f&quot;Working directory set to: {working_dir}&quot;)&#10;    print(f&quot;Current directory: {os.path.abspath(os.getcwd())}&quot;)&#10;&#10;    # Set up logging&#10;    logfile = f&quot;{os.path.splitext(input_file)[0]}.log&quot;&#10;    logger = setup_logger('pyMAOS', logfile)&#10;&#10;    logger.info(f&quot;Using working directory: {working_dir}&quot;)&#10;&#10;    # global DATADIR&#10;    # DATADIR = os.environ.get('DATADIR', working_dir)&#10;&#10;    from pyMAOS.units_mod import set_unit_system, IMPERIAL_UNITS, SI_UNITS, METRIC_KN_UNITS&#10;&#10;    # Choose the unit system with a simple function call&#10;    logger.info(f&quot;\nSetting {args.units} unit system...&quot;)&#10;    if args.units == &quot;imperial&quot;:&#10;        unit_manager.set_display_unit_system(IMPERIAL_UNITS, args.units)&#10;        logger.info(&quot;Using imperial unit system&quot;)&#10;    elif args.units == &quot;si&quot;:&#10;        unit_manager.set_display_unit_system(SI_UNITS, args.units)&#10;        logger.info(&quot;Using SI unit system&quot;)&#10;    elif args.units == &quot;metric_kn&quot;:&#10;        unit_manager.set_display_unit_system(METRIC_KN_UNITS, args.units)&#10;        logger.info(&quot;Using metric kN unit system&quot;)&#10;&#10;    # Get current unit system directly from the manager&#10;    from pprint import pprint&#10;    current_units = unit_manager.get_current_units(); pprint(current_units)&#10;&#10;    system_name = unit_manager.get_system_name(); print(system_name)&#10;&#10;    # Import the R2Structure class&#10;    from pyMAOS.structure2d import R2Structure  # Instead of from pyMAOS.R2Structure import R2Structure&#10;    from frame2d import R2Frame&#10;    R2Frame.plot_enabled = False&#10;&#10;    loadcombo = LoadCombo(&quot;D&quot;, {&quot;D&quot;: 1.0}, [&quot;D&quot;], False, &quot;SLS&quot;)&#10;    structure_state_bin = f&quot;{os.path.splitext(input_file)[0]}_structure_state.bin&quot;&#10;    if os.path.exists(structure_state_bin):&#10;        logger.info(f&quot;Loading structure state from binary file: {structure_state_bin}&quot;)&#10;        model_structure = R2Structure([], [])  # Create empty structure initially&#10;        if model_structure.load_structure_state(structure_state_bin):&#10;            print(&quot;Successfully loaded structure state&quot;)&#10;            model_structure.set_node_displacements(loadcombo)&#10;        else:&#10;            print(&quot;Failed to load structure state&quot;)&#10;            sys.exit(1)&#10;    else:&#10;        try:&#10;            logger.info(f&quot;Loading structural model from file: {input_file}&quot;)&#10;            # Pass the VTK flag to control visualization in load_frame_from_file&#10;            node_list, element_list = load_frame_from_file(input_file, logger=logger, show_vtk=args.vtk)&#10;        except Exception as e:&#10;            from pyMAOS.logger import log_exception&#10;            log_exception(logger, message=f&quot;Error loading structural model: {e}&quot;)&#10;            sys.exit(1)&#10;&#10;        logger.info(f&quot;Total nodes: {len(node_list)}&quot;)&#10;        logger.info(f&quot;Total elements: {len(element_list)}&quot;)&#10;        # Check if the R2Structure class is available&#10;&#10;        # if is_class_imported('R2Structure'):&#10;        #     print(&quot;R2Structure class is available&quot;)&#10;&#10;        # Pass all display units to the structure&#10;        model_structure = R2Structure(node_list, element_list)&#10;        # logger.info(model_structure)&#10;&#10;        logger.info(&quot;Solving linear static problem...&quot;)&#10;        # Solve the linear static problem&#10;        try:&#10;            U = model_structure.solve_linear_static(loadcombo, output_dir=working_dir, structure_state_bin=structure_state_bin, verbose=True)&#10;            model_structure.set_node_displacements(loadcombo)&#10;            model_structure.compute_reactions(loadcombo)&#10;        except ValueError as e:&#10;            from pyMAOS.logger import log_exception&#10;            log_exception(logger, message=f&quot;ValueError solving linear static problem: {e}&quot;)&#10;            sys.exit(1)&#10;        except Exception as e:&#10;            from pyMAOS.logger import log_exception&#10;            log_exception(logger, message=&quot;Error solving linear static problem&quot;)&#10;            sys.exit(1)&#10;    logger.info(&quot;Linear static problem solved successfully.&quot;)&#10;    # save state of the structure for a restart point&#10;    # After analysis is complete:&#10;    # from pyMAOS.structure2d_save import save_structure_state&#10;    if structure_state_bin is not None:&#10;        model_structure.save_structure_state(structure_state_bin)&#10;        logger.info(f&quot;Structure state saved to {structure_state_bin}&quot;)&#10;&#10;    # logger.info(f&quot;Displacements U:\n{U}&quot;)&#10;    # logger.info(str(model_structure))&#10;&#10;    # # Save displacement results&#10;    # np.save(os.path.join(working_dir, 'U.npy'), U)&#10;    # np.savetxt(os.path.join(working_dir, 'U.txt'), U)&#10;&#10;    # Output format handling&#10;    output_to_json = args.to in [&quot;JSON&quot;, &quot;BOTH&quot;]&#10;    output_to_xlsx = args.to in [&quot;XLSX&quot;, &quot;BOTH&quot;]&#10;&#10;    # Export results to JSON if requested&#10;    if output_to_json:&#10;        json_output = f&quot;{os.path.splitext(input_file)[0]}_results.json&quot;&#10;        export_results_to_json(model_structure, [loadcombo], json_output)&#10;        logger.info(f&quot;\nResults exported in SI units: {json_output}&quot;)&#10;&#10;        # Create a version with display units&#10;        try:&#10;            # Import the conversion utility&#10;            from pyMAOS.convert_units import convert_si_to_display_units&#10;&#10;            # Create path for display units version&#10;            json_output_display = f&quot;{os.path.splitext(input_file)[0]}_results_display.json&quot;&#10;&#10;            # Get current unit system directly from the manager&#10;            current_units = unit_manager.get_current_units()&#10;            system_name = unit_manager.get_system_name()&#10;&#10;            # Convert the SI results to the selected display units&#10;            convert_si_to_display_units(json_output, json_output_display, current_units)&#10;            logger.info(f&quot;Results exported in {system_name} units: {json_output_display}&quot;)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error creating display units version: {e}&quot;)&#10;            import traceback&#10;&#10;            traceback.print_exc()&#10;&#10;    # Export results to Excel if requested&#10;    if output_to_xlsx:&#10;        results_xlsx = f&quot;{os.path.splitext(input_file)[0]}_results.xlsx&quot;&#10;        try:&#10;            # Export results to Excel with proper unit system&#10;            model_structure.export_results_to_excel(results_xlsx, loadcombos=[loadcombo],&#10;                                                    unit_system=args.units)&#10;            logger.info(f&quot;Results exported to Excel: {results_xlsx} using {args.units} units&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error exporting results to Excel: {e}&quot;)&#10;            import traceback&#10;&#10;            traceback.print_exc()&#10;&#10;    # Visualize results only if --vtk flag is used&#10;    if args.vtk:&#10;        logger.info(&quot;Showing VTK visualization...&quot;)&#10;        model_structure.plot_loadcombos_vtk(loadcombos=None, scaling=default_scaling)&#10;&#10;    # Pause the program before exiting&#10;    logger.info(&quot;\n\nAnalysis complete. Press Enter to exit...&quot;)&#10;" />
              <option name="updatedContent" value="from ast import Constant&#10;import os&#10;from os import path&#10;import sys&#10;&#10;import numpy as np&#10;from contextlib import redirect_stdout&#10;import pint&#10;&#10;from PyQt6 import QtQml  # Import the module without the non-existent kwargs&#10;from rx.subject.subject import Subject&#10;import rx&#10;import logging  # Add logging module&#10;&#10;from pprint import pprint&#10;&#10;def is_class_imported(class_name):&#10;    &quot;&quot;&quot;&#10;    Check if a class has been imported in the current namespace&#10;    &#10;    Parameters&#10;    ----------&#10;    class_name : str&#10;        Name of the class to check&#10;        &#10;    Returns&#10;    -------&#10;    bool&#10;        True if class exists, False otherwise&#10;    &quot;&quot;&quot;&#10;    return class_name in globals() or class_name in locals()&#10;&#10;&#10;def check_class_exists(class_name):&#10;    &quot;&quot;&quot;Check if a class is available in the current namespace&quot;&quot;&quot;&#10;    try:&#10;        # Try to evaluate the class name&#10;        return eval(class_name) is not None&#10;    except (NameError, AttributeError):&#10;        return False&#10;&#10;&#10;def is_class_available_from_module(module_name, class_name):&#10;    &quot;&quot;&quot;Check if a class is available from a specific imported module&quot;&quot;&quot;&#10;    import sys&#10;&#10;    # Check if module is imported&#10;    if module_name not in sys.modules:&#10;        return False&#10;&#10;    # Get the module object&#10;    module = sys.modules[module_name]&#10;&#10;    # Check if class exists in module&#10;    return hasattr(module, class_name)&#10;&#10;&#10;def list_imported_classes(module_filter=None):&#10;    &quot;&quot;&quot;&#10;    List all classes that have been imported in the current Python script&#10;    &#10;    Parameters&#10;    ----------&#10;    module_filter : str or list of str, optional&#10;        Filter classes by module name prefix (e.g., 'pyMAOS' or ['pyMAOS', 'numpy'])&#10;        &#10;    Returns&#10;    -------&#10;    dict&#10;        Dictionary mapping class names to their module names&#10;    &quot;&quot;&quot;&#10;    import inspect&#10;    import sys&#10;&#10;    # Normalize filter to a list&#10;    if module_filter is None:&#10;        filters = None&#10;    elif isinstance(module_filter, str):&#10;        filters = [module_filter]&#10;    else:&#10;        filters = list(module_filter)&#10;&#10;    classes_dict = {}&#10;&#10;    # Check global namespace&#10;    for name, obj in globals().items():&#10;        if inspect.isclass(obj):&#10;            module = inspect.getmodule(obj)&#10;            if module:&#10;                module_name = module.__name__&#10;                if filters is None or any(module_name.startswith(m) for m in filters):&#10;                    classes_dict[name] = module_name&#10;&#10;    # Check modules in sys.modules&#10;    for module_name, module in sys.modules.items():&#10;        # Skip None modules or if filtering is active and module doesn't match&#10;        if module is None:&#10;            continue&#10;        if filters and not any(module_name.startswith(m) for m in filters):&#10;            continue&#10;&#10;        try:&#10;            for name, obj in inspect.getmembers(module, inspect.isclass):&#10;                # Only include if defined in this module (not imported into it)&#10;                if hasattr(obj, '__module__') and obj.__module__ == module_name:&#10;                    classes_dict[name] = module_name&#10;        except:&#10;            # Some modules might raise errors when inspected&#10;            raise Warning(f&quot;Could not inspect module {module_name}. It may not be a valid Python module or may not support introspection.&quot;)&#10;            pass&#10;&#10;    return classes_dict&#10;&#10;&#10;# Example usage:&#10;def print_imported_classes(module_filter=None):&#10;    &quot;&quot;&quot;Print imported classes in a formatted table&quot;&quot;&quot;&#10;    classes = list_imported_classes(module_filter)&#10;&#10;    print(f&quot;\n{'Class Name':&lt;30} | {'Module'}&quot;)&#10;    print(&quot;-&quot; * 60)&#10;&#10;    for name, module in sorted(classes.items()):&#10;        print(f&quot;{name:&lt;30} | {module}&quot;)&#10;&#10;    print(f&quot;\nTotal: {len(classes)} classes found&quot;)&#10;&#10;&#10;# Alternative: show all imported classes&#10;# print_imported_classes()&#10;&#10;from pyMAOS.logger import setup_logger&#10;&#10;# Import all unit-related functionality from units.py module&#10;from pyMAOS.units_mod import (&#10;    unit_manager,&#10;    # FORCE_UNIT, LENGTH_UNIT, MOMENT_UNIT, PRESSURE_UNIT, DISTRIBUTED_LOAD_UNIT,  # Display units&#10;    # INTERNAL_FORCE_UNIT, INTERNAL_LENGTH_UNIT, INTERNAL_MOMENT_UNIT, INTERNAL_PRESSURE_UNIT,  # Internal units&#10;    # INTERNAL_DISTRIBUTED_LOAD_UNIT, INTERNAL_PRESSURE_UNIT_EXPANDED,  # More internal units&#10;    update_units_from_json,  set_unit_system, INTERNAL_DISTRIBUTED_LOAD_UNIT  # Functions&#10;)&#10;&#10;# from pyMAOS.units_mod import SI_UNITS, IMPERIAL_UNITS, METRIC_KN_UNITS&#10;&#10;# Import other modules&#10;from pyMAOS.structure2d_plot import plot_structure_vtk&#10;from pyMAOS.node2d import R2Node&#10;from pyMAOS.frame2d import R2Frame&#10;from pyMAOS.material import LinearElasticMaterial as Material&#10;from pyMAOS.section import Section&#10;&#10;from pyMAOS.loadcombos import LoadCombo&#10;&#10;from pyMAOS.load_utils import LoadConverter&#10;&#10;default_scaling = {&#10;    &quot;axial_load&quot;: 100,&#10;    &quot;normal_load&quot;: 100,&#10;    &quot;point_load&quot;: 1,&#10;    &quot;axial&quot;: 2,&#10;    &quot;shear&quot;: 2,&#10;    &quot;moment&quot;: 0.1,&#10;    &quot;rotation&quot;: 5000,&#10;    &quot;displacement&quot;: 100,&#10;}&#10;&#10;&#10;def load_frame_from_file(filename, logger=None, schema_file=None, show_vtk=False):&#10;    &quot;&quot;&quot;&#10;    Reads a structural model from a JSON or YAML file and creates nodes and elements in SI units&#10;    &#10;    Parameters&#10;    ----------&#10;    filename : str&#10;        Path to the input file (JSON or YAML format)&#10;    logger : logging.Logger, optional&#10;        Logger object for output&#10;    schema_file : str, optional&#10;        Path to JSON schema for validation (only used for JSON files)&#10;    show_vtk : bool, optional&#10;        Whether to show VTK plot of the structure&#10;    &#10;    Returns&#10;    -------&#10;    tuple&#10;        (node_list, element_list) ready for structural analysis, all in SI units&#10;    &quot;&quot;&quot;&#10;&#10;    # Use print or logger.info based on what's available&#10;    def log(message):&#10;        if logger:&#10;            logger.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    # Import the unit_manager directly from the module&#10;    import pyMAOS&#10;&#10;    log(f&quot;Using UnitManager registry with id: {id(pyMAOS.unit_manager.ureg)}&quot;)&#10;        &#10;    # Check file extension to determine format&#10;    file_ext = os.path.splitext(filename)[1].lower()&#10;&#10;    # Create reactive subjects for key data&#10;    model_data = Subject()&#10;    nodes_subject = Subject()&#10;    elements_subject = Subject()&#10;    results_subject = Subject()&#10;&#10;    # Load data from file based on format&#10;    if file_ext in ['.yml', '.yaml']:&#10;        try:&#10;            import yaml&#10;            log(f&quot;Loading YAML file: {filename}&quot;)&#10;            with open(filename, 'r') as file:&#10;                data = yaml.safe_load(file)&#10;            log(&quot;YAML file loaded successfully&quot;)&#10;        except ImportError:&#10;            log(&quot;Error: PyYAML package not found. Install it using: pip install pyyaml&quot;)&#10;            raise&#10;        except Exception as e:&#10;            log(f&quot;Error loading YAML file: {e}&quot;)&#10;            raise&#10;    else:  # Default to JSON&#10;        log(f&quot;Loading JSON file: {filename}&quot;)&#10;        import json&#10;        # Validate JSON file if schema_file is provided&#10;        if schema_file:&#10;            try:&#10;                from pyMAOS.json_utils import validate_input_with_schema&#10;                validate_input_with_schema(filename, schema_file=schema_file)&#10;                log(&quot;JSON validation passed!&quot;)&#10;            except Exception as e:&#10;                log(f&quot;Warning: JSON validation failed: {e}&quot;)&#10;&#10;        # Load JSON data&#10;        with open(filename, 'r', encoding='utf-8') as file:&#10;            data = json.load(file)&#10;&#10;    # Process nodes - always convert to SI units (meters)&#10;    nodes_dict = {}&#10;    for node_data in data.get(&quot;nodes&quot;, []):&#10;        node_id = node_data[&quot;id&quot;]&#10;&#10;        # Use unit_manager to parse coordinates with potential units&#10;        x = pyMAOS.unit_manager.parse_value(str(node_data[&quot;x&quot;]))&#10;        y = pyMAOS.unit_manager.parse_value(str(node_data[&quot;y&quot;]))&#10;&#10;        # Convert to meters if units are specified&#10;        x_meters = x.to('m').magnitude if isinstance(x, pint.Quantity) else x&#10;        y_meters = y.to('m').magnitude if isinstance(y, pint.Quantity) else y&#10;&#10;        node = R2Node(node_id, x_meters, y_meters)&#10;        nodes_dict[node_id] = node&#10;&#10;    log(f&quot;Read {len(nodes_dict)} nodes.&quot;)&#10;    log(str(nodes_dict))&#10;&#10;    # Process supports&#10;    for support_data in data.get(&quot;supports&quot;, []):&#10;        node_id = support_data[&quot;node&quot;]&#10;        rx = support_data[&quot;rx&quot;]&#10;        ry = support_data[&quot;ry&quot;]&#10;        rz = support_data[&quot;rz&quot;]&#10;&#10;        if node_id in nodes_dict:&#10;            nodes_dict[node_id].restraints = [rx, ry, rz]&#10;            log(f&quot;Node {node_id} supports: rx={rx}, ry={ry}, rz={rz}&quot;)&#10;&#10;    # Process materials&#10;    materials_dict = {}&#10;    try:&#10;        materials_yml = os.path.join(os.path.dirname(filename), &quot;materials.yml&quot;)&#10;        if not os.path.exists(materials_yml):&#10;            materials_yml = os.path.join(&quot;materials.yml&quot;)&#10;&#10;        log(f&quot;Loading materials from: {materials_yml}&quot;)&#10;        with open(materials_yml, 'r') as file:&#10;            # Use unsafe_load to allow object instantiation&#10;            import yaml&#10;            materials_list = yaml.unsafe_load(file)&#10;&#10;        # Convert list to dictionary using uid as key&#10;        for material in materials_list:&#10;            materials_dict[material.uid] = material&#10;        log(f&quot;Loaded {len(materials_dict)} materials&quot;)&#10;    except Exception as e:&#10;        log(f&quot;Error loading materials: {e}&quot;)&#10;        raise&#10;&#10;    # Process sections&#10;    sections_dict = {}&#10;    try:&#10;        sections_yml = os.path.join(os.path.dirname(filename), &quot;sections.yml&quot;)&#10;        if not os.path.exists(sections_yml):&#10;            sections_yml = os.path.join(&quot;sections.yml&quot;)&#10;&#10;        log(f&quot;Loading sections from: {sections_yml}&quot;)&#10;        with open(sections_yml, 'r') as file:&#10;            # Use unsafe_load to allow object instantiation&#10;            sections_list = yaml.unsafe_load(file)&#10;&#10;        # Convert list to dictionary using uid as key&#10;        for section in sections_list:&#10;            sections_dict[section.uid] = section&#10;        log(f&quot;Loaded {len(sections_dict)} sections&quot;)&#10;    except Exception as e:&#10;        log(f&quot;Error loading sections: {e}&quot;)&#10;        raise&#10;&#10;    # Process members/elements&#10;    element_list = []&#10;    elements_dict = {}&#10;    for member_data in data.get(&quot;members&quot;, []):&#10;        member_id = member_data[&quot;id&quot;]&#10;        i_node = member_data[&quot;i_node&quot;]&#10;&#10;        inode=nodes_dict[i_node]&#10;        inode.is_inode_of_elem_ids.append(member_id)&#10;&#10;&#10;        j_node = member_data[&quot;j_node&quot;]&#10;        jnode = nodes_dict[j_node]&#10;        jnode.is_jnode_of_elem_ids.append(member_id)&#10;&#10;&#10;        mat_id = member_data[&quot;material&quot;]&#10;        sec_id = member_data[&quot;section&quot;]&#10;&#10;        # Create frame element&#10;        element = R2Frame(&#10;            uid=member_id,&#10;            inode=nodes_dict[i_node],&#10;            jnode=nodes_dict[j_node],&#10;            material=materials_dict[mat_id],&#10;            section=sections_dict[sec_id]&#10;        )&#10;        element_list.append(element)&#10;        elements_dict[member_id] = element&#10;&#10;        inode.is_inode_of_elems.append(element); jnode.is_inode_of_elems.append(element)&#10;&#10;    log(f&quot;Read {len(element_list)} elements.&quot;)&#10;&#10;    # Process joint loads - always convert to SI units&#10;    for joint_load in data.get(&quot;joint_loads&quot;, []):&#10;        node_id = joint_load[&quot;node&quot;]&#10;&#10;        # Parse forces with potential units&#10;        fx_with_units = pyMAOS.unit_manager.parse_value(str(joint_load.get(&quot;fx&quot;, 0)))&#10;        fy_with_units = pyMAOS.unit_manager.parse_value(str(joint_load.get(&quot;fy&quot;, 0)))&#10;        mz_with_units = pyMAOS.unit_manager.parse_value(str(joint_load.get(&quot;mz&quot;, 0)))&#10;&#10;        # Convert to SI units (Newtons, Newton-meters)&#10;        fx = fx_with_units.to('N').magnitude if isinstance(fx_with_units, pint.Quantity) else fx_with_units&#10;        fy = fy_with_units.to('N').magnitude if isinstance(fy_with_units, pint.Quantity) else fy_with_units&#10;        mz = mz_with_units.to('N*m').magnitude if isinstance(mz_with_units, pint.Quantity) else mz_with_units&#10;&#10;        if node_id in nodes_dict:&#10;            # Store in SI units&#10;            nodes_dict[node_id].add_nodal_load(fx, fy, mz, &quot;D&quot;)&#10;            log(f&quot;Node {node_id} load: Fx={fx:.4g} N, Fy={fy:.4g} N, Mz={mz:.4g} N*m&quot;)&#10;&#10;    # Import the necessary load classes&#10;    from pyMAOS.loading import R2_Point_Load, LinearLoadXY, R2_Axial_Load, R2_Axial_Linear_Load, R2_Point_Moment&#10;&#10;    log(f&quot;\nProcessing {len(data.get('member_loads', []))} member loads:&quot;)&#10;&#10;    # Process member loads - always convert to SI units&#10;    for member_load in data.get(&quot;member_loads&quot;, []):&#10;&#10;        pprint(member_load)&#10;        element_id = member_load[&quot;member_uid&quot;]&#10;        load_type = member_load[&quot;load_type&quot;]&#10;&#10;        if element_id not in elements_dict:&#10;            log(f&quot;Warning: Member load specified for non-existent element {element_id}&quot;)&#10;            continue&#10;&#10;        element = elements_dict[element_id]&#10;        load_case = member_load.get(&quot;case&quot;, &quot;D&quot;)&#10;        direction = member_load.get(&quot;direction&quot;, &quot;Y&quot;).upper()&#10;&#10;        if load_type == 3:  # Distributed load&#10;            # Extract load intensity parameters with unit conversion&#10;            from pyMAOS.units_mod import INTERNAL_LENGTH_UNIT, INTERNAL_DISTRIBUTED_LOAD_UNIT&#10;            w1_with_units = unit_manager.parse_value(str(member_load.get(&quot;wi&quot;, 0))).to(INTERNAL_DISTRIBUTED_LOAD_UNIT)&#10;&#10;            if &quot;wj&quot; in member_load:&#10;                w2_with_units = unit_manager.parse_value(str(member_load[&quot;wj&quot;])).to(INTERNAL_DISTRIBUTED_LOAD_UNIT)&#10;            else:&#10;                w2_with_units = w1_with_units&#10;&#10;            # Get positions - check for percentage parameters first&#10;            if &quot;a_pct&quot; in member_load:&#10;                a_pct = float(member_load[&quot;a_pct&quot;])&#10;                a_with_units = a_pct / 100.0 * element.length&#10;                log(f&quot;  Using a_pct={a_pct}%  position a={a_with_units:.4f}&quot;)&#10;            else:&#10;                a_with_units = unit_manager.parse_value(str(member_load[&quot;a&quot;])).to(INTERNAL_LENGTH_UNIT)&#10;&#10;            if &quot;b_pct&quot; in member_load:&#10;                b_pct = float(member_load[&quot;b_pct&quot;])&#10;                b_with_units = b_pct / 100.0 * element.length&#10;                log(f&quot;  Using b_pct={b_pct}%  position b={b_with_units:.4f}&quot;)&#10;            else:&#10;                b_with_units = unit_manager.parse_value(member_load.get(&quot;b&quot;, element.length)).to(INTERNAL_LENGTH_UNIT)&#10;&#10;            element.add_distributed_load(w1_with_units, w2_with_units, a_with_units, b_with_units, load_case, direction=direction)&#10;&#10;        elif load_type == 1:  # Point load&#10;            # Parse force magnitude with unit conversion&#10;            from pyMAOS.units_mod import INTERNAL_LENGTH_UNIT, INTERNAL_FORCE_UNIT&#10;            p_with_units = unit_manager.parse_value(str(member_load.get(&quot;p&quot;, 0))).to(INTERNAL_FORCE_UNIT)&#10;            # Parse position - use percentage value if available&#10;            if &quot;a_pct&quot; in member_load:&#10;                a_pct = float(member_load[&quot;a_pct&quot;])&#10;                a_with_units = a_pct / 100.0 * element.length&#10;            else:&#10;                a_with_units = unit_manager.parse_value(str(member_load[&quot;a&quot;])).to(INTERNAL_LENGTH_UNIT)&#10;            if a_with_units &gt; element.length:&#10;                log(f&quot;Warning: Point load position {a_with_units} exceeds element length {element.length}. Clamping to length.&quot;)&#10;                a_with_units = element.length&#10;            # Remove b_with_units if it exists&#10;            if 'b_with_units' in locals():&#10;                del b_with_units&#10;&#10;            # Apply the load to the element with correct direction&#10;            if direction == &quot;X&quot;:&#10;                element.add_point_load(p_with_units, a_with_units, load_case, direction=&quot;xx&quot;)&#10;            else:&#10;                element.add_point_load(p_with_units, a_with_units, load_case)&#10;&#10;        elif load_type == 2:  # Point moment&#10;            # Parse moment magnitude with unit conversion&#10;            m_with_units = unit_manager.parse_value(str(member_load.get(&quot;m&quot;, 0)))&#10;&#10;            # Parse position - use percentage value if available&#10;            if &quot;a_pct&quot; in member_load:&#10;                a_pct = float(member_load[&quot;a_pct&quot;])&#10;                a = a_pct / 100.0 * element.length&#10;            else:&#10;                a = float(member_load.get(&quot;a&quot;, 0.0))&#10;&#10;            # Convert to SI units (Nm)&#10;            m = m_with_units.to('N*m').magnitude if isinstance(m_with_units, pint.Quantity) else m_with_units&#10;&#10;            # Log with SI units&#10;            log(f&quot;  Element {element_id}: Point moment m={m:.4g} Nm, position={a:.4f} m&quot;)&#10;&#10;            # Apply moment with SI units&#10;            element.add_point_moment(m, a, load_case)&#10;&#10;        elif load_type == 4:  # Axial load&#10;            # Parse axial load with unit conversion&#10;            p_with_units = unit_manager.parse_value(str(member_load.get(&quot;p&quot;, 0)))&#10;&#10;            # Convert to SI units (N)&#10;            p = p_with_units.to('N').magnitude if isinstance(p_with_units, pint.Quantity) else p_with_units&#10;&#10;            # Log with SI units&#10;            log(f&quot;  Element {element_id}: Axial load p={p:.4g} N&quot;)&#10;&#10;            # Apply the axial load&#10;            element.add_axial_load(p, load_case)&#10;&#10;        elif load_type == 5:  # Temperature load&#10;            delta_t = float(member_load.get(&quot;delta_t&quot;, 0))&#10;            alpha = float(member_load.get(&quot;alpha&quot;, 1.2e-5))&#10;&#10;            log(f&quot;  Element {element_id}: Temperature load T={delta_t}C, ={alpha}/C&quot;)&#10;&#10;            # Apply the temperature load if the element supports it&#10;            if hasattr(element, 'add_temperature_load'):&#10;                element.add_temperature_load(delta_t, alpha, load_case)&#10;            else:&#10;                log(f&quot;  Warning: Element {element_id} doesn't support temperature loads&quot;)&#10;&#10;        else:&#10;            log(f&quot;  Warning: Unsupported load type {load_type}&quot;)&#10;&#10;        # except Exception as e:&#10;        #     log(f&quot;Error processing member load: {e}&quot;)&#10;        #     log(f&quot;  Details: {type(e).__name__} - {str(e)}&quot;)&#10;&#10;    # Create final node list in sorted order&#10;    node_list = [nodes_dict[uid] for uid in sorted(nodes_dict)]&#10;&#10;    # Print node restraints&#10;    log(&quot;\n\n--- Node Restraints Summary ---&quot;)&#10;    log(&quot;Node ID  |  Ux  |  Uy  |  Rz&quot;)&#10;    log(&quot;-&quot; * 30)&#10;    for node in node_list:&#10;        rx, ry, rz = node.restraints&#10;        rx_status = &quot;Fixed&quot; if rx == 1 else &quot;Free&quot;&#10;        ry_status = &quot;Fixed&quot; if ry == 1 else &quot;Free&quot;&#10;        rz_status = &quot;Fixed&quot; if rz == 1 else &quot;Free&quot;&#10;        log(f&quot;Node {node.uid:2d}  |  {rx_status:5s} |  {ry_status:5s} |  {rz_status:5s}&quot;)&#10;&#10;    # Plot structure if requested&#10;    if show_vtk:&#10;        plot_structure_vtk(node_list, element_list, scaling=default_scaling)&#10;&#10;    return node_list, element_list&#10;&#10;def load_linear_load_reactively(element, member_load, logger=None):&#10;    &quot;&quot;&quot;Process linear load using reactive approach&quot;&quot;&quot;&#10;&#10;    # Use print or logger.info based on what's available&#10;    def log(message):&#10;        if logger:&#10;            logger.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    from pyMAOS.linear_load_reactive import LinearLoadReactive&#10;&#10;    # Create reactive load processor&#10;    load_processor = LinearLoadReactive()&#10;&#10;    # Extract load parameters&#10;    w1_with_units = unit_manager.parse_value(str(member_load.get(&quot;wi&quot;, 0)))&#10;    from pyMAOS.units_mod import INTERNAL_DISTRIBUTED_LOAD_UNIT&#10;    w1 = w1_with_units.to(INTERNAL_DISTRIBUTED_LOAD_UNIT).magnitude if isinstance(w1_with_units,&#10;                                                                                  pint.Quantity) else w1_with_units&#10;&#10;    if &quot;wj&quot; in member_load:&#10;        w2_with_units = unit_manager.parse_value(str(member_load[&quot;wj&quot;]))&#10;        w2 = w2_with_units.to(INTERNAL_DISTRIBUTED_LOAD_UNIT).magnitude if isinstance(w2_with_units,&#10;                                                                                      pint.Quantity) else w2_with_units&#10;    else:&#10;        w2 = w1&#10;&#10;    # Get positions - check for percentage parameters first&#10;    if &quot;a_pct&quot; in member_load:&#10;        a_pct = float(member_load[&quot;a_pct&quot;])&#10;        a = a_pct / 100.0 * element.length&#10;    else:&#10;        a = float(member_load.get(&quot;a&quot;, 0.0))&#10;&#10;    if &quot;b_pct&quot; in member_load:&#10;        b_pct = float(member_load[&quot;b_pct&quot;])&#10;        b = b_pct / 100.0 * element.length&#10;    else:&#10;        b = float(member_load.get(&quot;b&quot;, element.length))&#10;&#10;    # Set parameters in reactive system&#10;    load_processor.set_parameters(w1, w2, a, b, element.length)&#10;&#10;    # Subscribe to reactions and use them&#10;    load_processor.reactions.subscribe(&#10;        on_next=lambda reactions: log(f&quot;Calculated reactions: R_i={reactions[0]:.4f}, R_j={reactions[1]:.4f}&quot;)&#10;    )&#10;&#10;    # Subscribe to constants and use them for the element&#10;    load_processor.constants.pipe(ops.first()).subscribe(&#10;        on_next=lambda constants: element.add_distributed_load(&#10;            w1, w2, a, b, member_load.get(&quot;case&quot;, &quot;D&quot;),&#10;            direction=member_load.get(&quot;direction&quot;, &quot;Y&quot;).upper()&#10;        )&#10;    )&#10;&#10;&#10;from pyMAOS.export_utils import export_results_to_json&#10;from pyMAOS.units_mod import unit_manager&#10;&#10;# Example usage&#10;if __name__ == &quot;__main__&quot;:&#10;&#10;    # Show all pyMAOS classes&#10;    print_imported_classes('pyMAOS')&#10;    pprint(globals())&#10;    status = 0&#10;    import argparse&#10;&#10;    &quot;&quot;&quot;Command line interface for unit conversion.&quot;&quot;&quot;&#10;    parser = argparse.ArgumentParser(description=&quot;Convert JSON structural model to SI units&quot;)&#10;    parser.add_argument(&quot;input_file&quot;, help=&quot;Input JSON file path&quot;)&#10;    parser.add_argument(&quot;-w&quot;, &quot;--working_dir&quot;, default=None, help=&quot;Working directory for output files&quot;)&#10;    parser.add_argument(&quot;--units&quot;, choices=[&quot;si&quot;, &quot;imperial&quot;, &quot;metric_kn&quot;], default=&quot;imperial&quot;,&#10;                        help=&quot;Unit system to use (si, imperial, or metric_kn)&quot;)&#10;    parser.add_argument(&quot;--to&quot;, choices=[&quot;JSON&quot;, &quot;XLSX&quot;, &quot;BOTH&quot;], default=&quot;BOTH&quot;,&#10;                        help=&quot;Output format: JSON, XLSX, or BOTH (default)&quot;)&#10;    parser.add_argument(&quot;--vtk&quot;, action=&quot;store_true&quot;,&#10;                        help=&quot;Enable VTK visualization of the structure and results&quot;)&#10;    args = parser.parse_args()&#10;&#10;    # Use the directory of the input file as the working directory for all outputs&#10;    input_file = os.path.abspath(args.input_file)&#10;    if args.working_dir:&#10;        working_dir = args.working_dir&#10;        os.makedirs(working_dir, exist_ok=True)  # Create the directory if it doesn't exist&#10;    else:&#10;        working_dir = os.path.dirname(input_file) or os.path.curdir&#10;    # os.chdir(working_dir)  # Change to the working directory&#10;    print(f&quot;Working directory set to: {working_dir}&quot;)&#10;    print(f&quot;Current directory: {os.path.abspath(os.getcwd())}&quot;)&#10;&#10;    # Set up logging&#10;    logfile = f&quot;{os.path.splitext(input_file)[0]}.log&quot;&#10;    logger = setup_logger('pyMAOS', logfile)&#10;&#10;    logger.info(f&quot;Using working directory: {working_dir}&quot;)&#10;&#10;    # global DATADIR&#10;    # DATADIR = os.environ.get('DATADIR', working_dir)&#10;&#10;    from pyMAOS.units_mod import set_unit_system, IMPERIAL_UNITS, SI_UNITS, METRIC_KN_UNITS&#10;&#10;    # Choose the unit system with a simple function call&#10;    logger.info(f&quot;\nSetting {args.units} unit system...&quot;)&#10;    if args.units == &quot;imperial&quot;:&#10;        unit_manager.set_display_unit_system(IMPERIAL_UNITS, args.units)&#10;        logger.info(&quot;Using imperial unit system&quot;)&#10;    elif args.units == &quot;si&quot;:&#10;        unit_manager.set_display_unit_system(SI_UNITS, args.units)&#10;        logger.info(&quot;Using SI unit system&quot;)&#10;    elif args.units == &quot;metric_kn&quot;:&#10;        unit_manager.set_display_unit_system(METRIC_KN_UNITS, args.units)&#10;        logger.info(&quot;Using metric kN unit system&quot;)&#10;&#10;    # Get current unit system directly from the manager&#10;    from pprint import pprint&#10;    current_units = unit_manager.get_current_units(); pprint(current_units)&#10;&#10;    system_name = unit_manager.get_system_name(); print(system_name)&#10;&#10;    # Import the R2Structure class&#10;    from pyMAOS.structure2d import R2Structure  # Instead of from pyMAOS.R2Structure import R2Structure&#10;    from frame2d import R2Frame&#10;    R2Frame.plot_enabled = False&#10;&#10;    loadcombo = LoadCombo(&quot;D&quot;, {&quot;D&quot;: 1.0}, [&quot;D&quot;], False, &quot;SLS&quot;)&#10;    structure_state_bin = f&quot;{os.path.splitext(input_file)[0]}_structure_state.bin&quot;&#10;    if os.path.exists(structure_state_bin):&#10;        logger.info(f&quot;Loading structure state from binary file: {structure_state_bin}&quot;)&#10;        model_structure = R2Structure([], [])  # Create empty structure initially&#10;        if model_structure.load_structure_state(structure_state_bin):&#10;            print(&quot;Successfully loaded structure state&quot;)&#10;            model_structure.set_node_displacements(loadcombo)&#10;        else:&#10;            print(&quot;Failed to load structure state&quot;)&#10;            sys.exit(1)&#10;    else:&#10;        try:&#10;            logger.info(f&quot;Loading structural model from file: {input_file}&quot;)&#10;            # Pass the VTK flag to control visualization in load_frame_from_file&#10;            node_list, element_list = load_frame_from_file(input_file, logger=logger, show_vtk=args.vtk)&#10;        except Exception as e:&#10;            from pyMAOS.logger import log_exception&#10;            log_exception(logger, message=f&quot;Error loading structural model: {e}&quot;)&#10;            sys.exit(1)&#10;&#10;        logger.info(f&quot;Total nodes: {len(node_list)}&quot;)&#10;        logger.info(f&quot;Total elements: {len(element_list)}&quot;)&#10;        # Check if the R2Structure class is available&#10;&#10;        # if is_class_imported('R2Structure'):&#10;        #     print(&quot;R2Structure class is available&quot;)&#10;&#10;        # Pass all display units to the structure&#10;        model_structure = R2Structure(node_list, element_list)&#10;        # logger.info(model_structure)&#10;&#10;        logger.info(&quot;Solving linear static problem...&quot;)&#10;        # Solve the linear static problem&#10;        try:&#10;            U = model_structure.solve_linear_static(loadcombo, output_dir=working_dir, structure_state_bin=structure_state_bin, verbose=True)&#10;            model_structure.set_node_displacements(loadcombo)&#10;            model_structure.compute_reactions(loadcombo)&#10;        except ValueError as e:&#10;            from pyMAOS.logger import log_exception&#10;            log_exception(logger, message=f&quot;ValueError solving linear static problem: {e}&quot;)&#10;            sys.exit(1)&#10;        except Exception as e:&#10;            from pyMAOS.logger import log_exception&#10;            log_exception(logger, message=&quot;Error solving linear static problem&quot;)&#10;            sys.exit(1)&#10;    logger.info(&quot;Linear static problem solved successfully.&quot;)&#10;    # save state of the structure for a restart point&#10;    # After analysis is complete:&#10;    # from pyMAOS.structure2d_save import save_structure_state&#10;    if structure_state_bin is not None:&#10;        model_structure.save_structure_state(structure_state_bin)&#10;        logger.info(f&quot;Structure state saved to {structure_state_bin}&quot;)&#10;&#10;    # logger.info(f&quot;Displacements U:\n{U}&quot;)&#10;    # logger.info(str(model_structure))&#10;&#10;    # # Save displacement results&#10;    # np.save(os.path.join(working_dir, 'U.npy'), U)&#10;    # np.savetxt(os.path.join(working_dir, 'U.txt'), U)&#10;&#10;    # Output format handling&#10;    output_to_json = args.to in [&quot;JSON&quot;, &quot;BOTH&quot;]&#10;    output_to_xlsx = args.to in [&quot;XLSX&quot;, &quot;BOTH&quot;]&#10;&#10;    # Export results to JSON if requested&#10;    if output_to_json:&#10;        json_output = f&quot;{os.path.splitext(input_file)[0]}_results.json&quot;&#10;        export_results_to_json(model_structure, [loadcombo], json_output)&#10;        logger.info(f&quot;\nResults exported in SI units: {json_output}&quot;)&#10;&#10;        # Create a version with display units&#10;        try:&#10;            # Import the conversion utility&#10;            from pyMAOS.convert_units import convert_si_to_display_units&#10;&#10;            # Create path for display units version&#10;            json_output_display = f&quot;{os.path.splitext(input_file)[0]}_results_display.json&quot;&#10;&#10;            # Get current unit system directly from the manager&#10;            current_units = unit_manager.get_current_units()&#10;            system_name = unit_manager.get_system_name()&#10;&#10;            # Convert the SI results to the selected display units&#10;            convert_si_to_display_units(json_output, json_output_display, current_units)&#10;            logger.info(f&quot;Results exported in {system_name} units: {json_output_display}&quot;)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error creating display units version: {e}&quot;)&#10;            import traceback&#10;&#10;            traceback.print_exc()&#10;&#10;    # Export results to Excel if requested&#10;    if output_to_xlsx:&#10;        results_xlsx = f&quot;{os.path.splitext(input_file)[0]}_results.xlsx&quot;&#10;        try:&#10;            # Export results to Excel with proper unit system&#10;            model_structure.export_results_to_excel(results_xlsx, loadcombos=[loadcombo],&#10;                                                    unit_system=args.units)&#10;            logger.info(f&quot;Results exported to Excel: {results_xlsx} using {args.units} units&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error exporting results to Excel: {e}&quot;)&#10;            import traceback&#10;&#10;            traceback.print_exc()&#10;&#10;    # Visualize results only if --vtk flag is used&#10;    if args.vtk:&#10;        logger.info(&quot;Showing VTK visualization...&quot;)&#10;        model_structure.plot_loadcombos_vtk(loadcombos=None, scaling=default_scaling)&#10;&#10;    # Pause the program before exiting&#10;    logger.info(&quot;\n\nAnalysis complete. Press Enter to exit...&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/loading/distributed_loads.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/loading/distributed_loads.py" />
              <option name="originalContent" value="import sys&#10;import pint&#10;from pint import Quantity&#10;from typing import TYPE_CHECKING, Any&#10;# from pyMAOS.display_utils import display_node_load_vector_in_units&#10;import numpy as np&#10;from pyMAOS.loading.piecewisePolinomial import PiecewisePolynomial&#10;from pyMAOS.units_mod import (SI_UNITS, IMPERIAL_UNITS, METRIC_KN_UNITS,&#10;    INTERNAL_LENGTH_UNIT, INTERNAL_FORCE_UNIT,  INTERNAL_MOMENT_UNIT, INTERNAL_PRESSURE_UNIT, INTERNAL_DISTRIBUTED_LOAD_UNIT,&#10;    FORCE_DIMENSIONALITY, LENGTH_DIMENSIONALITY, MOMENT_DIMENSIONALITY, PRESSURE_DIMENSIONALITY, DISTRIBUTED_LOAD_DIMENSIONALITY,&#10;    unit_manager&#10;)&#10;&#10;from pprint import pprint&#10;&#10;# Use TYPE_CHECKING to avoid runtime imports&#10;if TYPE_CHECKING:&#10;    from pyMAOS.frame2d import R2Frame&#10;&#10;class LinearLoadXY:&#10;    def __init__(self, w1: pint.Quantity, w2: pint.Quantity, a: pint.Quantity, b: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        self.w1 = w1&#10;        self.w2 = w2&#10;        self.a = a&#10;        self.b = b&#10;        self.c = b - a&#10;        self.member_uid = member.uid&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.I = member.section.Ixx&#10;&#10;        self.EI = self.E * self.I&#10;&#10;        self.kind = &quot;LINE&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Constants of Integration&#10;        # self.integration_constants()&#10;        &quot;&quot;&quot;&#10;                Calculate the integration constants for beam deflection equations.&#10;&#10;                These constants (c01-c12) are determined by enforcing boundary conditions:&#10;                - Continuity of shear, moment, slope, and deflection at load discontinuities&#10;                - Zero displacement and rotation at member ends (for fixed-end conditions)&#10;                - Equilibrium of forces and moments&#10;                &quot;&quot;&quot;&#10;        # w1 = self.w1&#10;        # w2 = self.w2&#10;        # a = self.a&#10;        # b = self.b&#10;        L = self.L&#10;&#10;        #     These constants (c01-c12) are determined by enforcing boundary conditions:&#10;        #     - Continuity of shear, moment, slope, and deflection at load discontinuities&#10;        #     - Zero displacement and rotation at member ends (for fixed-end conditions)&#10;        #     - Equilibrium of forces and moments&#10;        #&#10;        #     The constants are used in the piecewise polynomial functions that define:&#10;        #     - Vy: Shear force distribution&#10;        #     - Mz: Bending moment distribution&#10;        #     - Sz: Slope (rotation) distribution&#10;        #     - Dy: Deflection distribution&#10;&#10;        # Constants for the shear force function (Vy)&#10;        self.c01 = (&#10;                          (((2 * b * b) + ((-a - 3 * L) * b) - (a * a) + (3 * L * a)) * w2)&#10;                          + (((b * b) + ((a - 3 * L) * b) - (2 * a * a) + (3 * L * a)) * w1)&#10;                  ) / (6 * L)&#10;        self.c02 = (&#10;                          (&#10;                                  (&#10;                                          (2 * b * b * b)&#10;                                          + ((-3 * a - 3 * L) * b * b)&#10;                                          + (6 * L * a * b)&#10;                                          + (a * a * a)&#10;                                  )&#10;                                  * w2&#10;                          )&#10;                          + (((b * b * b) - (3 * L * b * b) - (3 * a * a * b) + (2 * a * a * a)) * w1)&#10;                  ) / (6 * L * b - 6 * L * a)&#10;        self.c03 = (&#10;                          ((2 * b * b - a * b - a * a) * w2) + ((b * b + a * b - 2 * a * a) * w1)&#10;                  ) / (6 * L)&#10;&#10;        # Constants for the bending moment function (Mz)&#10;        # Use unit_manager.ureg instead of direct import&#10;        self.c04 = unit_manager.ureg.Quantity(0, INTERNAL_MOMENT_UNIT)  # Zero moment at x=0 for fixed-end condition&#10;        self.c05 = (&#10;                -1&#10;                * ((a * a * a * w2) + ((2 * a * a * a - 3 * a * a * b) * w1))&#10;                / (6 * b - 6 * a)&#10;        )&#10;        self.c06 = (&#10;                -1&#10;                * ((2 * b * b - a * b - a * a) * w2 + (b * b + a * b - 2 * a * a) * w1)&#10;                / 6&#10;        )&#10;&#10;        # Constants for the slope function (Sz)&#10;        self.c07 = (&#10;                          (&#10;                                  12 * b * b * b * b&#10;                                  + (-3 * a - 45 * L) * b * b * b&#10;                                  + (-3 * a * a + 15 * L * a + 40 * L * L) * b * b&#10;                                  + (-3 * a * a * a + 15 * L * a * a - 20 * L * L * a) * b&#10;                                  - 3 * a * a * a * a&#10;                                  + 15 * L * a * a * a&#10;                                  - 20 * L * L * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b&#10;                                  + (3 * a - 15 * L) * b * b * b&#10;                                  + (3 * a * a - 15 * L * a + 20 * L * L) * b * b&#10;                                  + (3 * a * a * a - 15 * L * a * a + 20 * L * L * a) * b&#10;                                  - 12 * a * a * a * a&#10;                                  + 45 * L * a * a * a&#10;                                  - 40 * L * L * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L)&#10;        self.c08 = (&#10;                          (&#10;                                  12 * b * b * b * b * b&#10;                                  + (-15 * a - 45 * L) * b * b * b * b&#10;                                  + (60 * L * a + 40 * L * L) * b * b * b&#10;                                  - 60 * L * L * a * b * b&#10;                                  + 3 * a * a * a * a * a&#10;                                  + 20 * L * L * a * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b * b&#10;                                  - 15 * L * b * b * b * b&#10;                                  + 20 * L * L * b * b * b&#10;                                  + (-15 * a * a * a * a - 60 * L * L * a * a) * b&#10;                                  + 12 * a * a * a * a * a&#10;                                  + 40 * L * L * a * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L * b - 360 * L * a)&#10;        self.c09 = (&#10;                          (&#10;                                  12 * b * b * b * b&#10;                                  - 3 * a * b * b * b&#10;                                  + (40 * L * L - 3 * a * a) * b * b&#10;                                  + (-3 * a * a * a - 20 * L * L * a) * b&#10;                                  - 3 * a * a * a * a&#10;                                  - 20 * L * L * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b&#10;                                  + 3 * a * b * b * b&#10;                                  + (3 * a * a + 20 * L * L) * b * b&#10;                                  + (3 * a * a * a + 20 * L * L * a) * b&#10;                                  - 12 * a * a * a * a&#10;                                  - 40 * L * L * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L)&#10;&#10;        # Constants for the deflection function (Dy)&#10;        self.c10 = unit_manager.ureg.Quantity(0, f&quot;{INTERNAL_LENGTH_UNIT}**3 * {INTERNAL_FORCE_UNIT}&quot;)  # Zero deflection at x=0 for fixed-end condition&#10;        self.c11 = (&#10;                -1 /120&#10;                * (&#10;                        a * a * a * a * a * w2&#10;                        + (4 * a * a * a * a * a - 5 * a * a * a * a * b) * w1&#10;                )&#10;                / (b - a)&#10;        )&#10;        self.c12 = (&#10;                -1&#10;                * (&#10;                        (&#10;                                4 * b * b * b * b&#10;                                - a * b * b * b&#10;                                - a * a * b * b&#10;                                - a * a * a * b&#10;                                - a * a * a * a&#10;                        )&#10;                        * w2&#10;                        + (&#10;                                b * b * b * b&#10;                                + a * b * b * b&#10;                                + a * a * b * b&#10;                                + a * a * a * b&#10;                                - 4 * a * a * a * a&#10;                        )&#10;                        * w1&#10;                )&#10;                / 120&#10;        )&#10;&#10;        # Simple End Reactions&#10;        self.W = 0.5 * self.c * (self.w2 + self.w1)&#10;        self.cbar = ((self.w1 + (2 * self.w2)) / (3 * (self.w2 + self.w1))) * self.c&#10;&#10;        self.Rjy = -1 * self.W * (self.a + self.cbar) * (1 / self.L)&#10;        self.Riy = -1 * self.W - self.Rjy&#10;&#10;        # Piecewise Functions&#10;        # Each piecewise function represents a different structural response:&#10;        # - Wy: Distributed load function (input)&#10;        # - Vy: Shear force distribution (integral of Wy)&#10;        # - Mz: Bending moment distribution (integral of Vy)&#10;        # - Sz: Rotation/slope distribution (integral of Mz/EI)&#10;        # - Dy: Deflection distribution (integral of Sz)&#10;        #&#10;        # Each function is defined in three pieces:&#10;        # 1. Before loaded region [0 to a]&#10;        # 2. Within loaded region [a to b] &#10;        # 3. After loaded region [b to L]&#10;        #&#10;        # Format: [[coefficients], [domain_bounds]]&#10;        # where coefficients = [c, c, c...] representing c + cx + cx + ...&#10;        Wy = [&#10;            [[unit_manager.ureg.Quantity(0, INTERNAL_DISTRIBUTED_LOAD_UNIT)], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    ((-1 * self.a * self.w2) - (self.c * self.w1) - (self.a * self.w1))&#10;                    / self.c,&#10;                    (self.w2 - self.w1) / self.c,&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[unit_manager.ureg.Quantity(0, INTERNAL_DISTRIBUTED_LOAD_UNIT)], [self.b, self.L]],&#10;        ]; print(&quot;Wy:\n&quot;, Wy)&#10;&#10;        Vy = [&#10;            [[self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c02,&#10;                    self.w1&#10;                    + ((self.a * self.w1) / self.c)&#10;                    - ((self.a * self.w2) / self.c),&#10;                    (self.w2 / (2 * self.c)) - (self.w1 / (2 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c03], [self.b, self.L]],&#10;        ]; print(&quot;Vy:\n&quot;, Vy)&#10;&#10;        Mz = [&#10;            [[self.c04, self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c05,&#10;                    self.c02,&#10;                    (self.w1 / 2)&#10;                    + ((self.a * self.w1) / (2 * self.c))&#10;                    - ((self.a * self.w2) / (2 * self.c)),&#10;                    (self.w2 / (6 * self.c)) - (self.w1 / (6 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c06, self.c03], [self.b, self.L]],&#10;        ]; print(&quot;Mz:\n&quot;, Mz)&#10;&#10;        Sz = [&#10;            [[self.c07, self.c04, 0.5 * self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c08,&#10;                    self.c05,&#10;                    0.5 * self.c02,&#10;                    (self.w1 / 6)&#10;                    + ((self.a * self.w1) / (6 * self.c))&#10;                    - ((self.a * self.w2) / (6 * self.c)),&#10;                    (self.w2 / (24 * self.c)) - (self.w1 / (24 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c09, self.c06, 0.5 * self.c03], [self.b, self.L]],&#10;        ]&#10;        Sz[0][0] = [i / self.EI for i in Sz[0][0]]&#10;        Sz[1][0] = [i / self.EI for i in Sz[1][0]]&#10;        Sz[2][0] = [i / self.EI for i in Sz[2][0]]&#10;&#10;        print(&quot;Sz:\n&quot;, Sz)&#10;&#10;        Dy = [&#10;            [[self.c10, self.c07, 0.5 * self.c04, self.c01 / 6], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c11,&#10;                    self.c08,&#10;                    0.5 * self.c05,&#10;                    self.c02 / 6,&#10;                    (self.w1 / 24)&#10;                    + ((self.a * self.w1) / (24 * self.c))&#10;                    - ((self.a * self.w2) / (24 * self.c)),&#10;                    (self.w2 / (120 * self.c)) - (self.w1 / (120 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [&#10;                [self.c12, self.c09, 0.5 * self.c06, self.c03 / 6],&#10;                [self.b, self.L],&#10;            ],&#10;        ]&#10;&#10;        Dy[0][0] = [i / self.EI for i in Dy[0][0]]&#10;        Dy[1][0] = [i / self.EI for i in Dy[1][0]]&#10;        Dy[2][0] = [i / self.EI for i in Dy[2][0]]&#10;&#10;        import inspect&#10;        print(f&quot;{inspect.getfile(inspect.currentframe())}:{inspect.currentframe().f_lineno}&quot;)&#10;        print(&quot;Dy:&quot;, Dy, sep=&quot;\n&quot;)&#10;        from display_utils import print_quantity_nested_list; print_quantity_nested_list(Dy,simplify_units=True)&#10;        # self.Wx = PiecewisePolynomial()  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial(Wy); print(&quot;Wy:&quot;, self.Wy, sep=&quot;\n&quot;) # Vertical Load Function&#10;&#10;        self.Ax = PiecewisePolynomial()&#10;        self.Dx = PiecewisePolynomial()&#10;        from pprint import pprint; pprint(Vy); self.Vy = PiecewisePolynomial(Vy); print(&quot;Vy:&quot;, self.Vy, sep=&quot;\n&quot;)&#10;        print(&quot;Mz=&quot;); pprint(Mz, width=240); self.Mz = PiecewisePolynomial(Mz); print(&quot;Mz:&quot;, self.Mz, sep=&quot;\n&quot;) # this is a moment&#10;        print(&quot;Sz=&quot;); pprint(Sz, width=240); self.Sz = PiecewisePolynomial(Sz); print(&quot;Sz:&quot;, self.Sz,sep=&quot;\n&quot;) # this is an angle&#10;        print(&quot;Dy=&quot;); pprint(Dy, width=240); self.Dy = PiecewisePolynomial(Dy); print(&quot;Dy:&quot;, self.Dy,sep=&quot;\n&quot;)&#10;&#10;        # After creating all polynomial objects&#10;        # fig = self.plot_all_functions()&#10;        # fig.show()  # If you want to display immediately&#10;&#10;        from PiecewisePolynomial2 import PiecewisePolynomial2&#10;        # Create PiecewisePolynomial2 objects for each function&#10;        self.Wy2 = PiecewisePolynomial2(Wy)&#10;        self.Vy2 = PiecewisePolynomial2(Vy)&#10;        self.Mz2 = PiecewisePolynomial2(Mz)&#10;        self.Sz2 = PiecewisePolynomial2(Sz)&#10;        self.Dy2 = PiecewisePolynomial2(Dy)&#10;        # Print the PiecewisePolynomial2 objects&#10;        print(&quot;Wy2:&quot;, self.Wy2)&#10;        print(&quot;Vy2:&quot;, self.Vy2)&#10;        print(&quot;Mz2:&quot;, self.Mz2)&#10;        print(&quot;Sz2:&quot;, self.Sz2)&#10;        print(&quot;Dy2:&quot;, self.Dy2)&#10;&#10;        # After creating PiecewisePolynomial2 objects&#10;        # ppoly_fig = self.plot_all_ppoly_functions()&#10;        # ppoly_fig.show()  # If you want to display immediately&#10;&#10;&#10;    def FEF(self):&#10;        L = self.L&#10;&#10;        c3 = self.c03&#10;        c6 = self.c06&#10;        c7 = self.c07&#10;        c9 = self.c09&#10;&#10;        # Calculate fixed end moments&#10;        Miz = -1 * (c3 * L * L + 2 * c6 * L + 2 * c9 + 4 * c7) / L&#10;        Mjz = -1 * (2 * c3 * L * L + 4 * c6 * L + 4 * c9 + 2 * c7) / L&#10;&#10;        # Calculate fixed end forces&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Dimension checking&#10;        # print(f&quot;DEBUG: Checking dimensions - Miz: {Miz.dimensionality}, Mjz: {Mjz.dimensionality}&quot;)&#10;        # print(f&quot;DEBUG: Checking dimensions - Riy: {Riy.dimensionality}, Rjy: {Rjy.dimensionality}&quot;)&#10;&#10;        # Verify moment dimensions&#10;        # try:&#10;        #     Miz.check(MOMENT_DIMENSIONALITY)&#10;        #     Mjz.check(MOMENT_DIMENSIONALITY)&#10;        #     # print(&quot;DEBUG: Moment dimension check passed&quot;)&#10;        # except pint.DimensionalityError as e:&#10;        #     print(f&quot;ERROR: Dimension error in moments: {e}&quot;)&#10;        #     # Create correctly dimensioned values as fallback&#10;        #     if not Miz.check(MOMENT_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Miz from {Miz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;        #         Miz = unit_manager.ureg.Quantity(Miz.magnitude, INTERNAL_MOMENT_UNIT)&#10;        #     if not Mjz.check(MOMENT_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Mjz from {Mjz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;        #         Mjz = unit_manager.ureg.Quantity(Mjz.magnitude, INTERNAL_MOMENT_UNIT)&#10;&#10;        # Verify force dimensions&#10;        # try:&#10;        #     Riy.check(FORCE_DIMENSIONALITY)&#10;        #     Rjy.check(FORCE_DIMENSIONALITY)&#10;        #     # print(&quot;DEBUG: Force dimension check passed&quot;)&#10;        # except pint.DimensionalityError as e:&#10;        #     print(f&quot;ERROR: Dimension error in forces: {e}&quot;)&#10;        #     # Create correctly dimensioned values as fallback&#10;        #     if not Riy.check(FORCE_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Riy from {Riy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;        #         Riy = unit_manager.ureg.Quantity(Riy.magnitude, INTERNAL_FORCE_UNIT)&#10;        #     if not Rjy.check(FORCE_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Rjy from {Rjy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;        #         Rjy = unit_manager.ureg.Quantity(Rjy.magnitude, INTERNAL_FORCE_UNIT)&#10;&#10;        # Print forces and moments in both SI and display units&#10;        from pyMAOS.units_mod import convert_to_display_units&#10;        from pyMAOS.units_mod import FORCE_DISPLAY_UNIT, MOMENT_DISPLAY_UNIT&#10;        # Get current unit system directly from the manager&#10;        # current_units = unit_manager.get_current_units()&#10;        # system_name = unit_manager.get_system_name()&#10;        # Riy_display = Riy.to(FORCE_DISPLAY_UNIT)&#10;        # Rjy_display = Rjy.to(FORCE_DISPLAY_UNIT)&#10;        # Miz_display = Miz.to(MOMENT_DISPLAY_UNIT)&#10;        # Mjz_display = Mjz.to(MOMENT_DISPLAY_UNIT)&#10;        #&#10;        # print(f&quot;Vertical reactions - SI: Riy={Riy:.3f} N, Rjy={Rjy:.3f} N&quot;)&#10;        # print(f&quot;Vertical reactions - Display: Riy={Riy_display:.3f}, Rjy={Rjy_display:.3f}&quot;)&#10;        # print(f&quot;Moments - SI: Miz={Miz:.3f} N*m, Mjz={Mjz:.3f} N*m&quot;)&#10;        # print(f&quot;Moments - Display: Miz={Miz_display:.3f}, Mjz={Mjz_display:.3f}&quot;)&#10;&#10;        ret_val = np.array([unit_manager.ureg.Quantity(0, INTERNAL_FORCE_UNIT), Riy, Miz, unit_manager.ureg.Quantity(0, INTERNAL_FORCE_UNIT), Rjy, Mjz], dtype=object)&#10;        print(f&quot;FEF distributed load results on member {self.member_uid} for Load Case {self.loadcase}:&quot;, ret_val, sep=&quot;\n&quot;)&#10;&#10;        # Final dimension check for return values&#10;        for i, (idx, expected_dim) in enumerate([(0, FORCE_DIMENSIONALITY), (1, FORCE_DIMENSIONALITY),&#10;                                               (2, MOMENT_DIMENSIONALITY), (3, FORCE_DIMENSIONALITY),&#10;                                               (4, FORCE_DIMENSIONALITY), (5, MOMENT_DIMENSIONALITY)]):&#10;            try:&#10;                ret_val[idx].check(expected_dim)&#10;            except pint.DimensionalityError as e:&#10;                print(f&quot;Dimensionality error in ret_val[{idx}]: {e}&quot;)&#10;                print(f&quot;  Actual: {ret_val[idx].dimensionality}, Expected: {expected_dim}&quot;)&#10;&#10;        return ret_val&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of a linear load.&#10;        &#10;        Returns:&#10;        -------&#10;        str&#10;            Description of the linear load including magnitude, position, and load case.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Linear Load ({self.loadcase}): &quot;&#10;                f&quot;w1={self.w1:.3f}, w2={self.w2:.3f}, &quot;&#10;                f&quot;from x={self.a:.3f} to x={self.b:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of beam response across all three regions with ASCII charts.&#10;&#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;        from pyMAOS.units_mod import convert_to_display_units&#10;        from pyMAOS.units_mod import unit_manager&#10;        import numpy as np&#10;&#10;        # Get current unit system directly from the manager&#10;        current_units = unit_manager.get_current_units()&#10;        system_name = unit_manager.get_system_name()&#10;        print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        print(f&quot;Total Load W = {self.W:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.W, 'force'):.3f} {current_units['force']})&quot;)&#10;        print(f&quot;Load centroid from left: {self.a + self.cbar:.3f}&quot;)&#10;        print(f&quot;Reactions: Riy = {self.Riy:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.Riy, 'force'):.3f} {current_units['force']}), Rjy = {self.Rjy:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.Rjy, 'force'):.3f} {current_units['force']})&quot;, end=&quot;\n&quot;)&#10;&#10;        # Sample points across all regions&#10;        regions = [(0, self.a), (self.a, self.b), (self.b, self.L)]&#10;        region_names = [&quot;Before Load [0 to a]&quot;, &quot;Loaded Region [a to b]&quot;, &quot;After Load [b to L]&quot;]&#10;&#10;        # Create sampling points&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                # points=np.linspace(start, end, num_points+1).tolist()&#10;                print(f&quot;Region {i+1} ({region_names[i]}): {points}&quot;)&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;&#10;        # Convert to numpy array&#10;        x_array = np.array(all_x, dtype=object)&#10;&#10;        # Calculate function values using vectorized evaluation&#10;        wy_values = self.Wy.evaluate_vectorized(x_array)&#10;        vy_values = self.Vy.evaluate_vectorized(x_array)&#10;        mz_values = self.Mz.evaluate_vectorized(x_array)&#10;        sz_values = self.Sz.evaluate_vectorized(x_array)&#10;        dy_values = self.Dy.evaluate_vectorized(x_array)&#10;&#10;        # Print ASCII charts&#10;        self._print_ascii_chart(&quot;Distributed Load (Wy)&quot;, all_x, wy_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Shear Force (Vy)&quot;, all_x, vy_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Bending Moment (Mz)&quot;, all_x, mz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Rotation (Sz)&quot;, all_x, sz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Deflection (Dy)&quot;, all_x, dy_values, regions, chart_width, chart_height)&#10;&#10;        # Print table of values at region boundaries&#10;        print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;        print(f&quot;{'Position':15} {'Load':15} {'Shear':15} {'Moment':15} {'Rotation':15} {'Deflection':15}&quot;)&#10;        print(&quot;-&quot; * 90)&#10;        for x in [0, self.a, self.b, self.L]:&#10;            print(f&quot;{x:15.3f} {self.Wy.evaluate(x):15.3f} {self.Vy.evaluate(x):15.3f} {self.Mz.evaluate(x):15.3f} &quot;&#10;                  f&quot;{self.Sz.evaluate(x):15.3e} {self.Dy.evaluate(x):15.3e}&quot;)&#10;    &#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;&#10;        Parameters&#10;        ----------&#10;        title : str&#10;            Chart title&#10;        x_values : list or array&#10;            X-coordinates (can include units)&#10;        y_values : list or array&#10;            Y-coordinates (can include units)&#10;        regions : list&#10;            List of region boundaries as (start, end) tuples&#10;        width : int&#10;            Chart width in characters&#10;        height : int&#10;            Chart height in characters&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Debug prints for troubleshooting&#10;        # print(f&quot;First few x values: {x_values[:3]}&quot;)&#10;        # print(f&quot;First few y values: {y_values[:3]}&quot;)&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(y_values)&#10;        max_y = max(y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            range_y = max_y - min_y&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart&#10;            range_y = max_y - min_y&#10;            y_pos = height - 1 - int((y - min_y) / range_y * (height - 1))&#10;            y_pos = min(height - 1, max(0, y_pos))&#10;&#10;            chart[y_pos][x_pos] = '*'&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        print(f&quot;Region boundaries: [{Quantity(0, self.a.units)}, {self.a:.2f}, {self.b:.2f}, {self.L:.2f}]&quot;)&#10;&#10;    def plot_all_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all non-empty PiecewisePolynomial functions.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial objects with their names and colors&#10;        functions = []&#10;        if hasattr(self, 'Wy') and self.Wy.functions:&#10;            functions.append(('Wy', self.Wy, 'blue', 'Distributed Load'))&#10;        if hasattr(self, 'Vy') and self.Vy.functions:&#10;            functions.append(('Vy', self.Vy, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz') and self.Mz.functions:&#10;            functions.append(('Mz', self.Mz, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz') and self.Sz.functions:&#10;            functions.append(('Sz', self.Sz, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy') and self.Dy.functions:&#10;            functions.append(('Dy', self.Dy, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key points&#10;            for x in [self.a, self.b]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title&#10;        fig.suptitle(f&quot;Beam Analysis for {self.__str__()}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig&#10;&#10;    def plot_all_ppoly_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all PiecewisePolynomial2 functions.&#10;        Uses the efficient PPoly representation for better performance.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial2 objects&#10;        functions = []&#10;        if hasattr(self, 'Wy2') and self.Wy2.ppoly is not None:&#10;            functions.append(('Wy2', self.Wy2, 'blue', 'Distributed Load'))&#10;        if hasattr(self, 'Vy2') and self.Vy2.ppoly is not None:&#10;            functions.append(('Vy2', self.Vy2, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz2') and self.Mz2.ppoly is not None:&#10;            functions.append(('Mz2', self.Mz2, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz2') and self.Sz2.ppoly is not None:&#10;            functions.append(('Sz2', self.Sz2, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy2') and self.Dy2.ppoly is not None:&#10;            functions.append(('Dy2', self.Dy2, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No PiecewisePolynomial2 functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} PiecewisePolynomial2 functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key load boundaries&#10;            for x in [self.a, self.b]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title&#10;        fig.suptitle(f&quot;Beam Analysis (PPoly) for {self.__str__()}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig" />
              <option name="updatedContent" value="import sys&#10;import pint&#10;from pint import Quantity&#10;from typing import TYPE_CHECKING, Any&#10;# from pyMAOS.display_utils import display_node_load_vector_in_units&#10;import numpy as np&#10;from pyMAOS.loading.piecewisePolinomial import PiecewisePolynomial&#10;import pyMAOS&#10;# from pyMAOS.units_mod import (SI_UNITS, IMPERIAL_UNITS, METRIC_KN_UNITS,&#10;#     INTERNAL_LENGTH_UNIT, INTERNAL_FORCE_UNIT,  INTERNAL_MOMENT_UNIT, INTERNAL_PRESSURE_UNIT, INTERNAL_DISTRIBUTED_LOAD_UNIT,&#10;#     FORCE_DIMENSIONALITY, LENGTH_DIMENSIONALITY, MOMENT_DIMENSIONALITY, PRESSURE_DIMENSIONALITY, DISTRIBUTED_LOAD_DIMENSIONALITY,&#10;#     unit_manager&#10;# )&#10;&#10;from pprint import pprint&#10;&#10;# Use TYPE_CHECKING to avoid runtime imports&#10;if TYPE_CHECKING:&#10;    from pyMAOS.frame2d import R2Frame&#10;&#10;class LinearLoadXY:&#10;    def __init__(self, w1: pint.Quantity, w2: pint.Quantity, a: pint.Quantity, b: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        self.w1 = w1&#10;        self.w2 = w2&#10;        self.a = a&#10;        self.b = b&#10;        self.c = b - a&#10;        self.member_uid = member.uid&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.I = member.section.Ixx&#10;&#10;        self.EI = self.E * self.I&#10;&#10;        self.kind = &quot;LINE&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Constants of Integration&#10;        # self.integration_constants()&#10;        &quot;&quot;&quot;&#10;                Calculate the integration constants for beam deflection equations.&#10;&#10;                These constants (c01-c12) are determined by enforcing boundary conditions:&#10;                - Continuity of shear, moment, slope, and deflection at load discontinuities&#10;                - Zero displacement and rotation at member ends (for fixed-end conditions)&#10;                - Equilibrium of forces and moments&#10;                &quot;&quot;&quot;&#10;        # w1 = self.w1&#10;        # w2 = self.w2&#10;        # a = self.a&#10;        # b = self.b&#10;        L = self.L&#10;&#10;        #     These constants (c01-c12) are determined by enforcing boundary conditions:&#10;        #     - Continuity of shear, moment, slope, and deflection at load discontinuities&#10;        #     - Zero displacement and rotation at member ends (for fixed-end conditions)&#10;        #     - Equilibrium of forces and moments&#10;        #&#10;        #     The constants are used in the piecewise polynomial functions that define:&#10;        #     - Vy: Shear force distribution&#10;        #     - Mz: Bending moment distribution&#10;        #     - Sz: Slope (rotation) distribution&#10;        #     - Dy: Deflection distribution&#10;&#10;        # Constants for the shear force function (Vy)&#10;        self.c01 = (&#10;                          (((2 * b * b) + ((-a - 3 * L) * b) - (a * a) + (3 * L * a)) * w2)&#10;                          + (((b * b) + ((a - 3 * L) * b) - (2 * a * a) + (3 * L * a)) * w1)&#10;                  ) / (6 * L)&#10;        self.c02 = (&#10;                          (&#10;                                  (&#10;                                          (2 * b * b * b)&#10;                                          + ((-3 * a - 3 * L) * b * b)&#10;                                          + (6 * L * a * b)&#10;                                          + (a * a * a)&#10;                                  )&#10;                                  * w2&#10;                          )&#10;                          + (((b * b * b) - (3 * L * b * b) - (3 * a * a * b) + (2 * a * a * a)) * w1)&#10;                  ) / (6 * L * b - 6 * L * a)&#10;        self.c03 = (&#10;                          ((2 * b * b - a * b - a * a) * w2) + ((b * b + a * b - 2 * a * a) * w1)&#10;                  ) / (6 * L)&#10;&#10;        # Constants for the bending moment function (Mz)&#10;        # Use unit_manager.ureg instead of direct import&#10;        self.c04 = pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)  # Zero moment at x=0 for fixed-end condition&#10;        self.c05 = (&#10;                -1&#10;                * ((a * a * a * w2) + ((2 * a * a * a - 3 * a * a * b) * w1))&#10;                / (6 * b - 6 * a)&#10;        )&#10;        self.c06 = (&#10;                -1&#10;                * ((2 * b * b - a * b - a * a) * w2 + (b * b + a * b - 2 * a * a) * w1)&#10;                / 6&#10;        )&#10;&#10;        # Constants for the slope function (Sz)&#10;        self.c07 = (&#10;                          (&#10;                                  12 * b * b * b * b&#10;                                  + (-3 * a - 45 * L) * b * b * b&#10;                                  + (-3 * a * a + 15 * L * a + 40 * L * L) * b * b&#10;                                  + (-3 * a * a * a + 15 * L * a * a - 20 * L * L * a) * b&#10;                                  - 3 * a * a * a * a&#10;                                  + 15 * L * a * a * a&#10;                                  - 20 * L * L * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b&#10;                                  + (3 * a - 15 * L) * b * b * b&#10;                                  + (3 * a * a - 15 * L * a + 20 * L * L) * b * b&#10;                                  + (3 * a * a * a - 15 * L * a * a + 20 * L * L * a) * b&#10;                                  - 12 * a * a * a * a&#10;                                  + 45 * L * a * a * a&#10;                                  - 40 * L * L * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L)&#10;        self.c08 = (&#10;                          (&#10;                                  12 * b * b * b * b * b&#10;                                  + (-15 * a - 45 * L) * b * b * b * b&#10;                                  + (60 * L * a + 40 * L * L) * b * b * b&#10;                                  - 60 * L * L * a * b * b&#10;                                  + 3 * a * a * a * a * a&#10;                                  + 20 * L * L * a * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b * b&#10;                                  - 15 * L * b * b * b * b&#10;                                  + 20 * L * L * b * b * b&#10;                                  + (-15 * a * a * a * a - 60 * L * L * a * a) * b&#10;                                  + 12 * a * a * a * a * a&#10;                                  + 40 * L * L * a * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L * b - 360 * L * a)&#10;        self.c09 = (&#10;                          (&#10;                                  12 * b * b * b * b&#10;                                  - 3 * a * b * b * b&#10;                                  + (40 * L * L - 3 * a * a) * b * b&#10;                                  + (-3 * a * a * a - 20 * L * L * a) * b&#10;                                  - 3 * a * a * a * a&#10;                                  - 20 * L * L * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b&#10;                                  + 3 * a * b * b * b&#10;                                  + (3 * a * a + 20 * L * L) * b * b&#10;                                  + (3 * a * a * a + 20 * L * L * a) * b&#10;                                  - 12 * a * a * a * a&#10;                                  - 40 * L * L * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L)&#10;&#10;        # Constants for the deflection function (Dy)&#10;        self.c10 = pyMAOS.unit_manager.ureg.Quantity(0, f&quot;{pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}**3 * {pyMAOS.unit_manager.INTERNAL_FORCE_UNIT}&quot;)  # Zero deflection at x=0 for fixed-end condition&#10;        self.c11 = (&#10;                -1 /120&#10;                * (&#10;                        a * a * a * a * a * w2&#10;                        + (4 * a * a * a * a * a - 5 * a * a * a * a * b) * w1&#10;                )&#10;                / (b - a)&#10;        )&#10;        self.c12 = (&#10;                -1&#10;                * (&#10;                        (&#10;                                4 * b * b * b * b&#10;                                - a * b * b * b&#10;                                - a * a * b * b&#10;                                - a * a * a * b&#10;                                - a * a * a * a&#10;                        )&#10;                        * w2&#10;                        + (&#10;                                b * b * b * b&#10;                                + a * b * b * b&#10;                                + a * a * b * b&#10;                                + a * a * a * b&#10;                                - 4 * a * a * a * a&#10;                        )&#10;                        * w1&#10;                )&#10;                / 120&#10;        )&#10;&#10;        # Simple End Reactions&#10;        self.W = 0.5 * self.c * (self.w2 + self.w1)&#10;        self.cbar = ((self.w1 + (2 * self.w2)) / (3 * (self.w2 + self.w1))) * self.c&#10;&#10;        self.Rjy = -1 * self.W * (self.a + self.cbar) * (1 / self.L)&#10;        self.Riy = -1 * self.W - self.Rjy&#10;&#10;        # Piecewise Functions&#10;        # Each piecewise function represents a different structural response:&#10;        # - Wy: Distributed load function (input)&#10;        # - Vy: Shear force distribution (integral of Wy)&#10;        # - Mz: Bending moment distribution (integral of Vy)&#10;        # - Sz: Rotation/slope distribution (integral of Mz/EI)&#10;        # - Dy: Deflection distribution (integral of Sz)&#10;        #&#10;        # Each function is defined in three pieces:&#10;        # 1. Before loaded region [0 to a]&#10;        # 2. Within loaded region [a to b] &#10;        # 3. After loaded region [b to L]&#10;        #&#10;        # Format: [[coefficients], [domain_bounds]]&#10;        # where coefficients = [c, c, c...] representing c + cx + cx + ...&#10;        Wy = [&#10;            [[pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT)], [pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    ((-1 * self.a * self.w2) - (self.c * self.w1) - (self.a * self.w1))&#10;                    / self.c,&#10;                    (self.w2 - self.w1) / self.c,&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT)], [self.b, self.L]],&#10;        ]; print(&quot;Wy:\n&quot;, Wy)&#10;&#10;        Vy = [&#10;            [[self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c02,&#10;                    self.w1&#10;                    + ((self.a * self.w1) / self.c)&#10;                    - ((self.a * self.w2) / self.c),&#10;                    (self.w2 / (2 * self.c)) - (self.w1 / (2 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c03], [self.b, self.L]],&#10;        ]; print(&quot;Vy:\n&quot;, Vy)&#10;&#10;        Mz = [&#10;            [[self.c04, self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c05,&#10;                    self.c02,&#10;                    (self.w1 / 2)&#10;                    + ((self.a * self.w1) / (2 * self.c))&#10;                    - ((self.a * self.w2) / (2 * self.c)),&#10;                    (self.w2 / (6 * self.c)) - (self.w1 / (6 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c06, self.c03], [self.b, self.L]],&#10;        ]; print(&quot;Mz:\n&quot;, Mz)&#10;&#10;        Sz = [&#10;            [[self.c07, self.c04, 0.5 * self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c08,&#10;                    self.c05,&#10;                    0.5 * self.c02,&#10;                    (self.w1 / 6)&#10;                    + ((self.a * self.w1) / (6 * self.c))&#10;                    - ((self.a * self.w2) / (6 * self.c)),&#10;                    (self.w2 / (24 * self.c)) - (self.w1 / (24 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c09, self.c06, 0.5 * self.c03], [self.b, self.L]],&#10;        ]&#10;        Sz[0][0] = [i / self.EI for i in Sz[0][0]]&#10;        Sz[1][0] = [i / self.EI for i in Sz[1][0]]&#10;        Sz[2][0] = [i / self.EI for i in Sz[2][0]]&#10;&#10;        print(&quot;Sz:\n&quot;, Sz)&#10;&#10;        Dy = [&#10;            [[self.c10, self.c07, 0.5 * self.c04, self.c01 / 6], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c11,&#10;                    self.c08,&#10;                    0.5 * self.c05,&#10;                    self.c02 / 6,&#10;                    (self.w1 / 24)&#10;                    + ((self.a * self.w1) / (24 * self.c))&#10;                    - ((self.a * self.w2) / (24 * self.c)),&#10;                    (self.w2 / (120 * self.c)) - (self.w1 / (120 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [&#10;                [self.c12, self.c09, 0.5 * self.c06, self.c03 / 6],&#10;                [self.b, self.L],&#10;            ],&#10;        ]&#10;&#10;        Dy[0][0] = [i / self.EI for i in Dy[0][0]]&#10;        Dy[1][0] = [i / self.EI for i in Dy[1][0]]&#10;        Dy[2][0] = [i / self.EI for i in Dy[2][0]]&#10;&#10;        import inspect&#10;        print(f&quot;{inspect.getfile(inspect.currentframe())}:{inspect.currentframe().f_lineno}&quot;)&#10;        print(&quot;Dy:&quot;, Dy, sep=&quot;\n&quot;)&#10;        from display_utils import print_quantity_nested_list; print_quantity_nested_list(Dy,simplify_units=True)&#10;        # self.Wx = PiecewisePolynomial()  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial(Wy); print(&quot;Wy:&quot;, self.Wy, sep=&quot;\n&quot;) # Vertical Load Function&#10;&#10;        self.Ax = PiecewisePolynomial()&#10;        self.Dx = PiecewisePolynomial()&#10;        from pprint import pprint; pprint(Vy); self.Vy = PiecewisePolynomial(Vy); print(&quot;Vy:&quot;, self.Vy, sep=&quot;\n&quot;)&#10;        print(&quot;Mz=&quot;); pprint(Mz, width=240); self.Mz = PiecewisePolynomial(Mz); print(&quot;Mz:&quot;, self.Mz, sep=&quot;\n&quot;) # this is a moment&#10;        print(&quot;Sz=&quot;); pprint(Sz, width=240); self.Sz = PiecewisePolynomial(Sz); print(&quot;Sz:&quot;, self.Sz,sep=&quot;\n&quot;) # this is an angle&#10;        print(&quot;Dy=&quot;); pprint(Dy, width=240); self.Dy = PiecewisePolynomial(Dy); print(&quot;Dy:&quot;, self.Dy,sep=&quot;\n&quot;)&#10;&#10;        # After creating all polynomial objects&#10;        # fig = self.plot_all_functions()&#10;        # fig.show()  # If you want to display immediately&#10;&#10;        from PiecewisePolynomial2 import PiecewisePolynomial2&#10;        # Create PiecewisePolynomial2 objects for each function&#10;        self.Wy2 = PiecewisePolynomial2(Wy)&#10;        self.Vy2 = PiecewisePolynomial2(Vy)&#10;        self.Mz2 = PiecewisePolynomial2(Mz)&#10;        self.Sz2 = PiecewisePolynomial2(Sz)&#10;        self.Dy2 = PiecewisePolynomial2(Dy)&#10;        # Print the PiecewisePolynomial2 objects&#10;        print(&quot;Wy2:&quot;, self.Wy2)&#10;        print(&quot;Vy2:&quot;, self.Vy2)&#10;        print(&quot;Mz2:&quot;, self.Mz2)&#10;        print(&quot;Sz2:&quot;, self.Sz2)&#10;        print(&quot;Dy2:&quot;, self.Dy2)&#10;&#10;        # After creating PiecewisePolynomial2 objects&#10;        # ppoly_fig = self.plot_all_ppoly_functions()&#10;        # ppoly_fig.show()  # If you want to display immediately&#10;&#10;&#10;    def FEF(self):&#10;        &quot;&quot;&quot;&#10;        Compute and return the fixed and forces&#10;        &quot;&quot;&quot;&#10;        L = self.L&#10;&#10;        c3 = self.c03&#10;        c6 = self.c06&#10;        c7 = self.c07&#10;        c9 = self.c09&#10;&#10;        # Calculate fixed end moments&#10;        Miz = -1 * (c3 * L * L + 2 * c6 * L + 2 * c9 + 4 * c7) / L&#10;        Mjz = -1 * (2 * c3 * L * L + 4 * c6 * L + 4 * c9 + 2 * c7) / L&#10;&#10;        # Calculate fixed end forces&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Dimension checking&#10;        # print(f&quot;DEBUG: Checking dimensions - Miz: {Miz.dimensionality}, Mjz: {Mjz.dimensionality}&quot;)&#10;        # print(f&quot;DEBUG: Checking dimensions - Riy: {Riy.dimensionality}, Rjy: {Rjy.dimensionality}&quot;)&#10;&#10;        # Verify moment dimensions&#10;        # try:&#10;        #     Miz.check(MOMENT_DIMENSIONALITY)&#10;        #     Mjz.check(MOMENT_DIMENSIONALITY)&#10;        #     # print(&quot;DEBUG: Moment dimension check passed&quot;)&#10;        # except pint.DimensionalityError as e:&#10;        #     print(f&quot;ERROR: Dimension error in moments: {e}&quot;)&#10;        #     # Create correctly dimensioned values as fallback&#10;        #     if not Miz.check(MOMENT_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Miz from {Miz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;        #         Miz = unit_manager.ureg.Quantity(Miz.magnitude, INTERNAL_MOMENT_UNIT)&#10;        #     if not Mjz.check(MOMENT_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Mjz from {Mjz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;        #         Mjz = unit_manager.ureg.Quantity(Mjz.magnitude, INTERNAL_MOMENT_UNIT)&#10;&#10;        # Verify force dimensions&#10;        # try:&#10;        #     Riy.check(FORCE_DIMENSIONALITY)&#10;        #     Rjy.check(FORCE_DIMENSIONALITY)&#10;        #     # print(&quot;DEBUG: Force dimension check passed&quot;)&#10;        # except pint.DimensionalityError as e:&#10;        #     print(f&quot;ERROR: Dimension error in forces: {e}&quot;)&#10;        #     # Create correctly dimensioned values as fallback&#10;        #     if not Riy.check(FORCE_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Riy from {Riy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;        #         Riy = unit_manager.ureg.Quantity(Riy.magnitude, INTERNAL_FORCE_UNIT)&#10;        #     if not Rjy.check(FORCE_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Rjy from {Rjy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;        #         Rjy = unit_manager.ureg.Quantity(Rjy.magnitude, INTERNAL_FORCE_UNIT)&#10;&#10;        # Print forces and moments in both SI and display units&#10;        from pyMAOS.units_mod import convert_to_display_units&#10;        from pyMAOS.units_mod import FORCE_DISPLAY_UNIT, MOMENT_DISPLAY_UNIT&#10;        # Get current unit system directly from the manager&#10;        # current_units = unit_manager.get_current_units()&#10;        # system_name = unit_manager.get_system_name()&#10;        # Riy_display = Riy.to(FORCE_DISPLAY_UNIT)&#10;        # Rjy_display = Rjy.to(FORCE_DISPLAY_UNIT)&#10;        # Miz_display = Miz.to(MOMENT_DISPLAY_UNIT)&#10;        # Mjz_display = Mjz.to(MOMENT_DISPLAY_UNIT)&#10;        #&#10;        # print(f&quot;Vertical reactions - SI: Riy={Riy:.3f} N, Rjy={Rjy:.3f} N&quot;)&#10;        # print(f&quot;Vertical reactions - Display: Riy={Riy_display:.3f}, Rjy={Rjy_display:.3f}&quot;)&#10;        # print(f&quot;Moments - SI: Miz={Miz:.3f} N*m, Mjz={Mjz:.3f} N*m&quot;)&#10;        # print(f&quot;Moments - Display: Miz={Miz_display:.3f}, Mjz={Mjz_display:.3f}&quot;)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = 0 * pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;&#10;        ret_val = np.array([pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT), Riy, Miz, pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS unit_manager.INTERNAL_FORCE_UNIT), Rjy, Mjz], dtype=object)&#10;        print(f&quot;FEF distributed load results on member {self.member_uid} for Load Case {self.loadcase}:&quot;, ret_val, sep=&quot;\n&quot;)&#10;&#10;        # Final dimension check for return values&#10;        for i, (idx, expected_dim) in enumerate([(0, FORCE_DIMENSIONALITY), (1, FORCE_DIMENSIONALITY),&#10;                                               (2, MOMENT_DIMENSIONALITY), (3, FORCE_DIMENSIONALITY),&#10;                                               (4, FORCE_DIMENSIONALITY), (5, MOMENT_DIMENSIONALITY)]):&#10;            try:&#10;                ret_val[idx].check(expected_dim)&#10;            except pint.DimensionalityError as e:&#10;                print(f&quot;Dimensionality error in ret_val[{idx}]: {e}&quot;)&#10;                print(f&quot;  Actual: {ret_val[idx].dimensionality}, Expected: {expected_dim}&quot;)&#10;&#10;        return ret_val&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of a linear load.&#10;        &#10;        Returns:&#10;        -------&#10;        str&#10;            Description of the linear load including magnitude, position, and load case.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Linear Load ({self.loadcase}): &quot;&#10;                f&quot;w1={self.w1:.3f}, w2={self.w2:.3f}, &quot;&#10;                f&quot;from x={self.a:.3f} to x={self.b:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of beam response across all three regions with ASCII charts.&#10;&#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;        from pyMAOS.units_mod import convert_to_display_units&#10;        from pyMAOS.units_mod import unit_manager&#10;        import numpy as np&#10;&#10;        # Get current unit system directly from the manager&#10;        current_units = unit_manager.get_current_units()&#10;        system_name = unit_manager.get_system_name()&#10;        print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        print(f&quot;Total Load W = {self.W:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.W, 'force'):.3f} {current_units['force']})&quot;)&#10;        print(f&quot;Load centroid from left: {self.a + self.cbar:.3f}&quot;)&#10;        print(f&quot;Reactions: Riy = {self.Riy:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.Riy, 'force'):.3f} {current_units['force']}), Rjy = {self.Rjy:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.Rjy, 'force'):.3f} {current_units['force']})&quot;, end=&quot;\n&quot;)&#10;&#10;        # Sample points across all regions&#10;        regions = [(0, self.a), (self.a, self.b), (self.b, self.L)]&#10;        region_names = [&quot;Before Load [0 to a]&quot;, &quot;Loaded Region [a to b]&quot;, &quot;After Load [b to L]&quot;]&#10;&#10;        # Create sampling points&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                # points=np.linspace(start, end, num_points+1).tolist()&#10;                print(f&quot;Region {i+1} ({region_names[i]}): {points}&quot;)&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;&#10;        # Convert to numpy array&#10;        x_array = np.array(all_x, dtype=object)&#10;&#10;        # Calculate function values using vectorized evaluation&#10;        wy_values = self.Wy.evaluate_vectorized(x_array)&#10;        vy_values = self.Vy.evaluate_vectorized(x_array)&#10;        mz_values = self.Mz.evaluate_vectorized(x_array)&#10;        sz_values = self.Sz.evaluate_vectorized(x_array)&#10;        dy_values = self.Dy.evaluate_vectorized(x_array)&#10;&#10;        # Print ASCII charts&#10;        self._print_ascii_chart(&quot;Distributed Load (Wy)&quot;, all_x, wy_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Shear Force (Vy)&quot;, all_x, vy_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Bending Moment (Mz)&quot;, all_x, mz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Rotation (Sz)&quot;, all_x, sz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Deflection (Dy)&quot;, all_x, dy_values, regions, chart_width, chart_height)&#10;&#10;        # Print table of values at region boundaries&#10;        print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;        print(f&quot;{'Position':15} {'Load':15} {'Shear':15} {'Moment':15} {'Rotation':15} {'Deflection':15}&quot;)&#10;        print(&quot;-&quot; * 90)&#10;        for x in [0, self.a, self.b, self.L]:&#10;            print(f&quot;{x:15.3f} {self.Wy.evaluate(x):15.3f} {self.Vy.evaluate(x):15.3f} {self.Mz.evaluate(x):15.3f} &quot;&#10;                  f&quot;{self.Sz.evaluate(x):15.3e} {self.Dy.evaluate(x):15.3e}&quot;)&#10;    &#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;&#10;        Parameters&#10;        ----------&#10;        title : str&#10;            Chart title&#10;        x_values : list or array&#10;            X-coordinates (can include units)&#10;        y_values : list or array&#10;            Y-coordinates (can include units)&#10;        regions : list&#10;            List of region boundaries as (start, end) tuples&#10;        width : int&#10;            Chart width in characters&#10;        height : int&#10;            Chart height in characters&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Debug prints for troubleshooting&#10;        # print(f&quot;First few x values: {x_values[:3]}&quot;)&#10;        # print(f&quot;First few y values: {y_values[:3]}&quot;)&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(y_values)&#10;        max_y = max(y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            range_y = max_y - min_y&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart&#10;            range_y = max_y - min_y&#10;            y_pos = height - 1 - int((y - min_y) / range_y * (height - 1))&#10;            y_pos = min(height - 1, max(0, y_pos))&#10;&#10;            chart[y_pos][x_pos] = '*'&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        print(f&quot;Region boundaries: [{Quantity(0, self.a.units)}, {self.a:.2f}, {self.b:.2f}, {self.L:.2f}]&quot;)&#10;&#10;    def plot_all_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all non-empty PiecewisePolynomial functions.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial objects with their names and colors&#10;        functions = []&#10;        if hasattr(self, 'Wy') and self.Wy.functions:&#10;            functions.append(('Wy', self.Wy, 'blue', 'Distributed Load'))&#10;        if hasattr(self, 'Vy') and self.Vy.functions:&#10;            functions.append(('Vy', self.Vy, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz') and self.Mz.functions:&#10;            functions.append(('Mz', self.Mz, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz') and self.Sz.functions:&#10;            functions.append(('Sz', self.Sz, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy') and self.Dy.functions:&#10;            functions.append(('Dy', self.Dy, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key points&#10;            for x in [self.a, self.b]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title&#10;        fig.suptitle(f&quot;Beam Analysis for {self.__str__()}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig&#10;&#10;    def plot_all_ppoly_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all PiecewisePolynomial2 functions.&#10;        Uses the efficient PPoly representation for better performance.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial2 objects&#10;        functions = []&#10;        if hasattr(self, 'Wy2') and self.Wy2.ppoly is not None:&#10;            functions.append(('Wy2', self.Wy2, 'blue', 'Distributed Load'))&#10;        if hasattr(self, 'Vy2') and self.Vy2.ppoly is not None:&#10;            functions.append(('Vy2', self.Vy2, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz2') and self.Mz2.ppoly is not None:&#10;            functions.append(('Mz2', self.Mz2, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz2') and self.Sz2.ppoly is not None:&#10;            functions.append(('Sz2', self.Sz2, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy2') and self.Dy2.ppoly is not None:&#10;            functions.append(('Dy2', self.Dy2, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No PiecewisePolynomial2 functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} PiecewisePolynomial2 functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key load boundaries&#10;            for x in [self.a, self.b]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title&#10;        fig.suptitle(f&quot;Beam Analysis (PPoly) for {self.__str__()}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/loading/point_loads.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/loading/point_loads.py" />
              <option name="originalContent" value="import pint&#10;from typing import TYPE_CHECKING, Any&#10;from pyMAOS.loading.piecewisePolinomial import PiecewisePolynomial&#10;from pprint import pprint&#10;from display_utils import print_quantity_nested_list&#10;# Use TYPE_CHECKING to avoid runtime imports&#10;if TYPE_CHECKING:&#10;    from pyMAOS.frame2d import R2Frame&#10;from pyMAOS.units_mod import unit_manager&#10;&#10;class R2_Point_Moment:&#10;    def __init__(self, M: pint.Quantity, a: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        &quot;&quot;&quot;&#10;        Parameters&#10;        ----------&#10;        M : FLOAT&#10;            Applied moment, counter-clockwise positive.&#10;        a : FLOAT&#10;            Point of application of moment as measured from the member left end.&#10;        member : Element Class&#10;            the member that the load is applied to.&#10;        loadcase : STRING, optional&#10;            String representation of the applied load type, this&#10;            data is used for load cases and combindations. The default is &quot;D&quot;.&#10;        &quot;&quot;&quot;&#10;        self.M = M&#10;        self.a = a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.I = member.section.Ixx&#10;&#10;        self.EI = self.E * self.I&#10;&#10;        self.kind = &quot;MOMENT&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Constants of Integration&#10;        self.integration_constants()&#10;&#10;        # Simple End Reactions&#10;        self.Riy = self.M / self.L&#10;        self.Rjy = -1 * self.Riy&#10;&#10;        # Piecewise Functions&#10;        # [co....cn x^n] [xa, xb]&#10;&#10;        Vy = [[[self.Riy], [0, self.a]], [[self.Riy], [self.a, self.L]]]&#10;        pprint(Vy)&#10;        Mz = [&#10;            [[0, self.Riy], [0, self.a]],&#10;            [[-1 * self.M, self.Riy], [self.a, self.L]],&#10;        ]&#10;        pprint(Mz)&#10;        Sz = [&#10;            [[self.c1 / self.EI, 0, self.Riy / (2 * self.EI)], [0, self.a]],&#10;            [&#10;                [&#10;                    self.c2 / self.EI,&#10;                    -1 * self.M / self.EI,&#10;                    self.Riy / (2 * self.EI),&#10;                ],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        pprint(Sz)&#10;        Dy = [&#10;            [&#10;                [&#10;                    self.c3 / self.EI,&#10;                    self.c1 / self.EI,&#10;                    0,&#10;                    self.Riy / (6 * self.EI),&#10;                ],&#10;                [0, self.a],&#10;            ],&#10;            [&#10;                [&#10;                    self.c4 / self.EI,&#10;                    self.c2 / self.EI,&#10;                    -1 * self.M / (2 * self.EI),&#10;                    self.Riy / (6 * self.EI),&#10;                ],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        pprint(Dy)&#10;        self.Wx = PiecewisePolynomial()  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        self.Ax = PiecewisePolynomial()&#10;        self.Dx = PiecewisePolynomial()&#10;        self.Vy = PiecewisePolynomial(Vy)&#10;        self.Mz = PiecewisePolynomial(Mz)&#10;        self.Sz = PiecewisePolynomial(Sz)&#10;        self.Dy = PiecewisePolynomial(Dy)&#10;&#10;    def integration_constants(self):&#10;        M = self.M&#10;        a = self.a&#10;        L = self.L&#10;&#10;        # Constants of Integration&#10;        self.c1 = ((3 * M * a * a) - (6 * L * M * a) + (2 * L * L * M)) / (6 * L)&#10;        self.c2 = ((3 * M * a * a) + (2 * L * L * M)) / (6 * L)&#10;        self.c3 = 0&#10;        self.c4 = -1 / 2 * M * a * a&#10;&#10;    def FEF(self):&#10;        &quot;&quot;&quot;&#10;        Compute and return the fixed and forces&#10;        &quot;&quot;&quot;&#10;        M = self.M&#10;        a = self.a&#10;        L = self.L&#10;&#10;        Miz = -1 * (M * (a - L) * ((3 * a) - L)) / (L * L)&#10;        Mjz = -1 * (M * a * (3 * a - 2 * L)) / (L * L)&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = 0 * unit_manager.ureg(Riy.units)&#10;&#10;        return [zero_force, Riy, Miz, zero_force, Rjy, Mjz]&#10;&#10;&#10;class R2_Point_Load:&#10;    def __init__(self, p: pint.Quantity, a: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        self.p = p&#10;        self.a = a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.I = member.section.Ixx&#10;&#10;        self.EI = self.E * self.I&#10;&#10;        self.kind = &quot;POINT&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Constants of Integration&#10;        # self.integration_constants()&#10;        # p = self.p&#10;        # a = self.a&#10;        L = self.L&#10;        import inspect;&#10;        print(f&quot;{inspect.getfile(inspect.currentframe())}:{inspect.currentframe().f_lineno}&quot;)&#10;&#10;        from pyMAOS.units_mod import INTERNAL_LENGTH_UNIT,INTERNAL_FORCE_UNIT,INTERNAL_MOMENT_UNIT&#10;        self.c1 = unit_manager.ureg.Quantity(0, INTERNAL_MOMENT_UNIT)&#10;        self.c2 = -1 * p * a&#10;        self.c3 = (p * a * (a - (2 * L)) * (a - L)) / (6 * L)&#10;        self.c4 = (p * a * ((a * a) + (2 * L * L))) / (6 * L)&#10;        self.c5 = unit_manager.ureg.Quantity(0, f&quot;{INTERNAL_FORCE_UNIT} * {INTERNAL_LENGTH_UNIT}**3&quot;)&#10;        self.c6 = (-1 * p * a * a * a) / 6&#10;&#10;        # Simple End Reactions&#10;        self.Riy = self.p * ((self.a - self.L) / self.L)&#10;        self.Rjy = -1 * self.p * self.a * (1 / self.L)&#10;        print(f&quot;Riy: {self.Riy:.3f}, Rjy: {self.Rjy:.3f}&quot;)&#10;        # Piecewise Functions&#10;        # [co....cn x^n] [xa, xb]&#10;        Vy = [&#10;            [[self.Riy], [unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.Riy + self.p], [self.a, self.L]],&#10;        ]&#10;        print(&quot;Vy:&quot;); print_quantity_nested_list(Vy)&#10;        Mz = [&#10;            [[self.c1, self.Riy], [unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.c2, self.Riy + self.p], [self.a, self.L]],&#10;        ]&#10;        print(&quot;Mz:&quot;); print_quantity_nested_list(Mz)&#10;        Sz = [&#10;            [[self.c3, self.c1, self.Riy / 2], [unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.c4, self.c2, (self.Riy + self.p) / 2], [self.a, self.L]],&#10;        ]&#10;        Sz[0][0] = [i / self.EI for i in Sz[0][0]]&#10;        Sz[1][0] = [i / self.EI for i in Sz[1][0]]&#10;        print(&quot;Sz:&quot;); print_quantity_nested_list(Sz)&#10;        Dy = [&#10;            [[self.c5, self.c3, self.c1 / 2, self.Riy / 6], [unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [&#10;                [self.c6, self.c4, self.c2 / 2, (self.Riy + self.p) / 6],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        Dy[0][0] = [i / self.EI for i in Dy[0][0]]&#10;        Dy[1][0] = [i / self.EI for i in Dy[1][0]]&#10;        #print(Dy)&#10;        print(&quot;Dy:&quot;); print_quantity_nested_list(Dy, precision=2, width=20, simplify_units=True)&#10;&#10;        self.Wx = PiecewisePolynomial()&#10;        # print(self.Wx) # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        # print(self.Wy)&#10;        self.Ax = PiecewisePolynomial()&#10;        # print(self.Ax)&#10;        self.Dx = PiecewisePolynomial()&#10;        #print(self.Dx)&#10;        from pprint import pprint; pprint(Vy); self.Vy = PiecewisePolynomial(Vy)&#10;        print(&quot;Vy:\n&quot;, self.Vy)&#10;&#10;&#10;        self.Mz = PiecewisePolynomial(Mz)&#10;        print(&quot;Mz:\n&quot;, self.Mz)&#10;        self.Sz = PiecewisePolynomial(Sz)&#10;        print(&quot;Sz:\n&quot;, self.Sz)&#10;        self.Dy = PiecewisePolynomial(Dy)&#10;        print(&quot;Dy:\n&quot;,self.Dy)&#10;&#10;        # Create PiecewisePolynomial2 instances alongside existing ones&#10;        from pyMAOS.loading.PiecewisePolynomial2 import PiecewisePolynomial2&#10;&#10;        self.Vy2 = PiecewisePolynomial2(Vy)&#10;        print(&quot;Vy2:&quot;, self.Vy2, sep=&quot;\n&quot;)&#10;&#10;        self.Mz2 = PiecewisePolynomial2(Mz)&#10;        print(&quot;Mz2:&quot;, self.Mz2, sep=&quot;\n&quot;)&#10;&#10;        self.Sz2 = PiecewisePolynomial2(Sz)&#10;        print(&quot;Sz2:&quot;, self.Sz2, sep=&quot;\n&quot;)&#10;&#10;        self.Dy2 = PiecewisePolynomial2(Dy)&#10;        print(&quot;Dy2:&quot;, self.Dy2, sep=&quot;\n&quot;)&#10;&#10;&#10;    def FEF(self):&#10;        p = self.p&#10;        a = self.a&#10;        L = self.L&#10;&#10;        # Calculate fixed end moments&#10;        Miz = -1 * (p * a * (a - L) * (a - L)) / (L * L)&#10;        Mjz = -1 * (p * a * a * (a - L)) / (L * L)&#10;&#10;        # Calculate fixed end forces&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Import dimension constants&#10;        from pyMAOS.units_mod import INTERNAL_MOMENT_UNIT, INTERNAL_FORCE_UNIT&#10;&#10;        # Define expected dimensionalities&#10;        FORCE_DIMENSIONALITY = unit_manager.ureg.parse_units(INTERNAL_FORCE_UNIT).dimensionality&#10;        MOMENT_DIMENSIONALITY = unit_manager.ureg.parse_units(INTERNAL_MOMENT_UNIT).dimensionality&#10;&#10;        # Debug prints showing actual dimensionality&#10;        print(f&quot;DEBUG: Checking dimensions - Miz: {Miz.dimensionality}, Mjz: {Mjz.dimensionality}&quot;)&#10;        print(f&quot;DEBUG: Checking dimensions - Riy: {Riy.dimensionality}, Rjy: {Rjy.dimensionality}&quot;)&#10;&#10;        # Verify moment dimensions&#10;        try:&#10;            Miz.check(MOMENT_DIMENSIONALITY)&#10;            Mjz.check(MOMENT_DIMENSIONALITY)&#10;            print(&quot;DEBUG: Moment dimension check passed&quot;)&#10;        except pint.DimensionalityError as e:&#10;            print(f&quot;ERROR: Dimension error in moments: {e}&quot;)&#10;            # Create correctly dimensioned values as fallback&#10;            if not Miz.check(MOMENT_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Miz from {Miz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;                Miz = unit_manager.ureg.Quantity(Miz.magnitude, INTERNAL_MOMENT_UNIT)&#10;            if not Mjz.check(MOMENT_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Mjz from {Mjz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;                Mjz = unit_manager.ureg.Quantity(Mjz.magnitude, INTERNAL_MOMENT_UNIT)&#10;&#10;        # Verify force dimensions&#10;        try:&#10;            Riy.check(FORCE_DIMENSIONALITY)&#10;            Rjy.check(FORCE_DIMENSIONALITY)&#10;            print(&quot;DEBUG: Force dimension check passed&quot;)&#10;        except pint.DimensionalityError as e:&#10;            print(f&quot;ERROR: Dimension error in forces: {e}&quot;)&#10;            # Create correctly dimensioned values as fallback&#10;            if not Riy.check(FORCE_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Riy from {Riy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;                Riy = unit_manager.ureg.Quantity(Riy.magnitude, INTERNAL_FORCE_UNIT)&#10;            if not Rjy.check(FORCE_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Rjy from {Rjy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;                Rjy = unit_manager.ureg.Quantity(Rjy.magnitude, INTERNAL_FORCE_UNIT)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = unit_manager.ureg.Quantity(0, Riy.units)&#10;&#10;        # Print forces and moments for debugging&#10;        print(f&quot;Point load FEF - Forces: Riy={Riy:.3f}, Rjy={Rjy:.3f}&quot;)&#10;        print(f&quot;Point load FEF - Moments: Miz={Miz:.3f}, Mjz={Mjz:.3f}&quot;)&#10;&#10;        ret_val = [zero_force, Riy, Miz, zero_force, Rjy, Mjz]&#10;&#10;        # Final dimension check for return values&#10;        for i, (val, expected_dim) in enumerate(zip(ret_val, [&#10;            FORCE_DIMENSIONALITY, FORCE_DIMENSIONALITY, MOMENT_DIMENSIONALITY,&#10;            FORCE_DIMENSIONALITY, FORCE_DIMENSIONALITY, MOMENT_DIMENSIONALITY&#10;        ])):&#10;            try:&#10;                val.check(expected_dim)&#10;            except pint.DimensionalityError as e:&#10;                print(f&quot;ERROR: Dimensionality error in ret_val[{i}]: {e}&quot;)&#10;                print(f&quot;  Actual: {val.dimensionality}, Expected: {expected_dim}&quot;)&#10;&#10;        return ret_val&#10;&#10;    def plot_all_ppoly_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all PiecewisePolynomial2 functions.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy2': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial2 objects&#10;        functions = []&#10;        if hasattr(self, 'Vy2') and self.Vy2.ppoly is not None:&#10;            functions.append(('Vy2', self.Vy2, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz2') and self.Mz2.ppoly is not None:&#10;            functions.append(('Mz2', self.Mz2, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz2') and self.Sz2.ppoly is not None:&#10;            functions.append(('Sz2', self.Sz2, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy2') and self.Dy2.ppoly is not None:&#10;            functions.append(('Dy2', self.Dy2, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No PiecewisePolynomial2 functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} PiecewisePolynomial2 functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key points&#10;            for x in [self.a, self.L]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title with sign-preserving formatting for load value&#10;        load_str = f&quot;{self.p:+.3g}&quot;  # Shows + for positive values&#10;        fig.suptitle(f&quot;Beam Analysis (PPoly) for Point Load {load_str} at x={self.a:.3g}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig" />
              <option name="updatedContent" value="import pint&#10;from typing import TYPE_CHECKING, Any&#10;from pyMAOS.loading.piecewisePolinomial import PiecewisePolynomial&#10;from pprint import pprint&#10;from display_utils import print_quantity_nested_list&#10;import pyMAOS&#10;# Use TYPE_CHECKING to avoid runtime imports&#10;if TYPE_CHECKING:&#10;    from pyMAOS.frame2d import R2Frame&#10;&#10;class R2_Point_Moment:&#10;    def __init__(self, M: pint.Quantity, a: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        &quot;&quot;&quot;&#10;        Parameters&#10;        ----------&#10;        M : FLOAT&#10;            Applied moment, counter-clockwise positive.&#10;        a : FLOAT&#10;            Point of application of moment as measured from the member left end.&#10;        member : Element Class&#10;            the member that the load is applied to.&#10;        loadcase : STRING, optional&#10;            String representation of the applied load type, this&#10;            data is used for load cases and combindations. The default is &quot;D&quot;.&#10;        &quot;&quot;&quot;&#10;        self.M = M&#10;        self.a = a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.I = member.section.Ixx&#10;&#10;        self.EI = self.E * self.I&#10;&#10;        self.kind = &quot;MOMENT&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Constants of Integration&#10;        self.integration_constants()&#10;&#10;        # Simple End Reactions&#10;        self.Riy = self.M / self.L&#10;        self.Rjy = -1 * self.Riy&#10;&#10;        # Piecewise Functions&#10;        # [co....cn x^n] [xa, xb]&#10;&#10;        Vy = [[[self.Riy], [0, self.a]], [[self.Riy], [self.a, self.L]]]&#10;        pprint(Vy)&#10;        Mz = [&#10;            [[0, self.Riy], [0, self.a]],&#10;            [[-1 * self.M, self.Riy], [self.a, self.L]],&#10;        ]&#10;        pprint(Mz)&#10;        Sz = [&#10;            [[self.c1 / self.EI, 0, self.Riy / (2 * self.EI)], [0, self.a]],&#10;            [&#10;                [&#10;                    self.c2 / self.EI,&#10;                    -1 * self.M / self.EI,&#10;                    self.Riy / (2 * self.EI),&#10;                ],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        pprint(Sz)&#10;        Dy = [&#10;            [&#10;                [&#10;                    self.c3 / self.EI,&#10;                    self.c1 / self.EI,&#10;                    0,&#10;                    self.Riy / (6 * self.EI),&#10;                ],&#10;                [0, self.a],&#10;            ],&#10;            [&#10;                [&#10;                    self.c4 / self.EI,&#10;                    self.c2 / self.EI,&#10;                    -1 * self.M / (2 * self.EI),&#10;                    self.Riy / (6 * self.EI),&#10;                ],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        pprint(Dy)&#10;        self.Wx = PiecewisePolynomial()  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        self.Ax = PiecewisePolynomial()&#10;        self.Dx = PiecewisePolynomial()&#10;        self.Vy = PiecewisePolynomial(Vy)&#10;        self.Mz = PiecewisePolynomial(Mz)&#10;        self.Sz = PiecewisePolynomial(Sz)&#10;        self.Dy = PiecewisePolynomial(Dy)&#10;&#10;    def integration_constants(self):&#10;        M = self.M&#10;        a = self.a&#10;        L = self.L&#10;&#10;        # Constants of Integration&#10;        self.c1 = ((3 * M * a * a) - (6 * L * M * a) + (2 * L * L * M)) / (6 * L)&#10;        self.c2 = ((3 * M * a * a) + (2 * L * L * M)) / (6 * L)&#10;        self.c3 = 0&#10;        self.c4 = -1 / 2 * M * a * a&#10;&#10;    def FEF(self):&#10;        &quot;&quot;&quot;&#10;        Compute and return the fixed and forces&#10;        &quot;&quot;&quot;&#10;        M = self.M&#10;        a = self.a&#10;        L = self.L&#10;&#10;        Miz = -1 * (M * (a - L) * ((3 * a) - L)) / (L * L)&#10;        Mjz = -1 * (M * a * (3 * a - 2 * L)) / (L * L)&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = 0 * unit_manager.ureg(Riy.units)&#10;&#10;        return [zero_force, Riy, Miz, zero_force, Rjy, Mjz]&#10;&#10;&#10;class R2_Point_Load:&#10;    def __init__(self, p: pint.Quantity, a: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        self.p = p&#10;        self.a = a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.I = member.section.Ixx&#10;&#10;        self.EI = self.E * self.I&#10;&#10;        self.kind = &quot;POINT&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Constants of Integration&#10;        # self.integration_constants()&#10;        # p = self.p&#10;        # a = self.a&#10;        L = self.L&#10;        import inspect;&#10;        print(f&quot;{inspect.getfile(inspect.currentframe())}:{inspect.currentframe().f_lineno}&quot;)&#10;&#10;        from pyMAOS.units_mod import INTERNAL_LENGTH_UNIT,INTERNAL_FORCE_UNIT,INTERNAL_MOMENT_UNIT&#10;        self.c1 = pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;        self.c2 = -1 * p * a&#10;        self.c3 = (p * a * (a - (2 * L)) * (a - L)) / (6 * L)&#10;        self.c4 = (p * a * ((a * a) + (2 * L * L))) / (6 * L)&#10;        self.c5 = pyMAOS.unit_manager.ureg.Quantity(0, f&quot;{pyMAOS.unit_manager.INTERNAL_FORCE_UNIT} * {pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}**3&quot;)&#10;        self.c6 = (-1 * p * a * a * a) / 6&#10;&#10;        # Simple End Reactions&#10;        self.Riy = self.p * ((self.a - self.L) / self.L)&#10;        self.Rjy = -1 * self.p * self.a * (1 / self.L)&#10;        print(f&quot;Riy: {self.Riy:.3f}, Rjy: {self.Rjy:.3f}&quot;)&#10;        # Piecewise Functions&#10;        # [co....cn x^n] [xa, xb]&#10;        Vy = [&#10;            [[self.Riy], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.Riy + self.p], [self.a, self.L]],&#10;        ]&#10;        print(&quot;Vy:&quot;); print_quantity_nested_list(Vy)&#10;        Mz = [&#10;            [[self.c1, self.Riy], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.c2, self.Riy + self.p], [self.a, self.L]],&#10;        ]&#10;        print(&quot;Mz:&quot;); print_quantity_nested_list(Mz)&#10;        Sz = [&#10;            [[self.c3, self.c1, self.Riy / 2], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.c4, self.c2, (self.Riy + self.p) / 2], [self.a, self.L]],&#10;        ]&#10;        Sz[0][0] = [i / self.EI for i in Sz[0][0]]&#10;        Sz[1][0] = [i / self.EI for i in Sz[1][0]]&#10;        print(&quot;Sz:&quot;); print_quantity_nested_list(Sz)&#10;        Dy = [&#10;            [[self.c5, self.c3, self.c1 / 2, self.Riy / 6], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [&#10;                [self.c6, self.c4, self.c2 / 2, (self.Riy + self.p) / 6],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        Dy[0][0] = [i / self.EI for i in Dy[0][0]]&#10;        Dy[1][0] = [i / self.EI for i in Dy[1][0]]&#10;        #print(Dy)&#10;        print(&quot;Dy:&quot;); print_quantity_nested_list(Dy, precision=2, width=20, simplify_units=True)&#10;&#10;        self.Wx = PiecewisePolynomial()&#10;        # print(self.Wx) # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        # print(self.Wy)&#10;        self.Ax = PiecewisePolynomial()&#10;        # print(self.Ax)&#10;        self.Dx = PiecewisePolynomial()&#10;        #print(self.Dx)&#10;        from pprint import pprint; pprint(Vy); self.Vy = PiecewisePolynomial(Vy)&#10;        print(&quot;Vy:\n&quot;, self.Vy)&#10;&#10;&#10;        self.Mz = PiecewisePolynomial(Mz)&#10;        print(&quot;Mz:\n&quot;, self.Mz)&#10;        self.Sz = PiecewisePolynomial(Sz)&#10;        print(&quot;Sz:\n&quot;, self.Sz)&#10;        self.Dy = PiecewisePolynomial(Dy)&#10;        print(&quot;Dy:\n&quot;,self.Dy)&#10;&#10;        # Create PiecewisePolynomial2 instances alongside existing ones&#10;        from pyMAOS.loading.PiecewisePolynomial2 import PiecewisePolynomial2&#10;&#10;        self.Vy2 = PiecewisePolynomial2(Vy)&#10;        print(&quot;Vy2:&quot;, self.Vy2, sep=&quot;\n&quot;)&#10;&#10;        self.Mz2 = PiecewisePolynomial2(Mz)&#10;        print(&quot;Mz2:&quot;, self.Mz2, sep=&quot;\n&quot;)&#10;&#10;        self.Sz2 = PiecewisePolynomial2(Sz)&#10;        print(&quot;Sz2:&quot;, self.Sz2, sep=&quot;\n&quot;)&#10;&#10;        self.Dy2 = PiecewisePolynomial2(Dy)&#10;        print(&quot;Dy2:&quot;, self.Dy2, sep=&quot;\n&quot;)&#10;&#10;&#10;    def FEF(self):&#10;        p = self.p&#10;        a = self.a&#10;        L = self.L&#10;&#10;        # Calculate fixed end moments&#10;        Miz = -1 * (p * a * (a - L) * (a - L)) / (L * L)&#10;        Mjz = -1 * (p * a * a * (a - L)) / (L * L)&#10;&#10;        # Calculate fixed end forces&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Import dimension constants&#10;        from pyMAOS.units_mod import INTERNAL_MOMENT_UNIT, INTERNAL_FORCE_UNIT&#10;&#10;        # Define expected dimensionalities&#10;        FORCE_DIMENSIONALITY = pyMAOS.unit_manager.ureg.parse_units(pyMAOS.unit_manager.INTERNAL_FORCE_UNIT).dimensionality&#10;        MOMENT_DIMENSIONALITY = pyMAOS.unit_manager.ureg.parse_units(pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT).dimensionality&#10;&#10;        # Debug prints showing actual dimensionality&#10;        print(f&quot;DEBUG: Checking dimensions - Miz: {Miz.dimensionality}, Mjz: {Mjz.dimensionality}&quot;)&#10;        print(f&quot;DEBUG: Checking dimensions - Riy: {Riy.dimensionality}, Rjy: {Rjy.dimensionality}&quot;)&#10;&#10;        # Verify moment dimensions&#10;        try:&#10;            Miz.check(MOMENT_DIMENSIONALITY)&#10;            Mjz.check(MOMENT_DIMENSIONALITY)&#10;            print(&quot;DEBUG: Moment dimension check passed&quot;)&#10;        except pint.DimensionalityError as e:&#10;            print(f&quot;ERROR: Dimension error in moments: {e}&quot;)&#10;            # Create correctly dimensioned values as fallback&#10;            if not Miz.check(MOMENT_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Miz from {Miz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;                Miz = pyMAOS.unit_manager.ureg.Quantity(Miz.magnitude, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;            if not Mjz.check(MOMENT_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Mjz from {Mjz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;                Mjz = pyMAOS.unit_manager.ureg.Quantity(Mjz.magnitude, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;&#10;        # Verify force dimensions&#10;        try:&#10;            Riy.check(FORCE_DIMENSIONALITY)&#10;            Rjy.check(FORCE_DIMENSIONALITY)&#10;            print(&quot;DEBUG: Force dimension check passed&quot;)&#10;        except pint.DimensionalityError as e:&#10;            print(f&quot;ERROR: Dimension error in forces: {e}&quot;)&#10;            # Create correctly dimensioned values as fallback&#10;            if not Riy.check(FORCE_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Riy from {Riy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;                Riy = pyMAOS.unit_manager.ureg.Quantity(Riy.magnitude, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;            if not Rjy.check(FORCE_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Rjy from {Rjy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;                Rjy = pyMAOS.unit_manager.ureg.Quantity(Rjy.magnitude, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = pyMAOS.unit_manager.ureg.Quantity(0, Riy.units)&#10;&#10;        # Print forces and moments for debugging&#10;        print(f&quot;Point load FEF - Forces: Riy={Riy:.3f}, Rjy={Rjy:.3f}&quot;)&#10;        print(f&quot;Point load FEF - Moments: Miz={Miz:.3f}, Mjz={Mjz:.3f}&quot;)&#10;&#10;        ret_val = [zero_force, Riy, Miz, zero_force, Rjy, Mjz]&#10;&#10;        # Final dimension check for return values&#10;        for i, (val, expected_dim) in enumerate(zip(ret_val, [&#10;            FORCE_DIMENSIONALITY, FORCE_DIMENSIONALITY, MOMENT_DIMENSIONALITY,&#10;            FORCE_DIMENSIONALITY, FORCE_DIMENSIONALITY, MOMENT_DIMENSIONALITY&#10;        ])):&#10;            try:&#10;                val.check(expected_dim)&#10;            except pint.DimensionalityError as e:&#10;                print(f&quot;ERROR: Dimensionality error in ret_val[{i}]: {e}&quot;)&#10;                print(f&quot;  Actual: {val.dimensionality}, Expected: {expected_dim}&quot;)&#10;&#10;        return ret_val&#10;&#10;    def plot_all_ppoly_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all PiecewisePolynomial2 functions.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy2': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial2 objects&#10;        functions = []&#10;        if hasattr(self, 'Vy2') and self.Vy2.ppoly is not None:&#10;            functions.append(('Vy2', self.Vy2, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz2') and self.Mz2.ppoly is not None:&#10;            functions.append(('Mz2', self.Mz2, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz2') and self.Sz2.ppoly is not None:&#10;            functions.append(('Sz2', self.Sz2, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy2') and self.Dy2.ppoly is not None:&#10;            functions.append(('Dy2', self.Dy2, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No PiecewisePolynomial2 functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} PiecewisePolynomial2 functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key points&#10;            for x in [self.a, self.L]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title with sign-preserving formatting for load value&#10;        load_str = f&quot;{self.p:+.3g}&quot;  # Shows + for positive values&#10;        fig.suptitle(f&quot;Beam Analysis (PPoly) for Point Load {load_str} at x={self.a:.3g}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/material.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/material.py" />
              <option name="originalContent" value="from xarray.coding.times import resolve_time_unit_from_attrs_dtype&#10;&#10;import pyMAOS&#10;&#10;from typing import Union&#10;import pint&#10;from pyMAOS import unit_manager&#10;&#10;class LinearElasticMaterial():&#10;    def __init__(self, uid: int,&#10;                 density: Union[float, str, Quantity] = 7861.092937697687,&#10;                 E: Union[float, str,Quantity] = 199947961501.8826,&#10;                 nu: float = 0.3):&#10;        super().__init__()&#10;        self.uid = uid  # Unique Material Identifier&#10;        self.nu = nu  # Poisson's ratio (dimensionless)&#10;&#10;        import pint&#10;        if isinstance(E, pint.Quantity):&#10;            # If it's a pint Quantity, convert to SI units&#10;            self.E=E.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            self.E = self._parse_value_with_units(E, 'pressure')&#10;            if isinstance(self.E, pint.Quantity):&#10;                self.E = self.E.to_reduced_units()&#10;&#10;&#10;        if isinstance(density, pint.Quantity):&#10;            self.density=density.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            density = unit_manager.ureg(density).to_reduced_units()&#10;        print(&#10;            f&quot;LinearElasticMaterial uid {self.uid} initialized with density={self.density:.4g}, E={self.E:.3g}, nu={self.nu}&quot;)&#10;&#10;    def __setstate__(self, state):&#10;&#10;&#10;        # Initialize the object properly&#10;        self.__init__(state.get('uid'),&#10;                      unit_manager.ureg(state.get('density', &quot;0.284 lb/in^3&quot;)).to_reduced_units(),&#10;                      unit_manager.ureg(state.get('E', &quot;29000.0 ksi&quot;)).to_reduced_units(),&#10;                      state.get('nu', 0.3))&#10;&#10;    def _parse_value_with_units(self, value: Union[float, str], unit_type: str) -&gt; float:&#10;        &quot;&quot;&quot;&#10;        Parse a value that may be a float or string with units.&#10;        &#10;        Parameters&#10;        ----------&#10;        value : float or str&#10;            Value, either as a number or string with units (e.g., &quot;29000ksi&quot;, &quot;0.000284klb/in^3&quot;)&#10;        unit_type : str&#10;            Type of unit ('pressure', 'density')&#10;            &#10;        Returns&#10;        -------&#10;        float&#10;            Value in SI units&#10;        &quot;&quot;&quot;&#10;        # If it's already a number, return it as-is (assume SI units)&#10;        if isinstance(value, (int, float)):&#10;            return float(value)&#10;&#10;        # If it's a string, try to parse units&#10;        if isinstance(value, str):&#10;            try:&#10;                # Import the parse function from units_mod&#10;                from pyMAOS.pymaos_units import parse_value_with_units&#10;                import pint&#10;&#10;                # Parse the value string&#10;                parsed_value = parse_value_with_units(value)&#10;&#10;                # If it has units, convert to SI units&#10;                if isinstance(parsed_value, pint.Quantity):&#10;&#10;                    # Convert based on unit type&#10;                    if unit_type == 'pressure':&#10;                        # Young's modulus - convert to Pascals&#10;                        si_value = parsed_value.to('Pa')#.magnitude&#10;                    elif unit_type == 'density':&#10;                        # Density - convert to kg/m^3&#10;                        si_value = parsed_value.to('kg/m^3')#.magnitude&#10;                    else:&#10;                        # Fallback - just use the magnitude&#10;                        si_value = None&#10;                    return float(si_value)&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not convert '{value}' to SI units for {unit_type}: {e}&quot;)&#10;                # Fall back to magnitude if conversion fails&#10;                return&#10;&#10;    # If we get here, something unexpected happened&#10;        raise ValueError(f&quot;Unsupported material value type: {type(value)}&quot;)&#10;&#10;    def stress(self, strain):&#10;        return self.E * strain&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the material properties&quot;&quot;&quot;&#10;&#10;        units = pyMAOS.unit_manager.get_current_units()&#10;        e_display = self.E.to(units['pressure'])&#10;        density_display = self.density.to(units['density'])&#10;        # pressure_unit = units.get('pressure', 'Pa')&#10;        # density_unit = units.get('density', 'kg/m^3')&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={density_display:.4f}, E={e_display}, nu={self.nu}) in {units.get('name', 'default')} units&quot;&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return developer representation of the material&quot;&quot;&quot;&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={self.density:.4f}, E={self.E:.2f}, nu={self.nu})&quot;&#10;&#10;def get_materials_from_yaml(materials_yml, logger=None):&#10;    &quot;&quot;&quot;&#10;    Loads materials from a YAML file and converts properties to internal units&#10;&#10;    Parameters&#10;    ----------&#10;    materials_yml : str&#10;        Path to the materials YAML file&#10;    logger : logging.Logger, optional&#10;        Logger for output messages&#10;&#10;    Returns&#10;    -------&#10;    dict&#10;        Dictionary of materials with uid as key&#10;    &quot;&quot;&quot;&#10;    materials_dict = {}&#10;&#10;    # Use print or logger.info based on what's available&#10;    def log(message):&#10;        if logger:&#10;            logger.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    # Get internal units directly from unit_manager (force refresh)&#10;    import pyMAOS&#10;&#10;    # Debug the unit manager state&#10;    log(f&quot;Unit manager system: {pyMAOS.unit_manager.system_name}&quot;)&#10;    log(f&quot;Unit manager base units: Force={pyMAOS.unit_manager.INTERNAL_FORCE_UNIT}, Length={pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}&quot;)&#10;&#10;    # Force update derived units before accessing them&#10;    # pyMAOS.unit_manager._update_derived_units()&#10;&#10;    # Now get the updated internal units&#10;    internal_pressure_unit = pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT&#10;    internal_density_unit = pyMAOS.unit_manager.INTERNAL_DENSITY_UNIT&#10;    system_name = pyMAOS.unit_manager.system_name&#10;&#10;    log(f&quot;Loading materials from: {materials_yml}&quot;)&#10;    log(f&quot;Using internal unit system: {system_name}&quot;)&#10;    log(f&quot;Internal pressure unit: {internal_pressure_unit}&quot;)&#10;    log(f&quot;Internal pressure unit expanded: {pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT_EXPANDED}&quot;)&#10;    log(f&quot;Internal density unit: {internal_density_unit}&quot;)&#10;&#10;    # Rest of the function...&#10;&#10;    with open(materials_yml, 'r') as file:&#10;        import yaml&#10;        materials_list = yaml.unsafe_load(file)&#10;&#10;    # Process each material and convert units to internal units&#10;    for material in materials_list:&#10;        # If the material is already a LinearElasticMaterial instance, update its units&#10;        if hasattr(material, 'E') and hasattr(material, 'density'):&#10;            # Convert E to internal pressure units if it's a Quantity&#10;            import pint&#10;            if isinstance(material.E, pint.Quantity):&#10;                material.E = material.E.to(internal_pressure_unit)&#10;&#10;            # Convert density to internal density units if it's a Quantity&#10;            if isinstance(material.density, pint.Quantity):&#10;                material.density = material.density.to(internal_density_unit)&#10;&#10;            log(f&quot;Material {material.uid}: E={material.E}, density={material.density}&quot;)&#10;&#10;        # Add material to dictionary&#10;        materials_dict[material.uid] = material&#10;&#10;    log(f&quot;Loaded {len(materials_dict)} materials&quot;)&#10;    return materials_dict" />
              <option name="updatedContent" value="from xarray.coding.times import resolve_time_unit_from_attrs_dtype&#10;&#10;import pyMAOS&#10;&#10;from typing import Union&#10;import pint&#10;from pyMAOS import unit_manager&#10;&#10;class LinearElasticMaterial():&#10;    def __init__(self, uid: int,&#10;                 density: Union[float, str, Quantity] = 7861.092937697687,&#10;                 E: Union[float, str,Quantity] = 199947961501.8826,&#10;                 nu: float = 0.3):&#10;        super().__init__()&#10;        self.uid = uid  # Unique Material Identifier&#10;        self.nu = nu  # Poisson's ratio (dimensionless)&#10;&#10;        import pint&#10;        if isinstance(E, pint.Quantity):&#10;            # If it's a pint Quantity, convert to SI units&#10;            self.E=E.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            self.E = self._parse_value_with_units(E, 'pressure')&#10;            if isinstance(self.E, pint.Quantity):&#10;                self.E = self.E.to_reduced_units()&#10;&#10;&#10;        if isinstance(density, pint.Quantity):&#10;            self.density=density.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            density = unit_manager.ureg(density).to_reduced_units()&#10;        print(&#10;            f&quot;LinearElasticMaterial uid {self.uid} initialized with density={self.density:.4g}, E={self.E:.3g}, nu={self.nu}&quot;)&#10;&#10;    def __setstate__(self, state):&#10;&#10;&#10;        # Initialize the object properly&#10;        self.__init__(state.get('uid'),&#10;                      unit_manager.ureg(state.get('density', &quot;0.284 lb/in^3&quot;)).to_reduced_units(),&#10;                      unit_manager.ureg(state.get('E', &quot;29000.0 ksi&quot;)).to_reduced_units(),&#10;                      state.get('nu', 0.3))&#10;&#10;    def _parse_value_with_units(self, value: Union[float, str], unit_type: str) -&gt; float:&#10;        &quot;&quot;&quot;&#10;        Parse a value that may be a float or string with units.&#10;        &#10;        Parameters&#10;        ----------&#10;        value : float or str&#10;            Value, either as a number or string with units (e.g., &quot;29000ksi&quot;, &quot;0.000284klb/in^3&quot;)&#10;        unit_type : str&#10;            Type of unit ('pressure', 'density')&#10;            &#10;        Returns&#10;        -------&#10;        float&#10;            Value in SI units&#10;        &quot;&quot;&quot;&#10;        # If it's already a number, return it as-is (assume SI units)&#10;        if isinstance(value, (int, float)):&#10;            return float(value)&#10;&#10;        # If it's a string, try to parse units&#10;        if isinstance(value, str):&#10;            try:&#10;                # Import the parse function from units_mod&#10;                from pyMAOS.pymaos_units import parse_value_with_units&#10;                import pint&#10;&#10;                # Parse the value string&#10;                parsed_value = parse_value_with_units(value)&#10;&#10;                # If it has units, convert to SI units&#10;                if isinstance(parsed_value, pint.Quantity):&#10;&#10;                    # Convert based on unit type&#10;                    if unit_type == 'pressure':&#10;                        # Young's modulus - convert to Pascals&#10;                        si_value = parsed_value.to('Pa')#.magnitude&#10;                    elif unit_type == 'density':&#10;                        # Density - convert to kg/m^3&#10;                        si_value = parsed_value.to('kg/m^3')#.magnitude&#10;                    else:&#10;                        # Fallback - just use the magnitude&#10;                        si_value = None&#10;                    return float(si_value)&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not convert '{value}' to SI units for {unit_type}: {e}&quot;)&#10;                # Fall back to magnitude if conversion fails&#10;                return&#10;&#10;    # If we get here, something unexpected happened&#10;        raise ValueError(f&quot;Unsupported material value type: {type(value)}&quot;)&#10;&#10;    def stress(self, strain):&#10;        return self.E * strain&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the material properties&quot;&quot;&quot;&#10;&#10;        units = pyMAOS.unit_manager.get_current_units()&#10;        e_display = self.E.to(units['pressure'])&#10;        density_display = self.density.to(units['density'])&#10;        # pressure_unit = units.get('pressure', 'Pa')&#10;        # density_unit = units.get('density', 'kg/m^3')&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={density_display:.4f}, E={e_display}, nu={self.nu}) in {units.get('name', 'default')} units&quot;&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return developer representation of the material&quot;&quot;&quot;&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={self.density:.4f}, E={self.E:.2f}, nu={self.nu})&quot;&#10;&#10;def get_materials_from_yaml(materials_yml, logger=None):&#10;    &quot;&quot;&quot;&#10;    Loads materials from a YAML file and converts properties to internal units&#10;&#10;    Parameters&#10;    ----------&#10;    materials_yml : str&#10;        Path to the materials YAML file&#10;    logger : logging.Logger, optional&#10;        Logger for output messages&#10;&#10;    Returns&#10;    -------&#10;    dict&#10;        Dictionary of materials with uid as key&#10;    &quot;&quot;&quot;&#10;    materials_dict = {}&#10;&#10;    # Use print or logger.info based on what's available&#10;    def log(message):&#10;        if logger:&#10;            logger.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    # Get internal units directly from unit_manager (force refresh)&#10;    import pyMAOS&#10;&#10;    # Debug the unit manager state&#10;    log(f&quot;Unit manager system: {pyMAOS.unit_manager.system_name}&quot;)&#10;    log(f&quot;Unit manager base units: Force={pyMAOS.unit_manager.INTERNAL_FORCE_UNIT}, Length={pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}&quot;)&#10;&#10;    # Force update derived units before accessing them&#10;    # pyMAOS.unit_manager._update_derived_units()&#10;&#10;    # Now get the updated internal units&#10;    internal_pressure_unit = pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT&#10;    internal_density_unit = pyMAOS.unit_manager.INTERNAL_DENSITY_UNIT&#10;    system_name = pyMAOS.unit_manager.system_name&#10;&#10;    log(f&quot;Loading materials from: {materials_yml}&quot;)&#10;    log(f&quot;Using internal unit system: {system_name}&quot;)&#10;    log(f&quot;Internal pressure unit: {internal_pressure_unit}&quot;)&#10;    log(f&quot;Internal pressure unit expanded: {pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT_EXPANDED}&quot;)&#10;    log(f&quot;Internal density unit: {internal_density_unit}&quot;)&#10;&#10;    # Rest of the function...&#10;&#10;    with open(materials_yml, 'r') as file:&#10;        import yaml&#10;        materials_list = yaml.unsafe_load(file)&#10;&#10;    # Process each material and convert units to internal units&#10;    for material in materials_list:&#10;        # If the material is already a LinearElasticMaterial instance, update its units&#10;        if hasattr(material, 'E') and hasattr(material, 'density'):&#10;            # Convert E to internal pressure units if it's a Quantity&#10;            import pint&#10;            if isinstance(material.E, pint.Quantity):&#10;                material.E = material.E.to(internal_pressure_unit)&#10;&#10;            # Convert density to internal density units if it's a Quantity&#10;            if isinstance(material.density, pint.Quantity):&#10;                material.density = material.density.to(internal_density_unit)&#10;&#10;            log(f&quot;Material {material.uid}: E={material.E}, density={material.density}&quot;)&#10;&#10;        # Add material to dictionary&#10;        materials_dict[material.uid] = material&#10;&#10;    log(f&quot;Loaded {len(materials_dict)} materials&quot;)&#10;    return materials_dict" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/node2d.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/node2d.py" />
              <option name="originalContent" value="# -*- coding: utf-8 -*-&#10;import math&#10;import numpy as np&#10;import pint&#10;from pint import Quantity&#10;from pyMAOS.units_mod import unit_manager, parse_value_with_units&#10;&#10;&#10;class LoadsDict(dict):&#10;    &quot;&quot;&quot;Custom dictionary class that handles unit parsing for load values&quot;&quot;&quot;&#10;&#10;    def __init__(self, node):&#10;        super().__init__()&#10;        self.node = node  # Reference to the parent node for access to parsing methods&#10;&#10;    def __setitem__(self, key, value):&#10;        &quot;&quot;&quot;Override setitem to parse units when assigning individual load cases&quot;&quot;&quot;&#10;        if isinstance(value, (list, tuple)):&#10;            # Parse the load values with units&#10;            parsed_values = self.node._parse_load_values(value)&#10;            super().__setitem__(key, parsed_values)&#10;        else:&#10;            super().__setitem__(key, value)&#10;&#10;    def update(self, other_dict):&#10;        &quot;&quot;&quot;Override update to parse units for bulk updates&quot;&quot;&quot;&#10;        if isinstance(other_dict, dict):&#10;            for key, value in other_dict.items():&#10;                self[key] = value  # Use our custom __setitem__&#10;&#10;&#10;class R2Node:&#10;    def __init__(self, uid, x, y):&#10;        &quot;&quot;&quot;&#10;        Parameters&#10;        ----------&#10;        x : float, str, or pint.Quantity&#10;            x-axis coordinate of the node in R2.&#10;        y : float, str, or pint.Quantity&#10;            y-axis coordinate of the node in R2.&#10;        uid : int&#10;            unique node number.&#10;        &quot;&quot;&quot;&#10;        self.uid = uid&#10;        # Ux,Uy, and Rz = 3&#10;        # Number of possible Joint Displacements&#10;        self.NJD = 3&#10;&#10;        self.is_inode_of_elem_ids = []; self.is_jnode_of_elem_ids = []&#10;&#10;        self.is_inode_of_elems=[]; self.is_jnode_of_elems=[]&#10;&#10;        # Parse and store coordinates as pint.Quantity objects&#10;        self.x = self._parse_coordinate(x)&#10;        self.y = self._parse_coordinate(y)&#10;&#10;        # Restraints [Ux, Uy, Rz]&#10;        self.restraints_key = [&quot;Ux&quot;, &quot;Uy&quot;, &quot;Rz&quot;]&#10;        self.restraints = [0, 0, 0]&#10;&#10;        # Spring Restraint [kux, kuy, krz]&#10;        # Spring Stiffness should be 0 for a restrained direction&#10;        # Spring is still a DOF for the node&#10;        self._spring_stiffness = [0, 0, 0]&#10;&#10;        # Directionality of spring&#10;        # 0 = bidirectional resistance&#10;        # 1 = spring resists positive axis displacement&#10;        # -1 = spring resists negative axis displacement&#10;        self._spring_direction = [0, 0, 0]&#10;&#10;        # Spring Stiffness Multiplier&#10;        self._springUxmulti = {}&#10;        self._springUymulti = {}&#10;        self._springRzmulti = {}&#10;&#10;        # Enforced Displacement [Ux, Uy, Rz]&#10;        self._enforced_displacements = [0, 0, 0]&#10;&#10;        # Dict of Loads by case - use custom dictionary that handles unit parsing&#10;        self.loads = LoadsDict(self)&#10;&#10;        # Dict of Displacements by combo&#10;        self.displacements = {}&#10;&#10;        # Dict of Reactions by combo&#10;        self.reactions = {}&#10;&#10;        # Flags&#10;        self._isSpring = False&#10;        self._isNonLinear = False&#10;&#10;    def _parse_coordinate(self, coordinate):&#10;        &quot;&quot;&quot;&#10;        Parse a coordinate value and return as pint.Quantity.&#10;&#10;        Parameters&#10;        ----------&#10;        coordinate : float, str, or pint.Quantity&#10;            Coordinate value&#10;&#10;        Returns&#10;        -------&#10;        pint.Quantity&#10;            Coordinate value as a Quantity in meters&#10;        &quot;&quot;&quot;&#10;        # If already a Quantity, convert to meters&#10;        if isinstance(coordinate, pint.Quantity):&#10;            return coordinate.to('m')&#10;&#10;        # If it's a number, create a Quantity in meters&#10;        if isinstance(coordinate, (int, float)):&#10;            return coordinate * unit_manager.ureg.m&#10;&#10;        # If it's a string, parse units&#10;        if isinstance(coordinate, str):&#10;            try:&#10;                parsed_value = parse_value_with_units(coordinate)&#10;&#10;                if isinstance(parsed_value, pint.Quantity):&#10;                    return parsed_value.to('m')&#10;                else:&#10;                    # No units specified, assume meters&#10;                    return float(parsed_value) * unit_manager.ureg.m&#10;&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not parse coordinate '{coordinate}': {e}&quot;)&#10;                try:&#10;                    return float(coordinate) * unit_manager.ureg.m&#10;                except Exception:&#10;                    raise ValueError(f&quot;Could not parse coordinate value: {coordinate}&quot;)&#10;&#10;        raise ValueError(f&quot;Unsupported coordinate type: {type(coordinate)}&quot;)&#10;&#10;    def _parse_load_value(self, load_value):&#10;        &quot;&quot;&quot;&#10;        Parse a load value and return as pint.Quantity.&#10;&#10;        Parameters&#10;        ----------&#10;        load_value : float, str, or pint.Quantity&#10;            Load value&#10;&#10;        Returns&#10;        -------&#10;        pint.Quantity&#10;            Load value as a Quantity in N or N*m&#10;        &quot;&quot;&quot;&#10;        # If already a Quantity, return as is&#10;        if isinstance(load_value, pint.Quantity):&#10;            # Check dimensionality to convert to correct units&#10;            if load_value.dimensionality == unit_manager.ureg.N.dimensionality:&#10;                return load_value.to('N')&#10;            elif load_value.dimensionality == (unit_manager.ureg.N * unit_manager.ureg.m).dimensionality:&#10;                return load_value.to('N*m')&#10;            return load_value&#10;&#10;        # If it's a number, assume Newtons (force)&#10;        if isinstance(load_value, (int, float)):&#10;            return float(load_value) * unit_manager.ureg.N&#10;&#10;        # If it's a string, parse units&#10;        if isinstance(load_value, str):&#10;            try:&#10;                parsed_value = parse_value_with_units(load_value)&#10;&#10;                if isinstance(parsed_value, pint.Quantity):&#10;                    # Convert to appropriate SI units based on dimensionality&#10;                    if parsed_value.dimensionality == unit_manager.ureg.N.dimensionality:&#10;                        return parsed_value.to('N')&#10;                    elif parsed_value.dimensionality == (unit_manager.ureg.N * unit_manager.ureg.m).dimensionality:&#10;                        return parsed_value.to('N*m')&#10;                    return parsed_value&#10;                else:&#10;                    # No units specified, assume Newtons&#10;                    return float(parsed_value) * unit_manager.ureg.N&#10;&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not parse load value '{load_value}': {e}&quot;)&#10;                try:&#10;                    return float(load_value) * unit_manager.ureg.N&#10;                except Exception:&#10;                    raise ValueError(f&quot;Could not parse load value: {load_value}&quot;)&#10;&#10;        raise ValueError(f&quot;Unsupported load value type: {type(load_value)}&quot;)&#10;&#10;    def _parse_load_values(self, load_values):&#10;        &quot;&quot;&quot;&#10;        Parse a list of load values [fx, fy, mz].&#10;&#10;        Parameters&#10;        ----------&#10;        load_values : list&#10;            List of load values [fx, fy, mz]&#10;&#10;        Returns&#10;        -------&#10;        list&#10;            List of load values as pint.Quantity objects&#10;        &quot;&quot;&quot;&#10;        if not isinstance(load_values, (list, tuple)):&#10;            raise ValueError(&quot;Load values must be a list or tuple&quot;)&#10;&#10;        if len(load_values) != 3:&#10;            raise ValueError(&quot;Load values must contain exactly 3 elements [fx, fy, mz]&quot;)&#10;&#10;        parsed_loads = []&#10;        for i, load_value in enumerate(load_values):&#10;            parsed_loads.append(self._parse_load_value(load_value))&#10;&#10;        return parsed_loads&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return a readable string representation of the node with complete restraint information&quot;&quot;&quot;&#10;        restraint_symbols = {0: &quot;Free&quot;, 1: &quot;Fixed&quot;}&#10;&#10;        str_repr = f&quot;Node:{self.uid}\n&quot;&#10;        str_repr += f&quot;Coordinates: ({self.x}, {self.y})\n&quot;&#10;        str_repr += &quot;Restraints:\n&quot;&#10;        str_repr += &quot;-&quot; * 15 + &quot;\n&quot;&#10;&#10;        for i, r in enumerate(self.restraints):&#10;            str_repr += f&quot;{self.restraints_key[i]}: {restraint_symbols[r]}&quot;&#10;&#10;            # Add spring information if applicable&#10;            if self._isSpring and self._spring_stiffness[i] &gt; 0:&#10;                direction_info = &quot;&quot;&#10;                if self._spring_direction[i] == 1:&#10;                    direction_info = &quot; (+ direction only)&quot;&#10;                elif self._spring_direction[i] == -1:&#10;                    direction_info = &quot; (- direction only)&quot;&#10;&#10;                str_repr += f&quot; with Spring k={self._spring_stiffness[i]}{direction_info}&quot;&#10;&#10;            str_repr += &quot;\n&quot;&#10;&#10;        return str_repr&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return a string representation of the node for debugging&quot;&quot;&quot;&#10;        return f&quot;R2Node(uid={self.uid}, x={self.x}, y={self.y})&quot;&#10;&#10;    def x_displaced(self, combo, scale=1.0):&#10;        &quot;&quot;&quot;Return X coordinate with displacement applied&quot;&quot;&quot;&#10;        if combo.name in self.displacements:&#10;            return self.x + self.displacements[combo.name][0] * scale * unit_manager.ureg.m&#10;        return self.x&#10;&#10;    def y_displaced(self, combo, scale=1.0):&#10;        &quot;&quot;&quot;Return Y coordinate with displacement applied&quot;&quot;&quot;&#10;        if combo.name in self.displacements:&#10;            return self.y + self.displacements[combo.name][1] * scale * unit_manager.ureg.m&#10;        return self.y&#10;&#10;    def distance(self, other):&#10;        &quot;&quot;&quot;&#10;        Calculate Euclidean distance between nodes.&#10;&#10;        Parameters&#10;        ----------&#10;        other : R2Node&#10;            Another node&#10;&#10;        Returns&#10;        -------&#10;        pint.Quantity&#10;            Euclidean distance in meters&#10;        &quot;&quot;&quot;&#10;        dx = self.x - other.x&#10;        dy = self.y - other.y&#10;&#10;        # Calculate distance preserving units&#10;        return (dx ** 2 + dy ** 2) ** 0.5&#10;&#10;    def restrainUx(self):&#10;        self.restraints[0] = 1&#10;&#10;    def restrainUy(self):&#10;        self.restraints[1] = 1&#10;&#10;    def restrainMz(self):&#10;        self.restraints[2] = 1&#10;&#10;    def restrainAll(self):&#10;        self.restraints = [1, 1, 1]&#10;&#10;    def restrainTranslation(self):&#10;        self.restraints = [1, 1, 0]&#10;&#10;    def releaseUx(self):&#10;        self.restraints[0] = 0&#10;&#10;    def releaseUy(self):&#10;        self.restraints[1] = 0&#10;&#10;    def releaseMz(self):&#10;        self.restraints[2] = 0&#10;&#10;    def releaseAll(self):&#10;        self.restraints = [0, 0, 0]&#10;&#10;    def applySpringUx(self, k=100, direction=0):&#10;        self.restraints[0] = 0&#10;        self._spring_stiffness[0] = k&#10;        self._spring_direction[0] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def applySpringUy(self, k=100, direction=0):&#10;        self.restraints[1] = 0&#10;        self._spring_stiffness[1] = k&#10;        self._spring_direction[1] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def applySpringRz(self, k=100, direction=0):&#10;        self.restraints[2] = 0&#10;        self._spring_stiffness[2] = k&#10;        self._spring_direction[2] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def add_nodal_load(self, fx, fy, mz, loadcase=&quot;D&quot;):&#10;        &quot;&quot;&quot;&#10;        Add a nodal load to the node.&#10;&#10;        Parameters&#10;        ----------&#10;        fx : float, str, or pint.Quantity&#10;            Force in x-direction.&#10;        fy : float, str, or pint.Quantity&#10;            Force in y-direction.&#10;        mz : float, str, or pint.Quantity&#10;            Moment around z-axis.&#10;        loadcase : str, optional&#10;            Load case identifier. Default is &quot;D&quot; (Dead Load).&#10;        &quot;&quot;&quot;&#10;        if loadcase not in self.loads:&#10;            self.loads[loadcase] = [0 * unit_manager.ureg.N, 0 * unit_manager.ureg.N, 0 * unit_manager.ureg.N * unit_manager.ureg.m]&#10;&#10;        # Parse load values with units&#10;        fx_parsed = self._parse_load_value(fx)&#10;        fy_parsed = self._parse_load_value(fy)&#10;        mz_parsed = self._parse_load_value(mz)&#10;&#10;        # Add the load components to any existing loads&#10;        self.loads[loadcase][0] += fx_parsed&#10;        self.loads[loadcase][1] += fy_parsed&#10;        self.loads[loadcase][2] += mz_parsed&#10;&#10;    def display_loads(self):&#10;        &quot;&quot;&quot;Display all loads applied to the node.&quot;&quot;&quot;&#10;        if not self.loads:&#10;            print(f&quot;Node:{self.uid} - No loads applied&quot;)&#10;            return&#10;&#10;        print(f&quot;Node:{self.uid} - Applied Loads&quot;)&#10;        print(&quot;-&quot; * 50)&#10;&#10;        for loadcase, forces in self.loads.items():&#10;            print(f&quot;Load Case: {loadcase}&quot;)&#10;            print(f&quot;  Fx: {forces[0]}, Fy: {forces[1]}, Mz: {forces[2]}&quot;)&#10;&#10;    def compute_reactions(self, load_combination):&#10;        &quot;&quot;&quot;Calculate reactions for a given load combination&#10;&#10;        Computes support reactions by summing member end forces&#10;        at support nodes.&#10;&#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to calculate reactions&#10;&#10;        Returns&#10;        -------&#10;        numpy.ndarray&#10;            Vector of reaction forces/moments at support nodes&#10;        &quot;&quot;&quot;&#10;        # Initialize reactions array with object dtype to store quantities with units&#10;        reactions = np.zeros(self.NJD, dtype=object)&#10;&#10;        # Convert zeros to quantities with appropriate units&#10;        from pyMAOS.units_mod import unit_manager&#10;        for i in range(self.NJD):&#10;            # Use alternating force and moment units based on DOF index&#10;            unit = unit_manager.get_current_units().get('force' if i % 3 != 2 else 'moment', 'N')&#10;            reactions[i] = unit_manager.get_zero_quantity(unit)&#10;&#10;        print(f&quot;Computing reactions for load combination: {load_combination.name}&quot;)&#10;&#10;        # For each member, add its contribution to the reactions&#10;        from pyMAOS.quantity_utils import add_arrays_with_units&#10;        # First iterate through members where this node is the i-node&#10;        for member in self.is_inode_of_elems:&#10;            member_FG = member.set_end_forces_global(load_combination)&#10;            # Use slice for i-node forces (first part of force vector)&#10;            reactions = add_arrays_with_units(reactions, member_FG[0:self.NJD])&#10;            print(f&quot;After adding i-node member {member.uid}, reactions = {reactions}&quot;)&#10;&#10;        # Then iterate through members where this node is the j-node&#10;        for member in self.is_jnode_of_elems:&#10;            member_FG = member.set_end_forces_global(load_combination)&#10;            # Use slice for j-node forces (second part of force vector)&#10;            reactions = add_arrays_with_units(reactions, member_FG[self.NJD:(2*self.NJD)])&#10;            print(f&quot;After adding j-node member {member.uid}, reactions = {reactions}&quot;)&#10;&#10;        self.reactions = reactions&#10;        print(f&quot;Node {self.uid} reactions: Rx={reactions[0]:.4E}, Ry={reactions[1]:.4E}, Mz={reactions[2]:.4E}&quot;)&#10;&#10;        return reactions&#10;&#10;# --- Read nodes ---&#10;def get_nodes_from_csv(csv_file):&#10;    import csv&#10;    nodes_dict = {}&#10;    with open(csv_file, newline=&quot;&quot;) as csvfile:&#10;        reader = csv.DictReader(csvfile, skipinitialspace=True)&#10;        for row in reader:&#10;            uid = int(row[&quot;uid&quot;])&#10;            x = float(row[&quot;X&quot;])&#10;            y = float(row[&quot;Y&quot;])&#10;            rx = int(row[&quot;rx&quot;])&#10;            ry = int(row[&quot;ry&quot;])&#10;            rz = int(row[&quot;rz&quot;])&#10;            node = R2Node(uid, x, y)&#10;            node.restraints = [rx, ry, rz]&#10;            nodes_dict[uid] = node&#10;    return nodes_dict" />
              <option name="updatedContent" value="# -*- coding: utf-8 -*-&#10;import math&#10;import numpy as np&#10;import pint&#10;from pint import Quantity&#10;import pyMAOS&#10;from pyMAOS.units_mod import parse_value_with_units&#10;&#10;&#10;class LoadsDict(dict):&#10;    &quot;&quot;&quot;Custom dictionary class that handles unit parsing for load values&quot;&quot;&quot;&#10;&#10;    def __init__(self, node):&#10;        super().__init__()&#10;        self.node = node  # Reference to the parent node for access to parsing methods&#10;&#10;    def __setitem__(self, key, value):&#10;        &quot;&quot;&quot;Override setitem to parse units when assigning individual load cases&quot;&quot;&quot;&#10;        if isinstance(value, (list, tuple)):&#10;            # Parse the load values with units&#10;            parsed_values = self.node._parse_load_values(value)&#10;            super().__setitem__(key, parsed_values)&#10;        else:&#10;            super().__setitem__(key, value)&#10;&#10;    def update(self, other_dict):&#10;        &quot;&quot;&quot;Override update to parse units for bulk updates&quot;&quot;&quot;&#10;        if isinstance(other_dict, dict):&#10;            for key, value in other_dict.items():&#10;                self[key] = value  # Use our custom __setitem__&#10;&#10;&#10;class R2Node:&#10;    def __init__(self, uid, x, y):&#10;        &quot;&quot;&quot;&#10;        Parameters&#10;        ----------&#10;        x : float, str, or pint.Quantity&#10;            x-axis coordinate of the node in R2.&#10;        y : float, str, or pint.Quantity&#10;            y-axis coordinate of the node in R2.&#10;        uid : int&#10;            unique node number.&#10;        &quot;&quot;&quot;&#10;        self.uid = uid&#10;        # Ux,Uy, and Rz = 3&#10;        # Number of possible Joint Displacements&#10;        self.NJD = 3&#10;&#10;        self.is_inode_of_elem_ids = []; self.is_jnode_of_elem_ids = []&#10;&#10;        self.is_inode_of_elems=[]; self.is_jnode_of_elems=[]&#10;&#10;        # Parse and store coordinates as pint.Quantity objects&#10;        self.x = self._parse_coordinate(x)&#10;        self.y = self._parse_coordinate(y)&#10;&#10;        # Restraints [Ux, Uy, Rz]&#10;        self.restraints_key = [&quot;Ux&quot;, &quot;Uy&quot;, &quot;Rz&quot;]&#10;        self.restraints = [0, 0, 0]&#10;&#10;        # Spring Restraint [kux, kuy, krz]&#10;        # Spring Stiffness should be 0 for a restrained direction&#10;        # Spring is still a DOF for the node&#10;        self._spring_stiffness = [0, 0, 0]&#10;&#10;        # Directionality of spring&#10;        # 0 = bidirectional resistance&#10;        # 1 = spring resists positive axis displacement&#10;        # -1 = spring resists negative axis displacement&#10;        self._spring_direction = [0, 0, 0]&#10;&#10;        # Spring Stiffness Multiplier&#10;        self._springUxmulti = {}&#10;        self._springUymulti = {}&#10;        self._springRzmulti = {}&#10;&#10;        # Enforced Displacement [Ux, Uy, Rz]&#10;        self._enforced_displacements = [0, 0, 0]&#10;&#10;        # Dict of Loads by case - use custom dictionary that handles unit parsing&#10;        self.loads = LoadsDict(self)&#10;&#10;        # Dict of Displacements by combo&#10;        self.displacements = {}&#10;&#10;        # Dict of Reactions by combo&#10;        self.reactions = {}&#10;&#10;        # Flags&#10;        self._isSpring = False&#10;        self._isNonLinear = False&#10;&#10;    def _parse_coordinate(self, coordinate):&#10;        &quot;&quot;&quot;&#10;        Parse a coordinate value and return as pint.Quantity.&#10;&#10;        Parameters&#10;        ----------&#10;        coordinate : float, str, or pint.Quantity&#10;            Coordinate value&#10;&#10;        Returns&#10;        -------&#10;        pint.Quantity&#10;            Coordinate value as a Quantity in meters&#10;        &quot;&quot;&quot;&#10;        # If already a Quantity, convert to meters&#10;        if isinstance(coordinate, pint.Quantity):&#10;            return coordinate.to('m')&#10;&#10;        # If it's a number, create a Quantity in meters&#10;        if isinstance(coordinate, (int, float)):&#10;            return coordinate * pyMAOS.unit_manager.ureg.m&#10;&#10;        # If it's a string, parse units&#10;        if isinstance(coordinate, str):&#10;            try:&#10;                parsed_value = parse_value_with_units(coordinate)&#10;&#10;                if isinstance(parsed_value, pint.Quantity):&#10;                    return parsed_value.to('m')&#10;                else:&#10;                    # No units specified, assume meters&#10;                    return float(parsed_value) * pyMAOS.unit_manager.ureg.m&#10;&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not parse coordinate '{coordinate}': {e}&quot;)&#10;                try:&#10;                    return float(coordinate) * pyMAOS.unit_manager.ureg.m&#10;                except Exception:&#10;                    raise ValueError(f&quot;Could not parse coordinate value: {coordinate}&quot;)&#10;&#10;        raise ValueError(f&quot;Unsupported coordinate type: {type(coordinate)}&quot;)&#10;&#10;    def _parse_load_value(self, load_value):&#10;        &quot;&quot;&quot;&#10;        Parse a load value and return as pint.Quantity.&#10;&#10;        Parameters&#10;        ----------&#10;        load_value : float, str, or pint.Quantity&#10;            Load value&#10;&#10;        Returns&#10;        -------&#10;        pint.Quantity&#10;            Load value as a Quantity in N or N*m&#10;        &quot;&quot;&quot;&#10;        # If already a Quantity, return as is&#10;        if isinstance(load_value, pint.Quantity):&#10;            # Check dimensionality to convert to correct units&#10;            if load_value.dimensionality == pyMAOS.unit_manager.ureg.N.dimensionality:&#10;                return load_value.to('N')&#10;            elif load_value.dimensionality == (pyMAOS.unit_manager.ureg.N * pyMAOS.unit_manager.ureg.m).dimensionality:&#10;                return load_value.to('N*m')&#10;            return load_value&#10;&#10;        # If it's a number, assume Newtons (force)&#10;        if isinstance(load_value, (int, float)):&#10;            return float(load_value) * pyMAOS.unit_manager.ureg.N&#10;&#10;        # If it's a string, parse units&#10;        if isinstance(load_value, str):&#10;            try:&#10;                parsed_value = parse_value_with_units(load_value)&#10;&#10;                if isinstance(parsed_value, pint.Quantity):&#10;                    # Convert to appropriate SI units based on dimensionality&#10;                    if parsed_value.dimensionality == pyMAOS.unit_manager.ureg.N.dimensionality:&#10;                        return parsed_value.to('N')&#10;                    elif parsed_value.dimensionality == (pyMAOS.unit_manager.ureg.N * pyMAOS.unit_manager.ureg.m).dimensionality:&#10;                        return parsed_value.to('N*m')&#10;                    return parsed_value&#10;                else:&#10;                    # No units specified, assume Newtons&#10;                    return float(parsed_value) * pyMAOS.unit_manager.ureg.N&#10;&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not parse load value '{load_value}': {e}&quot;)&#10;                try:&#10;                    return float(load_value) * pyMAOS.unit_manager.ureg.N&#10;                except Exception:&#10;                    raise ValueError(f&quot;Could not parse load value: {load_value}&quot;)&#10;&#10;        raise ValueError(f&quot;Unsupported load value type: {type(load_value)}&quot;)&#10;&#10;    def _parse_load_values(self, load_values):&#10;        &quot;&quot;&quot;&#10;        Parse a list of load values [fx, fy, mz].&#10;&#10;        Parameters&#10;        ----------&#10;        load_values : list&#10;            List of load values [fx, fy, mz]&#10;&#10;        Returns&#10;        -------&#10;        list&#10;            List of load values as pint.Quantity objects&#10;        &quot;&quot;&quot;&#10;        if not isinstance(load_values, (list, tuple)):&#10;            raise ValueError(&quot;Load values must be a list or tuple&quot;)&#10;&#10;        if len(load_values) != 3:&#10;            raise ValueError(&quot;Load values must contain exactly 3 elements [fx, fy, mz]&quot;)&#10;&#10;        parsed_loads = []&#10;        for i, load_value in enumerate(load_values):&#10;            parsed_loads.append(self._parse_load_value(load_value))&#10;&#10;        return parsed_loads&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return a readable string representation of the node with complete restraint information&quot;&quot;&quot;&#10;        restraint_symbols = {0: &quot;Free&quot;, 1: &quot;Fixed&quot;}&#10;&#10;        str_repr = f&quot;Node:{self.uid}\n&quot;&#10;        str_repr += f&quot;Coordinates: ({self.x}, {self.y})\n&quot;&#10;        str_repr += &quot;Restraints:\n&quot;&#10;        str_repr += &quot;-&quot; * 15 + &quot;\n&quot;&#10;&#10;        for i, r in enumerate(self.restraints):&#10;            str_repr += f&quot;{self.restraints_key[i]}: {restraint_symbols[r]}&quot;&#10;&#10;            # Add spring information if applicable&#10;            if self._isSpring and self._spring_stiffness[i] &gt; 0:&#10;                direction_info = &quot;&quot;&#10;                if self._spring_direction[i] == 1:&#10;                    direction_info = &quot; (+ direction only)&quot;&#10;                elif self._spring_direction[i] == -1:&#10;                    direction_info = &quot; (- direction only)&quot;&#10;&#10;                str_repr += f&quot; with Spring k={self._spring_stiffness[i]}{direction_info}&quot;&#10;&#10;            str_repr += &quot;\n&quot;&#10;&#10;        return str_repr&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return a string representation of the node for debugging&quot;&quot;&quot;&#10;        return f&quot;R2Node(uid={self.uid}, x={self.x}, y={self.y})&quot;&#10;&#10;    def x_displaced(self, combo, scale=1.0):&#10;        &quot;&quot;&quot;Return X coordinate with displacement applied&quot;&quot;&quot;&#10;        if combo.name in self.displacements:&#10;            return self.x + self.displacements[combo.name][0] * scale * unit_manager.ureg.m&#10;        return self.x&#10;&#10;    def y_displaced(self, combo, scale=1.0):&#10;        &quot;&quot;&quot;Return Y coordinate with displacement applied&quot;&quot;&quot;&#10;        if combo.name in self.displacements:&#10;            return self.y + self.displacements[combo.name][1] * scale * unit_manager.ureg.m&#10;        return self.y&#10;&#10;    def distance(self, other):&#10;        &quot;&quot;&quot;&#10;        Calculate Euclidean distance between nodes.&#10;&#10;        Parameters&#10;        ----------&#10;        other : R2Node&#10;            Another node&#10;&#10;        Returns&#10;        -------&#10;        pint.Quantity&#10;            Euclidean distance in meters&#10;        &quot;&quot;&quot;&#10;        dx = self.x - other.x&#10;        dy = self.y - other.y&#10;&#10;        # Calculate distance preserving units&#10;        return (dx ** 2 + dy ** 2) ** 0.5&#10;&#10;    def restrainUx(self):&#10;        self.restraints[0] = 1&#10;&#10;    def restrainUy(self):&#10;        self.restraints[1] = 1&#10;&#10;    def restrainMz(self):&#10;        self.restraints[2] = 1&#10;&#10;    def restrainAll(self):&#10;        self.restraints = [1, 1, 1]&#10;&#10;    def restrainTranslation(self):&#10;        self.restraints = [1, 1, 0]&#10;&#10;    def releaseUx(self):&#10;        self.restraints[0] = 0&#10;&#10;    def releaseUy(self):&#10;        self.restraints[1] = 0&#10;&#10;    def releaseMz(self):&#10;        self.restraints[2] = 0&#10;&#10;    def releaseAll(self):&#10;        self.restraints = [0, 0, 0]&#10;&#10;    def applySpringUx(self, k=100, direction=0):&#10;        self.restraints[0] = 0&#10;        self._spring_stiffness[0] = k&#10;        self._spring_direction[0] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def applySpringUy(self, k=100, direction=0):&#10;        self.restraints[1] = 0&#10;        self._spring_stiffness[1] = k&#10;        self._spring_direction[1] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def applySpringRz(self, k=100, direction=0):&#10;        self.restraints[2] = 0&#10;        self._spring_stiffness[2] = k&#10;        self._spring_direction[2] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def add_nodal_load(self, fx, fy, mz, loadcase=&quot;D&quot;):&#10;        &quot;&quot;&quot;&#10;        Add a nodal load to the node.&#10;&#10;        Parameters&#10;        ----------&#10;        fx : float, str, or pint.Quantity&#10;            Force in x-direction.&#10;        fy : float, str, or pint.Quantity&#10;            Force in y-direction.&#10;        mz : float, str, or pint.Quantity&#10;            Moment around z-axis.&#10;        loadcase : str, optional&#10;            Load case identifier. Default is &quot;D&quot; (Dead Load).&#10;        &quot;&quot;&quot;&#10;        if loadcase not in self.loads:&#10;            self.loads[loadcase] = [0 * pyMAOS.unit_manager.ureg.N, 0 * pyMAOS.unit_manager.ureg.N, 0 * pyMAOS.unit_manager.ureg.N * pyMAOS.unit_manager.ureg.m]&#10;&#10;        # Parse load values with units&#10;        fx_parsed = self._parse_load_value(fx)&#10;        fy_parsed = self._parse_load_value(fy)&#10;        mz_parsed = self._parse_load_value(mz)&#10;&#10;        # Add the load components to any existing loads&#10;        self.loads[loadcase][0] += fx_parsed&#10;        self.loads[loadcase][1] += fy_parsed&#10;        self.loads[loadcase][2] += mz_parsed&#10;&#10;    def display_loads(self):&#10;        &quot;&quot;&quot;Display all loads applied to the node.&quot;&quot;&quot;&#10;        if not self.loads:&#10;            print(f&quot;Node:{self.uid} - No loads applied&quot;)&#10;            return&#10;&#10;        print(f&quot;Node:{self.uid} - Applied Loads&quot;)&#10;        print(&quot;-&quot; * 50)&#10;&#10;        for loadcase, forces in self.loads.items():&#10;            print(f&quot;Load Case: {loadcase}&quot;)&#10;            print(f&quot;  Fx: {forces[0]}, Fy: {forces[1]}, Mz: {forces[2]}&quot;)&#10;&#10;    def compute_reactions(self, load_combination):&#10;        &quot;&quot;&quot;Calculate reactions for a given load combination&#10;&#10;        Computes support reactions by summing member end forces&#10;        at support nodes.&#10;&#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to calculate reactions&#10;&#10;        Returns&#10;        -------&#10;        numpy.ndarray&#10;            Vector of reaction forces/moments at support nodes&#10;        &quot;&quot;&quot;&#10;        # Initialize reactions array with object dtype to store quantities with units&#10;        reactions = np.zeros(self.NJD, dtype=object)&#10;&#10;        # Convert zeros to quantities with appropriate units&#10;        import pyMAOS&#10;        for i in range(self.NJD):&#10;            # Use alternating force and moment units based on DOF index&#10;            unit = pyMAOS.unit_manager.get_current_units().get('force' if i % 3 != 2 else 'moment', 'N')&#10;            reactions[i] = pyMAOS.unit_manager.get_zero_quantity(unit)&#10;&#10;        print(f&quot;Computing reactions for load combination: {load_combination.name}&quot;)&#10;&#10;        # For each member, add its contribution to the reactions&#10;        from pyMAOS.quantity_utils import add_arrays_with_units&#10;        # First iterate through members where this node is the i-node&#10;        for member in self.is_inode_of_elems:&#10;            member_FG = member.set_end_forces_global(load_combination)&#10;            # Use slice for i-node forces (first part of force vector)&#10;            reactions = add_arrays_with_units(reactions, member_FG[0:self.NJD])&#10;            print(f&quot;After adding i-node member {member.uid}, reactions = {reactions}&quot;)&#10;&#10;        # Then iterate through members where this node is the j-node&#10;        for member in self.is_jnode_of_elems:&#10;            member_FG = member.set_end_forces_global(load_combination)&#10;            # Use slice for j-node forces (second part of force vector)&#10;            reactions = add_arrays_with_units(reactions, member_FG[self.NJD:(2*self.NJD)])&#10;            print(f&quot;After adding j-node member {member.uid}, reactions = {reactions}&quot;)&#10;&#10;        self.reactions = reactions&#10;        print(f&quot;Node {self.uid} reactions: Rx={reactions[0]:.4E}, Ry={reactions[1]:.4E}, Mz={reactions[2]:.4E}&quot;)&#10;&#10;        return reactions&#10;&#10;# --- Read nodes ---&#10;def get_nodes_from_csv(csv_file):&#10;    import csv&#10;    nodes_dict = {}&#10;    with open(csv_file, newline=&quot;&quot;) as csvfile:&#10;        reader = csv.DictReader(csvfile, skipinitialspace=True)&#10;        for row in reader:&#10;            uid = int(row[&quot;uid&quot;])&#10;            x = float(row[&quot;X&quot;])&#10;            y = float(row[&quot;Y&quot;])&#10;            rx = int(row[&quot;rx&quot;])&#10;            ry = int(row[&quot;ry&quot;])&#10;            rz = int(row[&quot;rz&quot;])&#10;            node = R2Node(uid, x, y)&#10;            node.restraints = [rx, ry, rz]&#10;            nodes_dict[uid] = node&#10;    return nodes_dict" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/quantity_utils.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/quantity_utils.py" />
              <option name="originalContent" value="import numpy as np&#10;import pint&#10;import pyMAOS&#10;&#10;# Replace any direct ureg usage with unit_manager.ureg&#10;Q_ = pyMAOS.unit_manager.ureg.Quantity&#10;&#10;# Performance Considerations&#10;# There is a performance penalty compared to standard numpy arrays:&#10;#&#10;#&#10;# Type checking overhead: Every __setitem__ and __getitem__ operation performs a type check against pint.Quantity&#10;# Unit extraction: Extra processing to extract magnitude values&#10;# Method overriding: Custom methods add function call overhead&#10;# The penalty is typically negligible for small to medium matrices but could be significant for:&#10;#&#10;#&#10;# Large matrices (thousands of elements)&#10;# Performance-critical code with frequent matrix operations&#10;# Tight loops accessing many elements individually&#10;# Important Limitations&#10;# Unit information is lost: Only magnitudes are stored, not units&#10;# No dimensional checking: The class doesn't verify unit compatibility in operations&#10;# No unit conversion: Values must be converted to consistent units before assignment&#10;# For occasional use with matrices where unit handling is important at boundaries but not during computation, QuantityArray provides a good balance of convenience and functionality.&#10;&#10;import numpy as np&#10;import pint&#10;&#10;# class QuantityArray(np.ndarray):&#10;#     &quot;&quot;&quot;&#10;#     Custom NumPy array that can track units for its elements.&#10;#     Used to perform calculations with quantities while preserving unit information.&#10;#     &quot;&quot;&quot;&#10;#&#10;#     def __new__(cls, input_array):&#10;#         &quot;&quot;&quot;&#10;#         Create a new QuantityArray, preserving units if present.&#10;#&#10;#         Parameters&#10;#         ----------&#10;#         input_array : array_like&#10;#             Input array or list of values, possibly with units&#10;#&#10;#         Returns&#10;#         -------&#10;#         QuantityArray&#10;#             New array with units preserved&#10;#         &quot;&quot;&quot;&#10;#         print(f&quot;DEBUG: Creating QuantityArray from: {input_array}&quot;)&#10;#&#10;#         # Check if we're dealing with a list/array of quantities with units&#10;#         if isinstance(input_array, (list, np.ndarray)) and len(input_array) &gt; 0:&#10;#             has_units = any(hasattr(item, 'units') for item in input_array)&#10;#&#10;#             if has_units:&#10;#                 print(f&quot;DEBUG: Input contains units, extracting magnitudes&quot;)&#10;#                 # Extract magnitudes first&#10;#                 magnitudes = np.array([item.magnitude if hasattr(item, 'magnitude') else item&#10;#                                       for item in input_array])&#10;#&#10;#                 # Create new array from magnitudes&#10;#                 obj = np.asarray(magnitudes).view(cls)&#10;#&#10;#                 # Create units dictionary&#10;#                 obj._units_dict = {}&#10;#                 for i, item in enumerate(input_array):&#10;#                     if hasattr(item, 'units'):&#10;#                         obj._units_dict[i] = str(item.units)&#10;#                         print(f&quot;DEBUG: Item {i} has units: {item.units}&quot;)&#10;#&#10;#                 return obj&#10;#&#10;#         # Fall back to standard numpy array creation if no units&#10;#         print(f&quot;DEBUG: No units detected, using standard numpy array creation&quot;)&#10;#         obj = np.asarray(input_array).view(cls)&#10;#         return obj&#10;#&#10;#     def __array_finalize__(self, obj):&#10;#         if obj is None: return&#10;#         self._units_dict = getattr(obj, '_units_dict', {})&#10;#&#10;#     def __str__(self):&#10;#         &quot;&quot;&quot;Display array with units attached to values&quot;&quot;&quot;&#10;#         if self.ndim == 0:  # Scalar case&#10;#             return self._format_with_units(self[()])&#10;#&#10;#         # For 1D arrays&#10;#         if self.ndim == 1:&#10;#             elements = [self._format_with_units(val) for val in self]&#10;#             return f&quot;[{', '.join(elements)}]&quot;&#10;#&#10;#         # For multi-dimensional arrays, use numpy's formatting but with units&#10;#         # Get the string representation of the array without units&#10;#         base_str = np.array_str(self)&#10;#&#10;#         # Replace numeric values with unit-attached versions&#10;#         # This is a simple approach - for complex arrays a more sophisticated&#10;#         # implementation might be needed&#10;#         if self._units_dict:&#10;#             return f&quot;QuantityArray with units {self._units_dict}:\n{base_str}&quot;&#10;#         return base_str&#10;#&#10;#     def _format_with_units(self, value):&#10;#         &quot;&quot;&quot;Format a single value with its unit if available, avoiding unit duplication&quot;&quot;&quot;&#10;#         # If value is already a Quantity object, just return its string representation&#10;#         if hasattr(value, 'units'):&#10;#             return str(value)&#10;#&#10;#         # If value is an index into the array&#10;#         if isinstance(value, (int, np.integer)) and value &lt; len(self):&#10;#             value = self[value]&#10;#             # If after index access it's a Quantity, return its string representation&#10;#             if hasattr(value, 'units'):&#10;#                 return str(value)&#10;#&#10;#         # Find the unit for this position or value in the units dictionary&#10;#         unit = None&#10;#         for unit_key, unit_value in self._units_dict.items():&#10;#             if unit_key == value or (isinstance(unit_key, int) and unit_key &lt; len(self)):&#10;#                 unit = unit_value&#10;#                 break&#10;#&#10;#         # Prevent adding units to values that might already have units in string form&#10;#         if unit and not str(value).endswith(unit):&#10;#             return f&quot;{value} {unit}&quot;&#10;#&#10;#         return f&quot;{value}&quot;&#10;#&#10;#     def with_units(self):&#10;#         &quot;&quot;&quot;Return array with units attached for display&quot;&quot;&quot;&#10;#         return self  # The __str__ method will handle unit display&#10;#&#10;#     def __setitem__(self, key, value):&#10;#         if isinstance(value, pint.Quantity):&#10;#             # Store magnitude in array&#10;#             super().__setitem__(key, value.magnitude)&#10;#&#10;#             # Store unit for this position&#10;#             if isinstance(key, tuple):&#10;#                 # Handle multi-dimensional indices (e.g., [0, 0])&#10;#                 flat_idx = np.ravel_multi_index(key, self.shape)&#10;#                 self._units_dict[flat_idx] = value.units&#10;#             elif np.isscalar(key):&#10;#                 # Single element assignment with scalar index&#10;#                 self._units_dict[key] = value.units&#10;#             else:&#10;#                 # Slice or advanced indexing assignment&#10;#                 try:&#10;#                     # Get the indices affected by this assignment&#10;#                     mask = np.ones(self.shape)[key]&#10;#                     indices = np.where(np.atleast_1d(mask) if np.isscalar(mask) else mask)&#10;#&#10;#                     for idx in zip(*indices):&#10;#                         flat_idx = np.ravel_multi_index(idx, self.shape)&#10;#                         self._units_dict[flat_idx] = value.units&#10;#                 except (TypeError, ValueError):&#10;#                     # Fallback for unusual key types&#10;#                     print(f&quot;Warning: Unusual key type in QuantityArray.__setitem__: {type(key)}&quot;)&#10;#         else:&#10;#             # Regular assignment without units&#10;#             super().__setitem__(key, value)&#10;#&#10;#             # Remove any units for these indices if they exist&#10;#             if isinstance(key, tuple):&#10;#                 flat_idx = np.ravel_multi_index(key, self.shape)&#10;#                 if flat_idx in self._units_dict:&#10;#                     del self._units_dict[flat_idx]&#10;#             elif np.isscalar(key) and key in self._units_dict:&#10;#                 del self._units_dict[key]&#10;#&#10;#     def __getitem__(self, key):&#10;#         # Get the value using the parent class's __getitem__&#10;#         value = super().__getitem__(key)&#10;#&#10;#         # Handle slice operations that return a new array&#10;#         if isinstance(value, np.ndarray) and isinstance(value, QuantityArray):&#10;#             # If we have a slice and units dictionary exists&#10;#             if hasattr(self, '_units_dict') and self._units_dict:&#10;#                 original_shape = self.shape&#10;#                 new_shape = value.shape&#10;#&#10;#                 # Create a new units dictionary for the sliced array&#10;#                 new_units_dict = {}&#10;#&#10;#                 # Convert key to slice objects to work with&#10;#                 full_key = self._normalize_key_to_tuple(key, len(original_shape))&#10;#&#10;#                 # Process each unit in the original dictionary&#10;#                 for flat_idx, unit in self._units_dict.items():&#10;#                     # Get original indices for this flat index&#10;#                     try:&#10;#                         orig_indices = np.unravel_index(flat_idx, original_shape)&#10;#&#10;#                         # Check if these indices are within our slice&#10;#                         in_slice = True&#10;#                         new_indices = []&#10;#&#10;#                         for i, (idx, sl) in enumerate(zip(orig_indices, full_key)):&#10;#                             if isinstance(sl, slice):&#10;#                                 # Handle slice&#10;#                                 start = sl.start if sl.start is not None else 0&#10;#                                 stop = sl.stop if sl.stop is not None else original_shape[i]&#10;#                                 step = sl.step if sl.step is not None else 1&#10;#&#10;#                                 # Check if index is in the slice&#10;#                                 if start &lt;= idx &lt; stop and (idx - start) % step == 0:&#10;#                                     new_indices.append((idx - start) // step)&#10;#                                 else:&#10;#                                     in_slice = False&#10;#                                     break&#10;#                             elif isinstance(sl, int):&#10;#                                 # Handle integer index&#10;#                                 if idx == sl:&#10;#                                     # This dimension is removed in the result&#10;#                                     pass&#10;#                                 else:&#10;#                                     in_slice = False&#10;#                                     break&#10;#                             else:&#10;#                                 # Other advanced indexing cases&#10;#                                 # For simplicity, we don't handle these yet&#10;#                                 in_slice = False&#10;#                                 break&#10;#&#10;#                         if in_slice and len(new_indices) == len(new_shape):&#10;#                             # Calculate new flat index in the sliced array&#10;#                             new_flat_idx = np.ravel_multi_index(tuple(new_indices), new_shape)&#10;#                             new_units_dict[new_flat_idx] = unit&#10;#                     except (ValueError, TypeError) as e:&#10;#                         # Skip indices that can't be unraveled or processed&#10;#                         print(f&quot;DEBUG: Error processing index {flat_idx}: {e}&quot;)&#10;#                         continue&#10;#&#10;#                 # Set the new units dictionary on the sliced array&#10;#                 value._units_dict = new_units_dict&#10;#                 print(f&quot;DEBUG: Updated units dict for slice: original had {len(self._units_dict)} entries, new has {len(new_units_dict)}&quot;)&#10;#&#10;#             return value&#10;#&#10;#         # If this is a scalar value, check if we have units for it&#10;#         if np.isscalar(value):&#10;#             # Calculate flat index for the key&#10;#             if isinstance(key, tuple):&#10;#                 try:&#10;#                     flat_idx = np.ravel_multi_index(key, self.shape)&#10;#                     # If we have a unit for this index, return a Quantity&#10;#                     if flat_idx in self._units_dict:&#10;#                         #&#10;#                         return pyMAOS.unit_manager.ureg.Quantity(value, self._units_dict[flat_idx])&#10;#                 except (ValueError, TypeError):&#10;#                     # Handle cases where ravel_multi_index might fail&#10;#                     pass&#10;#             elif np.isscalar(key) and key in self._units_dict:&#10;#                 # Direct scalar indexing&#10;#                 #&#10;#                 return pyMAOS.unit_manager.ureg.Quantity(value, self._units_dict[key])&#10;#&#10;#         # If no units or non-scalar result, return value as-is&#10;#         return value&#10;#&#10;#     def _normalize_key_to_tuple(self, key, ndim):&#10;#         &quot;&quot;&quot;Convert any key to a tuple of slices with the same length as ndim&quot;&quot;&quot;&#10;#         if not isinstance(key, tuple):&#10;#             # Single key becomes (key, slice(None), slice(None), ...)&#10;#             return (key,) + (slice(None),) * (ndim - 1)&#10;#&#10;#         # If key is already a tuple but shorter than ndim&#10;#         if len(key) &lt; ndim:&#10;#             return key + (slice(None),) * (ndim - len(key))&#10;#&#10;#         return key&#10;#&#10;#     def get_units(self):&#10;#         &quot;&quot;&quot;&#10;#         Returns the units of the elements in the array.&#10;#&#10;#         Returns&#10;#         -------&#10;#         pint.Unit or None&#10;#             The unit object for the array, or None if no units are found.&#10;#         &quot;&quot;&quot;&#10;#         #&#10;#&#10;#         if not hasattr(self, '_units_dict') or not self._units_dict:&#10;#             print(&quot;DEBUG: No units dictionary found in QuantityArray&quot;)&#10;#             return None&#10;#&#10;#         print(f&quot;DEBUG: Units dictionary contains {len(self._units_dict)} entries&quot;)&#10;#         print(f&quot;DEBUG: Keys in _units_dict: {list(self._units_dict.keys())}&quot;)&#10;#&#10;#         # For arrays with a single unit (most common case)&#10;#         if len(self._units_dict) == 1:&#10;#             unit_str = next(iter(self._units_dict.values()))&#10;#             print(f&quot;DEBUG: Found single unit string: {unit_str}&quot;)&#10;#             # Convert string to pint.Unit object&#10;#             return pyMAOS.unit_manager.ureg.parse_units(unit_str)&#10;#&#10;#         # For 1D arrays, try to find unit for first element&#10;#         if self.ndim == 1 and len(self) &gt; 0:&#10;#             for idx, unit_str in self._units_dict.items():&#10;#                 if idx == 0 or idx == (0,):&#10;#                     print(f&quot;DEBUG: Using first element unit: {unit_str}&quot;)&#10;#                     return pyMAOS.unit_manager.ureg.parse_units(unit_str)&#10;#&#10;#         # Check if all units are the same&#10;#         units = list(self._units_dict.values())&#10;#         if len(units) &gt; 0 and all(u == units[0] for u in units):&#10;#             print(f&quot;DEBUG: All units are the same: {units[0]}&quot;)&#10;#             return pyMAOS.unit_manager.ureg.parse_units(units[0])&#10;#&#10;#         print(&quot;DEBUG: Multiple different units found - using first unit&quot;)&#10;#         first_unit = next(iter(self._units_dict.values()))&#10;#         return pyMAOS.unit_manager.ureg.parse_units(first_unit)&#10;#     def __add__(self, other):&#10;#         &quot;&quot;&quot;&#10;#         Addition operator that handles unit inheritance.&#10;#         When one operand has units and the other doesn't, the result inherits units from the one with units.&#10;#&#10;#         Parameters&#10;#         ----------&#10;#         other : array_like or scalar&#10;#             Value to add to self&#10;#&#10;#         Returns&#10;#         -------&#10;#         QuantityArray&#10;#             Result with appropriate units&#10;#         &quot;&quot;&quot;&#10;#         # Create result using standard addition&#10;#         result = super().__add__(other)&#10;#&#10;#         # Case 1: Self has units&#10;#         if hasattr(self, '_units_dict') and self._units_dict:&#10;#             print(f&quot;DEBUG: Self has units, copying to result&quot;)&#10;#             result._units_dict = self._units_dict.copy()&#10;#&#10;#         # Case 2: Self doesn't have units but other might have units&#10;#         else:&#10;#             # Check if other is a QuantityArray with units&#10;#             if isinstance(other, QuantityArray) and hasattr(other, '_units_dict') and other._units_dict:&#10;#                 print(f&quot;DEBUG: Inheriting units from QuantityArray&quot;)&#10;#                 result._units_dict = other._units_dict.copy()&#10;#&#10;#             # Check if other is a single Quantity with units&#10;#             elif hasattr(other, 'units'):&#10;#                 print(f&quot;DEBUG: Inheriting units from single Quantity in addition: {other.units}&quot;)&#10;#                 result._units_dict = {0: str(other.units)}&#10;#&#10;#             # Check if other is a numpy array containing Quantities&#10;#             elif isinstance(other, np.ndarray) and other.size &gt; 0:&#10;#                 # Process all elements in a single pass to find all units&#10;#                 result._units_dict = {}&#10;#                 has_units = False&#10;#&#10;#                 print(f&quot;DEBUG: Checking numpy array for Quantities&quot;)&#10;#&#10;#                 # Iterate through all elements&#10;#                 for i, item in enumerate(other.flat):&#10;#                     if item is not None and hasattr(item, 'units'):&#10;#                         result._units_dict[i] = str(item.units)&#10;#                         has_units = True&#10;#                         print(f&quot;DEBUG: Found unit at position {i}: {item.units}&quot;)&#10;#&#10;#                 if has_units:&#10;#                     print(f&quot;DEBUG: Inherited {len(result._units_dict)} units from array&quot;)&#10;#                 else:&#10;#                     print(f&quot;DEBUG: No units found in the array&quot;)&#10;#&#10;#         return result&#10;#     def __sub__(self, other):&#10;#         &quot;&quot;&quot;&#10;#         Subtraction operator that handles unit inheritance.&#10;#         When one operand has units and the other doesn't, the result inherits units from the one with units.&#10;#&#10;#         Parameters&#10;#         ----------&#10;#         other : array_like or scalar&#10;#             Value to subtract from self&#10;#&#10;#         Returns&#10;#         -------&#10;#         QuantityArray&#10;#             Result with appropriate units&#10;#         &quot;&quot;&quot;&#10;#         # Create result using standard subtraction&#10;#         result = super().__sub__(other)&#10;#&#10;#         # Case 1: Self has units&#10;#         if hasattr(self, '_units_dict') and self._units_dict:&#10;#             print(f&quot;DEBUG: Self has units, copying to result&quot;)&#10;#             result._units_dict = self._units_dict.copy()&#10;#&#10;#         # Case 2: Self doesn't have units but other might have units&#10;#         else:&#10;#             # Check if other is a QuantityArray with units&#10;#             if isinstance(other, QuantityArray) and hasattr(other, '_units_dict') and other._units_dict:&#10;#                 print(f&quot;DEBUG: Inheriting units from QuantityArray&quot;)&#10;#                 result._units_dict = other._units_dict.copy()&#10;#&#10;#             # Check if other is a single Quantity with units&#10;#             elif hasattr(other, 'units'):&#10;#                 print(f&quot;DEBUG: Inheriting units from single Quantity in subtraction: {other.units}&quot;)&#10;#                 result._units_dict = {0: str(other.units)}&#10;#&#10;#             # Check if other is a numpy array containing Quantities&#10;#             # Check if other is a numpy array containing Quantities&#10;#             elif isinstance(other, np.ndarray) and other.size &gt; 0:&#10;#                 # Process all elements in a single pass to find all units&#10;#                 result._units_dict = {}&#10;#                 has_units = False&#10;#&#10;#                 print(f&quot;DEBUG: Checking numpy array for Quantities&quot;)&#10;#&#10;#                 # Iterate through all elements&#10;#                 for i, item in enumerate(other.flat):&#10;#                     if item is not None and hasattr(item, 'units'):&#10;#                         result._units_dict[i] = str(item.units)&#10;#                         has_units = True&#10;#                         print(f&quot;DEBUG: Found unit at position {i}: {item.units}&quot;)&#10;#&#10;#                 if has_units:&#10;#                     print(f&quot;DEBUG: Inherited {len(result._units_dict)} units from array&quot;)&#10;#                 else:&#10;#                     print(f&quot;DEBUG: No units found in the array&quot;)&#10;#         return result&#10;#&#10;#     def __mul__(self, other):&#10;#         &quot;&quot;&quot;Handle multiplication while preserving units&quot;&quot;&quot;&#10;#         result = super().__mul__(other)&#10;#         # Units remain the same after scalar multiplication&#10;#         return result&#10;#&#10;#     def __rmul__(self, other):&#10;#         &quot;&quot;&quot;Handle right multiplication (scalar * array)&quot;&quot;&quot;&#10;#         result = super().__rmul__(other)&#10;#         # Units remain the same after scalar multiplication&#10;#         return result&#10;#&#10;#     def view(self, dtype=None, type=None):&#10;#         &quot;&quot;&quot;Ensure views preserve unit information&quot;&quot;&quot;&#10;#         result = super().view(dtype, type)&#10;#         if type is QuantityArray or isinstance(result, QuantityArray):&#10;#             result._units_dict = self._units_dict.copy()&#10;#         return result&#10;#&#10;#     def copy(self):&#10;#         &quot;&quot;&quot;Ensure copies preserve unit information&quot;&quot;&quot;&#10;#         result = super().copy()&#10;#         result._units_dict = self._units_dict.copy()&#10;#         return result&#10;#&#10;#     def __repr__(self):&#10;#         &quot;&quot;&quot;Representation showing it's a QuantityArray&quot;&quot;&quot;&#10;#         return f&quot;QuantityArray({np.asarray(self).__repr__()})&quot;&#10;#&#10;#&#10;#&#10;#     def incremental_add_with_units(self, position, value):&#10;#         &quot;&quot;&quot;&#10;#         Add a value to a specific position in the array while preserving units.&#10;#         Checks for unit consistency and only adds new units when needed.&#10;#&#10;#         Parameters&#10;#         ----------&#10;#         position : tuple&#10;#             Position in the array (i, j, ...)&#10;#         value : scalar or pint.Quantity&#10;#             Value to add&#10;#         &quot;&quot;&quot;&#10;#         # Calculate flat index for looking up units&#10;#         flat_idx = np.ravel_multi_index(position, self.shape)&#10;#&#10;#         # Get current value&#10;#         current_value = self[position]&#10;#&#10;#         print(f&quot;DEBUG: Adding at position {position}: value type={type(value)}&quot;)&#10;#         print(f&quot;DEBUG: Is Quantity? {isinstance(value, pint.Quantity)}&quot;)&#10;#&#10;#         # Check if we're adding a Quantity with units&#10;#         if isinstance(value, pint.Quantity):&#10;#             value_magnitude = value.magnitude&#10;#             value_unit = value.units&#10;#&#10;#             print(f&quot;DEBUG: Found Quantity value={value}, magnitude={value_magnitude}, unit={value_unit}&quot;)&#10;#&#10;#             # Check if position already has a unit assigned&#10;#             if flat_idx in self._units_dict:&#10;#                 existing_unit = self._units_dict[flat_idx]&#10;#                 print(f&quot;DEBUG: Position already has unit {existing_unit}&quot;)&#10;#&#10;#                 try:&#10;#                     # Convert the incoming value to match the existing unit&#10;#                     converted_value = value.to(existing_unit)&#10;#                     print(f&quot;DEBUG: Converted value to {existing_unit}: {converted_value}&quot;)&#10;#                     value_magnitude = converted_value.magnitude&#10;#&#10;#                     # Add the magnitude to current value&#10;#                     new_value = current_value + value_magnitude&#10;#                 except pint.DimensionalityError:&#10;#                     # If units can't be converted, create a new Quantity from current value&#10;#                     # with the existing unit, then add&#10;#                     current_quantity = pyMAOS.unit_manager.ureg.Quantity(current_value, existing_unit)&#10;#                     result_quantity = current_quantity + value&#10;#                     new_value = result_quantity.magnitude&#10;#&#10;#                     # Update the unit if necessary (e.g., if result has derived units)&#10;#                     self._units_dict[flat_idx] = result_quantity.units&#10;#                     print(f&quot;DEBUG: Updated unit to {result_quantity.units} after addition&quot;)&#10;#             else:&#10;#                 # No existing unit, just add magnitude and assign the unit&#10;#                 new_value = current_value + value_magnitude&#10;#                 self._units_dict[flat_idx] = value_unit&#10;#                 print(f&quot;DEBUG: Added unit {value_unit} at position {position}, flat_idx={flat_idx}&quot;)&#10;#         else:&#10;#             # No units on incoming value&#10;#             if flat_idx in self._units_dict:&#10;#                 # If the position has a unit, treat the incoming value as a magnitude in that unit&#10;#                 print(f&quot;DEBUG: Adding unitless value to position with unit {self._units_dict[flat_idx]}&quot;)&#10;#                 new_value = current_value + value&#10;#             else:&#10;#                 # Both are unitless, just add&#10;#                 new_value = current_value + value&#10;#&#10;#         # Store the result&#10;#         super().__setitem__(position, new_value)&#10;#         print(f&quot;DEBUG: Final value at position {position}: {new_value}&quot;)&#10;&#10;# def _quantity_array_str(self):&#10;#     return format_object_array(self)&#10;# QuantityArray.__str__ = _quantity_array_str&#10;#&#10;def format_object_array(arr, precision=4):&#10;    &quot;&quot;&quot;&#10;    Format a numpy array of objects (especially Pint quantities) using&#10;    each element's __str__ representation.&#10;    &quot;&quot;&quot;&#10;    if not isinstance(arr, np.ndarray):&#10;        return str(arr)&#10;&#10;    # Handle QuantityArray with stored units&#10;    if isinstance(arr, QuantityArray) and hasattr(arr, '_units_array'):&#10;        # Convert to array with reattached units first&#10;        arr = arr.with_units()&#10;&#10;    # For empty arrays&#10;    if arr.size == 0:&#10;        return &quot;[]&quot;&#10;&#10;    # For scalar arrays&#10;    if arr.ndim == 0:&#10;        return str(arr.item())&#10;&#10;    # For 1D arrays&#10;    if arr.ndim == 1:&#10;        elements = [str(x) for x in arr]&#10;        return &quot;[&quot; + &quot;, &quot;.join(elements) + &quot;]&quot;&#10;&#10;    # For 2D arrays&#10;    if arr.ndim == 2:&#10;        rows = []&#10;        for row in arr:&#10;            row_str = &quot;[&quot; + &quot;, &quot;.join(str(x) for x in row) + &quot;]&quot;&#10;            rows.append(row_str)&#10;        return &quot;[&quot; + &quot;,\n &quot;.join(rows) + &quot;]&quot;&#10;&#10;    # For higher dimensions, fall back to numpy's repr&#10;    return np.array2string(arr, formatter={'all': lambda x: str(x)})&#10;&#10;import numpy as np&#10;import pint&#10;&#10;&#10;# Replace any direct ureg usage with unit_manager.ureg&#10;Q_ = pyMAOS.unit_manager.ureg.Quantity&#10;&#10;def convert_to_unit(array_with_units, target_unit):&#10;    &quot;&quot;&quot;Convert all quantities in the array to a common unit.&#10;&#10;    Parameters&#10;    ----------&#10;    array_with_units : QuantityArray or array of pint.Quantity&#10;        Array containing quantities to convert&#10;    target_unit : str or pint.Unit&#10;        Target unit to convert all quantities to&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array with all values converted to the target unit&#10;    &quot;&quot;&quot;&#10;    if isinstance(array_with_units, np.ndarray):&#10;        # Convert to object array to handle mixed types&#10;        result = np.empty_like(array_with_units, dtype=object)&#10;&#10;        # Process each element&#10;        for idx in np.ndindex(array_with_units.shape):&#10;            value = array_with_units[idx]&#10;            if isinstance(value, pint.Quantity):&#10;                try:&#10;                    # Try to convert to target unit&#10;                    result[idx] = value.to(target_unit).magnitude&#10;                except pint.DimensionalityError:&#10;                    # If conversion not possible, keep original value&#10;                    result[idx] = value&#10;            else:&#10;                result[idx] = value&#10;&#10;        return result&#10;    else:&#10;        raise TypeError(&quot;Input must be a numpy array containing pint.Quantity objects&quot;)&#10;&#10;# def format_object_array(arr, precision=4):&#10;#     &quot;&quot;&quot;&#10;#     Format a numpy array of objects (especially Pint quantities) using&#10;#     each element's __str__ representation.&#10;#&#10;#     Parameters&#10;#     ----------&#10;#     arr : numpy.ndarray&#10;#         Array with dtype='object' containing elements with __str__ method&#10;#     precision : int, optional&#10;#         Number of decimal places for formatting numbers, by default 4&#10;#&#10;#     Returns&#10;#     -------&#10;#     str&#10;#         Formatted string representation of the array&#10;#     &quot;&quot;&quot;&#10;#     if not isinstance(arr, np.ndarray):&#10;#         return str(arr)&#10;#&#10;#     # For empty arrays&#10;#     if arr.size == 0:&#10;#         return &quot;[]&quot;&#10;#&#10;#     # For scalar arrays&#10;#     if arr.ndim == 0:&#10;#         return str(arr.item())&#10;#&#10;#     # For 1D arrays&#10;#     if arr.ndim == 1:&#10;#         elements = [str(x) for x in arr]&#10;#         return &quot;[&quot; + &quot;, &quot;.join(elements) + &quot;]&quot;&#10;#&#10;#     # For 2D arrays&#10;#     if arr.ndim == 2:&#10;#         rows = []&#10;#         for row in arr:&#10;#             row_str = &quot;[&quot; + &quot;, &quot;.join(str(x) for x in row) + &quot;]&quot;&#10;#             rows.append(row_str)&#10;#         return &quot;[&quot; + &quot;,\n &quot;.join(rows) + &quot;]&quot;&#10;#&#10;#     # For higher dimensions, fall back to numpy's repr&#10;#     return np.array2string(arr, formatter={'all': lambda x: str(x)})&#10;#&#10;# # Register the function as a method for QuantityArray&#10;# def _quantity_array_str(self):&#10;#     return format_object_array(self)&#10;#&#10;# QuantityArray.__str__ = _quantity_array_str&#10;&#10;import numpy as np&#10;import pint&#10;&#10;# def quantity_array_to_float64(quantity_array):&#10;#     &quot;&quot;&quot;&#10;#     Convert a QuantityArray or array containing pint.Quantity objects to&#10;#     a standard NumPy array of float64 values for use with linear algebra libraries.&#10;#&#10;#     Parameters&#10;#     ----------&#10;#     quantity_array : QuantityArray or array-like&#10;#         Array containing Pint Quantity objects or numeric values&#10;#&#10;#     Returns&#10;#     -------&#10;#     numpy.ndarray&#10;#         Array of float64 values with units stripped&#10;#     &quot;&quot;&quot;&#10;#     import numpy as np&#10;#&#10;#     # Fast path for arrays that are already numeric&#10;#     if np.issubdtype(quantity_array.dtype, np.number):&#10;#         print(f&quot;DEBUG: Fast path - array already has numeric dtype {quantity_array.dtype}&quot;)&#10;#         return quantity_array.astype(np.float64)&#10;#&#10;#     # For single Quantity objects&#10;#     if hasattr(quantity_array, 'magnitude'):&#10;#         print(f&quot;DEBUG: Converting single Quantity with magnitude&quot;)&#10;#         return np.float64(quantity_array.magnitude)&#10;#&#10;#     # Create output array directly using numpy&#10;#     result = np.zeros(quantity_array.shape, dtype=np.float64)&#10;#&#10;#     # Use flat iteration for efficiency&#10;#     for i, val in enumerate(quantity_array.flat):&#10;#         # Extract magnitude if it's a Quantity, otherwise use the value directly&#10;#         result.flat[i] = val.magnitude if hasattr(val, 'magnitude') else float(val)&#10;#&#10;#     print(f&quot;DEBUG: Converted array with shape {quantity_array.shape} to float64&quot;)&#10;#     return result&#10;#&#10;# # Alternative vectorized implementation for homogeneous arrays&#10;# def quantity_array_to_float64_vectorized(quantity_array):&#10;#     &quot;&quot;&quot;Vectorized version for homogeneous arrays of Quantities&quot;&quot;&quot;&#10;#     if all(isinstance(x, pint.Quantity) for x in quantity_array.flat):&#10;#         return np.vectorize(lambda x: x.magnitude)(quantity_array).astype(np.float64)&#10;#     else:&#10;#         # Fall back to element-wise approach for mixed arrays&#10;#         return quantity_array_to_float64(quantity_array)&#10;&#10;def convert_array_to_float64(input_array):&#10;    &quot;&quot;&quot;&#10;    Convert an array with mixed types or Quantity objects to a uniform float64 array.&#10;&#10;    Parameters&#10;    ----------&#10;    input_array : array-like&#10;        Array that may contain Quantity objects or other numeric types&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Converted array with dtype=float64&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # Convert to numpy array if not already&#10;    array = np.asarray(input_array)&#10;&#10;    # If already float64 array, return directly&#10;    if array.dtype == np.float64:&#10;        return array&#10;&#10;    # Create output array&#10;    result = np.empty(array.shape, dtype=np.float64)&#10;&#10;    # Process each element&#10;    for idx in np.ndindex(array.shape):&#10;        val = array[idx]&#10;&#10;        # Handle Quantity objects&#10;        if hasattr(val, 'magnitude'):&#10;            result[idx] = float(val.magnitude)&#10;        else:&#10;            # Handle other types&#10;            try:&#10;                result[idx] = float(val)&#10;            except (TypeError, ValueError):&#10;                print(f&quot;DEBUG: Cannot convert value at {idx}: {val}&quot;)&#10;                result[idx] = 0.0&#10;&#10;    print(f&quot;DEBUG: Converted array to float64: {result}&quot;)&#10;    return result&#10;&#10;def quantity_array_to_numpy(quantity_array):&#10;    &quot;&quot;&quot;&#10;    Convert a numpy array of Quantity objects to a numpy array of their&#10;    magnitude values stored as float64.&#10;&#10;    Parameters&#10;    ----------&#10;    quantity_array : numpy.ndarray&#10;        Array containing Pint Quantity objects&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array with the same shape as input but with magnitudes as float64 values&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # Fast path for arrays that are already numeric&#10;    if np.issubdtype(quantity_array.dtype, np.number):&#10;        print(f&quot;DEBUG: Array already has numeric dtype {quantity_array.dtype}, converting to float64&quot;)&#10;        return quantity_array.astype(np.float64)&#10;&#10;    # For single Quantity objects&#10;    if hasattr(quantity_array, 'magnitude'):&#10;        print(f&quot;DEBUG: Converting single Quantity with magnitude&quot;)&#10;        return np.float64(quantity_array.magnitude)&#10;&#10;    # Create output array with same shape but float64 dtype&#10;    result = np.zeros(quantity_array.shape, dtype=np.float64)&#10;&#10;    # Use flat iteration to extract magnitude values&#10;    for i, val in enumerate(quantity_array.flat):&#10;        # Extract magnitude if it's a Quantity, otherwise use value directly&#10;        result.flat[i] = val.magnitude if hasattr(val, 'magnitude') else float(val)&#10;&#10;    print(f&quot;DEBUG: Converted array with shape {quantity_array.shape} to float64&quot;)&#10;    return result&#10;&#10;def extract_units_from_quantities(quantity_array):&#10;    &quot;&quot;&quot;&#10;    Extract unit information from an array of Pint Quantity objects.&#10;&#10;    Parameters&#10;    ----------&#10;    quantity_array : numpy.ndarray&#10;        Array containing Pint Quantity objects&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array of the same shape containing only the unit information&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # Create an empty array with object dtype to store unit objects&#10;    units_array = np.empty_like(quantity_array, dtype=object)&#10;&#10;    # Iterate through all elements&#10;    for idx in np.ndindex(quantity_array.shape):&#10;        # Get the quantity at this position&#10;        quantity = quantity_array[idx]&#10;&#10;        # Extract just the unit information if it's a Quantity&#10;        if hasattr(quantity, 'units'):&#10;            units_array[idx] = quantity.units&#10;            print(f&quot;DEBUG: Found unit {quantity.units} at position {idx}&quot;)&#10;        else:&#10;            units_array[idx] = None&#10;            print(f&quot;DEBUG: No unit at position {idx}&quot;)&#10;&#10;    return units_array&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Example usage&#10;    import pint&#10;    AE_L = 1.0 * unit_manager.ureg.meter  # Example quantity in meters&#10;&#10;    # Create an instance of QuantityArray&#10;    k_with_units = np.zeros((6, 6), dtype=object).view(QuantityArray)&#10;&#10;    # Assign quantities to the array&#10;    k_with_units[0, 0] = AE_L&#10;    k_with_units[3, 3] = AE_L&#10;&#10;    # Print the array to see the magnitudes&#10;    print(2*k_with_units)&#10;&#10;    # Example usage&#10;    array_with_units = np.array([&#10;        unit_manager.ureg.Quantity(5, 'meter'),&#10;        unit_manager.ureg.Quantity(10, 'centimeter'),&#10;        unit_manager.ureg.Quantity(2, 'kilometer')&#10;    ], dtype=object)&#10;&#10;    # Convert all quantities to meters&#10;    converted_array = convert_to_unit(array_with_units, 'meter')&#10;    print(converted_array)# Create array with mixed units&#10;&#10;    qarray=array_with_units.view(QuantityArray)&#10;    print(qarray)&#10;    print(qarray.with_units())  # Should print quantities with units reattached&#10;&#10;&#10;&#10;def increment_with_units(self, addend):&#10;    &quot;&quot;&quot;&#10;    Increment a value with another value while ensuring consistent units.&#10;&#10;    If self is not a Quantity, it's promoted to a Quantity with internal units.&#10;    If addend is a Quantity, it's converted to internal units before adding.&#10;&#10;    Parameters&#10;    ----------&#10;    addend : pint.Quantity or scalar&#10;        The value to add&#10;&#10;    Returns&#10;    -------&#10;    pint.Quantity&#10;        A new Quantity with internal units, incremented by addend&#10;    &quot;&quot;&quot;&#10;    import pint&#10;    # from pyMAOS.units_mod import get_internal_unit&#10;&#10;    print(f&quot;DEBUG: Incrementing {self} with {addend}&quot;)&#10;&#10;    # If addend is not a Quantity, just do regular addition&#10;    if not isinstance(addend, pint.Quantity):&#10;        result = self + addend&#10;        print(f&quot;DEBUG: Added non-Quantity addend, result = {result}&quot;)&#10;        return result&#10;&#10;    # Determine the internal unit type based on addend's dimensionality&#10;    unit_type = None&#10;    if addend.check('[length]'):&#10;        unit_type = 'length'&#10;    elif addend.check('[force]'):&#10;        unit_type = 'force'&#10;    elif addend.check('[length] * [force]'):&#10;        unit_type = 'moment'&#10;    elif addend.check('[force] / [length]'):&#10;        unit_type = 'distributed_load'&#10;    elif addend.check('[force] / [length]^2'):&#10;        unit_type = 'pressure'&#10;&#10;    # Get the appropriate internal unit&#10;    if unit_type:&#10;        internal_unit = pyMAOS.unit_manager.get_internal_unit(unit_type)&#10;        print(f&quot;DEBUG: Using internal unit {internal_unit} for {unit_type}&quot;)&#10;    else:&#10;        # If we can't determine the unit type, use addend's units as fallback&#10;        internal_unit = addend.units&#10;        print(f&quot;DEBUG: Could not determine unit type, using addend units {internal_unit}&quot;)&#10;&#10;    # If self is not a Quantity, promote it to a Quantity with internal units&#10;    if not isinstance(self, pint.Quantity):&#10;        self = pyMAOS.unit_manager.ureg.Quantity(self, internal_unit)&#10;        print(f&quot;DEBUG: Promoted self to Quantity with internal units: {self}&quot;)&#10;&#10;    try:&#10;        # Convert addend to internal units before adding&#10;        converted_addend = addend.to(internal_unit)&#10;        print(f&quot;DEBUG: Converted addend from {addend} to {converted_addend}&quot;)&#10;&#10;        # Create result with the proper internal units&#10;        result = type(self)(self.magnitude + converted_addend.magnitude, internal_unit)&#10;        print(f&quot;DEBUG: Result after increment: {result}&quot;)&#10;&#10;        return result&#10;    except pint.DimensionalityError as e:&#10;        print(f&quot;DEBUG: Dimensionality error - {self.dimensionality}  {addend.dimensionality}&quot;)&#10;        raise e&#10;&#10;def add_arrays_with_units(array1, array2):&#10;    &quot;&quot;&quot;&#10;    Add two arrays element-wise while ensuring consistent units for each element.&#10;&#10;    For each element pair:&#10;    - Checks that dimensions agree, or one is a pure number and the other a Quantity&#10;    - Sums the magnitudes elementwise&#10;    - Converts the result to a Quantity in the internal unit system&#10;&#10;    Parameters&#10;    ----------&#10;    array1 : array-like&#10;        First array, may contain Quantity objects&#10;    array2 : array-like&#10;        Second array, may contain Quantity objects&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Result array with proper internal units for each element&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;    from pyMAOS.quantity_utils import increment_with_units&#10;&#10;    # Convert inputs to numpy arrays if they're not already&#10;    array1 = np.asarray(array1)&#10;    array2 = np.asarray(array2)&#10;&#10;    # Check that shapes are compatible&#10;    if array1.shape != array2.shape:&#10;        raise ValueError(f&quot;Arrays must have the same shape, got {array1.shape} and {array2.shape}&quot;)&#10;&#10;    # Create output array with the same shape&#10;    result = np.empty_like(array1, dtype=object)&#10;&#10;    # Process each element using the existing increment_with_units function&#10;    for idx in np.ndindex(array1.shape):&#10;        result[idx] = increment_with_units(array1[idx], array2[idx])&#10;        print(f&quot;DEBUG: Element-wise addition at {idx}: {array1[idx]} + {array2[idx]} = {result[idx]}&quot;)&#10;&#10;    return result&#10;&#10;def print_units_matrix(array):&#10;    &quot;&quot;&quot;&#10;    Print a matrix with its values and units.&#10;&#10;    This function displays the content of a numpy array containing Pint Quantity objects,&#10;    showing both the magnitude values and their corresponding units.&#10;&#10;    For elements without units, only their values are shown.&#10;&#10;    Parameters&#10;    ----------&#10;    array : numpy.ndarray&#10;        The array to print, potentially containing Pint Quantity objects&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # First, print the shape information&#10;    print(f&quot;Matrix shape: {array.shape}&quot;)&#10;&#10;    # Helper function for formatting a single value&#10;    def format_value(val):&#10;        if val is None:&#10;            return &quot;None&quot;&#10;        elif hasattr(val, 'units'):&#10;            # Format magnitude with appropriate precision&#10;            if abs(val.magnitude) &lt; 1e-10:&#10;                return f&quot;0 {val.units}&quot;&#10;            else:&#10;                return f&quot;{val.magnitude:.4g} {val.units}&quot;&#10;        else:&#10;            # Format plain numbers with appropriate precision&#10;            if isinstance(val, (int, float)) and abs(val) &lt; 1e-10:&#10;                return &quot;0&quot;&#10;            return str(val)&#10;&#10;    # Helper function for recursive printing of subarrays&#10;    def print_array(arr, indent=&quot;&quot;):&#10;        if arr.ndim == 1:&#10;            elements = [format_value(val) for val in arr]&#10;            print(indent + &quot;[&quot; + &quot;, &quot;.join(elements) + &quot;]&quot;)&#10;        elif arr.ndim == 2:&#10;            print(indent + &quot;[&quot;)&#10;            for row in arr:&#10;                print_array(row, indent + &quot;  &quot;)&#10;            print(indent + &quot;]&quot;)&#10;        else:&#10;            print(indent + f&quot;Array with {arr.ndim} dimensions:&quot;)&#10;            for i, subarray in enumerate(arr):&#10;                print(indent + f&quot;Dimension {i}:&quot;)&#10;                print_array(subarray, indent + &quot;  &quot;)&#10;&#10;    # Collect unit information for reporting&#10;    if array.size &gt; 0:&#10;        unique_units = set()&#10;        has_units = False&#10;&#10;        # Check for units in the array&#10;        for idx in np.ndindex(array.shape):&#10;            val = array[idx]&#10;            if hasattr(val, 'units'):&#10;                has_units = True&#10;                unique_units.add(str(val.units))&#10;&#10;        if has_units:&#10;            print(f&quot;DEBUG: Units found in matrix: {', '.join(sorted(unique_units))}&quot;)&#10;        else:&#10;            print(&quot;DEBUG: No units found in matrix&quot;)&#10;&#10;    # For empty arrays&#10;    if array.size == 0:&#10;        print(&quot;[]&quot;)&#10;        return&#10;&#10;    # For scalar arrays&#10;    if array.ndim == 0:&#10;        val = array.item()&#10;        print(format_value(val))&#10;        return&#10;&#10;    # Print the array&#10;    print_array(array)" />
              <option name="updatedContent" value="import numpy as np&#10;import pint&#10;import pyMAOS&#10;&#10;# Replace any direct ureg usage with unit_manager.ureg&#10;Q_ = pyMAOS.unit_manager.ureg.Quantity&#10;&#10;def convert_to_unit(array_with_units, target_unit):&#10;    &quot;&quot;&quot;Convert all quantities in the array to a common unit.&#10;&#10;    Parameters&#10;    ----------&#10;    array_with_units : array of pint.Quantity&#10;        Array containing quantities to convert&#10;    target_unit : str or pint.Unit&#10;        Target unit to convert all quantities to&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array with all values converted to the target unit&#10;    &quot;&quot;&quot;&#10;    if isinstance(array_with_units, np.ndarray):&#10;        # Convert to object array to handle mixed types&#10;        result = np.empty_like(array_with_units, dtype=object)&#10;&#10;        # Process each element&#10;        for idx in np.ndindex(array_with_units.shape):&#10;            value = array_with_units[idx]&#10;            if isinstance(value, pint.Quantity):&#10;                try:&#10;                    # Try to convert to target unit&#10;                    result[idx] = value.to(target_unit).magnitude&#10;                except pint.DimensionalityError:&#10;                    # If conversion not possible, keep original value&#10;                    result[idx] = value&#10;            else:&#10;                result[idx] = value&#10;&#10;        return result&#10;    else:&#10;        raise TypeError(&quot;Input must be a numpy array containing pint.Quantity objects&quot;)&#10;&#10;def convert_array_to_float64(input_array):&#10;    &quot;&quot;&quot;&#10;    Convert an array with mixed types or Quantity objects to a uniform float64 array.&#10;&#10;    Parameters&#10;    ----------&#10;    input_array : array-like&#10;        Array that may contain Quantity objects or other numeric types&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Converted array with dtype=float64&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # Convert to numpy array if not already&#10;    array = np.asarray(input_array)&#10;&#10;    # If already float64 array, return directly&#10;    if array.dtype == np.float64:&#10;        return array&#10;&#10;    # Create output array&#10;    result = np.empty(array.shape, dtype=np.float64)&#10;&#10;    # Process each element&#10;    for idx in np.ndindex(array.shape):&#10;        val = array[idx]&#10;&#10;        # Handle Quantity objects&#10;        if hasattr(val, 'magnitude'):&#10;            result[idx] = float(val.magnitude)&#10;        else:&#10;            # Handle other types&#10;            try:&#10;                result[idx] = float(val)&#10;            except (TypeError, ValueError):&#10;                print(f&quot;DEBUG: Cannot convert value at {idx}: {val}&quot;)&#10;                result[idx] = 0.0&#10;&#10;    print(f&quot;DEBUG: Converted array to float64: {result}&quot;)&#10;    return result&#10;&#10;def quantity_array_to_numpy(quantity_array):&#10;    &quot;&quot;&quot;&#10;    Convert a numpy array of Quantity objects to a numpy array of their&#10;    magnitude values stored as float64.&#10;&#10;    Parameters&#10;    ----------&#10;    quantity_array : numpy.ndarray&#10;        Array containing Pint Quantity objects&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array with the same shape as input but with magnitudes as float64 values&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # Fast path for arrays that are already numeric&#10;    if np.issubdtype(quantity_array.dtype, np.number):&#10;        print(f&quot;DEBUG: Array already has numeric dtype {quantity_array.dtype}, converting to float64&quot;)&#10;        return quantity_array.astype(np.float64)&#10;&#10;    # For single Quantity objects&#10;    if hasattr(quantity_array, 'magnitude'):&#10;        print(f&quot;DEBUG: Converting single Quantity with magnitude&quot;)&#10;        return np.float64(quantity_array.magnitude)&#10;&#10;    # Create output array with same shape but float64 dtype&#10;    result = np.zeros(quantity_array.shape, dtype=np.float64)&#10;&#10;    # Use flat iteration to extract magnitude values&#10;    for i, val in enumerate(quantity_array.flat):&#10;        # Extract magnitude if it's a Quantity, otherwise use value directly&#10;        result.flat[i] = val.magnitude if hasattr(val, 'magnitude') else float(val)&#10;&#10;    print(f&quot;DEBUG: Converted array with shape {quantity_array.shape} to float64&quot;)&#10;    return result&#10;&#10;def extract_units_from_quantities(quantity_array):&#10;    &quot;&quot;&quot;&#10;    Extract unit information from an array of Pint Quantity objects.&#10;&#10;    Parameters&#10;    ----------&#10;    quantity_array : numpy.ndarray&#10;        Array containing Pint Quantity objects&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array of the same shape containing only the unit information&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # Create an empty array with object dtype to store unit objects&#10;    units_array = np.empty_like(quantity_array, dtype=object)&#10;&#10;    # Iterate through all elements&#10;    for idx in np.ndindex(quantity_array.shape):&#10;        # Get the quantity at this position&#10;        quantity = quantity_array[idx]&#10;&#10;        # Extract just the unit information if it's a Quantity&#10;        if hasattr(quantity, 'units'):&#10;            units_array[idx] = quantity.units&#10;            print(f&quot;DEBUG: Found unit {quantity.units} at position {idx}&quot;)&#10;        else:&#10;            units_array[idx] = None&#10;            print(f&quot;DEBUG: No unit at position {idx}&quot;)&#10;&#10;    return units_array&#10;&#10;def increment_with_units(self, addend):&#10;    &quot;&quot;&quot;&#10;    Increment a value with another value while ensuring consistent units.&#10;&#10;    If self is not a Quantity, it's promoted to a Quantity with internal units.&#10;    If addend is a Quantity, it's converted to internal units before adding.&#10;&#10;    Parameters&#10;    ----------&#10;    addend : pint.Quantity or scalar&#10;        The value to add&#10;&#10;    Returns&#10;    -------&#10;    pint.Quantity&#10;        A new Quantity with internal units, incremented by addend&#10;    &quot;&quot;&quot;&#10;    import pint&#10;&#10;    print(f&quot;DEBUG: Incrementing {self} with {addend}&quot;)&#10;&#10;    # If addend is not a Quantity, just do regular addition&#10;    if not isinstance(addend, pint.Quantity):&#10;        result = self + addend&#10;        print(f&quot;DEBUG: Added non-Quantity addend, result = {result}&quot;)&#10;        return result&#10;&#10;    # Determine the internal unit type based on addend's dimensionality&#10;    unit_type = None&#10;    if addend.check('[length]'):&#10;        unit_type = 'length'&#10;    elif addend.check('[force]'):&#10;        unit_type = 'force'&#10;    elif addend.check('[length] * [force]'):&#10;        unit_type = 'moment'&#10;    elif addend.check('[force] / [length]'):&#10;        unit_type = 'distributed_load'&#10;    elif addend.check('[force] / [length]^2'):&#10;        unit_type = 'pressure'&#10;&#10;    # Get the appropriate internal unit&#10;    if unit_type:&#10;        internal_unit = pyMAOS.unit_manager.get_internal_unit(unit_type)&#10;        print(f&quot;DEBUG: Using internal unit {internal_unit} for {unit_type}&quot;)&#10;    else:&#10;        # If we can't determine the unit type, use addend's units as fallback&#10;        internal_unit = addend.units&#10;        print(f&quot;DEBUG: Could not determine unit type, using addend units {internal_unit}&quot;)&#10;&#10;    # If self is not a Quantity, promote it to a Quantity with internal units&#10;    if not isinstance(self, pint.Quantity):&#10;        self = pyMAOS.unit_manager.ureg.Quantity(self, internal_unit)&#10;        print(f&quot;DEBUG: Promoted self to Quantity with internal units: {self}&quot;)&#10;&#10;    try:&#10;        # Convert addend to internal units before adding&#10;        converted_addend = addend.to(internal_unit)&#10;        print(f&quot;DEBUG: Converted addend from {addend} to {converted_addend}&quot;)&#10;&#10;        # Create result with the proper internal units&#10;        result = type(self)(self.magnitude + converted_addend.magnitude, internal_unit)&#10;        print(f&quot;DEBUG: Result after increment: {result}&quot;)&#10;&#10;        return result&#10;    except pint.DimensionalityError as e:&#10;        print(f&quot;DEBUG: Dimensionality error - {self.dimensionality}  {addend.dimensionality}&quot;)&#10;        raise e&#10;&#10;def add_arrays_with_units(array1, array2):&#10;    &quot;&quot;&quot;&#10;    Add two arrays element-wise while ensuring consistent units for each element.&#10;&#10;    For each element pair:&#10;    - Checks that dimensions agree, or one is a pure number and the other a Quantity&#10;    - Sums the magnitudes elementwise&#10;    - Converts the result to a Quantity in the internal unit system&#10;&#10;    Parameters&#10;    ----------&#10;    array1 : array-like&#10;        First array, may contain Quantity objects&#10;    array2 : array-like&#10;        Second array, may contain Quantity objects&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Result array with proper internal units for each element&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;    from pyMAOS.quantity_utils import increment_with_units&#10;&#10;    # Convert inputs to numpy arrays if they're not already&#10;    array1 = np.asarray(array1)&#10;    array2 = np.asarray(array2)&#10;&#10;    # Check that shapes are compatible&#10;    if array1.shape != array2.shape:&#10;        raise ValueError(f&quot;Arrays must have the same shape, got {array1.shape} and {array2.shape}&quot;)&#10;&#10;    # Create output array with the same shape&#10;    result = np.empty_like(array1, dtype=object)&#10;&#10;    # Process each element using the existing increment_with_units function&#10;    for idx in np.ndindex(array1.shape):&#10;        result[idx] = increment_with_units(array1[idx], array2[idx])&#10;        print(f&quot;DEBUG: Element-wise addition at {idx}: {array1[idx]} + {array2[idx]} = {result[idx]}&quot;)&#10;&#10;    return result&#10;&#10;def print_units_matrix(array):&#10;    &quot;&quot;&quot;&#10;    Print a matrix with its values and units.&#10;&#10;    This function displays the content of a numpy array containing Pint Quantity objects,&#10;    showing both the magnitude values and their corresponding units.&#10;&#10;    For elements without units, only their values are shown.&#10;&#10;    Parameters&#10;    ----------&#10;    array : numpy.ndarray&#10;        The array to print, potentially containing Pint Quantity objects&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # First, print the shape information&#10;    print(f&quot;Matrix shape: {array.shape}&quot;)&#10;&#10;    # Helper function for formatting a single value&#10;    def format_value(val):&#10;        if val is None:&#10;            return &quot;None&quot;&#10;        elif hasattr(val, 'units'):&#10;            # Format magnitude with appropriate precision&#10;            if abs(val.magnitude) &lt; 1e-10:&#10;                return f&quot;0 {val.units}&quot;&#10;            else:&#10;                return f&quot;{val.magnitude:.4g} {val.units}&quot;&#10;        else:&#10;            # Format plain numbers with appropriate precision&#10;            if isinstance(val, (int, float)) and abs(val) &lt; 1e-10:&#10;                return &quot;0&quot;&#10;            return str(val)&#10;&#10;    # Helper function for recursive printing of subarrays&#10;    def print_array(arr, indent=&quot;&quot;):&#10;        if arr.ndim == 1:&#10;            elements = [format_value(val) for val in arr]&#10;            print(indent + &quot;[&quot; + &quot;, &quot;.join(elements) + &quot;]&quot;)&#10;        elif arr.ndim == 2:&#10;            print(indent + &quot;[&quot;)&#10;            for row in arr:&#10;                print_array(row, indent + &quot;  &quot;)&#10;            print(indent + &quot;]&quot;)&#10;        else:&#10;            print(indent + f&quot;Array with {arr.ndim} dimensions:&quot;)&#10;            for i, subarray in enumerate(arr):&#10;                print(indent + f&quot;Dimension {i}:&quot;)&#10;                print_array(subarray, indent + &quot;  &quot;)&#10;&#10;    # Collect unit information for reporting&#10;    if array.size &gt; 0:&#10;        unique_units = set()&#10;        has_units = False&#10;&#10;        # Check for units in the array&#10;        for idx in np.ndindex(array.shape):&#10;            val = array[idx]&#10;            if hasattr(val, 'units'):&#10;                has_units = True&#10;                unique_units.add(str(val.units))&#10;&#10;        if has_units:&#10;            print(f&quot;DEBUG: Units found in matrix: {', '.join(sorted(unique_units))}&quot;)&#10;        else:&#10;            print(&quot;DEBUG: No units found in matrix&quot;)&#10;&#10;    # For empty arrays&#10;    if array.size == 0:&#10;        print(&quot;[]&quot;)&#10;        return&#10;&#10;    # For scalar arrays&#10;    if array.ndim == 0:&#10;        val = array.item()&#10;        print(format_value(val))&#10;        return&#10;&#10;    # Print the array&#10;    print_array(array)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/structure2d_to_excel.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/structure2d_to_excel.py" />
              <option name="originalContent" value="def export_results_to_excel(self, output_file, loadcombos=None, **kwargs):&#10;    # [existing imports and initial setup]&#10;&#10;    # Process unit system&#10;    unit_system = kwargs.get('unit_system')&#10;    if unit_system:&#10;        # Import unit systems&#10;        from pyMAOS import unit_manager&#10;        from unit_manager import SI_UNITS, IMPERIAL_UNITS, METRIC_KN_UNITS, set_unit_system&#10;&#10;        # Use the specified unit system for display&#10;        if unit_system == &quot;imperial&quot;:&#10;            display_units = IMPERIAL_UNITS.copy()  # Make a copy so we can modify it&#10;            system_name = &quot;Imperial&quot;&#10;            # Add distance unit (feet) for node positions specifically in imperial units&#10;            display_units['distance'] = 'ft'&#10;        elif unit_system == &quot;si&quot;:&#10;            display_units = SI_UNITS&#10;            system_name = &quot;SI&quot;&#10;            # Use same unit for distance as length in SI&#10;            display_units['distance'] = display_units['length']&#10;        elif unit_system == &quot;metric_kn&quot;:&#10;            display_units = METRIC_KN_UNITS&#10;            system_name = &quot;Metric kN&quot;&#10;            # Use same unit for distance as length in metric_kn&#10;            display_units['distance'] = display_units['length']&#10;        else:&#10;            display_units = self.units.copy()&#10;            # Default to using length unit for distance if not specified&#10;            if 'distance' not in display_units:&#10;                display_units['distance'] = display_units['length']&#10;            system_name = &quot;Current&quot;&#10;    else:&#10;        display_units = self.units.copy()&#10;        # Default to using length unit for distance if not specified&#10;        if 'distance' not in display_units:&#10;            display_units['distance'] = display_units['length']&#10;        system_name = &quot;Current&quot;&#10;&#10;    print(f&quot;Using {system_name} units for Excel export&quot;)&#10;&#10;    def convert_value(value, from_unit, to_unit):&#10;        &quot;&quot;&quot;Convert a value from one unit to another&quot;&quot;&quot;&#10;        try:&#10;            # Handle special case for dimensionless units like radians&#10;            if to_unit in ['rad', 'radian', 'radians']:&#10;                return value&#10;&#10;            # Convert using pint&#10;            return Q_(value, from_unit).to(to_unit).magnitude&#10;        except Exception as e:&#10;            print(f&quot;Warning: Could not convert {value} from {from_unit} to {to_unit}: {e}&quot;)&#10;            return value&#10;&#10;    # Resolve output file path&#10;    output_file = Path(output_file)&#10;&#10;    # Get list of all load combinations that have been analyzed&#10;    if loadcombos is None:&#10;        # Find all unique load combos that have results&#10;        all_combos = set()&#10;        for node in self.nodes:&#10;            if hasattr(node, 'displacements'):&#10;                all_combos.update(node.displacements.keys())&#10;        from pyMAOS.loadcombos import LoadCombo&#10;        loadcombos = [LoadCombo(name, {name: 1.0}, [name], False, &quot;CUSTOM&quot;) for name in all_combos]&#10;&#10;    if not loadcombos:&#10;        raise ValueError(&quot;No load combinations specified and no analysis results found.&quot;)&#10;&#10;    # Extract options&#10;    include_visualization = kwargs.get('include_visualization', True)&#10;&#10;    print(f&quot;Exporting analysis results to {output_file}...&quot;)&#10;&#10;    # Create Excel writer&#10;    with pd.ExcelWriter(output_file, engine='xlsxwriter') as writer:&#10;        workbook = writer.book&#10;&#10;        # Create formats&#10;        try:&#10;            header_format = workbook.add_format({&#10;                'bold': True,&#10;                'text_wrap': True,&#10;                'valign': 'top',&#10;                'fg_color': '#D7E4BC',&#10;                'border': 1&#10;            })&#10;        except AttributeError:&#10;            header_format = None&#10;&#10;        # 1. Summary sheet&#10;        summary_data = {&#10;            'Parameter': ['Number of Nodes', 'Number of Members', 'Degrees of Freedom',&#10;                          'Number of Restraints', 'Analysis Type'],&#10;            'Value': [self.NJ, self.NM, self.NDOF, self.NR, 'Linear Static']&#10;        }&#10;        # Add load combinations to summary&#10;        for i, combo in enumerate(loadcombos):&#10;            summary_data['Parameter'].append(f&quot;Load Combination {i + 1}&quot;)&#10;            summary_data['Value'].append(combo.name)&#10;&#10;        summary_df = pd.DataFrame(summary_data)&#10;        summary_df.to_excel(writer, sheet_name='Summary', index=False)&#10;&#10;        # 2. Structure visualization (if requested)&#10;        # Modify _export_results_to_excel to convert coordinates for plotting&#10;        if include_visualization:&#10;            try:&#10;                from pyMAOS.structure2d_plot_with_matplotlib import plot_structure_matplotlib&#10;&#10;                # Create temporary lists of nodes with converted coordinates for plotting&#10;                class TempNode:&#10;                    def __init__(self, uid, x, y):&#10;                        self.uid = uid&#10;                        self.x = x&#10;                        self.y = y&#10;&#10;                # Convert node coordinates to display units&#10;                temp_nodes = []&#10;                for node in self.nodes:&#10;                    # Convert from meters to the display unit (e.g., inches or feet)&#10;                    x_display = convert_value(node.x, 'm', display_units['distance'])&#10;                    y_display = convert_value(node.y, 'm', display_units['distance'])&#10;                    temp_nodes.append(TempNode(node.uid, x_display, y_display))&#10;&#10;                # Create temporary members with converted nodes&#10;                class TempMember:&#10;                    def __init__(self, uid, inode, jnode, member_type, hinges=None):&#10;                        self.uid = uid&#10;                        self.inode = inode&#10;                        self.jnode = jnode&#10;                        self.type = member_type&#10;                        self.hinges = hinges&#10;&#10;                temp_members = []&#10;                for member in self.members:&#10;                    # Find the converted i and j nodes&#10;                    i_node = next(n for n in temp_nodes if n.uid == member.inode.uid)&#10;                    j_node = next(n for n in temp_nodes if n.uid == member.jnode.uid)&#10;&#10;                    # Create temporary member with hinges if applicable&#10;                    hinges = member.hinges if hasattr(member, 'hinges') else None&#10;                    temp_members.append(TempMember(member.uid, i_node, j_node, member.type, hinges))&#10;&#10;                # Use the existing plot function with converted coordinates&#10;                fig, ax = plot_structure_matplotlib(temp_nodes, temp_members)&#10;&#10;                # Add units to axis labels&#10;                ax.set_xlabel(f'X ({display_units[&quot;distance&quot;]})')&#10;                ax.set_ylabel(f'Y ({display_units[&quot;distance&quot;]})')&#10;                ax.set_title(f'Structure Plot ({system_name} Units)')&#10;&#10;                # Add visualization to Excel&#10;                worksheet = workbook.add_worksheet('Structure Visualization')&#10;&#10;                # Save the figure to a BytesIO object&#10;                imgdata = io.BytesIO()&#10;                fig.savefig(imgdata, format='png', dpi=150, bbox_inches='tight')&#10;                imgdata.seek(0)&#10;&#10;                # Insert the image into the worksheet&#10;                worksheet.insert_image('A1', 'structure.png',&#10;                                      {'image_data': imgdata, 'x_scale': 0.8, 'y_scale': 0.8})&#10;&#10;                # Close the matplotlib figure to free memory&#10;                plt.close(fig)&#10;                print(f&quot;Added structure visualization in {system_name} units&quot;)&#10;&#10;            except (ImportError, AttributeError) as e:&#10;                print(f&quot;Warning: Could not create structure visualization: {e}&quot;)&#10;&#10;        # 3. Units sheet&#10;        units_data = []&#10;        for dimension, unit in display_units.items():&#10;            units_data.append({'Dimension': dimension, 'Unit': unit})&#10;        units_df = pd.DataFrame(units_data)&#10;        units_df.to_excel(writer, sheet_name='Units', index=False)&#10;&#10;    # Process each load combination&#10;    for combo in loadcombos:&#10;        combo_name = combo.name&#10;        sheet_name = f&quot;Results_{combo_name}&quot;[:31]  # Excel sheet name limit is 31 chars&#10;&#10;        # 4. Node information sheet for this load combination&#10;        nodes_data = []&#10;        for node in sorted(self.nodes, key=lambda n: n.uid):&#10;            # Convert coordinates to display units - using 'distance' (feet) instead of 'length'&#10;            x_display = convert_value(node.x, 'm', display_units['distance'])&#10;            y_display = convert_value(node.y, 'm', display_units['distance'])&#10;&#10;            node_info = {&#10;                'Node ID': node.uid,&#10;                f'X ({display_units[&quot;distance&quot;]})': x_display,&#10;                f'Y ({display_units[&quot;distance&quot;]})': y_display,&#10;                # [rest of node info code remains the same]&#10;            }&#10;&#10;            # [keep existing code for displacements and reactions]&#10;&#10;            nodes_data.append(node_info)&#10;&#10;        nodes_df = pd.DataFrame(nodes_data)&#10;        nodes_df.to_excel(writer, sheet_name=sheet_name, index=False)&#10;&#10;        # Create member forces sheet&#10;        _export_member_forces(self, writer, combo, combo_name, display_units, convert_value)&#10;&#10;        # Add fixed end forces sheet for this load combo&#10;        _export_fixed_end_forces(self, writer, combo, combo_name, display_units, convert_value)&#10;&#10;    # Add a member properties sheet (common to all load combos)&#10;    _export_member_properties(self, writer, display_units, convert_value)&#10;&#10;    print(f&quot;Successfully exported results to {output_file}&quot;)&#10;    return str(output_file)&#10;&#10;def _export_fixed_end_forces(structure, writer, combo, combo_name, display_units, convert_value):&#10;    &quot;&quot;&quot;Helper function to export fixed end forces to Excel&quot;&quot;&quot;&#10;    import numpy as np&#10;    import pandas as pd&#10;&#10;    fef_data = []&#10;    for member in sorted(structure.members, key=lambda m: m.uid):&#10;        # Get fixed end forces if available&#10;        if hasattr(member, 'fixed_end_forces') and combo_name in member.fixed_end_forces:&#10;            fef = member.fixed_end_forces[combo_name]&#10;&#10;            # Convert forces to display units&#10;            fef_display = [&#10;                convert_value(fef[0], 'N', display_units['force']),     # i-node Fx&#10;                convert_value(fef[1], 'N', display_units['force']),     # i-node Fy&#10;                convert_value(fef[2], 'N*m', display_units['moment']),  # i-node Mz&#10;                convert_value(fef[3], 'N', display_units['force']),     # j-node Fx&#10;                convert_value(fef[4], 'N', display_units['force']),     # j-node Fy&#10;                convert_value(fef[5], 'N*m', display_units['moment'])   # j-node Mz&#10;            ]&#10;&#10;            # i-node fixed end forces&#10;            fef_data.append({&#10;                'Member ID': member.uid,&#10;                'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;                f'Fx ({display_units[&quot;force&quot;]})': fef_display[0],&#10;                f'Fy ({display_units[&quot;force&quot;]})': fef_display[1],&#10;                f'Mz ({display_units[&quot;moment&quot;]})': fef_display[2]&#10;            })&#10;&#10;            # j-node fixed end forces&#10;            fef_data.append({&#10;                'Member ID': member.uid,&#10;                'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;                f'Fx ({display_units[&quot;force&quot;]})': fef_display[3],&#10;                f'Fy ({display_units[&quot;force&quot;]})': fef_display[4],&#10;                f'Mz ({display_units[&quot;moment&quot;]})': fef_display[5]&#10;            })&#10;        else:&#10;            # If no fixed end forces, add zeros&#10;            fef_data.append({&#10;                'Member ID': member.uid,&#10;                'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;                f'Fx ({display_units[&quot;force&quot;]})': 0.0,&#10;                f'Fy ({display_units[&quot;force&quot;]})': 0.0,&#10;                f'Mz ({display_units[&quot;moment&quot;]})': 0.0&#10;            })&#10;&#10;            fef_data.append({&#10;                'Member ID': member.uid,&#10;                'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;                f'Fx ({display_units[&quot;force&quot;]})': 0.0,&#10;                f'Fy ({display_units[&quot;force&quot;]})': 0.0,&#10;                f'Mz ({display_units[&quot;moment&quot;]})': 0.0&#10;            })&#10;&#10;    # Write fixed end forces to a separate sheet for this load combo&#10;    if fef_data:&#10;        fef_df = pd.DataFrame(fef_data)&#10;        sheet_name = f&quot;FixedEndForces_{combo_name}&quot;[:31]  # Excel sheet name limit is 31 chars&#10;        fef_df.to_excel(writer, sheet_name=sheet_name, index=False)&#10;        print(f&quot;Added Fixed End Forces sheet for {combo_name}&quot;)&#10;&#10;def _export_member_forces(structure, writer, combo, combo_name, display_units, convert_value):&#10;    &quot;&quot;&quot;Helper function to export member forces to Excel&quot;&quot;&quot;&#10;    import numpy as np&#10;    import pandas as pd&#10;    &#10;    forces_data = []&#10;    for member in sorted(structure.members, key=lambda m: m.uid):&#10;        # Get forces&#10;        global_forces, local_forces = _get_member_forces(member, combo, combo_name)&#10;        &#10;        # Convert forces to display units&#10;        global_forces_display = [&#10;            convert_value(global_forces[0], 'N', display_units['force']),&#10;            convert_value(global_forces[1], 'N', display_units['force']),&#10;            convert_value(global_forces[2], 'N*m', display_units['moment']),&#10;            convert_value(global_forces[3], 'N', display_units['force']),&#10;            convert_value(global_forces[4], 'N', display_units['force']),&#10;            convert_value(global_forces[5], 'N*m', display_units['moment'])&#10;        ]&#10;        &#10;        local_forces_display = [&#10;            convert_value(local_forces[0], 'N', display_units['force']),&#10;            convert_value(local_forces[1], 'N', display_units['force']),&#10;            convert_value(local_forces[2], 'N*m', display_units['moment']),&#10;            convert_value(local_forces[3], 'N', display_units['force']),&#10;            convert_value(local_forces[4], 'N', display_units['force']),&#10;            convert_value(local_forces[5], 'N*m', display_units['moment'])&#10;        ]&#10;        &#10;        # i-node forces&#10;        forces_data.append({&#10;            'Member ID': member.uid,&#10;            'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;            'System': 'Global',&#10;            f'Fx ({display_units[&quot;force&quot;]})': global_forces_display[0],&#10;            f'Fy ({display_units[&quot;force&quot;]})': global_forces_display[1],&#10;            f'Mz ({display_units[&quot;moment&quot;]})': global_forces_display[2]&#10;        })&#10;        forces_data.append({&#10;            'Member ID': member.uid,&#10;            'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;&#10;            'System': 'Local',&#10;            f'Fx ({display_units[&quot;force&quot;]})': local_forces_display[0],&#10;            f'Fy ({display_units[&quot;force&quot;]})': local_forces_display[1],&#10;            f'Mz ({display_units[&quot;moment&quot;]})': local_forces_display[2],&#10;        })&#10;        &#10;        # j-node forces&#10;        forces_data.append({&#10;            'Member ID': member.uid,&#10;            'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;            'System': 'Global',&#10;            f'Fx ({display_units[&quot;force&quot;]})': global_forces_display[3],&#10;            f'Fy ({display_units[&quot;force&quot;]})': global_forces_display[4],&#10;            f'Mz ({display_units[&quot;moment&quot;]})': global_forces_display[5]&#10;        })&#10;        forces_data.append({&#10;            'Member ID': member.uid,&#10;            'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;&#10;            'System': 'Local',&#10;            f'Fx ({display_units[&quot;force&quot;]})': local_forces_display[3],&#10;            f'Fy ({display_units[&quot;force&quot;]})': local_forces_display[4],&#10;            f'Mz ({display_units[&quot;moment&quot;]})': local_forces_display[5],&#10;        })&#10;        &#10;    # Write member forces to a separate sheet for this load combo&#10;    forces_df = pd.DataFrame(forces_data)&#10;    sheet_name = f&quot;Forces_{combo_name}&quot;[:31]  # Excel sheet name limit is 31 chars&#10;    forces_df.to_excel(writer, sheet_name=sheet_name, index=False)&#10;&#10;def _export_member_properties(structure, writer, display_units, convert_value):&#10;    &quot;&quot;&quot;Helper function to export member properties to Excel&quot;&quot;&quot;&#10;    import pandas as pd&#10;    &#10;    members_data = []&#10;    for member in sorted(structure.members, key=lambda m: m.uid):&#10;        # Convert member properties to display units&#10;        length_display = convert_value(member.length, 'm', display_units['length'])&#10;        e_display = convert_value(member.material.E, 'Pa', display_units['pressure'])&#10;        area_display = convert_value(member.section.Area, 'm^2', f&quot;{display_units['length']}^2&quot;)&#10;        ixx_display = convert_value(member.section.Ixx, 'm^4', f&quot;{display_units['length']}^4&quot;)&#10;        &#10;        member_info = {&#10;            'Member ID': member.uid,&#10;            'Type': member.type,&#10;            'i-node': member.inode.uid,&#10;            'j-node': member.jnode.uid,&#10;            f'Length ({display_units[&quot;length&quot;]})': length_display,&#10;            'Material ID': member.material.uid,&#10;            f'E ({display_units[&quot;pressure&quot;]})': e_display,&#10;            'Section ID': member.section.uid,&#10;            f'Area ({display_units[&quot;length&quot;]})': area_display,&#10;            f'Ixx ({display_units[&quot;length&quot;]})': ixx_display,&#10;        }&#10;        &#10;        # Add hinge information if it's a frame&#10;        if hasattr(member, 'hinges'):&#10;            hinge_info = []&#10;            if member.hinges[0]:&#10;                hinge_info.append('i-node')&#10;            if member.hinges[1]:&#10;                hinge_info.append('j-node')&#10;            member_info['Hinges'] = ', '.join(hinge_info) if hinge_info else 'None'&#10;        &#10;        members_data.append(member_info)&#10;    &#10;    members_df = pd.DataFrame(members_data)&#10;    members_df.to_excel(writer, sheet_name='Member Properties', index=False)&#10;&#10;def _get_member_forces(member, combo, combo_name):&#10;    &quot;&quot;&quot;Helper function to get member forces in both global and local coordinates&quot;&quot;&quot;&#10;    import numpy as np&#10;    &#10;    # Calculate member forces for this load combination&#10;    if hasattr(member, 'end_forces_global') and combo_name in member.end_forces_global:&#10;        global_forces = np.asarray(member.end_forces_global[combo_name]).flatten()&#10;    else:&#10;        # Calculate forces if not already available&#10;        try:&#10;            global_forces = np.asarray(member.set_end_forces_global(combo)).flatten()&#10;        except:&#10;            global_forces = np.zeros(6)&#10;    &#10;    if hasattr(member, 'end_forces_local') and combo_name in member.end_forces_local:&#10;        local_forces = np.asarray(member.end_forces_local[combo_name]).flatten()&#10;    else:&#10;        try:&#10;            member.Flocal(combo)&#10;            local_forces = np.asarray(member.end_forces_local[combo_name]).flatten()&#10;        except:&#10;            local_forces = np.zeros(6)&#10;    &#10;    return global_forces, local_forces&#10;" />
              <option name="updatedContent" value="def export_results_to_excel(self, output_file, loadcombos=None, **kwargs):&#10;    # [existing imports and initial setup]&#10;&#10;    # Process unit system&#10;    unit_system = kwargs.get('unit_system')&#10;    if unit_system:&#10;        # Import unit systems&#10;        from pyMAOS import unit_manager&#10;        from unit_manager import SI_UNITS, IMPERIAL_UNITS, METRIC_KN_UNITS, set_unit_system&#10;&#10;        # Use the specified unit system for display&#10;        if unit_system == &quot;imperial&quot;:&#10;            display_units = IMPERIAL_UNITS.copy()  # Make a copy so we can modify it&#10;            system_name = &quot;Imperial&quot;&#10;            # Add distance unit (feet) for node positions specifically in imperial units&#10;            display_units['distance'] = 'ft'&#10;        elif unit_system == &quot;si&quot;:&#10;            display_units = SI_UNITS&#10;            system_name = &quot;SI&quot;&#10;            # Use same unit for distance as length in SI&#10;            display_units['distance'] = display_units['length']&#10;        elif unit_system == &quot;metric_kn&quot;:&#10;            display_units = METRIC_KN_UNITS&#10;            system_name = &quot;Metric kN&quot;&#10;            # Use same unit for distance as length in metric_kn&#10;            display_units['distance'] = display_units['length']&#10;        else:&#10;            display_units = self.units.copy()&#10;            # Default to using length unit for distance if not specified&#10;            if 'distance' not in display_units:&#10;                display_units['distance'] = display_units['length']&#10;            system_name = &quot;Current&quot;&#10;    else:&#10;        display_units = self.units.copy()&#10;        # Default to using length unit for distance if not specified&#10;        if 'distance' not in display_units:&#10;            display_units['distance'] = display_units['length']&#10;        system_name = &quot;Current&quot;&#10;&#10;    print(f&quot;Using {system_name} units for Excel export&quot;)&#10;&#10;    def convert_value(value, from_unit, to_unit):&#10;        &quot;&quot;&quot;Convert a value from one unit to another&quot;&quot;&quot;&#10;        try:&#10;            # Handle special case for dimensionless units like radians&#10;            if to_unit in ['rad', 'radian', 'radians']:&#10;                return value&#10;&#10;            # Convert using pint&#10;            return Q_(value, from_unit).to(to_unit).magnitude&#10;        except Exception as e:&#10;            print(f&quot;Warning: Could not convert {value} from {from_unit} to {to_unit}: {e}&quot;)&#10;            return value&#10;&#10;    # Resolve output file path&#10;    output_file = Path(output_file)&#10;&#10;    # Get list of all load combinations that have been analyzed&#10;    if loadcombos is None:&#10;        # Find all unique load combos that have results&#10;        all_combos = set()&#10;        for node in self.nodes:&#10;            if hasattr(node, 'displacements'):&#10;                all_combos.update(node.displacements.keys())&#10;        from pyMAOS.loadcombos import LoadCombo&#10;        loadcombos = [LoadCombo(name, {name: 1.0}, [name], False, &quot;CUSTOM&quot;) for name in all_combos]&#10;&#10;    if not loadcombos:&#10;        raise ValueError(&quot;No load combinations specified and no analysis results found.&quot;)&#10;&#10;    # Extract options&#10;    include_visualization = kwargs.get('include_visualization', True)&#10;&#10;    print(f&quot;Exporting analysis results to {output_file}...&quot;)&#10;&#10;    # Create Excel writer&#10;    with pd.ExcelWriter(output_file, engine='xlsxwriter') as writer:&#10;        workbook = writer.book&#10;&#10;        # Create formats&#10;        try:&#10;            header_format = workbook.add_format({&#10;                'bold': True,&#10;                'text_wrap': True,&#10;                'valign': 'top',&#10;                'fg_color': '#D7E4BC',&#10;                'border': 1&#10;            })&#10;        except AttributeError:&#10;            header_format = None&#10;&#10;        # 1. Summary sheet&#10;        summary_data = {&#10;            'Parameter': ['Number of Nodes', 'Number of Members', 'Degrees of Freedom',&#10;                          'Number of Restraints', 'Analysis Type'],&#10;            'Value': [self.NJ, self.NM, self.NDOF, self.NR, 'Linear Static']&#10;        }&#10;        # Add load combinations to summary&#10;        for i, combo in enumerate(loadcombos):&#10;            summary_data['Parameter'].append(f&quot;Load Combination {i + 1}&quot;)&#10;            summary_data['Value'].append(combo.name)&#10;&#10;        summary_df = pd.DataFrame(summary_data)&#10;        summary_df.to_excel(writer, sheet_name='Summary', index=False)&#10;&#10;        # 2. Structure visualization (if requested)&#10;        # Modify _export_results_to_excel to convert coordinates for plotting&#10;        if include_visualization:&#10;            try:&#10;                from pyMAOS.structure2d_plot_with_matplotlib import plot_structure_matplotlib&#10;&#10;                # Create temporary lists of nodes with converted coordinates for plotting&#10;                class TempNode:&#10;                    def __init__(self, uid, x, y):&#10;                        self.uid = uid&#10;                        self.x = x&#10;                        self.y = y&#10;&#10;                # Convert node coordinates to display units&#10;                temp_nodes = []&#10;                for node in self.nodes:&#10;                    # Convert from meters to the display unit (e.g., inches or feet)&#10;                    x_display = convert_value(node.x, 'm', display_units['distance'])&#10;                    y_display = convert_value(node.y, 'm', display_units['distance'])&#10;                    temp_nodes.append(TempNode(node.uid, x_display, y_display))&#10;&#10;                # Create temporary members with converted nodes&#10;                class TempMember:&#10;                    def __init__(self, uid, inode, jnode, member_type, hinges=None):&#10;                        self.uid = uid&#10;                        self.inode = inode&#10;                        self.jnode = jnode&#10;                        self.type = member_type&#10;                        self.hinges = hinges&#10;&#10;                temp_members = []&#10;                for member in self.members:&#10;                    # Find the converted i and j nodes&#10;                    i_node = next(n for n in temp_nodes if n.uid == member.inode.uid)&#10;                    j_node = next(n for n in temp_nodes if n.uid == member.jnode.uid)&#10;&#10;                    # Create temporary member with hinges if applicable&#10;                    hinges = member.hinges if hasattr(member, 'hinges') else None&#10;                    temp_members.append(TempMember(member.uid, i_node, j_node, member.type, hinges))&#10;&#10;                # Use the existing plot function with converted coordinates&#10;                fig, ax = plot_structure_matplotlib(temp_nodes, temp_members)&#10;&#10;                # Add units to axis labels&#10;                ax.set_xlabel(f'X ({display_units[&quot;distance&quot;]})')&#10;                ax.set_ylabel(f'Y ({display_units[&quot;distance&quot;]})')&#10;                ax.set_title(f'Structure Plot ({system_name} Units)')&#10;&#10;                # Add visualization to Excel&#10;                worksheet = workbook.add_worksheet('Structure Visualization')&#10;&#10;                # Save the figure to a BytesIO object&#10;                imgdata = io.BytesIO()&#10;                fig.savefig(imgdata, format='png', dpi=150, bbox_inches='tight')&#10;                imgdata.seek(0)&#10;&#10;                # Insert the image into the worksheet&#10;                worksheet.insert_image('A1', 'structure.png',&#10;                                      {'image_data': imgdata, 'x_scale': 0.8, 'y_scale': 0.8})&#10;&#10;                # Close the matplotlib figure to free memory&#10;                plt.close(fig)&#10;                print(f&quot;Added structure visualization in {system_name} units&quot;)&#10;&#10;            except (ImportError, AttributeError) as e:&#10;                print(f&quot;Warning: Could not create structure visualization: {e}&quot;)&#10;&#10;        # 3. Units sheet&#10;        units_data = []&#10;        for dimension, unit in display_units.items():&#10;            units_data.append({'Dimension': dimension, 'Unit': unit})&#10;        units_df = pd.DataFrame(units_data)&#10;        units_df.to_excel(writer, sheet_name='Units', index=False)&#10;&#10;        # Process each load combination&#10;        for combo in loadcombos:&#10;            combo_name = combo.name&#10;            sheet_name = f&quot;Results_{combo_name}&quot;[:31]  # Excel sheet name limit is 31 chars&#10;&#10;            # 4. Node information sheet for this load combination&#10;            nodes_data = []&#10;            for node in sorted(self.nodes, key=lambda n: n.uid):&#10;                # Convert coordinates to display units - using 'distance' (feet) instead of 'length'&#10;                x_display = convert_value(node.x, 'm', display_units['distance'])&#10;                y_display = convert_value(node.y, 'm', display_units['distance'])&#10;&#10;                node_info = {&#10;                    'Node ID': node.uid,&#10;                    f'X ({display_units[&quot;distance&quot;]})': x_display,&#10;                    f'Y ({display_units[&quot;distance&quot;]})': y_display,&#10;                    # [rest of node info code remains the same]&#10;                }&#10;&#10;                # [keep existing code for displacements and reactions]&#10;&#10;                nodes_data.append(node_info)&#10;&#10;            nodes_df = pd.DataFrame(nodes_data)&#10;            nodes_df.to_excel(writer, sheet_name=sheet_name, index=False)&#10;&#10;            # Create member forces sheet&#10;            _export_member_forces(self, writer, combo, combo_name, display_units, convert_value)&#10;&#10;            # Add fixed end forces sheet for this load combo&#10;            _export_fixed_end_forces(self, writer, combo, combo_name, display_units, convert_value)&#10;&#10;        # Add a member properties sheet (common to all load combos)&#10;        _export_member_properties(self, writer, display_units, convert_value)&#10;&#10;    print(f&quot;Successfully exported results to {output_file}&quot;)&#10;    return str(output_file)&#10;&#10;def _export_fixed_end_forces(structure, writer, combo, combo_name, display_units, convert_value):&#10;    &quot;&quot;&quot;Helper function to export fixed end forces to Excel&quot;&quot;&quot;&#10;    import numpy as np&#10;    import pandas as pd&#10;&#10;    fef_data = []&#10;    for member in sorted(structure.members, key=lambda m: m.uid):&#10;        # Get fixed end forces if available&#10;        if hasattr(member, 'fixed_end_forces') and combo_name in member.fixed_end_forces:&#10;            fef = member.fixed_end_forces[combo_name]&#10;&#10;            # Convert forces to display units&#10;            fef_display = [&#10;                convert_value(fef[0], 'N', display_units['force']),     # i-node Fx&#10;                convert_value(fef[1], 'N', display_units['force']),     # i-node Fy&#10;                convert_value(fef[2], 'N*m', display_units['moment']),  # i-node Mz&#10;                convert_value(fef[3], 'N', display_units['force']),     # j-node Fx&#10;                convert_value(fef[4], 'N', display_units['force']),     # j-node Fy&#10;                convert_value(fef[5], 'N*m', display_units['moment'])   # j-node Mz&#10;            ]&#10;&#10;            # i-node fixed end forces&#10;            fef_data.append({&#10;                'Member ID': member.uid,&#10;                'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;                f'Fx ({display_units[&quot;force&quot;]})': fef_display[0],&#10;                f'Fy ({display_units[&quot;force&quot;]})': fef_display[1],&#10;                f'Mz ({display_units[&quot;moment&quot;]})': fef_display[2]&#10;            })&#10;&#10;            # j-node fixed end forces&#10;            fef_data.append({&#10;                'Member ID': member.uid,&#10;                'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;                f'Fx ({display_units[&quot;force&quot;]})': fef_display[3],&#10;                f'Fy ({display_units[&quot;force&quot;]})': fef_display[4],&#10;                f'Mz ({display_units[&quot;moment&quot;]})': fef_display[5]&#10;            })&#10;        else:&#10;            # If no fixed end forces, add zeros&#10;            fef_data.append({&#10;                'Member ID': member.uid,&#10;                'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;                f'Fx ({display_units[&quot;force&quot;]})': 0.0,&#10;                f'Fy ({display_units[&quot;force&quot;]})': 0.0,&#10;                f'Mz ({display_units[&quot;moment&quot;]})': 0.0&#10;            })&#10;&#10;            fef_data.append({&#10;                'Member ID': member.uid,&#10;                'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;                f'Fx ({display_units[&quot;force&quot;]})': 0.0,&#10;                f'Fy ({display_units[&quot;force&quot;]})': 0.0,&#10;                f'Mz ({display_units[&quot;moment&quot;]})': 0.0&#10;            })&#10;&#10;    # Write fixed end forces to a separate sheet for this load combo&#10;    if fef_data:&#10;        fef_df = pd.DataFrame(fef_data)&#10;        sheet_name = f&quot;FixedEndForces_{combo_name}&quot;[:31]  # Excel sheet name limit is 31 chars&#10;        fef_df.to_excel(writer, sheet_name=sheet_name, index=False)&#10;        print(f&quot;Added Fixed End Forces sheet for {combo_name}&quot;)&#10;&#10;def _export_member_forces(structure, writer, combo, combo_name, display_units, convert_value):&#10;    &quot;&quot;&quot;Helper function to export member forces to Excel&quot;&quot;&quot;&#10;    import numpy as np&#10;    import pandas as pd&#10;    &#10;    forces_data = []&#10;    for member in sorted(structure.members, key=lambda m: m.uid):&#10;        # Get forces&#10;        global_forces, local_forces = _get_member_forces(member, combo, combo_name)&#10;        &#10;        # Convert forces to display units&#10;        global_forces_display = [&#10;            convert_value(global_forces[0], 'N', display_units['force']),&#10;            convert_value(global_forces[1], 'N', display_units['force']),&#10;            convert_value(global_forces[2], 'N*m', display_units['moment']),&#10;            convert_value(global_forces[3], 'N', display_units['force']),&#10;            convert_value(global_forces[4], 'N', display_units['force']),&#10;            convert_value(global_forces[5], 'N*m', display_units['moment'])&#10;        ]&#10;        &#10;        local_forces_display = [&#10;            convert_value(local_forces[0], 'N', display_units['force']),&#10;            convert_value(local_forces[1], 'N', display_units['force']),&#10;            convert_value(local_forces[2], 'N*m', display_units['moment']),&#10;            convert_value(local_forces[3], 'N', display_units['force']),&#10;            convert_value(local_forces[4], 'N', display_units['force']),&#10;            convert_value(local_forces[5], 'N*m', display_units['moment'])&#10;        ]&#10;        &#10;        # i-node forces&#10;        forces_data.append({&#10;            'Member ID': member.uid,&#10;            'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;            'System': 'Global',&#10;            f'Fx ({display_units[&quot;force&quot;]})': global_forces_display[0],&#10;            f'Fy ({display_units[&quot;force&quot;]})': global_forces_display[1],&#10;            f'Mz ({display_units[&quot;moment&quot;]})': global_forces_display[2]&#10;        })&#10;        forces_data.append({&#10;            'Member ID': member.uid,&#10;            'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;&#10;            'System': 'Local',&#10;            f'Fx ({display_units[&quot;force&quot;]})': local_forces_display[0],&#10;            f'Fy ({display_units[&quot;force&quot;]})': local_forces_display[1],&#10;            f'Mz ({display_units[&quot;moment&quot;]})': local_forces_display[2],&#10;        })&#10;        &#10;        # j-node forces&#10;        forces_data.append({&#10;            'Member ID': member.uid,&#10;            'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;            'System': 'Global',&#10;            f'Fx ({display_units[&quot;force&quot;]})': global_forces_display[3],&#10;            f'Fy ({display_units[&quot;force&quot;]})': global_forces_display[4],&#10;            f'Mz ({display_units[&quot;moment&quot;]})': global_forces_display[5]&#10;        })&#10;        forces_data.append({&#10;            'Member ID': member.uid,&#10;            'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;&#10;            'System': 'Local',&#10;            f'Fx ({display_units[&quot;force&quot;]})': local_forces_display[3],&#10;            f'Fy ({display_units[&quot;force&quot;]})': local_forces_display[4],&#10;            f'Mz ({display_units[&quot;moment&quot;]})': local_forces_display[5],&#10;        })&#10;        &#10;    # Write member forces to a separate sheet for this load combo&#10;    forces_df = pd.DataFrame(forces_data)&#10;    sheet_name = f&quot;Forces_{combo_name}&quot;[:31]  # Excel sheet name limit is 31 chars&#10;    forces_df.to_excel(writer, sheet_name=sheet_name, index=False)&#10;&#10;def _export_member_properties(structure, writer, display_units, convert_value):&#10;    &quot;&quot;&quot;Helper function to export member properties to Excel&quot;&quot;&quot;&#10;    import pandas as pd&#10;    &#10;    members_data = []&#10;    for member in sorted(structure.members, key=lambda m: m.uid):&#10;        # Convert member properties to display units&#10;        length_display = convert_value(member.length, 'm', display_units['length'])&#10;        e_display = convert_value(member.material.E, 'Pa', display_units['pressure'])&#10;        area_display = convert_value(member.section.Area, 'm^2', f&quot;{display_units['length']}^2&quot;)&#10;        ixx_display = convert_value(member.section.Ixx, 'm^4', f&quot;{display_units['length']}^4&quot;)&#10;        &#10;        member_info = {&#10;            'Member ID': member.uid,&#10;            'Type': member.type,&#10;            'i-node': member.inode.uid,&#10;            'j-node': member.jnode.uid,&#10;            f'Length ({display_units[&quot;length&quot;]})': length_display,&#10;            'Material ID': member.material.uid,&#10;            f'E ({display_units[&quot;pressure&quot;]})': e_display,&#10;            'Section ID': member.section.uid,&#10;            f'Area ({display_units[&quot;length&quot;]})': area_display,&#10;            f'Ixx ({display_units[&quot;length&quot;]})': ixx_display,&#10;        }&#10;        &#10;        # Add hinge information if it's a frame&#10;        if hasattr(member, 'hinges'):&#10;            hinge_info = []&#10;            if member.hinges[0]:&#10;                hinge_info.append('i-node')&#10;            if member.hinges[1]:&#10;                hinge_info.append('j-node')&#10;            member_info['Hinges'] = ', '.join(hinge_info) if hinge_info else 'None'&#10;        &#10;        members_data.append(member_info)&#10;    &#10;    members_df = pd.DataFrame(members_data)&#10;    members_df.to_excel(writer, sheet_name='Member Properties', index=False)&#10;&#10;def _get_member_forces(member, combo, combo_name):&#10;    &quot;&quot;&quot;Helper function to get member forces in both global and local coordinates&quot;&quot;&quot;&#10;    import numpy as np&#10;    &#10;    # Calculate member forces for this load combination&#10;    if hasattr(member, 'end_forces_global') and combo_name in member.end_forces_global:&#10;        global_forces = np.asarray(member.end_forces_global[combo_name]).flatten()&#10;    else:&#10;        # Calculate forces if not already available&#10;        try:&#10;            global_forces = np.asarray(member.set_end_forces_global(combo)).flatten()&#10;        except:&#10;            global_forces = np.zeros(6)&#10;    &#10;    if hasattr(member, 'end_forces_local') and combo_name in member.end_forces_local:&#10;        local_forces = np.asarray(member.end_forces_local[combo_name]).flatten()&#10;    else:&#10;        try:&#10;            member.Flocal(combo)&#10;            local_forces = np.asarray(member.end_forces_local[combo_name]).flatten()&#10;        except:&#10;            local_forces = np.zeros(6)&#10;    &#10;    return global_forces, local_forces" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/structure2d_to_html.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/structure2d_to_html.py" />
              <option name="originalContent" value="def generate_html_report(self, loadcombos=None, output_html=&quot;results.html&quot;):&#10;    &quot;&quot;&quot;&#10;    Generate an interactive HTML report for structural analysis results using Plotly.&#10;&#10;    Parameters&#10;    ----------&#10;    loadcombos : list, optional&#10;        List of load combinations to include in the report&#10;    output_html : str, optional&#10;        Path to save the HTML report&#10;&#10;    Returns&#10;    -------&#10;    str&#10;        Path to the created HTML file&#10;    &quot;&quot;&quot;&#10;    import plotly.graph_objects as go&#10;    from plotly.subplots import make_subplots&#10;    import numpy as np&#10;    import os&#10;&#10;    print(f&quot;Generating interactive HTML report: {output_html}&quot;)&#10;&#10;    # Use all load combos if none specified&#10;    if loadcombos is None:&#10;        # Determine available load combos from node displacements&#10;        if self.nodes and hasattr(self.nodes[0], 'displacements') and self.nodes[0].displacements:&#10;            available_combos = list(self.nodes[0].displacements.keys())&#10;            loadcombos = available_combos&#10;        else:&#10;            print(&quot;Warning: No load combinations found in results.&quot;)&#10;            return None&#10;&#10;    # Extract values safely (handling Pint quantities)&#10;    def extract_value(val):&#10;        try:&#10;            if hasattr(val, 'magnitude'):  # Check if it's a Pint quantity&#10;                return float(val.magnitude)&#10;            return float(val)&#10;        except Exception as e:&#10;            print(f&quot;Error extracting value: {e}&quot;)&#10;            return 0.0&#10;&#10;    # Create figure with subplots&#10;    fig = make_subplots(&#10;        rows=2, cols=2,&#10;        specs=[[{&quot;type&quot;: &quot;scatter&quot;}, {&quot;type&quot;: &quot;scatter&quot;}],&#10;               [{&quot;type&quot;: &quot;scatter&quot;}, {&quot;type&quot;: &quot;table&quot;}]],&#10;        subplot_titles=(&quot;Structure Geometry&quot;, &quot;Deformed Shape&quot;,&#10;                        &quot;Bending Moment Diagram&quot;, &quot;Results Summary&quot;)&#10;    )&#10;&#10;    # Plot 1: Structure Geometry&#10;    print(&quot;Creating structure geometry plot...&quot;)&#10;    # Add members&#10;    for member in self.members:&#10;        fig.add_trace(&#10;            go.Scatter(&#10;                x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                mode='lines',&#10;                line=dict(color='blue', width=3),&#10;                name=f&quot;Member {member.uid}&quot;&#10;            ),&#10;            row=1, col=1&#10;        )&#10;&#10;    # Add nodes with hover text showing restraints&#10;    for node in self.nodes:&#10;        hover_text = (f&quot;Node {node.uid}&lt;br&gt;&quot;&#10;                     f&quot;Restraints: {node.restraints}&lt;br&gt;&quot;&#10;                     f&quot;X: {extract_value(node.x):.4f}&lt;br&gt;&quot;&#10;                     f&quot;Y: {extract_value(node.y):.4f}&quot;)&#10;&#10;        # Use different markers for restrained nodes&#10;        marker_symbol = 'circle'&#10;        marker_color = 'blue'&#10;        if sum(node.restraints) &gt; 0:&#10;            marker_symbol = 'square'&#10;            marker_color = 'red'&#10;&#10;        fig.add_trace(&#10;            go.Scatter(&#10;                x=[extract_value(node.x)],&#10;                y=[extract_value(node.y)],&#10;                mode='markers',&#10;                marker=dict(size=10, symbol=marker_symbol, color=marker_color),&#10;                name=f&quot;Node {node.uid}&quot;,&#10;                text=hover_text,&#10;                hoverinfo='text'&#10;            ),&#10;            row=1, col=1&#10;        )&#10;&#10;    # Plot 2: Deformed Shape for each load combo&#10;    print(&quot;Creating deformed shape plot...&quot;)&#10;    for combo in loadcombos:&#10;        # Get max displacement for scaling&#10;        max_disp = 0.0&#10;        for node in self.nodes:&#10;            if hasattr(node, 'displacements') and combo in node.displacements:&#10;                ux = extract_value(node.displacements[combo][0])&#10;                uy = extract_value(node.displacements[combo][1])&#10;                disp_magnitude = np.sqrt(ux**2 + uy**2)&#10;                max_disp = max(max_disp, disp_magnitude)&#10;&#10;        # Apply scaling factor for better visualization&#10;        scale_factor = 20.0  # Adjust for visibility&#10;        if max_disp &gt; 0:&#10;            scale_factor = min(&#10;                0.2 * max([extract_value(m.length) for m in self.members]) / max_disp,&#10;                scale_factor&#10;            )&#10;&#10;        print(f&quot;Load combo: {combo}, Max displacement: {max_disp:.6f}, Scale factor: {scale_factor}&quot;)&#10;&#10;        # Plot deformed shape&#10;        for member in self.members:&#10;            i_node = member.inode&#10;            j_node = member.jnode&#10;&#10;            # Get original coordinates&#10;            x1, y1 = extract_value(i_node.x), extract_value(i_node.y)&#10;            x2, y2 = extract_value(j_node.x), extract_value(j_node.y)&#10;&#10;            # Get displacements if available&#10;            ux1, uy1, ux2, uy2 = 0, 0, 0, 0&#10;&#10;            if hasattr(i_node, 'displacements') and combo in i_node.displacements:&#10;                ux1 = extract_value(i_node.displacements[combo][0])&#10;                uy1 = extract_value(i_node.displacements[combo][1])&#10;&#10;            if hasattr(j_node, 'displacements') and combo in j_node.displacements:&#10;                ux2 = extract_value(j_node.displacements[combo][0])&#10;                uy2 = extract_value(j_node.displacements[combo][1])&#10;&#10;            # Calculate deformed coordinates&#10;            x1_def = x1 + ux1 * scale_factor&#10;            y1_def = y1 + uy1 * scale_factor&#10;            x2_def = x2 + ux2 * scale_factor&#10;            y2_def = y2 + uy2 * scale_factor&#10;&#10;            # Add deformed member&#10;            fig.add_trace(&#10;                go.Scatter(&#10;                    x=[x1_def, x2_def],&#10;                    y=[y1_def, y2_def],&#10;                    mode='lines',&#10;                    line=dict(color='red', width=2, dash='dash'),&#10;                    name=f&quot;Deformed Member {member.uid} ({combo})&quot;&#10;                ),&#10;                row=1, col=2&#10;            )&#10;&#10;    # Plot 3: Bending Moment Diagram&#10;    print(&quot;Creating bending moment diagram...&quot;)&#10;    for combo in loadcombos[:1]:  # Just use the first combo for this example&#10;        for member in self.members:&#10;            if not hasattr(member, 'Mz') or combo not in member.Mz:&#10;                continue&#10;&#10;            length = extract_value(member.length)&#10;            num_points = 21&#10;&#10;            # Create x positions along member&#10;            x_local = np.linspace(0, length, num_points)&#10;&#10;            # Get moment values at each position&#10;            moment_values = []&#10;            for x in x_local:&#10;                try:&#10;                    m = extract_value(member.Mz[combo].evaluate(x))&#10;                    moment_values.append(m)&#10;                except Exception as e:&#10;                    print(f&quot;Error evaluating moment at x={x}: {e}&quot;)&#10;                    moment_values.append(0)&#10;&#10;            # Scale for better visualization&#10;            max_moment = max(abs(np.array(moment_values)))&#10;            if max_moment &gt; 0:&#10;                moment_scale = 0.2 * length / max_moment&#10;            else:&#10;                moment_scale = 1.0&#10;&#10;            # Get the global coordinates&#10;            cos_theta = (extract_value(member.jnode.x) - extract_value(member.inode.x)) / length&#10;            sin_theta = (extract_value(member.jnode.y) - extract_value(member.inode.y)) / length&#10;&#10;            x_global = []&#10;            y_global = []&#10;            for i, x in enumerate(x_local):&#10;                # Position along the member in global coordinates&#10;                x_pos = extract_value(member.inode.x) + x * cos_theta&#10;                y_pos = extract_value(member.inode.y) + x * sin_theta&#10;&#10;                # Add moment value perpendicular to the member&#10;                m = moment_values[i] * moment_scale&#10;                x_pos -= m * sin_theta&#10;                y_pos += m * cos_theta&#10;&#10;                x_global.append(x_pos)&#10;                y_global.append(y_pos)&#10;&#10;            # Plot the moment diagram&#10;            fig.add_trace(&#10;                go.Scatter(&#10;                    x=x_global,&#10;                    y=y_global,&#10;                    mode='lines',&#10;                    line=dict(color='green', width=2),&#10;                    name=f&quot;Moment {member.uid} ({combo})&quot;&#10;                ),&#10;                row=2, col=1&#10;            )&#10;&#10;    # Plot 4: Results Table&#10;    print(&quot;Creating results table...&quot;)&#10;    table_headers = [&quot;Node&quot;, &quot;Ux (m)&quot;, &quot;Uy (m)&quot;, &quot;Rz (rad)&quot;]&#10;    table_data = []&#10;&#10;    for node in self.nodes:&#10;        for combo in loadcombos[:1]:  # Just use first combo for table&#10;            if hasattr(node, 'displacements') and combo in node.displacements:&#10;                ux = extract_value(node.displacements[combo][0])&#10;                uy = extract_value(node.displacements[combo][1])&#10;                rz = extract_value(node.displacements[combo][2])&#10;                table_data.append([str(node.uid), f&quot;{ux:.6e}&quot;, f&quot;{uy:.6e}&quot;, f&quot;{rz:.6e}&quot;])&#10;&#10;    fig.add_trace(&#10;        go.Table(&#10;            header=dict(values=table_headers),&#10;            cells=dict(values=list(zip(*table_data))),&#10;        ),&#10;        row=2, col=2&#10;    )&#10;&#10;    # Update layout&#10;    fig.update_layout(&#10;        title_text=&quot;Interactive Structural Analysis Results&quot;,&#10;        height=800,&#10;        showlegend=False&#10;    )&#10;&#10;    # Ensure consistent aspect ratio and axis ranges&#10;    fig.update_yaxes(&#10;        scaleanchor=&quot;x&quot;,&#10;        scaleratio=1,&#10;        row=1, col=1&#10;    )&#10;&#10;    fig.update_yaxes(&#10;        scaleanchor=&quot;x&quot;,&#10;        scaleratio=1,&#10;        row=1, col=2&#10;    )&#10;&#10;    # Write the HTML file&#10;    print(f&quot;Writing HTML report to: {output_html}&quot;)&#10;    try:&#10;        fig.write_html(output_html)&#10;        print(f&quot;Successfully created HTML report at: {output_html}&quot;)&#10;        return output_html&#10;    except Exception as e:&#10;        print(f&quot;Error writing HTML file: {e}&quot;)&#10;        return None" />
              <option name="updatedContent" value="def generate_html_report(self, loadcombos=None, output_html=&quot;results.html&quot;):&#10;    &quot;&quot;&quot;&#10;    Generate a comprehensive interactive HTML report for structural analysis results using Plotly.&#10;&#10;    Parameters&#10;    ----------&#10;    loadcombos : list, optional&#10;        List of load combinations to include in the report&#10;    output_html : str, optional&#10;        Path to save the HTML report&#10;&#10;    Returns&#10;    -------&#10;    str&#10;        Path to the created HTML file&#10;    &quot;&quot;&quot;&#10;    import plotly.graph_objects as go&#10;    from plotly.subplots import make_subplots&#10;    import numpy as np&#10;    import os&#10;    import plotly.io as pio&#10;    import pandas as pd&#10;    from plotly.colors import qualitative&#10;&#10;    print(f&quot;Generating comprehensive interactive HTML report: {output_html}&quot;)&#10;&#10;    # Use all load combos if none specified&#10;    if loadcombos is None:&#10;        # Determine available load combos from node displacements&#10;        if self.nodes and hasattr(self.nodes[0], 'displacements') and self.nodes[0].displacements:&#10;            available_combos = list(self.nodes[0].displacements.keys())&#10;            loadcombos = available_combos&#10;        else:&#10;            print(&quot;Warning: No load combinations found in results.&quot;)&#10;            return None&#10;&#10;    # Extract values safely (handling Pint quantities)&#10;    def extract_value(val):&#10;        try:&#10;            if hasattr(val, 'magnitude'):  # Check if it's a Pint quantity&#10;                return float(val.magnitude)&#10;            return float(val)&#10;        except Exception as e:&#10;            print(f&quot;Error extracting value: {e}&quot;)&#10;            return 0.0&#10;    &#10;    def extract_unit(val):&#10;        &quot;&quot;&quot;Extract unit string from a quantity&quot;&quot;&quot;&#10;        try:&#10;            if hasattr(val, 'units'):&#10;                return str(val.units)&#10;            return &quot;&quot;&#10;        except Exception:&#10;            return &quot;&quot;&#10;    &#10;    # Get display units from the first few quantities we encounter&#10;    display_units = {}&#10;    &#10;    # Try to determine units from first node coordinates&#10;    if self.nodes:&#10;        if hasattr(self.nodes[0].x, 'units'):&#10;            display_units['length'] = str(self.nodes[0].x.units)&#10;        &#10;    # Try to determine force units from first member reaction&#10;    if self.members and hasattr(self.members[0], 'end_forces_local'):&#10;        for combo_name, forces in self.members[0].end_forces_local.items():&#10;            if forces is not None and len(forces) &gt; 0:&#10;                if hasattr(forces[0], 'units'):&#10;                    display_units['force'] = str(forces[0].units)&#10;                    break&#10;    &#10;    # Set default units if not found&#10;    if 'length' not in display_units:&#10;        display_units['length'] = 'm'&#10;    if 'force' not in display_units:&#10;        display_units['force'] = 'N'&#10;    if 'moment' not in display_units:&#10;        display_units['moment'] = f&quot;{display_units['force']}{display_units['length']}&quot;&#10;        &#10;    print(f&quot;Using display units: {display_units}&quot;)&#10;    &#10;    # Create HTML with multiple tabs using Plotly's Dash components but rendered as static HTML&#10;    # First, create a list to hold all figures&#10;    figures = []&#10;    &#10;    # 1. Create summary information table&#10;    summary_fig = go.Figure(data=[go.Table(&#10;        header=dict(&#10;            values=['Parameter', 'Value'],&#10;            fill_color='lightblue',&#10;            align='left',&#10;            font=dict(size=14)&#10;        ),&#10;        cells=dict(&#10;            values=[&#10;                ['Number of Nodes', 'Number of Members', 'Degrees of Freedom', &#10;                 'Number of Restraints', 'Analysis Type', 'Load Combinations'],&#10;                [len(self.nodes), len(self.members), self.NDOF, &#10;                 sum(sum(node.restraints) for node in self.nodes), 'Linear Static',&#10;                 ', '.join(combo for combo in loadcombos)]&#10;            ],&#10;            fill_color='lavender',&#10;            align='left',&#10;            font=dict(size=12)&#10;        )&#10;    )])&#10;    &#10;    summary_fig.update_layout(&#10;        title_text=&quot;Analysis Summary&quot;,&#10;        height=300,&#10;        margin=dict(l=0, r=0, b=0, t=30),&#10;    )&#10;    &#10;    figures.append(summary_fig)&#10;    &#10;    # 2. Create structure visualization with loads&#10;    structure_fig = go.Figure()&#10;    &#10;    # Add members&#10;    for member in self.members:&#10;        structure_fig.add_trace(&#10;            go.Scatter(&#10;                x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                mode='lines',&#10;                line=dict(color='blue', width=3),&#10;                name=f&quot;Member {member.uid}&quot;&#10;            )&#10;        )&#10;    &#10;    # Add nodes with hover text showing restraints&#10;    for node in self.nodes:&#10;        hover_text = (f&quot;Node {node.uid}&lt;br&gt;&quot;&#10;                     f&quot;Restraints: {node.restraints}&lt;br&gt;&quot;&#10;                     f&quot;X: {extract_value(node.x)} {display_units['length']}&lt;br&gt;&quot;&#10;                     f&quot;Y: {extract_value(node.y)} {display_units['length']}&quot;)&#10;&#10;        # Use different markers for restrained nodes&#10;        marker_symbol = 'circle'&#10;        marker_color = 'blue'&#10;        if sum(node.restraints) &gt; 0:&#10;            marker_symbol = 'square'&#10;            marker_color = 'red'&#10;&#10;        structure_fig.add_trace(&#10;            go.Scatter(&#10;                x=[extract_value(node.x)],&#10;                y=[extract_value(node.y)],&#10;                mode='markers',&#10;                marker=dict(size=10, symbol=marker_symbol, color=marker_color),&#10;                name=f&quot;Node {node.uid}&quot;,&#10;                text=hover_text,&#10;                hoverinfo='text'&#10;            )&#10;        )&#10;        &#10;        # Add nodal loads (if any)&#10;        for combo in loadcombos:&#10;            if hasattr(node, 'loads') and combo in node.loads:&#10;                load = node.loads[combo]&#10;                fx = extract_value(load[0])&#10;                fy = extract_value(load[1])&#10;                mz = extract_value(load[2])&#10;                &#10;                # Only show loads that are not zero&#10;                load_magnitude = np.sqrt(fx*fx + fy*fy)&#10;                if load_magnitude &gt; 0:&#10;                    # Scale arrow for visibility&#10;                    scale = min(5.0, max(0.5, 20.0 / load_magnitude)) if load_magnitude &gt; 0 else 1.0&#10;                    &#10;                    # Add arrow for force&#10;                    arrow_x = extract_value(node.x)&#10;                    arrow_y = extract_value(node.y)&#10;                    arrow_dx = -fx * scale  # Negative because loads are in opposite direction&#10;                    arrow_dy = -fy * scale&#10;                    &#10;                    structure_fig.add_trace(&#10;                        go.Scatter(&#10;                            x=[arrow_x, arrow_x + arrow_dx],&#10;                            y=[arrow_y, arrow_y + arrow_dy],&#10;                            mode='lines+markers',&#10;                            line=dict(color='red', width=2),&#10;                            marker=dict(size=[0, 8], symbol='arrow', angle=np.degrees(np.arctan2(arrow_dy, arrow_dx))),&#10;                            name=f&quot;Load {combo} at Node {node.uid}&quot;,&#10;                            text=f&quot;Fx={fx:.2f} {display_units['force']}&lt;br&gt;Fy={fy:.2f} {display_units['force']}&quot;,&#10;                            hoverinfo='text'&#10;                        )&#10;                    )&#10;                &#10;                # Add curved arrow for moment (if not zero)&#10;                if abs(mz) &gt; 1e-8:&#10;                    # Create a small circle to represent moment&#10;                    theta = np.linspace(0, 2*np.pi, 20)&#10;                    radius = 0.05 * max([extract_value(m.length) for m in self.members if hasattr(m, 'length')])&#10;                    &#10;                    # Direction depends on sign of moment&#10;                    if mz &gt; 0:  # Counter-clockwise&#10;                        structure_fig.add_trace(&#10;                            go.Scatter(&#10;                                x=extract_value(node.x) + radius * np.cos(theta),&#10;                                y=extract_value(node.y) + radius * np.sin(theta),&#10;                                mode='lines',&#10;                                line=dict(color='red', width=2),&#10;                                name=f&quot;Moment {combo} at Node {node.uid}&quot;,&#10;                                text=f&quot;Mz={mz:.2f} {display_units['moment']}&quot;,&#10;                                hoverinfo='text'&#10;                            )&#10;                        )&#10;                        # Add arrowhead&#10;                        structure_fig.add_trace(&#10;                            go.Scatter(&#10;                                x=[extract_value(node.x) + radius, extract_value(node.x) + radius*0.8, &#10;                                   extract_value(node.x) + radius*0.8],&#10;                                y=[extract_value(node.y), extract_value(node.y) + radius*0.1, &#10;                                   extract_value(node.y) - radius*0.1],&#10;                                mode='lines',&#10;                                line=dict(color='red', width=2),&#10;                                showlegend=False&#10;                            )&#10;                        )&#10;                    else:  # Clockwise&#10;                        structure_fig.add_trace(&#10;                            go.Scatter(&#10;                                x=extract_value(node.x) + radius * np.cos(theta),&#10;                                y=extract_value(node.y) + radius * np.sin(theta),&#10;                                mode='lines',&#10;                                line=dict(color='red', width=2),&#10;                                name=f&quot;Moment {combo} at Node {node.uid}&quot;,&#10;                                text=f&quot;Mz={mz:.2f} {display_units['moment']}&quot;,&#10;                                hoverinfo='text'&#10;                            )&#10;                        )&#10;                        # Add arrowhead&#10;                        structure_fig.add_trace(&#10;                            go.Scatter(&#10;                                x=[extract_value(node.x) - radius, extract_value(node.x) - radius*0.8, &#10;                                   extract_value(node.x) - radius*0.8],&#10;                                y=[extract_value(node.y), extract_value(node.y) + radius*0.1, &#10;                                   extract_value(node.y) - radius*0.1],&#10;                                mode='lines',&#10;                                line=dict(color='red', width=2),&#10;                                showlegend=False&#10;                            )&#10;                        )&#10;    &#10;    # Add distributed loads on members&#10;    for member in self.members:&#10;        if hasattr(member, 'loads'):&#10;            for load in member.loads:&#10;                # Handle different types of loads&#10;                if hasattr(load, 'kind') and load.kind == 'DISTRIBUTED':&#10;                    # Draw distributed load&#10;                    length = extract_value(member.length)&#10;                    num_arrows = 5  # Number of arrows to represent distributed load&#10;                    &#10;                    # Get local coordinates&#10;                    cos_theta = (extract_value(member.jnode.x) - extract_value(member.inode.x)) / length&#10;                    sin_theta = (extract_value(member.jnode.y) - extract_value(member.inode.y)) / length&#10;                    &#10;                    # For each arrow position&#10;                    for i in range(num_arrows):&#10;                        x_local = length * (i + 0.5) / num_arrows&#10;                        &#10;                        # Get load magnitude at this position (assuming w1 and w2 attributes for linear load)&#10;                        if hasattr(load, 'w1') and hasattr(load, 'w2'):&#10;                            w1 = extract_value(load.w1)&#10;                            w2 = extract_value(load.w2)&#10;                            w_x = w1 + (w2 - w1) * x_local / length&#10;                        else:&#10;                            w_x = extract_value(load.p) if hasattr(load, 'p') else 1.0&#10;                        &#10;                        # Position along member&#10;                        x_pos = extract_value(member.inode.x) + x_local * cos_theta&#10;                        y_pos = extract_value(member.inode.y) + x_local * sin_theta&#10;                        &#10;                        # Arrow direction (perpendicular to member)&#10;                        scale = 0.1 * length  # Scale for visibility&#10;                        &#10;                        structure_fig.add_trace(&#10;                            go.Scatter(&#10;                                x=[x_pos, x_pos - w_x * scale * sin_theta],&#10;                                y=[y_pos, y_pos + w_x * scale * cos_theta],&#10;                                mode='lines+markers',&#10;                                line=dict(color='purple', width=2),&#10;                                marker=dict(size=[0, 8], symbol='arrow'),&#10;                                name=f&quot;Distributed Load on Member {member.uid}&quot;,&#10;                                showlegend=(i == 0)&#10;                            )&#10;                        )&#10;    &#10;    structure_fig.update_layout(&#10;        title_text=&quot;Structure Geometry and Loads&quot;,&#10;        xaxis=dict(&#10;            title=f&quot;X ({display_units['length']})&quot;,&#10;            constrain=&quot;domain&quot;,&#10;            scaleanchor=&quot;y&quot;,&#10;            scaleratio=1,&#10;        ),&#10;        yaxis=dict(&#10;            title=f&quot;Y ({display_units['length']})&quot;&#10;        ),&#10;        legend=dict(&#10;            yanchor=&quot;top&quot;,&#10;            y=0.99,&#10;            xanchor=&quot;left&quot;,&#10;            x=0.01,&#10;            bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;&#10;        ),&#10;        height=700,&#10;        margin=dict(l=0, r=0, b=0, t=50),&#10;    )&#10;    &#10;    figures.append(structure_fig)&#10;    &#10;    # 3. Create deformed shape for all load combinations&#10;    for combo_idx, combo in enumerate(loadcombos):&#10;        deformed_fig = go.Figure()&#10;        &#10;        # Add original structure (undeformed)&#10;        for member in self.members:&#10;            deformed_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                    y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                    mode='lines',&#10;                    line=dict(color='blue', width=2, dash='dot'),&#10;                    name=&quot;Undeformed Shape&quot;&#10;                )&#10;            )&#10;        &#10;        # Get max displacement for scaling&#10;        max_disp = 0.0&#10;        for node in self.nodes:&#10;            if hasattr(node, 'displacements') and combo in node.displacements:&#10;                ux = extract_value(node.displacements[combo][0])&#10;                uy = extract_value(node.displacements[combo][1])&#10;                disp_magnitude = np.sqrt(ux**2 + uy**2)&#10;                max_disp = max(max_disp, disp_magnitude)&#10;        &#10;        # Apply scaling factor for better visualization&#10;        scale_factor = 20.0  # Default&#10;        if max_disp &gt; 0:&#10;            avg_member_length = np.mean([extract_value(m.length) for m in self.members])&#10;            scale_factor = 0.2 * avg_member_length / max_disp&#10;            scale_factor = min(scale_factor, 50.0)  # Limit scaling&#10;        &#10;        print(f&quot;Load combo: {combo}, Max displacement: {max_disp:.6f}, Scale factor: {scale_factor}&quot;)&#10;        &#10;        # Draw deformed shape&#10;        for member_idx, member in enumerate(self.members):&#10;            i_node = member.inode&#10;            j_node = member.jnode&#10;            &#10;            # Get original coordinates&#10;            x1, y1 = extract_value(i_node.x), extract_value(i_node.y)&#10;            x2, y2 = extract_value(j_node.x), extract_value(j_node.y)&#10;            &#10;            # Get displacements if available&#10;            ux1, uy1, ux2, uy2 = 0, 0, 0, 0&#10;            &#10;            if hasattr(i_node, 'displacements') and combo in i_node.displacements:&#10;                ux1 = extract_value(i_node.displacements[combo][0])&#10;                uy1 = extract_value(i_node.displacements[combo][1])&#10;            &#10;            if hasattr(j_node, 'displacements') and combo in j_node.displacements:&#10;                ux2 = extract_value(j_node.displacements[combo][0])&#10;                uy2 = extract_value(j_node.displacements[combo][1])&#10;            &#10;            # For more accurate representation, use the member displacement function if available&#10;            if hasattr(member, 'displacement_functions') and combo in member.displacement_functions:&#10;                try:&#10;                    disp_function = member.displacement_functions[combo]&#10;                    &#10;                    # Generate multiple points along member&#10;                    num_points = 20&#10;                    x_local = np.linspace(0, extract_value(member.length), num_points)&#10;                    &#10;                    # Calculate displacement at each point&#10;                    x_global = []&#10;                    y_global = []&#10;                    &#10;                    for x in x_local:&#10;                        # Get member local coordinates&#10;                        cos_theta = (x2 - x1) / extract_value(member.length)&#10;                        sin_theta = (y2 - y1) / extract_value(member.length)&#10;                        &#10;                        # Position along undeformed member&#10;                        x_pos = x1 + x * cos_theta&#10;                        y_pos = y1 + x * sin_theta&#10;                        &#10;                        # Add displacement&#10;                        try:&#10;                            ux = extract_value(disp_function['ux'](x)) if 'ux' in disp_function else 0&#10;                            uy = extract_value(disp_function['uy'](x)) if 'uy' in disp_function else 0&#10;                        except Exception as e:&#10;                            print(f&quot;Error evaluating displacement at x={x}: {e}&quot;)&#10;                            ux, uy = 0, 0&#10;                        &#10;                        x_pos += ux * scale_factor&#10;                        y_pos += uy * scale_factor&#10;                        &#10;                        x_global.append(x_pos)&#10;                        y_global.append(y_pos)&#10;                    &#10;                    # Draw the deformed member as a smooth curve&#10;                    deformed_fig.add_trace(&#10;                        go.Scatter(&#10;                            x=x_global,&#10;                            y=y_global,&#10;                            mode='lines',&#10;                            line=dict(color='red', width=3),&#10;                            name=f&quot;Deformed Member {member.uid}&quot;&#10;                        )&#10;                    )&#10;                &#10;                except Exception as e:&#10;                    print(f&quot;Error generating displacement curve for member {member.uid}: {e}&quot;)&#10;                    # Fall back to linear deformation&#10;                    x1_def = x1 + ux1 * scale_factor&#10;                    y1_def = y1 + uy1 * scale_factor&#10;                    x2_def = x2 + ux2 * scale_factor&#10;                    y2_def = y2 + uy2 * scale_factor&#10;                    &#10;                    deformed_fig.add_trace(&#10;                        go.Scatter(&#10;                            x=[x1_def, x2_def],&#10;                            y=[y1_def, y2_def],&#10;                            mode='lines',&#10;                            line=dict(color='red', width=3),&#10;                            name=f&quot;Deformed Member {member.uid}&quot;&#10;                        )&#10;                    )&#10;            else:&#10;                # Simple linear deformation&#10;                x1_def = x1 + ux1 * scale_factor&#10;                y1_def = y1 + uy1 * scale_factor&#10;                x2_def = x2 + ux2 * scale_factor&#10;                y2_def = y2 + uy2 * scale_factor&#10;                &#10;                deformed_fig.add_trace(&#10;                    go.Scatter(&#10;                        x=[x1_def, x2_def],&#10;                        y=[y1_def, y2_def],&#10;                        mode='lines',&#10;                        line=dict(color='red', width=3),&#10;                        name=f&quot;Deformed Member {member.uid}&quot;&#10;                    )&#10;                )&#10;        &#10;        # Add deformed node positions with displacement text&#10;        for node in self.nodes:&#10;            if hasattr(node, 'displacements') and combo in node.displacements:&#10;                ux = extract_value(node.displacements[combo][0])&#10;                uy = extract_value(node.displacements[combo][1])&#10;                rz = extract_value(node.displacements[combo][2])&#10;                &#10;                # Calculate deformed position&#10;                x_def = extract_value(node.x) + ux * scale_factor&#10;                y_def = extract_value(node.y) + uy * scale_factor&#10;                &#10;                hover_text = (f&quot;Node {node.uid}&lt;br&gt;&quot;&#10;                             f&quot;Ux: {ux:.4e} {display_units['length']}&lt;br&gt;&quot;&#10;                             f&quot;Uy: {uy:.4e} {display_units['length']}&lt;br&gt;&quot;&#10;                             f&quot;Rz: {rz:.4e} rad&quot;)&#10;                &#10;                deformed_fig.add_trace(&#10;                    go.Scatter(&#10;                        x=[x_def],&#10;                        y=[y_def],&#10;                        mode='markers',&#10;                        marker=dict(size=8, color='red'),&#10;                        name=f&quot;Deformed Node {node.uid}&quot;,&#10;                        text=hover_text,&#10;                        hoverinfo='text'&#10;                    )&#10;                )&#10;        &#10;        deformed_fig.update_layout(&#10;            title_text=f&quot;Deformed Shape - {combo} (Scale: {scale_factor:.1f}X)&quot;,&#10;            xaxis=dict(&#10;                title=f&quot;X ({display_units['length']})&quot;,&#10;                constrain=&quot;domain&quot;,&#10;                scaleanchor=&quot;y&quot;,&#10;                scaleratio=1,&#10;            ),&#10;            yaxis=dict(&#10;                title=f&quot;Y ({display_units['length']})&quot;&#10;            ),&#10;            legend=dict(&#10;                yanchor=&quot;top&quot;,&#10;                y=0.99,&#10;                xanchor=&quot;left&quot;,&#10;                x=0.01,&#10;                bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;&#10;            ),&#10;            height=600,&#10;            margin=dict(l=0, r=0, b=0, t=50),&#10;        )&#10;        &#10;        figures.append(deformed_fig)&#10;    &#10;    # 4. Create internal force diagrams (moment, shear, axial)&#10;    for combo_idx, combo in enumerate(loadcombos):&#10;        # a. Bending Moment Diagram&#10;        moment_fig = go.Figure()&#10;        &#10;        # Add reference structure&#10;        for member in self.members:&#10;            moment_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                    y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                    mode='lines',&#10;                    line=dict(color='gray', width=1, dash='dot'),&#10;                    name=&quot;Structure&quot;&#10;                )&#10;            )&#10;        &#10;        # Plot moment diagram for each member&#10;        for member_idx, member in enumerate(self.members):&#10;            if not hasattr(member, 'Mz') or combo not in member.Mz:&#10;                continue&#10;            &#10;            length = extract_value(member.length)&#10;            num_points = 31&#10;            &#10;            # Create x positions along member&#10;            x_local = np.linspace(0, length, num_points)&#10;            &#10;            # Get moment values at each position&#10;            moment_values = []&#10;            for x in x_local:&#10;                try:&#10;                    m = extract_value(member.Mz[combo].evaluate(x))&#10;                    moment_values.append(m)&#10;                except Exception as e:&#10;                    print(f&quot;Error evaluating moment at x={x}: {e}&quot;)&#10;                    moment_values.append(0)&#10;            &#10;            # Scale for better visualization&#10;            max_moment = max(abs(np.array(moment_values))) if moment_values else 0&#10;            if max_moment &gt; 0:&#10;                moment_scale = 0.15 * length / max_moment&#10;            else:&#10;                moment_scale = 1.0&#10;            &#10;            # Get the global coordinates&#10;            cos_theta = (extract_value(member.jnode.x) - extract_value(member.inode.x)) / length&#10;            sin_theta = (extract_value(member.jnode.y) - extract_value(member.inode.y)) / length&#10;            &#10;            x_global = []&#10;            y_global = []&#10;            hover_texts = []&#10;            &#10;            for i, x in enumerate(x_local):&#10;                # Position along the member in global coordinates&#10;                x_pos = extract_value(member.inode.x) + x * cos_theta&#10;                y_pos = extract_value(member.inode.y) + x * sin_theta&#10;                &#10;                # Add moment value perpendicular to the member&#10;                m = moment_values[i] * moment_scale&#10;                x_pos -= m * sin_theta&#10;                y_pos += m * cos_theta&#10;                &#10;                x_global.append(x_pos)&#10;                y_global.append(y_pos)&#10;                hover_texts.append(f&quot;x: {x:.2f} {display_units['length']}&lt;br&gt;Mz: {moment_values[i]:.2f} {display_units['moment']}&quot;)&#10;            &#10;            # Plot the moment diagram&#10;            moment_fig.add_trace(&#10;                go.Scatter(&#10;                    x=x_global,&#10;                    y=y_global,&#10;                    mode='lines',&#10;                    line=dict(color=qualitative.Plotly[member_idx % len(qualitative.Plotly)], width=2),&#10;                    name=f&quot;Member {member.uid}&quot;,&#10;                    text=hover_texts,&#10;                    hoverinfo='text'&#10;                )&#10;            )&#10;            &#10;            # Add value labels at ends&#10;            moment_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[x_global[0], x_global[-1]],&#10;                    y=[y_global[0], y_global[-1]],&#10;                    mode='markers+text',&#10;                    marker=dict(size=5, color=qualitative.Plotly[member_idx % len(qualitative.Plotly)]),&#10;                    text=[f&quot;{moment_values[0]:.2f}&quot;, f&quot;{moment_values[-1]:.2f}&quot;],&#10;                    textposition=[&quot;bottom center&quot;, &quot;bottom center&quot;],&#10;                    showlegend=False&#10;                )&#10;            )&#10;        &#10;        moment_fig.update_layout(&#10;            title_text=f&quot;Bending Moment Diagram - {combo}&quot;,&#10;            xaxis=dict(&#10;                title=f&quot;X ({display_units['length']})&quot;,&#10;                constrain=&quot;domain&quot;,&#10;                scaleanchor=&quot;y&quot;,&#10;                scaleratio=1,&#10;            ),&#10;            yaxis=dict(&#10;                title=f&quot;Y ({display_units['length']})&quot;&#10;            ),&#10;            legend=dict(&#10;                yanchor=&quot;top&quot;,&#10;                y=0.99,&#10;                xanchor=&quot;left&quot;,&#10;                x=0.01,&#10;                bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;&#10;            ),&#10;            height=600,&#10;            margin=dict(l=0, r=0, b=0, t=50),&#10;        )&#10;        &#10;        figures.append(moment_fig)&#10;        &#10;        # b. Shear Force Diagram&#10;        shear_fig = go.Figure()&#10;        &#10;        # Add reference structure&#10;        for member in self.members:&#10;            shear_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                    y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                    mode='lines',&#10;                    line=dict(color='gray', width=1, dash='dot'),&#10;                    name=&quot;Structure&quot;&#10;                )&#10;            )&#10;        &#10;        # Plot shear diagram for each member&#10;        for member_idx, member in enumerate(self.members):&#10;            if not hasattr(member, 'Vy') or combo not in member.Vy:&#10;                continue&#10;            &#10;            length = extract_value(member.length)&#10;            num_points = 31&#10;            &#10;            # Create x positions along member&#10;            x_local = np.linspace(0, length, num_points)&#10;            &#10;            # Get shear values at each position&#10;            shear_values = []&#10;            for x in x_local:&#10;                try:&#10;                    v = extract_value(member.Vy[combo].evaluate(x))&#10;                    shear_values.append(v)&#10;                except Exception as e:&#10;                    print(f&quot;Error evaluating shear at x={x}: {e}&quot;)&#10;                    shear_values.append(0)&#10;            &#10;            # Scale for better visualization&#10;            max_shear = max(abs(np.array(shear_values))) if shear_values else 0&#10;            if max_shear &gt; 0:&#10;                shear_scale = 0.15 * length / max_shear&#10;            else:&#10;                shear_scale = 1.0&#10;            &#10;            # Get the global coordinates&#10;            cos_theta = (extract_value(member.jnode.x) - extract_value(member.inode.x)) / length&#10;            sin_theta = (extract_value(member.jnode.y) - extract_value(member.inode.y)) / length&#10;            &#10;            x_global = []&#10;            y_global = []&#10;            hover_texts = []&#10;            &#10;            for i, x in enumerate(x_local):&#10;                # Position along the member in global coordinates&#10;                x_pos = extract_value(member.inode.x) + x * cos_theta&#10;                y_pos = extract_value(member.inode.y) + x * sin_theta&#10;                &#10;                # Add shear value perpendicular to the member&#10;                v = shear_values[i] * shear_scale&#10;                x_pos -= v * sin_theta&#10;                y_pos += v * cos_theta&#10;                &#10;                x_global.append(x_pos)&#10;                y_global.append(y_pos)&#10;                hover_texts.append(f&quot;x: {x:.2f} {display_units['length']}&lt;br&gt;Vy: {shear_values[i]:.2f} {display_units['force']}&quot;)&#10;            &#10;            # Plot the shear diagram&#10;            shear_fig.add_trace(&#10;                go.Scatter(&#10;                    x=x_global,&#10;                    y=y_global,&#10;                    mode='lines',&#10;                    line=dict(color=qualitative.Plotly[member_idx % len(qualitative.Plotly)], width=2),&#10;                    name=f&quot;Member {member.uid}&quot;,&#10;                    text=hover_texts,&#10;                    hoverinfo='text'&#10;                )&#10;            )&#10;            &#10;            # Add value labels at ends&#10;            shear_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[x_global[0], x_global[-1]],&#10;                    y=[y_global[0], y_global[-1]],&#10;                    mode='markers+text',&#10;                    marker=dict(size=5, color=qualitative.Plotly[member_idx % len(qualitative.Plotly)]),&#10;                    text=[f&quot;{shear_values[0]:.2f}&quot;, f&quot;{shear_values[-1]:.2f}&quot;],&#10;                    textposition=[&quot;bottom center&quot;, &quot;bottom center&quot;],&#10;                    showlegend=False&#10;                )&#10;            )&#10;        &#10;        shear_fig.update_layout(&#10;            title_text=f&quot;Shear Force Diagram - {combo}&quot;,&#10;            xaxis=dict(&#10;                title=f&quot;X ({display_units['length']})&quot;,&#10;                constrain=&quot;domain&quot;,&#10;                scaleanchor=&quot;y&quot;,&#10;                scaleratio=1,&#10;            ),&#10;            yaxis=dict(&#10;                title=f&quot;Y ({display_units['length']})&quot;&#10;            ),&#10;            legend=dict(&#10;                yanchor=&quot;top&quot;,&#10;                y=0.99,&#10;                xanchor=&quot;left&quot;,&#10;                x=0.01,&#10;                bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;&#10;            ),&#10;            height=600,&#10;            margin=dict(l=0, r=0, b=0, t=50),&#10;        )&#10;        &#10;        figures.append(shear_fig)&#10;        &#10;        # c. Axial Force Diagram&#10;        axial_fig = go.Figure()&#10;        &#10;        # Add reference structure&#10;        for member in self.members:&#10;            axial_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                    y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                    mode='lines',&#10;                    line=dict(color='gray', width=1, dash='dot'),&#10;                    name=&quot;Structure&quot;&#10;                )&#10;            )&#10;        &#10;        # Plot axial diagram for each member&#10;        for member_idx, member in enumerate(self.members):&#10;            if not hasattr(member, 'N') or combo not in member.N:&#10;                continue&#10;            &#10;            length = extract_value(member.length)&#10;            num_points = 31&#10;            &#10;            # Create x positions along member&#10;            x_local = np.linspace(0, length, num_points)&#10;            &#10;            # Get axial values at each position&#10;            axial_values = []&#10;            for x in x_local:&#10;                try:&#10;                    n = extract_value(member.N[combo].evaluate(x))&#10;                    axial_values.append(n)&#10;                except Exception as e:&#10;                    print(f&quot;Error evaluating axial force at x={x}: {e}&quot;)&#10;                    axial_values.append(0)&#10;            &#10;            # Scale for better visualization (smaller scale for axial)&#10;            max_axial = max(abs(np.array(axial_values))) if axial_values else 0&#10;            if max_axial &gt; 0:&#10;                axial_scale = 0.05 * length / max_axial&#10;            else:&#10;                axial_scale = 1.0&#10;            &#10;            # Get member orientation&#10;            cos_theta = (extract_value(member.jnode.x) - extract_value(member.inode.x)) / length&#10;            sin_theta = (extract_value(member.jnode.y) - extract_value(member.inode.y)) / length&#10;            &#10;            # Lines parallel to the member&#10;            x_global = []&#10;            y_global = []&#10;            hover_texts = []&#10;            &#10;            for i, x in enumerate(x_local):&#10;                # Position along the member in global coordinates&#10;                x_pos = extract_value(member.inode.x) + x * cos_theta&#10;                y_pos = extract_value(member.inode.y) + x * sin_theta&#10;                &#10;                # Add axial value perpendicular to the member (rotated 90)&#10;                n = axial_values[i] * axial_scale&#10;                # For axial force, plot offset perpendicular to member direction&#10;                x_pos += n * sin_theta  # Note: Perpendicular direction&#10;                y_pos -= n * cos_theta  # Note: Perpendicular direction&#10;                &#10;                x_global.append(x_pos)&#10;                y_global.append(y_pos)&#10;                hover_texts.append(f&quot;x: {x:.2f} {display_units['length']}&lt;br&gt;N: {axial_values[i]:.2f} {display_units['force']}&quot;)&#10;            &#10;            # Plot the axial diagram&#10;            axial_fig.add_trace(&#10;                go.Scatter(&#10;                    x=x_global,&#10;                    y=y_global,&#10;                    mode='lines',&#10;                    line=dict(color=qualitative.Plotly[member_idx % len(qualitative.Plotly)], width=2),&#10;                    name=f&quot;Member {member.uid}&quot;,&#10;                    text=hover_texts,&#10;                    hoverinfo='text'&#10;                )&#10;            )&#10;            &#10;            # Add value labels at ends&#10;            axial_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[x_global[0], x_global[-1]],&#10;                    y=[y_global[0], y_global[-1]],&#10;                    mode='markers+text',&#10;                    marker=dict(size=5, color=qualitative.Plotly[member_idx % len(qualitative.Plotly)]),&#10;                    text=[f&quot;{axial_values[0]:.2f}&quot;, f&quot;{axial_values[-1]:.2f}&quot;],&#10;                    textposition=[&quot;bottom center&quot;, &quot;bottom center&quot;],&#10;                    showlegend=False&#10;                )&#10;            )&#10;        &#10;        axial_fig.update_layout(&#10;            title_text=f&quot;Axial Force Diagram - {combo}&quot;,&#10;            xaxis=dict(&#10;                title=f&quot;X ({display_units['length']})&quot;,&#10;                constrain=&quot;domain&quot;,&#10;                scaleanchor=&quot;y&quot;,&#10;                scaleratio=1,&#10;            ),&#10;            yaxis=dict(&#10;                title=f&quot;Y ({display_units['length']})&quot;&#10;            ),&#10;            legend=dict(&#10;                yanchor=&quot;top&quot;,&#10;                y=0.99,&#10;                xanchor=&quot;left&quot;,&#10;                x=0.01,&#10;                bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;&#10;            ),&#10;            height=600,&#10;            margin=dict(l=0, r=0, b=0, t=50),&#10;        )&#10;        &#10;        figures.append(axial_fig)&#10;    &#10;    # 5. Tabular results (Node displacements, reactions, member forces)&#10;    # a. Node displacements table&#10;    for combo in loadcombos:&#10;        disp_headers = [&quot;Node ID&quot;, f&quot;Ux ({display_units['length']})&quot;, &#10;                        f&quot;Uy ({display_units['length']})&quot;, &quot;Rz (rad)&quot;]&#10;        disp_data = [[], [], [], []]&#10;        &#10;        for node in sorted(self.nodes, key=lambda n: n.uid):&#10;            if hasattr(node, 'displacements') and combo in node.displacements:&#10;                disp = node.displacements[combo]&#10;                disp_data[0].append(node.uid)&#10;                disp_data[1].append(f&quot;{extract_value(disp[0]):.6e}&quot;)&#10;                disp_data[2].append(f&quot;{extract_value(disp[1]):.6e}&quot;)&#10;                disp_data[3].append(f&quot;{extract_value(disp[2]):.6e}&quot;)&#10;        &#10;        disp_table = go.Figure(data=[go.Table(&#10;            header=dict(&#10;                values=disp_headers,&#10;                fill_color='lightblue',&#10;                align='center',&#10;                font=dict(size=12)&#10;            ),&#10;            cells=dict(&#10;                values=disp_data,&#10;                fill_color='lavender',&#10;                align='right',&#10;                font=dict(size=11)&#10;            )&#10;        )])&#10;        &#10;        disp_table.update_layout(&#10;            title_text=f&quot;Node Displacements - {combo}&quot;,&#10;            height=400,&#10;            margin=dict(l=0, r=0, b=0, t=30),&#10;        )&#10;        &#10;        figures.append(disp_table)&#10;    &#10;    # b. Reaction forces table&#10;    for combo in loadcombos:&#10;        react_headers = [&quot;Node ID&quot;, f&quot;Rx ({display_units['force']})&quot;, &#10;                         f&quot;Ry ({display_units['force']})&quot;, f&quot;Mz ({display_units['moment']})&quot;]&#10;        react_data = [[], [], [], []]&#10;        &#10;        for node in sorted(self.nodes, key=lambda n: n.uid):&#10;            if any(node.restraints) and hasattr(node, 'reactions'):&#10;                if isinstance(node.reactions, dict) and combo in node.reactions:&#10;                    reaction = node.reactions[combo]&#10;                else:&#10;                    reaction = node.reactions  # Direct array&#10;                &#10;                react_data[0].append(node.uid)&#10;                &#10;                # Only show reactions where there are restraints&#10;                rx = extract_value(reaction[0]) if node.restraints[0] else 0&#10;                ry = extract_value(reaction[1]) if node.restraints[1] else 0&#10;                mz = extract_value(reaction[2]) if node.restraints[2] else 0&#10;                &#10;                react_data[1].append(f&quot;{rx:.4f}&quot;)&#10;                react_data[2].append(f&quot;{ry:.4f}&quot;)&#10;                react_data[3].append(f&quot;{mz:.4f}&quot;)&#10;        &#10;        react_table = go.Figure(data=[go.Table(&#10;            header=dict(&#10;                values=react_headers,&#10;                fill_color='lightblue',&#10;                align='center',&#10;                font=dict(size=12)&#10;            ),&#10;            cells=dict(&#10;                values=react_data,&#10;                fill_color='lavender',&#10;                align='right',&#10;                font=dict(size=11)&#10;            )&#10;        )])&#10;        &#10;        react_table.update_layout(&#10;            title_text=f&quot;Support Reactions - {combo}&quot;,&#10;            height=400,&#10;            margin=dict(l=0, r=0, b=0, t=30),&#10;        )&#10;        &#10;        figures.append(react_table)&#10;    &#10;    # c. Member end forces table&#10;    for combo in loadcombos:&#10;        force_headers = [&quot;Member&quot;, &#10;                         f&quot;Axial i ({display_units['force']})&quot;, &#10;                         f&quot;Shear i ({display_units['force']})&quot;, &#10;                         f&quot;Moment i ({display_units['moment']})&quot;,&#10;                         f&quot;Axial j ({display_units['force']})&quot;, &#10;                         f&quot;Shear j ({display_units['force']})&quot;, &#10;                         f&quot;Moment j ({display_units['moment']})&quot;]&#10;        force_data = [[], [], [], [], [], [], []]&#10;        &#10;        for member in sorted(self.members, key=lambda m: m.uid):&#10;            if hasattr(member, 'end_forces_local') and combo in member.end_forces_local:&#10;                forces = member.end_forces_local[combo]&#10;                &#10;                force_data[0].append(member.uid)&#10;                &#10;                # Local end forces - force sign convention&#10;                if len(forces) &gt;= 6:&#10;                    force_data[1].append(f&quot;{extract_value(forces[0]):.4f}&quot;)  # Axial i&#10;                    force_data[2].append(f&quot;{extract_value(forces[1]):.4f}&quot;)  # Shear i&#10;                    force_data[3].append(f&quot;{extract_value(forces[2]):.4f}&quot;)  # Moment i&#10;                    force_data[4].append(f&quot;{extract_value(forces[3]):.4f}&quot;)  # Axial j&#10;                    force_data[5].append(f&quot;{extract_value(forces[4]):.4f}&quot;)  # Shear j&#10;                    force_data[6].append(f&quot;{extract_value(forces[5]):.4f}&quot;)  # Moment j&#10;                else:&#10;                    # Fill with zeros if not enough data&#10;                    for i in range(1, 7):&#10;                        force_data[i].append(&quot;0.0000&quot;)&#10;        &#10;        force_table = go.Figure(data=[go.Table(&#10;            header=dict(&#10;                values=force_headers,&#10;                fill_color='lightblue',&#10;                align='center',&#10;                font=dict(size=12)&#10;            ),&#10;            cells=dict(&#10;                values=force_data,&#10;                fill_color='lavender',&#10;                align='right',&#10;                font=dict(size=11)&#10;            )&#10;        )])&#10;        &#10;        force_table.update_layout(&#10;            title_text=f&quot;Member End Forces (Local) - {combo}&quot;,&#10;            height=400,&#10;            margin=dict(l=0, r=0, b=0, t=30),&#10;        )&#10;        &#10;        figures.append(force_table)&#10;    &#10;    # 6. Member properties table&#10;    prop_headers = [&quot;Member&quot;, &#10;                   f&quot;Length ({display_units['length']})&quot;, &#10;                   &quot;Section&quot;, &#10;                   &quot;Material&quot;,&#10;                   &quot;Angle (deg)&quot;]&#10;    prop_data = [[], [], [], [], []]&#10;    &#10;    for member in sorted(self.members, key=lambda m: m.uid):&#10;        prop_data[0].append(member.uid)&#10;        prop_data[1].append(f&quot;{extract_value(member.length):.4f}&quot;)&#10;        &#10;        # Get section name&#10;        section_name = member.section.name if hasattr(member.section, 'name') else str(member.section.uid)&#10;        prop_data[2].append(section_name)&#10;        &#10;        # Get material name&#10;        material_name = str(member.material.uid)&#10;        prop_data[3].append(material_name)&#10;        &#10;        # Orientation angle&#10;        angle = np.degrees(member.theta) if hasattr(member, 'theta') else 0&#10;        prop_data[4].append(f&quot;{angle:.2f}&quot;)&#10;    &#10;    prop_table = go.Figure(data=[go.Table(&#10;        header=dict(&#10;            values=prop_headers,&#10;            fill_color='lightblue',&#10;            align='center',&#10;            font=dict(size=12)&#10;        ),&#10;        cells=dict(&#10;            values=prop_data,&#10;            fill_color='lavender',&#10;            align='right',&#10;            font=dict(size=11)&#10;        )&#10;    )])&#10;    &#10;    prop_table.update_layout(&#10;        title_text=&quot;Member Properties&quot;,&#10;        height=400,&#10;        margin=dict(l=0, r=0, b=0, t=30),&#10;    )&#10;    &#10;    figures.append(prop_table)&#10;    &#10;    # Combine all figures into an HTML report with navigation tabs&#10;    html_parts = [&quot;&quot;&quot;&#10;    &lt;!DOCTYPE html&gt;&#10;    &lt;html&gt;&#10;    &lt;head&gt;&#10;        &lt;title&gt;Structural Analysis Results&lt;/title&gt;&#10;        &lt;script src=&quot;https://cdn.plot.ly/plotly-latest.min.js&quot;&gt;&lt;/script&gt;&#10;        &lt;style&gt;&#10;            body { font-family: Arial, sans-serif; margin: 0; padding: 0; }&#10;            .header { background-color: #2c3e50; color: white; padding: 20px; text-align: center; }&#10;            .content { padding: 20px; }&#10;            .tab { overflow: hidden; border: 1px solid #ccc; background-color: #f1f1f1; }&#10;            .tab button { background-color: inherit; float: left; border: none; outline: none;&#10;                          cursor: pointer; padding: 14px 16px; transition: 0.3s; }&#10;            .tab button:hover { background-color: #ddd; }&#10;            .tab button.active { background-color: #ccc; }&#10;            .tabcontent { display: none; padding: 6px 12px; border: 1px solid #ccc; border-top: none; }&#10;            .plot-container { width: 100%; height: 100%; }&#10;        &lt;/style&gt;&#10;    &lt;/head&gt;&#10;    &lt;body&gt;&#10;        &lt;div class=&quot;header&quot;&gt;&#10;            &lt;h1&gt;Structural Analysis Results&lt;/h1&gt;&#10;            &lt;p&gt;Interactive visualization of analysis results&lt;/p&gt;&#10;        &lt;/div&gt;&#10;        &#10;        &lt;div class=&quot;tab&quot;&gt;&#10;    &quot;&quot;&quot;]&#10;    &#10;    # Create tabs&#10;    for i, fig in enumerate(figures):&#10;        tab_title = fig.layout.title.text if hasattr(fig.layout, 'title') and hasattr(fig.layout.title, 'text') else f&quot;Figure {i+1}&quot;&#10;        html_parts.append(f'&lt;button class=&quot;tablinks&quot; onclick=&quot;openTab(event, \'tab{i}\')&quot;&gt;{tab_title}&lt;/button&gt;')&#10;    &#10;    html_parts.append('&lt;/div&gt;')&#10;    &#10;    # Create content for each tab&#10;    for i, fig in enumerate(figures):&#10;        html_parts.append(f'&lt;div id=&quot;tab{i}&quot; class=&quot;tabcontent&quot;&gt;')&#10;        html_parts.append(f'&lt;div id=&quot;plot{i}&quot; class=&quot;plot-container&quot;&gt;&lt;/div&gt;')&#10;        html_parts.append('&lt;/div&gt;')&#10;        &#10;    # Add JavaScript for tabs and plots&#10;    html_parts.append(&quot;&quot;&quot;&#10;        &lt;script&gt;&#10;            // Tab functionality&#10;            function openTab(evt, tabName) {&#10;                var i, tabcontent, tablinks;&#10;                tabcontent = document.getElementsByClassName(&quot;tabcontent&quot;);&#10;                for (i = 0; i &lt; tabcontent.length; i++) {&#10;                    tabcontent[i].style.display = &quot;none&quot;;&#10;                }&#10;                tablinks = document.getElementsByClassName(&quot;tablinks&quot;);&#10;                for (i = 0; i &lt; tablinks.length; i++) {&#10;                    tablinks[i].className = tablinks[i].className.replace(&quot; active&quot;, &quot;&quot;);&#10;                }&#10;                document.getElementById(tabName).style.display = &quot;block&quot;;&#10;                evt.currentTarget.className += &quot; active&quot;;&#10;            }&#10;            &#10;            // Open the first tab by default&#10;            document.getElementsByClassName(&quot;tablinks&quot;)[0].click();&#10;        &lt;/script&gt;&#10;    &quot;&quot;&quot;)&#10;    &#10;    # Add plot data&#10;    for i, fig in enumerate(figures):&#10;        fig_json = fig.to_json()&#10;        html_parts.append(f&quot;&quot;&quot;&#10;        &lt;script&gt;&#10;            var plotData{i} = {fig_json};&#10;            Plotly.newPlot('plot{i}', plotData{i}.data, plotData{i}.layout);&#10;        &lt;/script&gt;&#10;        &quot;&quot;&quot;)&#10;    &#10;    html_parts.append(&quot;&quot;&quot;&#10;    &lt;/body&gt;&#10;    &lt;/html&gt;&#10;    &quot;&quot;&quot;)&#10;    &#10;    # Write HTML file&#10;    try:&#10;        with open(output_html, 'w') as f:&#10;            f.write(''.join(html_parts))&#10;        print(f&quot;Successfully created HTML report at: {output_html}&quot;)&#10;        return output_html&#10;    except Exception as e:&#10;        print(f&quot;Error writing HTML file: {e}&quot;)&#10;        return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/structure2d_to_json.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/structure2d_to_json.py" />
              <option name="originalContent" value="def export_results_to_json(structure, load_cases=None, output_file=None, convert_to_display_units=False, display_units=None):&#10;    &quot;&quot;&quot;&#10;    Export calculation results to a JSON file with Pint unit support,&#10;    including units next to magnitude values&#10;&#10;    Parameters&#10;    ----------&#10;    structure : R2Structure&#10;        The analyzed structure containing results&#10;    load_cases : list, optional&#10;        List of load case names to include in export (defaults to all)&#10;    output_file : str, optional&#10;        Path to output file (defaults to 'results.json')&#10;    convert_to_display_units : bool, optional&#10;        Whether to convert values to display units (default: False)&#10;    display_units : dict, optional&#10;        Dictionary of display units to use (default: None, uses system defaults)&#10;&#10;    Returns&#10;    -------&#10;    str&#10;        Path to the created JSON file&#10;    &quot;&quot;&quot;&#10;    import json&#10;    import numpy as np&#10;    import os&#10;&#10;    # Import the centralized unit manager&#10;    from pyMAOS import unit_manager&#10;    ureg = unit_manager.ureg&#10;&#10;    if output_file is None:&#10;        output_file = 'results.json'&#10;&#10;    print(f&quot;Starting export to JSON file: {output_file}&quot;)&#10;&#10;    # Get default display units if needed but not provided&#10;    if convert_to_display_units and display_units is None:&#10;        try:&#10;            from pyMAOS import unit_manager&#10;            display_units = unit_manager.current_system&#10;        except ImportError:&#10;            # Fallback to some standard display units&#10;            display_units = {&#10;                &quot;force&quot;: &quot;kN&quot;,&#10;                &quot;length&quot;: &quot;m&quot;,&#10;                &quot;moment&quot;: &quot;kN*m&quot;,&#10;                &quot;pressure&quot;: &quot;MPa&quot;,&#10;                &quot;area&quot;: &quot;cm^2&quot;,&#10;                &quot;moment_of_inertia&quot;: &quot;cm^4&quot;,&#10;                &quot;distributed_load&quot;: &quot;kN/m&quot;,&#10;                &quot;rotation&quot;: &quot;rad&quot;&#10;            }&#10;            print(f&quot;Using default display units: {display_units}&quot;)&#10;&#10;    # Define internal units based on the unit manager&#10;    internal_units = {&#10;        &quot;force&quot;: str(unit_manager.INTERNAL_FORCE_UNIT),&#10;        &quot;length&quot;: str(unit_manager.INTERNAL_LENGTH_UNIT),&#10;        &quot;moment&quot;: str(unit_manager.INTERNAL_MOMENT_UNIT),&#10;        &quot;pressure&quot;: str(unit_manager.INTERNAL_PRESSURE_UNIT),&#10;        &quot;area&quot;: f&quot;{unit_manager.INTERNAL_LENGTH_UNIT}^2&quot;,&#10;        &quot;moment_of_inertia&quot;: str(unit_manager.INTERNAL_MOMENT_OF_INERTIA_UNIT),&#10;        &quot;distributed_load&quot;: str(unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT),&#10;        &quot;rotation&quot;: str(unit_manager.INTERNAL_ROTATION_UNIT)&#10;    }&#10;&#10;    print(f&quot;Internal units: {internal_units}&quot;)&#10;    print(f&quot;Display units (if converting): {display_units}&quot;)&#10;&#10;    # Prepare data structure for JSON&#10;    results = {&#10;        &quot;units&quot;: display_units if convert_to_display_units else internal_units,&#10;        &quot;nodes&quot;: {},&#10;        &quot;members&quot;: {},&#10;        &quot;analysis_info&quot;: {&#10;            &quot;dof&quot;: structure.NDOF,&#10;            &quot;num_nodes&quot;: structure.NJ,&#10;            &quot;num_members&quot;: structure.NM&#10;        }&#10;    }&#10;&#10;    # Helper function to safely extract value from Pint quantities or regular values&#10;    def extract_value(val):&#10;        &quot;&quot;&quot;Extract numerical value from Pint quantities or regular values&quot;&quot;&quot;&#10;        try:&#10;            # Check if value has a 'magnitude' attribute (Pint Quantity)&#10;            if hasattr(val, 'magnitude'):&#10;                return float(val.magnitude)&#10;            # For numpy types&#10;            elif isinstance(val, (np.number, np.ndarray, np.matrix)):&#10;                return float(val)&#10;            else:&#10;                return float(val)&#10;        except Exception as e:&#10;            print(f&quot;Error extracting value: {e}, using 0.0&quot;)&#10;            return 0.0&#10;&#10;    # Unit conversion helper function&#10;    def convert_unit_with_info(value, dimension):&#10;        &quot;&quot;&quot;Convert value between unit systems and return both value and unit&quot;&quot;&quot;&#10;        try:&#10;            # Determine the unit based on conversion settings&#10;            unit = display_units[dimension] if convert_to_display_units else internal_units[dimension]&#10;&#10;            # Skip conversion for values very close to zero&#10;            if abs(float(value)) &lt; 1e-12:&#10;                return {&quot;value&quot;: 0.0, &quot;unit&quot;: unit}&#10;&#10;            # Extract the raw value&#10;            raw_value = extract_value(value)&#10;&#10;            # If conversion is requested, perform it&#10;            if convert_to_display_units:&#10;                source_unit = internal_units[dimension]&#10;                target_unit = display_units[dimension]&#10;&#10;                # Create quantity with source unit and convert to target unit&#10;                quantity = ureg.Quantity(raw_value, source_unit)&#10;                raw_value = quantity.to(target_unit).magnitude&#10;&#10;            # Return both value and unit&#10;            return {&quot;value&quot;: raw_value, &quot;unit&quot;: unit}&#10;        except Exception as e:&#10;            print(f&quot;Error converting {value} from {internal_units.get(dimension)} to {display_units.get(dimension)}: {e}&quot;)&#10;            unit = internal_units.get(dimension)&#10;            return {&quot;value&quot;: extract_value(value), &quot;unit&quot;: unit}&#10;&#10;    # Helper function to safely extract 6 force values from various array formats&#10;    def extract_force_values(force_array):&#10;        &quot;&quot;&quot;Extract 6 force values from various array formats with Pint support&quot;&quot;&quot;&#10;        values = [0.0] * 6&#10;&#10;        try:&#10;            # Handle Pint quantities in arrays&#10;            if hasattr(force_array, 'magnitude'):&#10;                force_array = force_array.magnitude&#10;&#10;            if isinstance(force_array, np.matrix):&#10;                array_data = np.array(force_array)&#10;                flat_data = array_data.flatten()&#10;                for i in range(min(6, len(flat_data))):&#10;                    values[i] = extract_value(flat_data[i])&#10;            elif isinstance(force_array, np.ndarray):&#10;                flat_data = force_array.flatten()&#10;                for i in range(min(6, len(flat_data))):&#10;                    values[i] = extract_value(flat_data[i])&#10;            elif hasattr(force_array, '__iter__'):&#10;                for i, val in enumerate(force_array):&#10;                    if i &gt;= 6: break&#10;                    values[i] = extract_value(val)&#10;            else:&#10;                # Single value or unknown type&#10;                values[0] = extract_value(force_array)&#10;&#10;            return values&#10;        except Exception as e:&#10;            print(f&quot;Error extracting force values: {e}&quot;)&#10;            return values&#10;&#10;    # Get all load combination names if not specified&#10;    if load_cases is None:&#10;        load_cases = set()&#10;        for node in structure.nodes:&#10;            if hasattr(node, 'displacements'):&#10;                load_cases.update(node.displacements.keys())&#10;        load_cases = list(load_cases)&#10;        print(f&quot;Found {len(load_cases)} load cases: {load_cases}&quot;)&#10;    # Handle case where LoadCombo objects are passed instead of names&#10;    elif all(hasattr(lc, 'name') for lc in load_cases):&#10;        load_cases = [lc.name for lc in load_cases]&#10;&#10;    # Extract node results&#10;    print(f&quot;Processing {len(structure.nodes)} nodes&quot;)&#10;    for node in structure.nodes:&#10;        node_data = {&#10;            &quot;coordinates&quot;: {&#10;                &quot;x&quot;: convert_unit_with_info(node.x, &quot;length&quot;),&#10;                &quot;y&quot;: convert_unit_with_info(node.y, &quot;length&quot;)&#10;            },&#10;            &quot;restraints&quot;: [int(r) for r in node.restraints] if hasattr(node, 'restraints') else [0, 0, 0],&#10;            &quot;displacements&quot;: {},&#10;            &quot;reactions&quot;: {}&#10;        }&#10;&#10;        # Add displacements for each load combo&#10;        if hasattr(node, 'displacements'):&#10;            for lc in load_cases:&#10;                if lc in node.displacements:&#10;                    node_data[&quot;displacements&quot;][lc] = {&#10;                        &quot;ux&quot;: convert_unit_with_info(node.displacements[lc][0], &quot;length&quot;),&#10;                        &quot;uy&quot;: convert_unit_with_info(node.displacements[lc][1], &quot;length&quot;),&#10;                        &quot;rz&quot;: convert_unit_with_info(node.displacements[lc][2], &quot;rotation&quot;)&#10;                    }&#10;&#10;        # Add reactions for each load combo&#10;        if hasattr(node, 'reactions'):&#10;            for lc in load_cases:&#10;                if lc in node.reactions:&#10;                    node_data[&quot;reactions&quot;][lc] = {&#10;                        &quot;rx&quot;: convert_unit_with_info(node.reactions[lc][0], &quot;force&quot;),&#10;                        &quot;ry&quot;: convert_unit_with_info(node.reactions[lc][1], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(node.reactions[lc][2], &quot;moment&quot;)&#10;                    }&#10;&#10;        results[&quot;nodes&quot;][str(node.uid)] = node_data&#10;&#10;    # Extract member results&#10;    print(f&quot;Processing {len(structure.members)} members&quot;)&#10;    for member in structure.members:&#10;        member_data = {&#10;            &quot;connectivity&quot;: {&#10;                &quot;i_node&quot;: int(member.inode.uid),&#10;                &quot;j_node&quot;: int(member.jnode.uid)&#10;            },&#10;            &quot;properties&quot;: {&#10;                &quot;length&quot;: convert_unit_with_info(member.length, &quot;length&quot;),&#10;                &quot;type&quot;: member.type if hasattr(member, 'type') else &quot;FRAME&quot;&#10;            },&#10;            &quot;forces&quot;: {}&#10;        }&#10;&#10;        # Add material and section properties&#10;        if hasattr(member, 'material'):&#10;            member_data[&quot;properties&quot;][&quot;material&quot;] = {&#10;                &quot;id&quot;: str(member.material.uid),&#10;                &quot;E&quot;: convert_unit_with_info(member.material.E, &quot;pressure&quot;)&#10;            }&#10;&#10;        if hasattr(member, 'section'):&#10;            member_data[&quot;properties&quot;][&quot;section&quot;] = {&#10;                &quot;id&quot;: str(member.section.uid),&#10;                &quot;area&quot;: convert_unit_with_info(member.section.Area, &quot;area&quot;),&#10;                &quot;Ixx&quot;: convert_unit_with_info(member.section.Ixx, &quot;moment_of_inertia&quot;)&#10;            }&#10;&#10;        # Add member hinges if applicable&#10;        if hasattr(member, 'hinges'):&#10;            member_data[&quot;properties&quot;][&quot;hinges&quot;] = [int(h) for h in member.hinges]&#10;&#10;        # Add forces for each load combo&#10;        for lc in load_cases:&#10;            # Process member forces if available&#10;            if hasattr(member, 'member_forces') and lc in member.member_forces:&#10;                forces = member.member_forces[lc]&#10;                force_values = extract_force_values(forces)&#10;&#10;                member_data[&quot;forces&quot;][lc] = {&#10;                    &quot;local&quot;: {&#10;                        &quot;i_node&quot;: {&#10;                            &quot;fx&quot;: convert_unit_with_info(force_values[0], &quot;force&quot;),&#10;                            &quot;fy&quot;: convert_unit_with_info(force_values[1], &quot;force&quot;),&#10;                            &quot;mz&quot;: convert_unit_with_info(force_values[2], &quot;moment&quot;)&#10;                        },&#10;                        &quot;j_node&quot;: {&#10;                            &quot;fx&quot;: convert_unit_with_info(force_values[3], &quot;force&quot;),&#10;                            &quot;fy&quot;: convert_unit_with_info(force_values[4], &quot;force&quot;),&#10;                            &quot;mz&quot;: convert_unit_with_info(force_values[5], &quot;moment&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;            # Add global forces if available&#10;            if hasattr(member, 'end_forces_global') and lc in member.end_forces_global:&#10;                forces_global = member.end_forces_global[lc]&#10;                global_values = extract_force_values(forces_global)&#10;&#10;                if &quot;forces&quot; not in member_data:&#10;                    member_data[&quot;forces&quot;] = {}&#10;                if lc not in member_data[&quot;forces&quot;]:&#10;                    member_data[&quot;forces&quot;][lc] = {}&#10;&#10;                member_data[&quot;forces&quot;][lc][&quot;global&quot;] = {&#10;                    &quot;i_node&quot;: {&#10;                        &quot;fx&quot;: convert_unit_with_info(global_values[0], &quot;force&quot;),&#10;                        &quot;fy&quot;: convert_unit_with_info(global_values[1], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(global_values[2], &quot;moment&quot;)&#10;                    },&#10;                    &quot;j_node&quot;: {&#10;                        &quot;fx&quot;: convert_unit_with_info(global_values[3], &quot;force&quot;),&#10;                        &quot;fy&quot;: convert_unit_with_info(global_values[4], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(global_values[5], &quot;moment&quot;)&#10;                    }&#10;                }&#10;&#10;            # Add distributed results if available&#10;            try:&#10;                # Only proceed if the member has generated these functions&#10;                if (hasattr(member, 'A') and lc in member.A and&#10;                    hasattr(member, 'Vy') and lc in member.Vy and&#10;                    hasattr(member, 'Mz') and lc in member.Mz):&#10;&#10;                    ax_func = member.A[lc]&#10;                    vy_func = member.Vy[lc]&#10;                    mz_func = member.Mz[lc]&#10;&#10;                    if ax_func and vy_func and mz_func:&#10;                        num_points = 21  # Number of points to sample along the member&#10;                        length = extract_value(member.length)&#10;                        x_vals = [length * i / (num_points - 1) for i in range(num_points)]&#10;&#10;                        if lc not in member_data[&quot;forces&quot;]:&#10;                            member_data[&quot;forces&quot;][lc] = {}&#10;&#10;                        member_data[&quot;forces&quot;][lc][&quot;distributed&quot;] = {&#10;                            &quot;positions&quot;: [convert_unit_with_info(x, &quot;length&quot;) for x in x_vals],&#10;                            &quot;axial&quot;: [convert_unit_with_info(ax_func.evaluate(x), &quot;force&quot;) for x in x_vals],&#10;                            &quot;shear&quot;: [convert_unit_with_info(vy_func.evaluate(x), &quot;force&quot;) for x in x_vals],&#10;                            &quot;moment&quot;: [convert_unit_with_info(mz_func.evaluate(x), &quot;moment&quot;) for x in x_vals]&#10;                        }&#10;&#10;                        # Add extreme moment values if available&#10;                        if hasattr(member, 'Mzextremes'):&#10;                            try:&#10;                                extremes = member.Mzextremes(lc)&#10;                                if extremes:&#10;                                    member_data[&quot;forces&quot;][lc][&quot;extremes&quot;] = {&#10;                                        &quot;max_moment&quot;: {&#10;                                            &quot;position&quot;: convert_unit_with_info(extremes[&quot;MaxM&quot;][0], &quot;length&quot;),&#10;                                            &quot;value&quot;: convert_unit_with_info(extremes[&quot;MaxM&quot;][1], &quot;moment&quot;)&#10;                                        },&#10;                                        &quot;min_moment&quot;: {&#10;                                            &quot;position&quot;: convert_unit_with_info(extremes[&quot;MinM&quot;][0], &quot;length&quot;),&#10;                                            &quot;value&quot;: convert_unit_with_info(extremes[&quot;MinM&quot;][1], &quot;moment&quot;)&#10;                                        }&#10;                                    }&#10;                            except Exception as e:&#10;                                print(f&quot;Error calculating moment extremes for member {member.uid}: {e}&quot;)&#10;            except Exception as e:&#10;                print(f&quot;Could not generate distributed results for member {member.uid}: {e}&quot;)&#10;&#10;        results[&quot;members&quot;][str(member.uid)] = member_data&#10;&#10;    # Create directory if it doesn't exist&#10;    os.makedirs(os.path.dirname(os.path.abspath(output_file)), exist_ok=True)&#10;&#10;    # Write to JSON file&#10;    print(f&quot;Writing results to {output_file}&quot;)&#10;    with open(output_file, 'w') as f:&#10;        json.dump(results, f, indent=2)&#10;&#10;    print(f&quot;Results successfully exported to {output_file}&quot;)&#10;    return output_file" />
              <option name="updatedContent" value="def export_results_to_json(structure, load_cases=None, output_file=None, convert_to_display_units=False, display_units=None):&#10;    &quot;&quot;&quot;&#10;    Export calculation results to a JSON file with Pint unit support,&#10;    including units next to magnitude values&#10;&#10;    Parameters&#10;    ----------&#10;    structure : R2Structure&#10;        The analyzed structure containing results&#10;    load_cases : list, optional&#10;        List of load case names to include in export (defaults to all)&#10;    output_file : str, optional&#10;        Path to output file (defaults to 'results.json')&#10;    convert_to_display_units : bool, optional&#10;        Whether to convert values to display units (default: False)&#10;    display_units : dict, optional&#10;        Dictionary of display units to use (default: None, uses system defaults)&#10;&#10;    Returns&#10;    -------&#10;    str&#10;        Path to the created JSON file&#10;    &quot;&quot;&quot;&#10;    import json&#10;    import numpy as np&#10;    import os&#10;&#10;    # Import the centralized unit manager&#10;    from pyMAOS import unit_manager&#10;    ureg = unit_manager.ureg&#10;&#10;    if output_file is None:&#10;        output_file = 'results.json'&#10;&#10;    print(f&quot;Starting export to JSON file: {output_file}&quot;)&#10;&#10;    # Get default display units if needed but not provided&#10;    if convert_to_display_units and display_units is None:&#10;        try:&#10;            from pyMAOS import unit_manager&#10;            display_units = unit_manager.current_system&#10;        except ImportError:&#10;            # Fallback to some standard display units&#10;            display_units = {&#10;                &quot;force&quot;: &quot;kN&quot;,&#10;                &quot;length&quot;: &quot;m&quot;,&#10;                &quot;moment&quot;: &quot;kN*m&quot;,&#10;                &quot;pressure&quot;: &quot;MPa&quot;,&#10;                &quot;area&quot;: &quot;cm^2&quot;,&#10;                &quot;moment_of_inertia&quot;: &quot;cm^4&quot;,&#10;                &quot;distributed_load&quot;: &quot;kN/m&quot;,&#10;                &quot;rotation&quot;: &quot;rad&quot;&#10;            }&#10;            print(f&quot;Using default display units: {display_units}&quot;)&#10;&#10;    # Define internal units based on the unit manager&#10;    internal_units = {&#10;        &quot;force&quot;: str(unit_manager.INTERNAL_FORCE_UNIT),&#10;        &quot;length&quot;: str(unit_manager.INTERNAL_LENGTH_UNIT),&#10;        &quot;moment&quot;: str(unit_manager.INTERNAL_MOMENT_UNIT),&#10;        &quot;pressure&quot;: str(unit_manager.INTERNAL_PRESSURE_UNIT),&#10;        &quot;area&quot;: f&quot;{unit_manager.INTERNAL_LENGTH_UNIT}^2&quot;,&#10;        &quot;moment_of_inertia&quot;: str(unit_manager.INTERNAL_MOMENT_OF_INERTIA_UNIT),&#10;        &quot;distributed_load&quot;: str(unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT),&#10;        &quot;rotation&quot;: str(unit_manager.INTERNAL_ROTATION_UNIT)&#10;    }&#10;&#10;    print(f&quot;Internal units: {internal_units}&quot;)&#10;    print(f&quot;Display units (if converting): {display_units}&quot;)&#10;&#10;    # Prepare data structure for JSON&#10;    results = {&#10;        &quot;units&quot;: display_units if convert_to_display_units else internal_units,&#10;        &quot;nodes&quot;: {},&#10;        &quot;members&quot;: {},&#10;        &quot;analysis_info&quot;: {&#10;            &quot;dof&quot;: structure.NDOF,&#10;            &quot;num_nodes&quot;: structure.NJ,&#10;            &quot;num_members&quot;: structure.NM&#10;        }&#10;    }&#10;&#10;    # Helper function to safely extract value from Pint quantities or regular values&#10;    def extract_value(val):&#10;        &quot;&quot;&quot;Extract numerical value from Pint quantities or regular values&quot;&quot;&quot;&#10;        try:&#10;            # Check if value has a 'magnitude' attribute (Pint Quantity)&#10;            if hasattr(val, 'magnitude'):&#10;                return float(val.magnitude)&#10;            # For numpy types&#10;            elif isinstance(val, (np.number, np.ndarray, np.matrix)):&#10;                return float(val)&#10;            else:&#10;                return float(val)&#10;        except Exception as e:&#10;            print(f&quot;Error extracting value: {e}, using 0.0&quot;)&#10;            return 0.0&#10;&#10;    # Unit conversion helper function&#10;    def convert_unit_with_info(value, dimension):&#10;        &quot;&quot;&quot;Convert value between unit systems and return both value and unit&quot;&quot;&quot;&#10;        try:&#10;            # Determine the unit based on conversion settings&#10;            unit = display_units[dimension] if convert_to_display_units else internal_units[dimension]&#10;&#10;            # Check if value is close to zero without direct float conversion&#10;            # Handle Pint quantities properly&#10;            if hasattr(value, 'magnitude'):&#10;                magnitude = value.magnitude&#10;            else:&#10;                try:&#10;                    magnitude = float(value)&#10;                except (TypeError, ValueError):&#10;                    print(f&quot;Warning: Could not convert {value} to float, using 0&quot;)&#10;                    magnitude = 0.0&#10;                &#10;            # Skip conversion for values very close to zero&#10;            if abs(magnitude) &lt; 1e-12:&#10;                return {&quot;value&quot;: 0.0, &quot;unit&quot;: unit}&#10;&#10;            # Extract the raw value&#10;            raw_value = extract_value(value)&#10;&#10;            # If conversion is requested, perform it&#10;            if convert_to_display_units:&#10;                source_unit = internal_units[dimension]&#10;                target_unit = display_units[dimension]&#10;&#10;                # Create quantity with source unit and convert to target unit&#10;                quantity = ureg.Quantity(raw_value, source_unit)&#10;                raw_value = quantity.to(target_unit).magnitude&#10;&#10;            # Return both value and unit&#10;            return {&quot;value&quot;: raw_value, &quot;unit&quot;: unit}&#10;        except Exception as e:&#10;            print(f&quot;Error converting {value} from {internal_units.get(dimension)} to {display_units.get(dimension)}: {e}&quot;)&#10;            unit = internal_units.get(dimension)&#10;            return {&quot;value&quot;: extract_value(value), &quot;unit&quot;: unit}&#10;&#10;    # Helper function to safely extract 6 force values from various array formats&#10;    def extract_force_values(force_array):&#10;        &quot;&quot;&quot;Extract 6 force values from various array formats with Pint support&quot;&quot;&quot;&#10;        values = [0.0] * 6&#10;&#10;        try:&#10;            # Handle Pint quantities in arrays&#10;            if hasattr(force_array, 'magnitude'):&#10;                force_array = force_array.magnitude&#10;&#10;            if isinstance(force_array, np.matrix):&#10;                array_data = np.array(force_array)&#10;                flat_data = array_data.flatten()&#10;                for i in range(min(6, len(flat_data))):&#10;                    values[i] = extract_value(flat_data[i])&#10;            elif isinstance(force_array, np.ndarray):&#10;                flat_data = force_array.flatten()&#10;                for i in range(min(6, len(flat_data))):&#10;                    values[i] = extract_value(flat_data[i])&#10;            elif hasattr(force_array, '__iter__'):&#10;                for i, val in enumerate(force_array):&#10;                    if i &gt;= 6: break&#10;                    values[i] = extract_value(val)&#10;            else:&#10;                # Single value or unknown type&#10;                values[0] = extract_value(force_array)&#10;&#10;            return values&#10;        except Exception as e:&#10;            print(f&quot;Error extracting force values: {e}&quot;)&#10;            return values&#10;&#10;    # Get all load combination names if not specified&#10;    if load_cases is None:&#10;        load_cases = set()&#10;        for node in structure.nodes:&#10;            if hasattr(node, 'displacements'):&#10;                load_cases.update(node.displacements.keys())&#10;        load_cases = list(load_cases)&#10;        print(f&quot;Found {len(load_cases)} load cases: {load_cases}&quot;)&#10;    # Handle case where LoadCombo objects are passed instead of names&#10;    elif all(hasattr(lc, 'name') for lc in load_cases):&#10;        load_cases = [lc.name for lc in load_cases]&#10;&#10;    # Extract node results&#10;    print(f&quot;Processing {len(structure.nodes)} nodes&quot;)&#10;    for node in structure.nodes:&#10;        node_data = {&#10;            &quot;coordinates&quot;: {&#10;                &quot;x&quot;: convert_unit_with_info(node.x, &quot;length&quot;),&#10;                &quot;y&quot;: convert_unit_with_info(node.y, &quot;length&quot;)&#10;            },&#10;            &quot;restraints&quot;: [int(r) for r in node.restraints] if hasattr(node, 'restraints') else [0, 0, 0],&#10;            &quot;displacements&quot;: {},&#10;            &quot;reactions&quot;: {}&#10;        }&#10;&#10;        # Add displacements for each load combo&#10;        if hasattr(node, 'displacements'):&#10;            for lc in load_cases:&#10;                if lc in node.displacements:&#10;                    node_data[&quot;displacements&quot;][lc] = {&#10;                        &quot;ux&quot;: convert_unit_with_info(node.displacements[lc][0], &quot;length&quot;),&#10;                        &quot;uy&quot;: convert_unit_with_info(node.displacements[lc][1], &quot;length&quot;),&#10;                        &quot;rz&quot;: convert_unit_with_info(node.displacements[lc][2], &quot;rotation&quot;)&#10;                    }&#10;&#10;        # Add reactions for each load combo&#10;        if hasattr(node, 'reactions'):&#10;            for lc in load_cases:&#10;                if lc in node.reactions:&#10;                    node_data[&quot;reactions&quot;][lc] = {&#10;                        &quot;rx&quot;: convert_unit_with_info(node.reactions[lc][0], &quot;force&quot;),&#10;                        &quot;ry&quot;: convert_unit_with_info(node.reactions[lc][1], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(node.reactions[lc][2], &quot;moment&quot;)&#10;                    }&#10;&#10;        results[&quot;nodes&quot;][str(node.uid)] = node_data&#10;&#10;    # Extract member results&#10;    print(f&quot;Processing {len(structure.members)} members&quot;)&#10;    for member in structure.members:&#10;        member_data = {&#10;            &quot;connectivity&quot;: {&#10;                &quot;i_node&quot;: int(member.inode.uid),&#10;                &quot;j_node&quot;: int(member.jnode.uid)&#10;            },&#10;            &quot;properties&quot;: {&#10;                &quot;length&quot;: convert_unit_with_info(member.length, &quot;length&quot;),&#10;                &quot;type&quot;: member.type if hasattr(member, 'type') else &quot;FRAME&quot;&#10;            },&#10;            &quot;forces&quot;: {}&#10;        }&#10;&#10;        # Add material and section properties&#10;        if hasattr(member, 'material'):&#10;            member_data[&quot;properties&quot;][&quot;material&quot;] = {&#10;                &quot;id&quot;: str(member.material.uid),&#10;                &quot;E&quot;: convert_unit_with_info(member.material.E, &quot;pressure&quot;)&#10;            }&#10;&#10;        if hasattr(member, 'section'):&#10;            member_data[&quot;properties&quot;][&quot;section&quot;] = {&#10;                &quot;id&quot;: str(member.section.uid),&#10;                &quot;area&quot;: convert_unit_with_info(member.section.Area, &quot;area&quot;),&#10;                &quot;Ixx&quot;: convert_unit_with_info(member.section.Ixx, &quot;moment_of_inertia&quot;)&#10;            }&#10;&#10;        # Add member hinges if applicable&#10;        if hasattr(member, 'hinges'):&#10;            member_data[&quot;properties&quot;][&quot;hinges&quot;] = [int(h) for h in member.hinges]&#10;&#10;        # Add forces for each load combo&#10;        for lc in load_cases:&#10;            # Process member forces if available&#10;            if hasattr(member, 'member_forces') and lc in member.member_forces:&#10;                forces = member.member_forces[lc]&#10;                force_values = extract_force_values(forces)&#10;&#10;                member_data[&quot;forces&quot;][lc] = {&#10;                    &quot;local&quot;: {&#10;                        &quot;i_node&quot;: {&#10;                            &quot;fx&quot;: convert_unit_with_info(force_values[0], &quot;force&quot;),&#10;                            &quot;fy&quot;: convert_unit_with_info(force_values[1], &quot;force&quot;),&#10;                            &quot;mz&quot;: convert_unit_with_info(force_values[2], &quot;moment&quot;)&#10;                        },&#10;                        &quot;j_node&quot;: {&#10;                            &quot;fx&quot;: convert_unit_with_info(force_values[3], &quot;force&quot;),&#10;                            &quot;fy&quot;: convert_unit_with_info(force_values[4], &quot;force&quot;),&#10;                            &quot;mz&quot;: convert_unit_with_info(force_values[5], &quot;moment&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;            # Add global forces if available&#10;            if hasattr(member, 'end_forces_global') and lc in member.end_forces_global:&#10;                forces_global = member.end_forces_global[lc]&#10;                global_values = extract_force_values(forces_global)&#10;&#10;                if &quot;forces&quot; not in member_data:&#10;                    member_data[&quot;forces&quot;] = {}&#10;                if lc not in member_data[&quot;forces&quot;]:&#10;                    member_data[&quot;forces&quot;][lc] = {}&#10;&#10;                member_data[&quot;forces&quot;][lc][&quot;global&quot;] = {&#10;                    &quot;i_node&quot;: {&#10;                        &quot;fx&quot;: convert_unit_with_info(global_values[0], &quot;force&quot;),&#10;                        &quot;fy&quot;: convert_unit_with_info(global_values[1], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(global_values[2], &quot;moment&quot;)&#10;                    },&#10;                    &quot;j_node&quot;: {&#10;                        &quot;fx&quot;: convert_unit_with_info(global_values[3], &quot;force&quot;),&#10;                        &quot;fy&quot;: convert_unit_with_info(global_values[4], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(global_values[5], &quot;moment&quot;)&#10;                    }&#10;                }&#10;&#10;            # Add distributed results if available&#10;            try:&#10;                # Only proceed if the member has generated these functions&#10;                if (hasattr(member, 'A') and lc in member.A and&#10;                    hasattr(member, 'Vy') and lc in member.Vy and&#10;                    hasattr(member, 'Mz') and lc in member.Mz):&#10;&#10;                    ax_func = member.A[lc]&#10;                    vy_func = member.Vy[lc]&#10;                    mz_func = member.Mz[lc]&#10;&#10;                    if ax_func and vy_func and mz_func:&#10;                        num_points = 21  # Number of points to sample along the member&#10;                        length = extract_value(member.length)&#10;                        x_vals = [length * i / (num_points - 1) for i in range(num_points)]&#10;&#10;                        if lc not in member_data[&quot;forces&quot;]:&#10;                            member_data[&quot;forces&quot;][lc] = {}&#10;&#10;                        member_data[&quot;forces&quot;][lc][&quot;distributed&quot;] = {&#10;                            &quot;positions&quot;: [convert_unit_with_info(x, &quot;length&quot;) for x in x_vals],&#10;                            &quot;axial&quot;: [convert_unit_with_info(ax_func.evaluate(x), &quot;force&quot;) for x in x_vals],&#10;                            &quot;shear&quot;: [convert_unit_with_info(vy_func.evaluate(x), &quot;force&quot;) for x in x_vals],&#10;                            &quot;moment&quot;: [convert_unit_with_info(mz_func.evaluate(x), &quot;moment&quot;) for x in x_vals]&#10;                        }&#10;&#10;                        # Add extreme moment values if available&#10;                        if hasattr(member, 'Mzextremes'):&#10;                            try:&#10;                                extremes = member.Mzextremes(lc)&#10;                                if extremes:&#10;                                    member_data[&quot;forces&quot;][lc][&quot;extremes&quot;] = {&#10;                                        &quot;max_moment&quot;: {&#10;                                            &quot;position&quot;: convert_unit_with_info(extremes[&quot;MaxM&quot;][0], &quot;length&quot;),&#10;                                            &quot;value&quot;: convert_unit_with_info(extremes[&quot;MaxM&quot;][1], &quot;moment&quot;)&#10;                                        },&#10;                                        &quot;min_moment&quot;: {&#10;                                            &quot;position&quot;: convert_unit_with_info(extremes[&quot;MinM&quot;][0], &quot;length&quot;),&#10;                                            &quot;value&quot;: convert_unit_with_info(extremes[&quot;MinM&quot;][1], &quot;moment&quot;)&#10;                                        }&#10;                                    }&#10;                            except Exception as e:&#10;                                print(f&quot;Error calculating moment extremes for member {member.uid}: {e}&quot;)&#10;            except Exception as e:&#10;                print(f&quot;Could not generate distributed results for member {member.uid}: {e}&quot;)&#10;&#10;        results[&quot;members&quot;][str(member.uid)] = member_data&#10;&#10;    # Create directory if it doesn't exist&#10;    os.makedirs(os.path.dirname(os.path.abspath(output_file)), exist_ok=True)&#10;&#10;    # Write to JSON file&#10;    print(f&quot;Writing results to {output_file}&quot;)&#10;    with open(output_file, 'w') as f:&#10;        json.dump(results, f, indent=2)&#10;&#10;    print(f&quot;Results successfully exported to {output_file}&quot;)&#10;    return output_file" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>