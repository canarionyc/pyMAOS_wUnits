<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Stairways/cantilevered_stairway_LR.JSON">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Stairways/cantilevered_stairway_LR.JSON" />
              <option name="updatedContent" value="{&#10;    &quot;design_parameters&quot;: {&#10;        &quot;name&quot;: &quot;Cantilevered Stairway Left to Right&quot;,&#10;        &quot;author&quot;: &quot;Structural Design Assistant&quot;,&#10;        &quot;description&quot;: &quot;Stairway descending left to right, attached to wall on back side&quot;&#10;    },&#10;&#10;    &quot;units&quot;: {&#10;        &quot;force&quot;: &quot;kip&quot;,&#10;        &quot;length&quot;: &quot;ft&quot;,&#10;        &quot;pressure&quot;: &quot;ksi&quot;&#10;    },&#10;&#10;    &quot;nodes&quot;: [&#10;        {&quot;id&quot;: 1, &quot;x&quot;: &quot;0 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;        {&quot;id&quot;: 2, &quot;x&quot;: &quot;0 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;        {&quot;id&quot;: 3, &quot;x&quot;: &quot;5 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;        {&quot;id&quot;: 4, &quot;x&quot;: &quot;5 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;&#10;        {&quot;id&quot;: 5, &quot;x&quot;: &quot;5 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;        {&quot;id&quot;: 6, &quot;x&quot;: &quot;5 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;        {&quot;id&quot;: 7, &quot;x&quot;: &quot;6.67 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;6.42 ft&quot;},&#10;        {&quot;id&quot;: 8, &quot;x&quot;: &quot;6.67 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;6.42 ft&quot;},&#10;        {&quot;id&quot;: 9, &quot;x&quot;: &quot;8.33 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;5.83 ft&quot;},&#10;        {&quot;id&quot;: 10, &quot;x&quot;: &quot;8.33 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;5.83 ft&quot;},&#10;        {&quot;id&quot;: 11, &quot;x&quot;: &quot;10 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;5.25 ft&quot;},&#10;        {&quot;id&quot;: 12, &quot;x&quot;: &quot;10 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;5.25 ft&quot;},&#10;        {&quot;id&quot;: 13, &quot;x&quot;: &quot;11.67 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;4.67 ft&quot;},&#10;        {&quot;id&quot;: 14, &quot;x&quot;: &quot;11.67 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;4.67 ft&quot;},&#10;        {&quot;id&quot;: 15, &quot;x&quot;: &quot;13.33 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;4.08 ft&quot;},&#10;        {&quot;id&quot;: 16, &quot;x&quot;: &quot;13.33 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;4.08 ft&quot;},&#10;        {&quot;id&quot;: 17, &quot;x&quot;: &quot;15 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;3.5 ft&quot;},&#10;        {&quot;id&quot;: 18, &quot;x&quot;: &quot;15 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;3.5 ft&quot;},&#10;        {&quot;id&quot;: 19, &quot;x&quot;: &quot;16.67 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;2.92 ft&quot;},&#10;        {&quot;id&quot;: 20, &quot;x&quot;: &quot;16.67 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;2.92 ft&quot;},&#10;        {&quot;id&quot;: 21, &quot;x&quot;: &quot;18.33 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;2.33 ft&quot;},&#10;        {&quot;id&quot;: 22, &quot;x&quot;: &quot;18.33 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;2.33 ft&quot;},&#10;        {&quot;id&quot;: 23, &quot;x&quot;: &quot;20 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;1.75 ft&quot;},&#10;        {&quot;id&quot;: 24, &quot;x&quot;: &quot;20 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;1.75 ft&quot;},&#10;        {&quot;id&quot;: 25, &quot;x&quot;: &quot;21.67 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;1.17 ft&quot;},&#10;        {&quot;id&quot;: 26, &quot;x&quot;: &quot;21.67 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;1.17 ft&quot;},&#10;        {&quot;id&quot;: 27, &quot;x&quot;: &quot;23.33 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;0.58 ft&quot;},&#10;        {&quot;id&quot;: 28, &quot;x&quot;: &quot;23.33 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;0.58 ft&quot;},&#10;&#10;        {&quot;id&quot;: 29, &quot;x&quot;: &quot;25 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;0 ft&quot;},&#10;        {&quot;id&quot;: 30, &quot;x&quot;: &quot;25 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;0 ft&quot;},&#10;        {&quot;id&quot;: 31, &quot;x&quot;: &quot;30 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;0 ft&quot;},&#10;        {&quot;id&quot;: 32, &quot;x&quot;: &quot;30 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;0 ft&quot;},&#10;        {&quot;id&quot;: 33, &quot;x&quot;: &quot;0 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;0 ft&quot;}&#10;    ],&#10;    &#10;    &quot;supports&quot;: [&#10;        {&quot;node&quot;: 2, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 6, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 10, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 14, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 18, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 22, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 26, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 30, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 31, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 32, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 33, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0}&#10;    ],&#10;&#10;    &quot;members&quot;: [&#10;        {&quot;id&quot;: 1, &quot;i_node&quot;: 1, &quot;j_node&quot;: 2, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 2, &quot;i_node&quot;: 3, &quot;j_node&quot;: 4, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 3, &quot;i_node&quot;: 1, &quot;j_node&quot;: 3, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 4, &quot;i_node&quot;: 2, &quot;j_node&quot;: 4, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;&#10;        {&quot;id&quot;: 5, &quot;i_node&quot;: 5, &quot;j_node&quot;: 7, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 6, &quot;i_node&quot;: 7, &quot;j_node&quot;: 9, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 7, &quot;i_node&quot;: 9, &quot;j_node&quot;: 11, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 8, &quot;i_node&quot;: 11, &quot;j_node&quot;: 13, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 9, &quot;i_node&quot;: 13, &quot;j_node&quot;: 15, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 10, &quot;i_node&quot;: 15, &quot;j_node&quot;: 17, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 11, &quot;i_node&quot;: 17, &quot;j_node&quot;: 19, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 12, &quot;i_node&quot;: 19, &quot;j_node&quot;: 21, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 13, &quot;i_node&quot;: 21, &quot;j_node&quot;: 23, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 14, &quot;i_node&quot;: 23, &quot;j_node&quot;: 25, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 15, &quot;i_node&quot;: 25, &quot;j_node&quot;: 27, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 16, &quot;i_node&quot;: 27, &quot;j_node&quot;: 29, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;&#10;        {&quot;id&quot;: 17, &quot;i_node&quot;: 6, &quot;j_node&quot;: 8, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 18, &quot;i_node&quot;: 8, &quot;j_node&quot;: 10, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 19, &quot;i_node&quot;: 10, &quot;j_node&quot;: 12, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 20, &quot;i_node&quot;: 12, &quot;j_node&quot;: 14, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 21, &quot;i_node&quot;: 14, &quot;j_node&quot;: 16, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 22, &quot;i_node&quot;: 16, &quot;j_node&quot;: 18, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 23, &quot;i_node&quot;: 18, &quot;j_node&quot;: 20, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 24, &quot;i_node&quot;: 20, &quot;j_node&quot;: 22, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 25, &quot;i_node&quot;: 22, &quot;j_node&quot;: 24, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 26, &quot;i_node&quot;: 24, &quot;j_node&quot;: 26, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 27, &quot;i_node&quot;: 26, &quot;j_node&quot;: 28, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 28, &quot;i_node&quot;: 28, &quot;j_node&quot;: 30, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;&#10;        {&quot;id&quot;: 29, &quot;i_node&quot;: 5, &quot;j_node&quot;: 6, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 30, &quot;i_node&quot;: 7, &quot;j_node&quot;: 8, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 31, &quot;i_node&quot;: 9, &quot;j_node&quot;: 10, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 32, &quot;i_node&quot;: 11, &quot;j_node&quot;: 12, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 33, &quot;i_node&quot;: 13, &quot;j_node&quot;: 14, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 34, &quot;i_node&quot;: 15, &quot;j_node&quot;: 16, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 35, &quot;i_node&quot;: 17, &quot;j_node&quot;: 18, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 36, &quot;i_node&quot;: 19, &quot;j_node&quot;: 20, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 37, &quot;i_node&quot;: 21, &quot;j_node&quot;: 22, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 38, &quot;i_node&quot;: 23, &quot;j_node&quot;: 24, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 39, &quot;i_node&quot;: 25, &quot;j_node&quot;: 26, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 40, &quot;i_node&quot;: 27, &quot;j_node&quot;: 28, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;&#10;        {&quot;id&quot;: 41, &quot;i_node&quot;: 29, &quot;j_node&quot;: 31, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 42, &quot;i_node&quot;: 30, &quot;j_node&quot;: 32, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 43, &quot;i_node&quot;: 29, &quot;j_node&quot;: 30, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 44, &quot;i_node&quot;: 31, &quot;j_node&quot;: 32, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;&#10;        {&quot;id&quot;: 45, &quot;i_node&quot;: 33, &quot;j_node&quot;: 3, &quot;material&quot;: 1, &quot;section&quot;: 5},&#10;        &#10;        {&quot;id&quot;: 46, &quot;i_node&quot;: 5, &quot;j_node&quot;: 10, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 47, &quot;i_node&quot;: 6, &quot;j_node&quot;: 9, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 48, &quot;i_node&quot;: 11, &quot;j_node&quot;: 16, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 49, &quot;i_node&quot;: 12, &quot;j_node&quot;: 15, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 50, &quot;i_node&quot;: 17, &quot;j_node&quot;: 22, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 51, &quot;i_node&quot;: 18, &quot;j_node&quot;: 21, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 52, &quot;i_node&quot;: 23, &quot;j_node&quot;: 28, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 53, &quot;i_node&quot;: 24, &quot;j_node&quot;: 27, &quot;material&quot;: 1, &quot;section&quot;: 4}&#10;    ],&#10;&#10;    &quot;member_loads&quot;: [&#10;        {&quot;member_uid&quot;: 1, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 2, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 3, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;5 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 4, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;5 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        &#10;        {&quot;member_uid&quot;: 29, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 30, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 31, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 32, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 33, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 34, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 35, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 36, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 37, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 38, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 39, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 40, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        &#10;        {&quot;member_uid&quot;: 43, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 44, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;}&#10;    ],&#10;&#10;    &quot;sections&quot;: [&#10;        {&quot;id&quot;: 1, &quot;area&quot;: &quot;7.65 in^2&quot;, &quot;r&quot;: &quot;4.91 in&quot;},&#10;        {&quot;id&quot;: 2, &quot;area&quot;: &quot;5.61 in^2&quot;, &quot;r&quot;: &quot;3.02 in&quot;},&#10;        {&quot;id&quot;: 3, &quot;area&quot;: &quot;4.44 in^2&quot;, &quot;r&quot;: &quot;2.48 in&quot;},&#10;        {&quot;id&quot;: 4, &quot;area&quot;: &quot;3.75 in^2&quot;, &quot;r&quot;: &quot;1.22 in&quot;},&#10;        {&quot;id&quot;: 5, &quot;area&quot;: &quot;10.3 in^2&quot;, &quot;r&quot;: &quot;4.19 in&quot;}&#10;    ],&#10;    &#10;    &quot;materials&quot;: [&#10;        {&#10;            &quot;id&quot;: 1,&#10;            &quot;type&quot;: &quot;isotropic&quot;,&#10;            &quot;E&quot;: &quot;29000 ksi&quot;,&#10;            &quot;G&quot;: &quot;11500 ksi&quot;,&#10;            &quot;nu&quot;: 0.27,&#10;            &quot;rho&quot;: &quot;0.000284 kip/in^3&quot;,&#10;            &quot;alpha&quot;: &quot;0.0000065 1/F&quot;&#10;        }&#10;    ]&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Stairways/run_stairway_interactive.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Stairways/run_stairway_interactive.py" />
              <option name="originalContent" value="# Interactive stairway structure visualization and editing tool&#10;&#10;import os&#10;import json&#10;import sys&#10;import re&#10;import matplotlib&#10;# Force use of TkAgg backend which has better interactive support&#10;matplotlib.use('TkAgg')&#10;import matplotlib.pyplot as plt&#10;from matplotlib.widgets import Button, RadioButtons, Slider, TextBox&#10;from mpl_toolkits.mplot3d import Axes3D&#10;import scipy as sp&#10;import numpy as np&#10;import datetime&#10;&#10;# Import proj3d for 3D to 2D projections&#10;try:&#10;    from mpl_toolkits.mplot3d import proj3d&#10;except ImportError:&#10;    print(&quot;Warning: Could not import proj3d, some 3D functions may be limited&quot;)&#10;&#10;# Global debug flag - set to True for verbose output&#10;DEBUG = True&#10;&#10;def debug_print(*args, **kwargs):&#10;    &quot;&quot;&quot;Helper function for debug printing that respects the global DEBUG flag&quot;&quot;&quot;&#10;    if DEBUG:&#10;        print(*args, **kwargs)&#10;&#10;class StairwayInteractiveVisualizer:&#10;    def __init__(self, json_file):&#10;        debug_print(f&quot;Initializing visualizer with file: {json_file}&quot;)&#10;        self.json_file = json_file&#10;        self.load_data()&#10;&#10;        # Initialize state variables&#10;        self.selected_node = None&#10;        self.selected_member = None&#10;        self.mode = 'view'  # 'view', 'move', 'add_node', 'add_member', 'delete_node', 'delete_member'&#10;&#10;        # For member creation&#10;        self.member_creation_nodes = []&#10;        self.next_member_id = max([m['id'] for m in self.members], default=0) + 1&#10;&#10;        # Create the figure and 3D axes&#10;        self.fig = plt.figure(figsize=(16, 10))&#10;        debug_print(&quot;Figure created&quot;)&#10;        self.ax = self.fig.add_subplot(111, projection='3d')&#10;        debug_print(&quot;3D axes created&quot;)&#10;&#10;        # Setup UI before connecting events&#10;        self.setup_ui()&#10;        debug_print(&quot;UI setup complete&quot;)&#10;&#10;        # Connect event handlers&#10;        debug_print(&quot;Connecting event handlers&quot;)&#10;        self.click_cid = self.fig.canvas.mpl_connect('button_press_event', self.on_click)&#10;        self.motion_cid = self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)&#10;        self.key_cid = self.fig.canvas.mpl_connect('key_press_event', self.on_key)&#10;        self.draw_cid = self.fig.canvas.mpl_connect('draw_event', self.on_draw)&#10;        debug_print(f&quot;Event handlers connected: {self.click_cid}, {self.motion_cid}, {self.key_cid}, {self.draw_cid}&quot;)&#10;&#10;        # Plot the stairway structure last&#10;        self.plot_stairway()&#10;&#10;        # Show debug message when initialization is complete&#10;        debug_print(&quot;Visualizer initialization complete&quot;)&#10;&#10;    def on_draw(self, event):&#10;        &quot;&quot;&quot;Debug handler for draw events&quot;&quot;&quot;&#10;        debug_print(&quot;Draw event occurred&quot;)&#10;&#10;    def load_data(self):&#10;        &quot;&quot;&quot;Load stairway data from JSON file&quot;&quot;&quot;&#10;        print(f&quot;Loading stairway structure from {self.json_file}&quot;)&#10;&#10;        try:&#10;            # Remove comments if present in the JSON file&#10;            with open(os.path.join(os.path.dirname(__file__), self.json_file), 'r') as file:&#10;                json_str = &quot;&quot;&#10;                for line in file:&#10;                    if '//' not in line:&#10;                        json_str += line&#10;&#10;                self.stairway_data = json.loads(json_str)&#10;&#10;            # Extract structure data&#10;            self.nodes = self.stairway_data['nodes']&#10;            self.supports = self.stairway_data['supports']&#10;            self.members = self.stairway_data['members']&#10;            self.materials = self.stairway_data.get('materials', [])&#10;            self.sections = self.stairway_data.get('sections', [])&#10;&#10;            # Create node dictionary for quick lookups&#10;            self.node_dict = {}&#10;            for node in self.nodes:&#10;                node_id = node['id']&#10;                x = float(node['x'].split()[0])&#10;                y = float(node['y'].split()[0])&#10;                z = float(node['z'].split()[0])&#10;                self.node_dict[node_id] = (x, y, z)&#10;&#10;            # Create dictionaries for materials and sections&#10;            self.material_dict = {m['id']: m for m in self.materials}&#10;            self.section_dict = {s['id']: s for s in self.sections}&#10;&#10;            # Create set of supported nodes&#10;            self.supported_nodes = {s['node'] for s in self.supports}&#10;&#10;            # Create map of connected members for each node&#10;            self.node_connections = {}&#10;            for node_id in self.node_dict:&#10;                self.node_connections[node_id] = []&#10;&#10;            for member in self.members:&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                member_id = member['id']&#10;&#10;                if i_node in self.node_connections:&#10;                    self.node_connections[i_node].append(member_id)&#10;                if j_node in self.node_connections:&#10;                    self.node_connections[j_node].append(member_id)&#10;&#10;            print(f&quot;Successfully loaded: {self.stairway_data['design_parameters']['name']}&quot;)&#10;            print(f&quot;Structure contains {len(self.nodes)} nodes, {len(self.members)} members, and {len(self.supports)} supports&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error loading JSON file: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            sys.exit(1)&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;Set up the UI elements for interactive editing&quot;&quot;&quot;&#10;        # Create a smaller subplot for buttons&#10;        self.button_area = plt.axes([0.01, 0.01, 0.20, 0.20])&#10;        self.button_area.axis('off')&#10;&#10;        # Mode selection radio buttons - add member modes&#10;        self.mode_radio_ax = plt.axes([0.01, 0.80, 0.15, 0.15])&#10;        self.mode_radio = RadioButtons(&#10;            self.mode_radio_ax,&#10;            ['View', 'Move Node', 'Add Node', 'Add Member', 'Delete Node', 'Delete Member'],&#10;            activecolor='green'&#10;        )&#10;        self.mode_radio.on_clicked(self.set_mode)&#10;&#10;        # Section selection for new members&#10;        self.section_radio_ax = plt.axes([0.01, 0.55, 0.15, 0.10])&#10;        self.section_radio = RadioButtons(&#10;            self.section_radio_ax,&#10;            ['Section 1', 'Section 2', 'Section 3', 'Section 4', 'Section 5'],&#10;            activecolor='blue'&#10;        )&#10;        self.section_radio.on_clicked(lambda label: debug_print(f&quot;Section changed to: {label}&quot;))&#10;&#10;        # Save button&#10;        self.save_button_ax = plt.axes([0.01, 0.70, 0.15, 0.05])&#10;        self.save_button = Button(self.save_button_ax, 'Save Structure')&#10;        self.save_button.on_clicked(self.save_structure)&#10;&#10;        # Reset view button&#10;        self.reset_view_ax = plt.axes([0.01, 0.65, 0.15, 0.05])&#10;        self.reset_view_button = Button(self.reset_view_ax, 'Reset View')&#10;        self.reset_view_button.on_clicked(self.reset_view)&#10;&#10;        # Information panel&#10;        self.info_ax = plt.axes([0.01, 0.05, 0.20, 0.45])&#10;        self.info_ax.axis('off')&#10;        self.info_text = self.info_ax.text(&#10;            0, 1,&#10;            &quot;Interactive Stairway Editor\n\nClick on a node to select it\n&quot;&#10;            &quot;Use the mode buttons to change actions\n&quot;&#10;            &quot;Hotkeys: v=View, m=Move, a=Add, d=Delete&quot;,&#10;            va='top'&#10;        )&#10;&#10;        # Node editor panel (initially hidden)&#10;        self.node_editor_ax = plt.axes([0.85, 0.65, 0.14, 0.30])&#10;        self.node_editor_ax.axis('off')&#10;        self.node_editor_title = self.node_editor_ax.text(0, 1.1, &quot;Node Editor&quot;, fontsize=10, weight='bold')&#10;        self.node_editor_ax.set_visible(False)&#10;&#10;        # X coordinate slider&#10;        self.x_slider_ax = plt.axes([0.87, 0.85, 0.10, 0.03])&#10;        self.x_slider = Slider(self.x_slider_ax, 'X', 0, 30, valinit=0)&#10;        self.x_slider.on_changed(self.update_node_position)&#10;        self.x_slider_ax.set_visible(False)&#10;&#10;        # Y coordinate slider&#10;        self.y_slider_ax = plt.axes([0.87, 0.80, 0.10, 0.03])&#10;        self.y_slider = Slider(self.y_slider_ax, 'Y', 0, 10, valinit=0)&#10;        self.y_slider.on_changed(self.update_node_position)&#10;        self.y_slider_ax.set_visible(False)&#10;&#10;        # Z coordinate slider&#10;        self.z_slider_ax = plt.axes([0.87, 0.75, 0.10, 0.03])&#10;        self.z_slider = Slider(self.z_slider_ax, 'Z', 0, 10, valinit=0)&#10;        self.z_slider.on_changed(self.update_node_position)&#10;        self.z_slider_ax.set_visible(False)&#10;&#10;    def set_mode(self, mode_label):&#10;        &quot;&quot;&quot;Change the current editing mode&quot;&quot;&quot;&#10;        debug_print(f&quot;\n----- Mode change: {mode_label} -----&quot;)&#10;        mode_map = {&#10;            'View': 'view',&#10;            'Move Node': 'move',&#10;            'Add Node': 'add_node',&#10;            'Add Member': 'add_member',&#10;            'Delete Node': 'delete_node',&#10;            'Delete Member': 'delete_member'&#10;        }&#10;        self.mode = mode_map[mode_label]&#10;        debug_print(f&quot;Mode changed to: {self.mode}&quot;)&#10;&#10;        # Reset state when changing modes&#10;        if self.mode == 'add_member':&#10;            self.member_creation_nodes = []&#10;            debug_print(&quot;Member creation state reset - select two nodes to create a member&quot;)&#10;        elif self.mode != 'move':&#10;            self.hide_node_editor()&#10;&#10;        # Keep appropriate selections based on mode&#10;        if self.mode.startswith('delete_node') and self.selected_member:&#10;            self.selected_member = None  # Clear member selection in node modes&#10;        elif self.mode.startswith('delete_member') and self.selected_node:&#10;            self.selected_node = None    # Clear node selection in member modes&#10;&#10;        # Handle mode-specific actions&#10;        if self.mode == 'move' and self.selected_node:&#10;            debug_print(f&quot;Showing node editor for node {self.selected_node}&quot;)&#10;            self.show_node_editor()&#10;        elif self.mode == 'delete_node' and self.selected_node:&#10;            debug_print(f&quot;Deleting node {self.selected_node}&quot;)&#10;            self.delete_node()&#10;        elif self.mode == 'delete_member' and self.selected_member:&#10;            debug_print(f&quot;Deleting member {self.selected_member}&quot;)&#10;            self.delete_member()&#10;&#10;        self.update_info_text()&#10;        self.plot_stairway()  # Redraw to show/hide appropriate elements&#10;        debug_print(&quot;Calling plt.draw() after mode change&quot;)&#10;        plt.draw()&#10;&#10;    def update_info_text(self):&#10;        &quot;&quot;&quot;Update the information panel text based on current state&quot;&quot;&quot;&#10;        info = f&quot;Mode: {self.mode.capitalize().replace('_', ' ')}\n\n&quot;&#10;&#10;        if self.mode == 'add_member':&#10;            info += f&quot;Creating new member - &quot;&#10;            if len(self.member_creation_nodes) == 0:&#10;                info += &quot;Select first node\n&quot;&#10;            elif len(self.member_creation_nodes) == 1:&#10;                info += f&quot;Node {self.member_creation_nodes[0]} selected\nSelect second node\n&quot;&#10;&#10;        if self.selected_node:&#10;            node_pos = self.node_dict[self.selected_node]&#10;            info += f&quot;Selected Node: {self.selected_node}\n&quot;&#10;            info += f&quot;Position: ({node_pos[0]:.2f}, {node_pos[1]:.2f}, {node_pos[2]:.2f})\n&quot;&#10;            info += f&quot;Connected to {len(self.node_connections[self.selected_node])} members\n&quot;&#10;&#10;            if self.selected_node in self.supported_nodes:&#10;                info += &quot;This node has support constraints\n&quot;&#10;        elif self.selected_member:&#10;            member = next((m for m in self.members if m['id'] == self.selected_member), None)&#10;            if member:&#10;                info += f&quot;Selected Member: {self.selected_member}\n&quot;&#10;                info += f&quot;Connects nodes: {member['i_node']} - {member['j_node']}\n&quot;&#10;                info += f&quot;Section: {member['section']}, Material: {member['material']}\n&quot;&#10;&#10;                # Get member length&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                if i_node in self.node_dict and j_node in self.node_dict:&#10;                    x1, y1, z1 = self.node_dict[i_node]&#10;                    x2, y2, z2 = self.node_dict[j_node]&#10;                    length = np.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)&#10;                    info += f&quot;Length: {length:.2f} ft\n&quot;&#10;&#10;        self.info_text.set_text(info)&#10;        plt.draw()&#10;&#10;    def plot_stairway(self):&#10;        &quot;&quot;&quot;Plot the stairway structure&quot;&quot;&quot;&#10;        self.ax.clear()&#10;&#10;        # Define colors and widths for different section types&#10;        section_colors = {&#10;            1: 'blue',    # Main stringers&#10;            2: 'green',   # Steps/treads&#10;            3: 'cyan',    # Secondary members&#10;            4: 'gray',    # Bracing&#10;            5: 'red'      # Column&#10;        }&#10;&#10;        section_widths = {&#10;            1: 2,         # Main stringers&#10;            2: 1.5,       # Steps/treads&#10;            3: 1,         # Secondary members&#10;            4: 1,         # Bracing&#10;            5: 3          # Column&#10;        }&#10;&#10;        # Plot members&#10;        self.member_lines = {}&#10;        for member in self.members:&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;            member_id = member['id']&#10;            section = member['section']&#10;&#10;            if i_node not in self.node_dict or j_node not in self.node_dict:&#10;                print(f&quot;WARNING: Member {member_id} references non-existent node(s): {i_node}-{j_node}&quot;)&#10;                continue&#10;&#10;            x1, y1, z1 = self.node_dict[i_node]&#10;            x2, y2, z2 = self.node_dict[j_node]&#10;&#10;            color = section_colors.get(section, 'black')&#10;            linewidth = section_widths.get(section, 1)&#10;&#10;            # Highlight selected member&#10;            if member_id == self.selected_member:&#10;                color = 'red'&#10;                linewidth += 1&#10;&#10;            line = self.ax.plot([x1, x2], [y1, y2], [z1, z2],&#10;                          color=color, linewidth=linewidth)[0]&#10;            self.member_lines[member_id] = line&#10;&#10;        # Plot nodes&#10;        self.node_points = {}&#10;        for node_id, (x, y, z) in self.node_dict.items():&#10;            # Different marker for nodes in the member creation process&#10;            if node_id in self.member_creation_nodes:&#10;                point = self.ax.scatter(x, y, z, color='blue', s=60, marker='o', edgecolors='black')&#10;            else:&#10;                point = self.ax.scatter(x, y, z, color='black', s=20)&#10;            self.node_points[node_id] = point&#10;&#10;        # Plot supports&#10;        for support in self.supports:&#10;            node_id = support['node']&#10;            if node_id not in self.node_dict:&#10;                print(f&quot;WARNING: Support references non-existent node: {node_id}&quot;)&#10;                continue&#10;&#10;            x, y, z = self.node_dict[node_id]&#10;&#10;            # Full support (fixed in all directions)&#10;            if support['ux'] == 1 and support['uy'] == 1 and support['uz'] == 1:&#10;                self.ax.scatter(x, y, z, color='red', s=100, marker='s')&#10;            # Partial support&#10;            else:&#10;                self.ax.scatter(x, y, z, color='orange', s=80, marker='^')&#10;&#10;        # Add a wall surface to represent the back wall&#10;        # Find the y value for the back of the stairway&#10;        back_y = max(pos[1] for pos in self.node_dict.values())&#10;        min_x = min(pos[0] for pos in self.node_dict.values())&#10;        max_x = max(pos[0] for pos in self.node_dict.values())&#10;        min_z = min(pos[2] for pos in self.node_dict.values())&#10;        max_z = max(pos[2] for pos in self.node_dict.values())&#10;&#10;        # Add some margin to the wall&#10;        margin = 1&#10;        wall_x = np.array([min_x-margin, max_x+margin])&#10;        wall_z = np.array([min_z-margin, max_z+margin])&#10;        wall_x_grid, wall_z_grid = np.meshgrid(wall_x, wall_z)&#10;        wall_y_grid = np.ones_like(wall_x_grid) * back_y&#10;&#10;        # Plot the wall with slight transparency&#10;        self.ax.plot_surface(wall_x_grid, wall_y_grid, wall_z_grid, color='gray', alpha=0.2)&#10;&#10;        # Create a legend&#10;        from matplotlib.lines import Line2D&#10;        legend_elements = [&#10;            Line2D([0], [0], color=section_colors[1], lw=section_widths[1], label='Main Stringers'),&#10;            Line2D([0], [0], color=section_colors[2], lw=section_widths[2], label='Steps/Treads'),&#10;            Line2D([0], [0], color=section_colors[4], lw=section_widths[4], label='Bracing'),&#10;            Line2D([0], [0], color=section_colors[5], lw=section_widths[5], label='Column'),&#10;            Line2D([0], [0], marker='s', color='w', markerfacecolor='red', markersize=10, label='Fixed Support'),&#10;            Line2D([0], [0], marker='^', color='w', markerfacecolor='orange', markersize=8, label='Partial Support')&#10;        ]&#10;        self.ax.legend(handles=legend_elements, loc='upper right')&#10;&#10;        # Set axis labels and title&#10;        self.ax.set_xlabel('X (ft)')&#10;        self.ax.set_ylabel('Y (ft)')&#10;        self.ax.set_zlabel('Z (ft)')&#10;        title = self.stairway_data['design_parameters']['name']&#10;        self.ax.set_title(title)&#10;&#10;        # Adjust view angle for better visualization&#10;        self.ax.view_init(elev=20, azim=-60)&#10;&#10;        # Set equal aspect ratio for a more realistic view&#10;        self.ax.set_box_aspect([max_x-min_x, back_y+1, max_z-min_z])&#10;&#10;        # Add text annotations for key structural elements&#10;        self.ax.text(0, 0, max_z+0.5, &quot;Upper Landing&quot;, color='blue')&#10;        self.ax.text(max_x, 0, min_z-0.5, &quot;Lower Landing&quot;, color='blue')&#10;&#10;        # Highlight selected node if any&#10;        if self.selected_node and self.selected_node in self.node_dict:&#10;            x, y, z = self.node_dict[self.selected_node]&#10;            self.ax.scatter(x, y, z, color='red', s=100, marker='o', edgecolors='black')&#10;&#10;    def find_closest_node(self, event):&#10;        &quot;&quot;&quot;Find the closest node to the clicked position&quot;&quot;&quot;&#10;        debug_print(&quot;\n===== Finding closest node =====&quot;)&#10;        if not event.inaxes:&#10;            debug_print(&quot;Click not in any axes&quot;)&#10;            return None&#10;&#10;        if event.inaxes != self.ax:&#10;            debug_print(f&quot;Click in wrong axes: {event.inaxes}&quot;)&#10;            return None&#10;&#10;        # Get screen coordinates of all nodes&#10;        closest_node = None&#10;        min_dist = float('inf')&#10;&#10;        # Raw click coordinates&#10;        click_x, click_y = event.x, event.y&#10;        debug_print(f&quot;Raw click at screen coordinates: ({click_x}, {click_y})&quot;)&#10;&#10;        try:&#10;            # Directly use screen coordinates with imported proj3d module&#10;            from mpl_toolkits.mplot3d import proj3d&#10;&#10;            for node_id, (x, y, z) in self.node_dict.items():&#10;                try:&#10;                    # Convert 3D coordinates to display coordinates&#10;                    xs, ys, _ = proj3d.proj_transform(x, y, z, self.ax.get_proj())&#10;&#10;                    # Convert to display coordinates&#10;                    display_coords = self.ax.transData.transform([(xs, ys)])&#10;                    if len(display_coords) &gt; 0:&#10;                        sx, sy = display_coords[0]&#10;                        dist = np.sqrt((click_x - sx)**2 + (click_y - sy)**2)&#10;&#10;                        debug_print(f&quot;Node {node_id} at 3D=({x:.1f},{y:.1f},{z:.1f}), &quot;&#10;                                   f&quot;screen=({sx:.1f},{sy:.1f}), dist={dist:.1f}&quot;)&#10;&#10;                        if dist &lt; min_dist:&#10;                            min_dist = dist&#10;                            closest_node = node_id&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error projecting node {node_id}: {e}&quot;)&#10;                    continue&#10;&#10;        except ImportError:&#10;            # Fallback method if proj3d import fails&#10;            debug_print(&quot;Using fallback node detection method&quot;)&#10;&#10;            # Get view angles&#10;            elev, azim = self.ax.elev, self.ax.azim&#10;&#10;            # Convert azimuth from degrees to radians&#10;            azim_rad = np.radians(azim)&#10;            elev_rad = np.radians(elev)&#10;&#10;            for node_id, (x, y, z) in self.node_dict.items():&#10;                try:&#10;                    # Simple projection based on view angles&#10;                    # This is an approximation but works reasonably for most views&#10;                    sx = x * np.cos(azim_rad) - y * np.sin(azim_rad)&#10;                    sy = z * np.cos(elev_rad) + np.sin(elev_rad) * (x * np.sin(azim_rad) + y * np.cos(azim_rad))&#10;&#10;                    # Convert to display coordinates (simplified)&#10;                    display_coords = self.ax.transData.transform([(sx, sy)])&#10;                    if len(display_coords) &gt; 0:&#10;                        disp_x, disp_y = display_coords[0]&#10;                        dist = np.sqrt((click_x - disp_x)**2 + (click_y - disp_y)**2)&#10;&#10;                        if dist &lt; min_dist:&#10;                            min_dist = dist&#10;                            closest_node = node_id&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error in fallback projection for node {node_id}: {e}&quot;)&#10;                    continue&#10;&#10;        # Use a reasonable threshold (in pixels)&#10;        threshold = 30&#10;        if min_dist &lt; threshold:&#10;            debug_print(f&quot;Found closest node: {closest_node} (distance: {min_dist:.1f}px)&quot;)&#10;            return closest_node&#10;        else:&#10;            debug_print(f&quot;No node within threshold. Closest was {min_dist:.1f}px away.&quot;)&#10;            return None&#10;&#10;    def find_closest_member(self, event):&#10;        &quot;&quot;&quot;Find the closest member to the clicked position&quot;&quot;&quot;&#10;        debug_print(&quot;\n===== Finding closest member =====&quot;)&#10;        if not event.inaxes or event.inaxes != self.ax:&#10;            return None&#10;&#10;        # Raw click coordinates&#10;        click_x, click_y = event.x, event.y&#10;        debug_print(f&quot;Raw click at screen coordinates: ({click_x}, {click_y})&quot;)&#10;&#10;        # Find closest member by measuring distance to line segments in screen coordinates&#10;        closest_member = None&#10;        min_dist = float('inf')&#10;&#10;        for member in self.members:&#10;            member_id = member['id']&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;&#10;            if i_node not in self.node_dict or j_node not in self.node_dict:&#10;                continue&#10;&#10;            # Get 3D coordinates&#10;            x1, y1, z1 = self.node_dict[i_node]&#10;            x2, y2, z2 = self.node_dict[j_node]&#10;&#10;            try:&#10;                # Project to 2D screen coordinates&#10;                from mpl_toolkits.mplot3d import proj3d&#10;&#10;                # Project endpoints&#10;                xs1, ys1, _ = proj3d.proj_transform(x1, y1, z1, self.ax.get_proj())&#10;                xs2, ys2, _ = proj3d.proj_transform(x2, y2, z2, self.ax.get_proj())&#10;&#10;                # Transform to display coordinates&#10;                display_coords1 = self.ax.transData.transform([(xs1, ys1)])&#10;                display_coords2 = self.ax.transData.transform([(xs2, ys2)])&#10;&#10;                if len(display_coords1) &gt; 0 and len(display_coords2) &gt; 0:&#10;                    sx1, sy1 = display_coords1[0]&#10;                    sx2, sy2 = display_coords2[0]&#10;&#10;                    # Calculate distance from click to line segment&#10;                    dist = point_to_line_distance(click_x, click_y, sx1, sy1, sx2, sy2)&#10;&#10;                    debug_print(f&quot;Member {member_id} distance: {dist:.1f}px&quot;)&#10;&#10;                    if dist &lt; min_dist:&#10;                        min_dist = dist&#10;                        closest_member = member_id&#10;            except Exception as e:&#10;                debug_print(f&quot;Error projecting member {member_id}: {e}&quot;)&#10;                continue&#10;&#10;        # Use a reasonable threshold (in pixels)&#10;        threshold = 15  # Smaller than node threshold&#10;        if min_dist &lt; threshold:&#10;            debug_print(f&quot;Found closest member: {closest_member} (distance: {min_dist:.1f}px)&quot;)&#10;            return closest_member&#10;        else:&#10;            debug_print(f&quot;No member within threshold. Closest was {min_dist:.1f}px away.&quot;)&#10;            return None&#10;&#10;    def on_click(self, event):&#10;        &quot;&quot;&quot;Handle mouse click events&quot;&quot;&quot;&#10;        debug_print(f&quot;\n***** Click event at ({event.x}, {event.y}) *****&quot;)&#10;&#10;        # Check if click is in the main axes&#10;        if event.inaxes != self.ax:&#10;            debug_print(f&quot;Click not in main axes but in {event.inaxes}&quot;)&#10;            # Let the widgets handle their own events&#10;            return&#10;&#10;        # Handle different modes&#10;        if self.mode == 'add_member':&#10;            # In add_member mode, we select two nodes to create a member between them&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                # If we already have this node in our selection, ignore the click&#10;                if node_id in self.member_creation_nodes:&#10;                    debug_print(f&quot;Node {node_id} already selected for member creation&quot;)&#10;                    return&#10;&#10;                # Add the node to our member creation list&#10;                self.member_creation_nodes.append(node_id)&#10;                debug_print(f&quot;Added node {node_id} to member creation (nodes: {self.member_creation_nodes})&quot;)&#10;&#10;                # If we have two nodes, create the member&#10;                if len(self.member_creation_nodes) == 2:&#10;                    self.create_member(self.member_creation_nodes[0], self.member_creation_nodes[1])&#10;                    # Reset for the next member&#10;                    self.member_creation_nodes = []&#10;&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        elif self.mode == 'delete_member':&#10;            # Try to find a member to delete&#10;            member_id = self.find_closest_member(event)&#10;            if member_id:&#10;                debug_print(f&quot;Selected member {member_id} for deletion&quot;)&#10;                self.selected_member = member_id&#10;                self.delete_member()&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        elif self.mode.startswith('delete_node'):&#10;            # Find closest node to the click&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                debug_print(f&quot;Selected node: {node_id} for deletion&quot;)&#10;                self.selected_node = node_id&#10;                self.delete_node()&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        else:  # View or other modes&#10;            # Try to find a node first&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                debug_print(f&quot;Selected node: {node_id}&quot;)&#10;                self.selected_node = node_id&#10;                self.selected_member = None&#10;&#10;                # If in move mode, show the position sliders&#10;                if self.mode == 'move':&#10;                    debug_print(f&quot;Move mode active - showing node editor for node {node_id}&quot;)&#10;                    self.show_node_editor()&#10;&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;            else:&#10;                # If no node found, try to find a member&#10;                member_id = self.find_closest_member(event)&#10;                if member_id:&#10;                    debug_print(f&quot;Selected member: {member_id}&quot;)&#10;                    self.selected_member = member_id&#10;                    self.selected_node = None&#10;                    self.update_info_text()&#10;                    self.plot_stairway()&#10;                    plt.draw()&#10;                else:&#10;                    # Clicked empty space - deselect everything&#10;                    if self.selected_node or self.selected_member:&#10;                        debug_print(&quot;Deselecting current selection&quot;)&#10;                        self.selected_node = None&#10;                        self.selected_member = None&#10;                        self.hide_node_editor()&#10;                        self.update_info_text()&#10;                        self.plot_stairway()&#10;                        plt.draw()&#10;&#10;    def on_motion(self, event):&#10;        &quot;&quot;&quot;Handle mouse motion events&quot;&quot;&quot;&#10;        # Simple implementation to avoid AttributeError&#10;        if not event.inaxes or event.inaxes != self.ax:&#10;            return&#10;&#10;        # Could implement hover highlighting here&#10;        pass&#10;&#10;    def on_key(self, event):&#10;        &quot;&quot;&quot;Handle keyboard events&quot;&quot;&quot;&#10;        debug_print(f&quot;\n##### Key press: {event.key} #####&quot;)&#10;&#10;        if event.key == 'v':&#10;            debug_print(&quot;Switching to View mode&quot;)&#10;            self.mode_radio.set_active(0)&#10;            self.mode = 'view'&#10;            self.hide_node_editor()&#10;        elif event.key == 'm':&#10;            debug_print(&quot;Switching to Move mode&quot;)&#10;            self.mode_radio.set_active(1)&#10;            self.mode = 'move'&#10;            if self.selected_node:&#10;                self.show_node_editor()&#10;        elif event.key == 'a':&#10;            debug_print(&quot;Switching to Add Node mode&quot;)&#10;            self.mode_radio.set_active(2)&#10;            self.mode = 'add_node'&#10;            self.hide_node_editor()&#10;        elif event.key == 'shift+a':&#10;            debug_print(&quot;Switching to Add Member mode&quot;)&#10;            self.mode_radio.set_active(3)&#10;            self.mode = 'add_member'&#10;            self.member_creation_nodes = []&#10;            self.hide_node_editor()&#10;        elif event.key == 'd':&#10;            debug_print(&quot;Switching to Delete Node mode&quot;)&#10;            self.mode_radio.set_active(4)&#10;            self.mode = 'delete_node'&#10;            self.hide_node_editor()&#10;            if self.selected_node and self.mode == 'delete_node':&#10;                self.delete_node()&#10;        elif event.key == 'shift+d':&#10;            debug_print(&quot;Switching to Delete Member mode&quot;)&#10;            self.mode_radio.set_active(5)&#10;            self.mode = 'delete_member'&#10;            self.hide_node_editor()&#10;            if self.selected_member and self.mode == 'delete_member':&#10;                self.delete_member()&#10;        elif event.key == 'escape':&#10;            debug_print(&quot;Escape pressed - deselecting&quot;)&#10;            self.selected_node = None&#10;            self.selected_member = None&#10;            self.member_creation_nodes = []&#10;            self.hide_node_editor()&#10;            self.plot_stairway()  # Redraw without selection highlight&#10;&#10;        self.update_info_text()&#10;        plt.draw()&#10;&#10;    def show_node_editor(self):&#10;        &quot;&quot;&quot;Show the node editor panel with current node position&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            debug_print(&quot;Cannot show node editor: no node selected&quot;)&#10;            return&#10;&#10;        debug_print(f&quot;Showing node editor for node {self.selected_node}&quot;)&#10;        x, y, z = self.node_dict[self.selected_node]&#10;&#10;        # Adjust slider ranges to encompass the current value&#10;        self.x_slider.valmin = max(0, x - 10)&#10;        self.x_slider.valmax = x + 10&#10;        self.y_slider.valmin = max(0, y - 5)&#10;        self.y_slider.valmax = y + 5&#10;        self.z_slider.valmin = max(0, z - 5)&#10;        self.z_slider.valmax = z + 5&#10;&#10;        # Update slider values&#10;        self.x_slider.set_val(x)&#10;        self.y_slider.set_val(y)&#10;        self.z_slider.set_val(z)&#10;&#10;        # Make the editor visible&#10;        debug_print(&quot;Setting editor UI elements to visible&quot;)&#10;        self.node_editor_ax.set_visible(True)&#10;        self.x_slider_ax.set_visible(True)&#10;        self.y_slider_ax.set_visible(True)&#10;        self.z_slider_ax.set_visible(True)&#10;        debug_print(&quot;Calling plt.draw() to update visibility&quot;)&#10;        plt.draw()&#10;&#10;    def hide_node_editor(self):&#10;        &quot;&quot;&quot;Hide the node editor panel&quot;&quot;&quot;&#10;        debug_print(&quot;Hiding node editor&quot;)&#10;        self.node_editor_ax.set_visible(False)&#10;        self.x_slider_ax.set_visible(False)&#10;        self.y_slider_ax.set_visible(False)&#10;        self.z_slider_ax.set_visible(False)&#10;        plt.draw()&#10;&#10;    def update_node_position(self, val):&#10;        &quot;&quot;&quot;Update the selected node's position from slider values&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            debug_print(&quot;Cannot update position: no node selected&quot;)&#10;            return&#10;&#10;        # Get new position from sliders&#10;        x = self.x_slider.val&#10;        y = self.y_slider.val&#10;        z = self.z_slider.val&#10;&#10;        debug_print(f&quot;Updating node {self.selected_node} position to ({x:.2f}, {y:.2f}, {z:.2f})&quot;)&#10;&#10;        # Update node position&#10;        self.node_dict[self.selected_node] = (x, y, z)&#10;&#10;        # Update position in the nodes list too&#10;        for node in self.nodes:&#10;            if node['id'] == self.selected_node:&#10;                node['x'] = f&quot;{x} ft&quot;&#10;                node['y'] = f&quot;{y} ft&quot;&#10;                node['z'] = f&quot;{z} ft&quot;&#10;                break&#10;&#10;        # Redraw structure&#10;        debug_print(&quot;Redrawing structure after position update&quot;)&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;&#10;    def delete_node(self):&#10;        &quot;&quot;&quot;Delete the selected node and connected members&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            print(&quot;Cannot delete: no node selected&quot;)&#10;            return&#10;&#10;        print(f&quot;Attempting to delete node {self.selected_node}&quot;)&#10;&#10;        # Check if node has any supports&#10;        if self.selected_node in self.supported_nodes:&#10;            print(f&quot;Cannot delete node {self.selected_node} because it has support constraints.&quot;)&#10;            return&#10;&#10;        # Get connected members&#10;        connected_members = self.node_connections[self.selected_node].copy()  # Make a copy to avoid modification during iteration&#10;        if connected_members:&#10;            print(f&quot;Deleting {len(connected_members)} members connected to node {self.selected_node}&quot;)&#10;&#10;            # Delete members&#10;            self.members = [m for m in self.members&#10;                           if m['id'] not in connected_members]&#10;&#10;            # Update connections dict for affected nodes&#10;            for member_id in connected_members:&#10;                member = next((m for m in self.members if m['id'] == member_id), None)&#10;                if member:&#10;                    other_node = member['i_node'] if member['j_node'] == self.selected_node else member['j_node']&#10;                    if other_node in self.node_connections and member_id in self.node_connections[other_node]:&#10;                        self.node_connections[other_node].remove(member_id)&#10;&#10;        # Delete node&#10;        self.nodes = [n for n in self.nodes if n['id'] != self.selected_node]&#10;        if self.selected_node in self.node_dict:&#10;            del self.node_dict[self.selected_node]&#10;        if self.selected_node in self.node_connections:&#10;            del self.node_connections[self.selected_node]&#10;&#10;        # Clear selection&#10;        self.selected_node = None&#10;        self.hide_node_editor()&#10;&#10;        # Redraw structure&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;&#10;    def reset_view(self, event):&#10;        &quot;&quot;&quot;Reset the 3D view to default angle&quot;&quot;&quot;&#10;        print(&quot;Resetting view&quot;)&#10;        self.ax.view_init(elev=20, azim=-60)&#10;        plt.draw()&#10;&#10;    def save_structure(self, event):&#10;        &quot;&quot;&quot;Save the modified structure back to a JSON file&quot;&quot;&quot;&#10;        print(&quot;Saving structure...&quot;)&#10;        # Update the structure data with modified nodes&#10;        self.stairway_data['nodes'] = self.nodes&#10;        self.stairway_data['members'] = self.members&#10;&#10;        # Generate a timestamped filename&#10;        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')&#10;        base_name = os.path.splitext(self.json_file)[0]&#10;        output_file = f&quot;{base_name}_edited_{timestamp}.json&quot;&#10;&#10;        try:&#10;            with open(os.path.join(os.path.dirname(__file__), output_file), 'w') as f:&#10;                json.dump(self.stairway_data, f, indent=4)&#10;            print(f&quot;Successfully saved structure to {output_file}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error saving structure: {e}&quot;)&#10;&#10;    def create_member(self, node1, node2):&#10;        &quot;&quot;&quot;Create a new member between two nodes&quot;&quot;&quot;&#10;        # Determine the section type from the radio button&#10;        section_label = self.section_radio.value_selected&#10;        section_number = int(section_label.split()[-1])&#10;&#10;        # Create a new member&#10;        new_member = {&#10;            'id': self.next_member_id,&#10;            'i_node': node1,&#10;            'j_node': node2,&#10;            'material': 1,  # Default material&#10;            'section': section_number&#10;        }&#10;&#10;        debug_print(f&quot;Creating new member: {new_member}&quot;)&#10;&#10;        # Add to members list&#10;        self.members.append(new_member)&#10;&#10;        # Update connections dictionary&#10;        self.node_connections[node1].append(self.next_member_id)&#10;        self.node_connections[node2].append(self.next_member_id)&#10;&#10;        # Increment ID counter for next member&#10;        self.next_member_id += 1&#10;&#10;        # Highlight the new member temporarily&#10;        self.selected_member = new_member['id']&#10;&#10;        # Provide feedback&#10;        debug_print(f&quot;Member {new_member['id']} created between nodes {node1} and {node2}&quot;)&#10;&#10;    def delete_member(self):&#10;        &quot;&quot;&quot;Delete the selected member&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot delete: no member selected&quot;)&#10;            return&#10;&#10;        member_id = self.selected_member&#10;        debug_print(f&quot;Deleting member {member_id}&quot;)&#10;&#10;        # Find the member&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            debug_print(f&quot;Member {member_id} not found&quot;)&#10;            return&#10;&#10;        # Remove member from connections&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        if i_node in self.node_connections and member_id in self.node_connections[i_node]:&#10;            self.node_connections[i_node].remove(member_id)&#10;&#10;        if j_node in self.node_connections and member_id in self.node_connections[j_node]:&#10;            self.node_connections[j_node].remove(member_id)&#10;&#10;        # Remove member from list&#10;        self.members = [m for m in self.members if m['id'] != member_id]&#10;&#10;        # Clear selection&#10;        self.selected_member = None&#10;&#10;        debug_print(f&quot;Member {member_id} deleted&quot;)&#10;&#10;&#10;# Helper functions for distance calculations&#10;def point_to_line_distance(x, y, x1, y1, x2, y2):&#10;    &quot;&quot;&quot;Calculate the distance from point (x,y) to line segment (x1,y1)-(x2,y2)&quot;&quot;&quot;&#10;    # Line segment length squared&#10;    l2 = (x2 - x1)**2 + (y2 - y1)**2&#10;&#10;    if l2 == 0:  # Line segment is a point&#10;        return np.sqrt((x - x1)**2 + (y - y1)**2)&#10;&#10;    # Calculate projection ratio (0-1 if within segment)&#10;    t = max(0, min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2))&#10;&#10;    # Calculate closest point on segment&#10;    px = x1 + t * (x2 - x1)&#10;    py = y1 + t * (y2 - y1)&#10;&#10;    # Return distance to that point&#10;    return np.sqrt((x - px)**2 + (y - py)**2)&#10;" />
              <option name="updatedContent" value="# Interactive stairway structure visualization and editing tool&#10;&#10;import os&#10;import json&#10;import sys&#10;import re&#10;import matplotlib&#10;# Force use of TkAgg backend which has better interactive support&#10;matplotlib.use('TkAgg')&#10;import matplotlib.pyplot as plt&#10;from matplotlib.widgets import Button, RadioButtons, Slider, TextBox&#10;from mpl_toolkits.mplot3d import Axes3D&#10;import scipy as sp&#10;import numpy as np&#10;import datetime&#10;&#10;# Import proj3d for 3D to 2D projections&#10;try:&#10;    from mpl_toolkits.mplot3d import proj3d&#10;except ImportError:&#10;    print(&quot;Warning: Could not import proj3d, some 3D functions may be limited&quot;)&#10;&#10;# Global debug flag - set to True for verbose output&#10;DEBUG = True&#10;&#10;def debug_print(*args, **kwargs):&#10;    &quot;&quot;&quot;Helper function for debug printing that respects the global DEBUG flag&quot;&quot;&quot;&#10;    if DEBUG:&#10;        print(*args, **kwargs)&#10;&#10;class StairwayInteractiveVisualizer:&#10;    def __init__(self, json_file):&#10;        debug_print(f&quot;Initializing visualizer with file: {json_file}&quot;)&#10;        self.json_file = json_file&#10;        self.load_data()&#10;&#10;        # Initialize state variables&#10;        self.selected_node = None&#10;        self.selected_member = None&#10;        self.mode = 'view'  # 'view', 'move', 'add_node', 'add_member', 'delete_node', 'delete_member', 'edit_member'&#10;&#10;        # For member creation&#10;        self.member_creation_nodes = []&#10;        self.next_member_id = max([m['id'] for m in self.members], default=0) + 1&#10;&#10;        # Create the figure and 3D axes&#10;        self.fig = plt.figure(figsize=(16, 10))&#10;        debug_print(&quot;Figure created&quot;)&#10;        self.ax = self.fig.add_subplot(111, projection='3d')&#10;        debug_print(&quot;3D axes created&quot;)&#10;&#10;        # Setup UI before connecting events&#10;        self.setup_ui()&#10;        debug_print(&quot;UI setup complete&quot;)&#10;&#10;        # Connect event handlers&#10;        debug_print(&quot;Connecting event handlers&quot;)&#10;        self.click_cid = self.fig.canvas.mpl_connect('button_press_event', self.on_click)&#10;        self.motion_cid = self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)&#10;        self.key_cid = self.fig.canvas.mpl_connect('key_press_event', self.on_key)&#10;        self.draw_cid = self.fig.canvas.mpl_connect('draw_event', self.on_draw)&#10;        debug_print(f&quot;Event handlers connected: {self.click_cid}, {self.motion_cid}, {self.key_cid}, {self.draw_cid}&quot;)&#10;&#10;        # Plot the stairway structure last&#10;        self.plot_stairway()&#10;&#10;        # Show debug message when initialization is complete&#10;        debug_print(&quot;Visualizer initialization complete&quot;)&#10;&#10;    def on_draw(self, event):&#10;        &quot;&quot;&quot;Debug handler for draw events&quot;&quot;&quot;&#10;        debug_print(&quot;Draw event occurred&quot;)&#10;&#10;    def load_data(self):&#10;        &quot;&quot;&quot;Load stairway data from JSON file&quot;&quot;&quot;&#10;        print(f&quot;Loading stairway structure from {self.json_file}&quot;)&#10;&#10;        try:&#10;            # Remove comments if present in the JSON file&#10;            with open(os.path.join(os.path.dirname(__file__), self.json_file), 'r') as file:&#10;                json_str = &quot;&quot;&#10;                for line in file:&#10;                    if '//' not in line:&#10;                        json_str += line&#10;&#10;                self.stairway_data = json.loads(json_str)&#10;&#10;            # Extract structure data&#10;            self.nodes = self.stairway_data['nodes']&#10;            self.supports = self.stairway_data['supports']&#10;            self.members = self.stairway_data['members']&#10;            self.materials = self.stairway_data.get('materials', [])&#10;            self.sections = self.stairway_data.get('sections', [])&#10;&#10;            # Create node dictionary for quick lookups&#10;            self.node_dict = {}&#10;            for node in self.nodes:&#10;                node_id = node['id']&#10;                x = float(node['x'].split()[0])&#10;                y = float(node['y'].split()[0])&#10;                z = float(node['z'].split()[0])&#10;                self.node_dict[node_id] = (x, y, z)&#10;&#10;            # Create dictionaries for materials and sections&#10;            self.material_dict = {m['id']: m for m in self.materials}&#10;            self.section_dict = {s['id']: s for s in self.sections}&#10;&#10;            # Create set of supported nodes&#10;            self.supported_nodes = {s['node'] for s in self.supports}&#10;&#10;            # Create map of connected members for each node&#10;            self.node_connections = {}&#10;            for node_id in self.node_dict:&#10;                self.node_connections[node_id] = []&#10;&#10;            for member in self.members:&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                member_id = member['id']&#10;&#10;                if i_node in self.node_connections:&#10;                    self.node_connections[i_node].append(member_id)&#10;                if j_node in self.node_connections:&#10;                    self.node_connections[j_node].append(member_id)&#10;&#10;            print(f&quot;Successfully loaded: {self.stairway_data['design_parameters']['name']}&quot;)&#10;            print(f&quot;Structure contains {len(self.nodes)} nodes, {len(self.members)} members, and {len(self.supports)} supports&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error loading JSON file: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            sys.exit(1)&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;Set up the UI elements for interactive editing&quot;&quot;&quot;&#10;        # Create a smaller subplot for buttons&#10;        self.button_area = plt.axes([0.01, 0.01, 0.20, 0.20])&#10;        self.button_area.axis('off')&#10;&#10;        # Mode selection radio buttons - add member modes&#10;        self.mode_radio_ax = plt.axes([0.01, 0.80, 0.15, 0.15])&#10;        self.mode_radio = RadioButtons(&#10;            self.mode_radio_ax,&#10;            ['View', 'Move Node', 'Add Node', 'Add Member', 'Delete Node', 'Delete Member', 'Edit Member'],&#10;            activecolor='green'&#10;        )&#10;        self.mode_radio.on_clicked(self.set_mode)&#10;&#10;        # Section selection for new members&#10;        self.section_radio_ax = plt.axes([0.01, 0.55, 0.15, 0.10])&#10;        section_labels = [f&quot;Section {i}&quot; for i in range(1, 6)]&#10;        self.section_radio = RadioButtons(&#10;            self.section_radio_ax,&#10;            section_labels,&#10;            activecolor='blue'&#10;        )&#10;        self.section_radio.on_clicked(lambda label: debug_print(f&quot;Section changed to: {label}&quot;))&#10;&#10;        # Save button&#10;        self.save_button_ax = plt.axes([0.01, 0.70, 0.15, 0.05])&#10;        self.save_button = Button(self.save_button_ax, 'Save Structure')&#10;        self.save_button.on_clicked(self.save_structure)&#10;&#10;        # Reset view button&#10;        self.reset_view_ax = plt.axes([0.01, 0.65, 0.15, 0.05])&#10;        self.reset_view_button = Button(self.reset_view_ax, 'Reset View')&#10;        self.reset_view_button.on_clicked(self.reset_view)&#10;&#10;        # Information panel&#10;        self.info_ax = plt.axes([0.01, 0.05, 0.20, 0.45])&#10;        self.info_ax.axis('off')&#10;        self.info_text = self.info_ax.text(&#10;            0, 1,&#10;            &quot;Interactive Stairway Editor\n\nClick on a node to select it\n&quot;&#10;            &quot;Use the mode buttons to change actions\n&quot;&#10;            &quot;Hotkeys: v=View, m=Move, a=Add, d=Delete, e=Edit&quot;,&#10;            va='top'&#10;        )&#10;&#10;        # Node editor panel (initially hidden)&#10;        self.node_editor_ax = plt.axes([0.85, 0.65, 0.14, 0.30])&#10;        self.node_editor_ax.axis('off')&#10;        self.node_editor_title = self.node_editor_ax.text(0, 1.1, &quot;Node Editor&quot;, fontsize=10, weight='bold')&#10;        self.node_editor_ax.set_visible(False)&#10;&#10;        # X coordinate slider&#10;        self.x_slider_ax = plt.axes([0.87, 0.85, 0.10, 0.03])&#10;        self.x_slider = Slider(self.x_slider_ax, 'X', 0, 30, valinit=0)&#10;        self.x_slider.on_changed(self.update_node_position)&#10;        self.x_slider_ax.set_visible(False)&#10;&#10;        # Y coordinate slider&#10;        self.y_slider_ax = plt.axes([0.87, 0.80, 0.10, 0.03])&#10;        self.y_slider = Slider(self.y_slider_ax, 'Y', 0, 10, valinit=0)&#10;        self.y_slider.on_changed(self.update_node_position)&#10;        self.y_slider_ax.set_visible(False)&#10;&#10;        # Z coordinate slider&#10;        self.z_slider_ax = plt.axes([0.87, 0.75, 0.10, 0.03])&#10;        self.z_slider = Slider(self.z_slider_ax, 'Z', 0, 10, valinit=0)&#10;        self.z_slider.on_changed(self.update_node_position)&#10;        self.z_slider_ax.set_visible(False)&#10;        &#10;        # Member editor panel (initially hidden)&#10;        self.member_editor_ax = plt.axes([0.85, 0.35, 0.14, 0.25])&#10;        self.member_editor_ax.axis('off')&#10;        self.member_editor_title = self.member_editor_ax.text(0, 1.1, &quot;Member Editor&quot;, fontsize=10, weight='bold')&#10;        self.member_editor_ax.set_visible(False)&#10;        &#10;        # Member section radio buttons&#10;        self.member_section_ax = plt.axes([0.87, 0.45, 0.10, 0.10])&#10;        self.member_section_radio = RadioButtons(&#10;            self.member_section_ax,&#10;            [f&quot;Section {i}&quot; for i in range(1, 6)],&#10;            activecolor='blue'&#10;        )&#10;        self.member_section_radio.on_clicked(self.update_member_section)&#10;        self.member_section_ax.set_visible(False)&#10;        &#10;        # Member material radio buttons&#10;        self.member_material_ax = plt.axes([0.87, 0.30, 0.10, 0.10])&#10;        self.member_material_radio = RadioButtons(&#10;            self.member_material_ax,&#10;            [f&quot;Material {i}&quot; for i in range(1, 4)],&#10;            activecolor='orange'&#10;        )&#10;        self.member_material_radio.on_clicked(self.update_member_material)&#10;        self.member_material_ax.set_visible(False)&#10;        &#10;        # Change member nodes button&#10;        self.change_nodes_ax = plt.axes([0.87, 0.25, 0.10, 0.04])&#10;        self.change_nodes_button = Button(self.change_nodes_ax, 'Change Nodes')&#10;        self.change_nodes_button.on_clicked(self.start_change_member_nodes)&#10;        self.change_nodes_ax.set_visible(False)&#10;&#10;    def set_mode(self, mode_label):&#10;        &quot;&quot;&quot;Change the current editing mode&quot;&quot;&quot;&#10;        debug_print(f&quot;\n----- Mode change: {mode_label} -----&quot;)&#10;        mode_map = {&#10;            'View': 'view',&#10;            'Move Node': 'move',&#10;            'Add Node': 'add_node',&#10;            'Add Member': 'add_member',&#10;            'Delete Node': 'delete_node',&#10;            'Delete Member': 'delete_member',&#10;            'Edit Member': 'edit_member'&#10;        }&#10;        self.mode = mode_map[mode_label]&#10;        debug_print(f&quot;Mode changed to: {self.mode}&quot;)&#10;&#10;        # Reset state when changing modes&#10;        if self.mode == 'add_member':&#10;            self.member_creation_nodes = []&#10;            debug_print(&quot;Member creation state reset - select two nodes to create a member&quot;)&#10;        elif self.mode == 'change_member_nodes':&#10;            self.member_creation_nodes = []&#10;            debug_print(&quot;Member node change state reset - select two nodes to reconnect the member&quot;)&#10;&#10;        # Hide/show appropriate editors&#10;        self.hide_node_editor()&#10;        self.hide_member_editor()&#10;        &#10;        if self.mode == 'move' and self.selected_node:&#10;            self.show_node_editor()&#10;        elif self.mode == 'edit_member' and self.selected_member:&#10;            self.show_member_editor()&#10;&#10;        # Handle mode-specific actions&#10;        if self.mode == 'delete_node' and self.selected_node:&#10;            debug_print(f&quot;Deleting node {self.selected_node}&quot;)&#10;            self.delete_node()&#10;        elif self.mode == 'delete_member' and self.selected_member:&#10;            debug_print(f&quot;Deleting member {self.selected_member}&quot;)&#10;            self.delete_member()&#10;&#10;        self.update_info_text()&#10;        self.plot_stairway()  # Redraw to show/hide appropriate elements&#10;        debug_print(&quot;Calling plt.draw() after mode change&quot;)&#10;        plt.draw()&#10;&#10;    def update_info_text(self):&#10;        &quot;&quot;&quot;Update the information panel text based on current state&quot;&quot;&quot;&#10;        info = f&quot;Mode: {self.mode.capitalize().replace('_', ' ')}\n\n&quot;&#10;&#10;        if self.mode == 'add_member':&#10;            info += f&quot;Creating new member - &quot;&#10;            if len(self.member_creation_nodes) == 0:&#10;                info += &quot;Select first node\n&quot;&#10;            elif len(self.member_creation_nodes) == 1:&#10;                info += f&quot;Node {self.member_creation_nodes[0]} selected\nSelect second node\n&quot;&#10;        elif self.mode == 'change_member_nodes':&#10;            info += f&quot;Changing member {self.selected_member} nodes - &quot;&#10;            if len(self.member_creation_nodes) == 0:&#10;                info += &quot;Select first node\n&quot;&#10;            elif len(self.member_creation_nodes) == 1:&#10;                info += f&quot;Node {self.member_creation_nodes[0]} selected\nSelect second node\n&quot;&#10;&#10;        if self.selected_node:&#10;            node_pos = self.node_dict[self.selected_node]&#10;            info += f&quot;Selected Node: {self.selected_node}\n&quot;&#10;            info += f&quot;Position: ({node_pos[0]:.2f}, {node_pos[1]:.2f}, {node_pos[2]:.2f})\n&quot;&#10;            info += f&quot;Connected to {len(self.node_connections[self.selected_node])} members\n&quot;&#10;&#10;            if self.selected_node in self.supported_nodes:&#10;                info += &quot;This node has support constraints\n&quot;&#10;        elif self.selected_member:&#10;            member = next((m for m in self.members if m['id'] == self.selected_member), None)&#10;            if member:&#10;                info += f&quot;Selected Member: {self.selected_member}\n&quot;&#10;                info += f&quot;Connects nodes: {member['i_node']} - {member['j_node']}\n&quot;&#10;                info += f&quot;Section: {member['section']}, Material: {member['material']}\n&quot;&#10;&#10;                # Get member length&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                if i_node in self.node_dict and j_node in self.node_dict:&#10;                    x1, y1, z1 = self.node_dict[i_node]&#10;                    x2, y2, z2 = self.node_dict[j_node]&#10;                    length = np.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)&#10;                    info += f&quot;Length: {length:.2f} ft\n&quot;&#10;&#10;        self.info_text.set_text(info)&#10;        plt.draw()&#10;&#10;    def plot_stairway(self):&#10;        &quot;&quot;&quot;Plot the stairway structure&quot;&quot;&quot;&#10;        self.ax.clear()&#10;&#10;        # Define colors and widths for different section types&#10;        section_colors = {&#10;            1: 'blue',    # Main stringers&#10;            2: 'green',   # Steps/treads&#10;            3: 'cyan',    # Secondary members&#10;            4: 'gray',    # Bracing&#10;            5: 'red'      # Column&#10;        }&#10;&#10;        section_widths = {&#10;            1: 2,         # Main stringers&#10;            2: 1.5,       # Steps/treads&#10;            3: 1,         # Secondary members&#10;            4: 1,         # Bracing&#10;            5: 3          # Column&#10;        }&#10;&#10;        # Plot members&#10;        self.member_lines = {}&#10;        for member in self.members:&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;            member_id = member['id']&#10;            section = member['section']&#10;&#10;            if i_node not in self.node_dict or j_node not in self.node_dict:&#10;                print(f&quot;WARNING: Member {member_id} references non-existent node(s): {i_node}-{j_node}&quot;)&#10;                continue&#10;&#10;            x1, y1, z1 = self.node_dict[i_node]&#10;            x2, y2, z2 = self.node_dict[j_node]&#10;&#10;            color = section_colors.get(section, 'black')&#10;            linewidth = section_widths.get(section, 1)&#10;&#10;            # Highlight selected member&#10;            if member_id == self.selected_member:&#10;                color = 'red'&#10;                linewidth += 1&#10;&#10;            line = self.ax.plot([x1, x2], [y1, y2], [z1, z2],&#10;                          color=color, linewidth=linewidth)[0]&#10;            self.member_lines[member_id] = line&#10;&#10;        # Plot nodes&#10;        self.node_points = {}&#10;        for node_id, (x, y, z) in self.node_dict.items():&#10;            # Different marker for nodes in the member creation process&#10;            if node_id in self.member_creation_nodes:&#10;                point = self.ax.scatter(x, y, z, color='blue', s=60, marker='o', edgecolors='black')&#10;            else:&#10;                point = self.ax.scatter(x, y, z, color='black', s=20)&#10;            self.node_points[node_id] = point&#10;&#10;        # Plot supports&#10;        for support in self.supports:&#10;            node_id = support['node']&#10;            if node_id not in self.node_dict:&#10;                print(f&quot;WARNING: Support references non-existent node: {node_id}&quot;)&#10;                continue&#10;&#10;            x, y, z = self.node_dict[node_id]&#10;&#10;            # Full support (fixed in all directions)&#10;            if support['ux'] == 1 and support['uy'] == 1 and support['uz'] == 1:&#10;                self.ax.scatter(x, y, z, color='red', s=100, marker='s')&#10;            # Partial support&#10;            else:&#10;                self.ax.scatter(x, y, z, color='orange', s=80, marker='^')&#10;&#10;        # Add a wall surface to represent the back wall&#10;        # Find the y value for the back of the stairway&#10;        back_y = max(pos[1] for pos in self.node_dict.values())&#10;        min_x = min(pos[0] for pos in self.node_dict.values())&#10;        max_x = max(pos[0] for pos in self.node_dict.values())&#10;        min_z = min(pos[2] for pos in self.node_dict.values())&#10;        max_z = max(pos[2] for pos in self.node_dict.values())&#10;&#10;        # Add some margin to the wall&#10;        margin = 1&#10;        wall_x = np.array([min_x-margin, max_x+margin])&#10;        wall_z = np.array([min_z-margin, max_z+margin])&#10;        wall_x_grid, wall_z_grid = np.meshgrid(wall_x, wall_z)&#10;        wall_y_grid = np.ones_like(wall_x_grid) * back_y&#10;&#10;        # Plot the wall with slight transparency&#10;        self.ax.plot_surface(wall_x_grid, wall_y_grid, wall_z_grid, color='gray', alpha=0.2)&#10;&#10;        # Create a legend&#10;        from matplotlib.lines import Line2D&#10;        legend_elements = [&#10;            Line2D([0], [0], color=section_colors[1], lw=section_widths[1], label='Main Stringers'),&#10;            Line2D([0], [0], color=section_colors[2], lw=section_widths[2], label='Steps/Treads'),&#10;            Line2D([0], [0], color=section_colors[4], lw=section_widths[4], label='Bracing'),&#10;            Line2D([0], [0], color=section_colors[5], lw=section_widths[5], label='Column'),&#10;            Line2D([0], [0], marker='s', color='w', markerfacecolor='red', markersize=10, label='Fixed Support'),&#10;            Line2D([0], [0], marker='^', color='w', markerfacecolor='orange', markersize=8, label='Partial Support')&#10;        ]&#10;        self.ax.legend(handles=legend_elements, loc='upper right')&#10;&#10;        # Set axis labels and title&#10;        self.ax.set_xlabel('X (ft)')&#10;        self.ax.set_ylabel('Y (ft)')&#10;        self.ax.set_zlabel('Z (ft)')&#10;        title = self.stairway_data['design_parameters']['name']&#10;        self.ax.set_title(title)&#10;&#10;        # Adjust view angle for better visualization&#10;        self.ax.view_init(elev=20, azim=-60)&#10;&#10;        # Set equal aspect ratio for a more realistic view&#10;        self.ax.set_box_aspect([max_x-min_x, back_y+1, max_z-min_z])&#10;&#10;        # Add text annotations for key structural elements&#10;        self.ax.text(0, 0, max_z+0.5, &quot;Upper Landing&quot;, color='blue')&#10;        self.ax.text(max_x, 0, min_z-0.5, &quot;Lower Landing&quot;, color='blue')&#10;&#10;        # Highlight selected node if any&#10;        if self.selected_node and self.selected_node in self.node_dict:&#10;            x, y, z = self.node_dict[self.selected_node]&#10;            self.ax.scatter(x, y, z, color='red', s=100, marker='o', edgecolors='black')&#10;&#10;    def find_closest_node(self, event):&#10;        &quot;&quot;&quot;Find the closest node to the clicked position&quot;&quot;&quot;&#10;        debug_print(&quot;\n===== Finding closest node =====&quot;)&#10;        if not event.inaxes:&#10;            debug_print(&quot;Click not in any axes&quot;)&#10;            return None&#10;&#10;        if event.inaxes != self.ax:&#10;            debug_print(f&quot;Click in wrong axes: {event.inaxes}&quot;)&#10;            return None&#10;&#10;        # Get screen coordinates of all nodes&#10;        closest_node = None&#10;        min_dist = float('inf')&#10;&#10;        # Raw click coordinates&#10;        click_x, click_y = event.x, event.y&#10;        debug_print(f&quot;Raw click at screen coordinates: ({click_x}, {click_y})&quot;)&#10;&#10;        try:&#10;            # Directly use screen coordinates with imported proj3d module&#10;            from mpl_toolkits.mplot3d import proj3d&#10;&#10;            for node_id, (x, y, z) in self.node_dict.items():&#10;                try:&#10;                    # Convert 3D coordinates to display coordinates&#10;                    xs, ys, _ = proj3d.proj_transform(x, y, z, self.ax.get_proj())&#10;&#10;                    # Convert to display coordinates&#10;                    display_coords = self.ax.transData.transform([(xs, ys)])&#10;                    if len(display_coords) &gt; 0:&#10;                        sx, sy = display_coords[0]&#10;                        dist = np.sqrt((click_x - sx)**2 + (click_y - sy)**2)&#10;&#10;                        debug_print(f&quot;Node {node_id} at 3D=({x:.1f},{y:.1f},{z:.1f}), &quot;&#10;                                   f&quot;screen=({sx:.1f},{sy:.1f}), dist={dist:.1f}&quot;)&#10;&#10;                        if dist &lt; min_dist:&#10;                            min_dist = dist&#10;                            closest_node = node_id&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error projecting node {node_id}: {e}&quot;)&#10;                    continue&#10;&#10;        except ImportError:&#10;            # Fallback method if proj3d import fails&#10;            debug_print(&quot;Using fallback node detection method&quot;)&#10;&#10;            # Get view angles&#10;            elev, azim = self.ax.elev, self.ax.azim&#10;&#10;            # Convert azimuth from degrees to radians&#10;            azim_rad = np.radians(azim)&#10;            elev_rad = np.radians(elev)&#10;&#10;            for node_id, (x, y, z) in self.node_dict.items():&#10;                try:&#10;                    # Simple projection based on view angles&#10;                    # This is an approximation but works reasonably for most views&#10;                    sx = x * np.cos(azim_rad) - y * np.sin(azim_rad)&#10;                    sy = z * np.cos(elev_rad) + np.sin(elev_rad) * (x * np.sin(azim_rad) + y * np.cos(azim_rad))&#10;&#10;                    # Convert to display coordinates (simplified)&#10;                    display_coords = self.ax.transData.transform([(sx, sy)])&#10;                    if len(display_coords) &gt; 0:&#10;                        disp_x, disp_y = display_coords[0]&#10;                        dist = np.sqrt((click_x - disp_x)**2 + (click_y - disp_y)**2)&#10;&#10;                        if dist &lt; min_dist:&#10;                            min_dist = dist&#10;                            closest_node = node_id&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error in fallback projection for node {node_id}: {e}&quot;)&#10;                    continue&#10;&#10;        # Use a reasonable threshold (in pixels)&#10;        threshold = 30&#10;        if min_dist &lt; threshold:&#10;            debug_print(f&quot;Found closest node: {closest_node} (distance: {min_dist:.1f}px)&quot;)&#10;            return closest_node&#10;        else:&#10;            debug_print(f&quot;No node within threshold. Closest was {min_dist:.1f}px away.&quot;)&#10;            return None&#10;&#10;    def find_closest_member(self, event):&#10;        &quot;&quot;&quot;Find the closest member to the clicked position&quot;&quot;&quot;&#10;        debug_print(&quot;\n===== Finding closest member =====&quot;)&#10;        if not event.inaxes or event.inaxes != self.ax:&#10;            return None&#10;&#10;        # Raw click coordinates&#10;        click_x, click_y = event.x, event.y&#10;        debug_print(f&quot;Raw click at screen coordinates: ({click_x}, {click_y})&quot;)&#10;&#10;        # Find closest member by measuring distance to line segments in screen coordinates&#10;        closest_member = None&#10;        min_dist = float('inf')&#10;&#10;        for member in self.members:&#10;            member_id = member['id']&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;&#10;            if i_node not in self.node_dict or j_node not in self.node_dict:&#10;                continue&#10;&#10;            # Get 3D coordinates&#10;            x1, y1, z1 = self.node_dict[i_node]&#10;            x2, y2, z2 = self.node_dict[j_node]&#10;&#10;            try:&#10;                # Project to 2D screen coordinates&#10;                from mpl_toolkits.mplot3d import proj3d&#10;&#10;                # Project endpoints&#10;                xs1, ys1, _ = proj3d.proj_transform(x1, y1, z1, self.ax.get_proj())&#10;                xs2, ys2, _ = proj3d.proj_transform(x2, y2, z2, self.ax.get_proj())&#10;&#10;                # Transform to display coordinates&#10;                display_coords1 = self.ax.transData.transform([(xs1, ys1)])&#10;                display_coords2 = self.ax.transData.transform([(xs2, ys2)])&#10;&#10;                if len(display_coords1) &gt; 0 and len(display_coords2) &gt; 0:&#10;                    sx1, sy1 = display_coords1[0]&#10;                    sx2, sy2 = display_coords2[0]&#10;&#10;                    # Calculate distance from click to line segment&#10;                    dist = point_to_line_distance(click_x, click_y, sx1, sy1, sx2, sy2)&#10;&#10;                    debug_print(f&quot;Member {member_id} distance: {dist:.1f}px&quot;)&#10;&#10;                    if dist &lt; min_dist:&#10;                        min_dist = dist&#10;                        closest_member = member_id&#10;            except Exception as e:&#10;                debug_print(f&quot;Error projecting member {member_id}: {e}&quot;)&#10;                continue&#10;&#10;        # Use a reasonable threshold (in pixels)&#10;        threshold = 15  # Smaller than node threshold&#10;        if min_dist &lt; threshold:&#10;            debug_print(f&quot;Found closest member: {closest_member} (distance: {min_dist:.1f}px)&quot;)&#10;            return closest_member&#10;        else:&#10;            debug_print(f&quot;No member within threshold. Closest was {min_dist:.1f}px away.&quot;)&#10;            return None&#10;&#10;    def on_click(self, event):&#10;        &quot;&quot;&quot;Handle mouse click events&quot;&quot;&quot;&#10;        debug_print(f&quot;\n***** Click event at ({event.x}, {event.y}) *****&quot;)&#10;&#10;        # Check if click is in the main axes&#10;        if event.inaxes != self.ax:&#10;            debug_print(f&quot;Click not in main axes but in {event.inaxes}&quot;)&#10;            # Let the widgets handle their own events&#10;            return&#10;&#10;        # Handle different modes&#10;        if self.mode == 'add_member':&#10;            # In add_member mode, we select two nodes to create a member between them&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                # If we already have this node in our selection, ignore the click&#10;                if node_id in self.member_creation_nodes:&#10;                    debug_print(f&quot;Node {node_id} already selected for member creation&quot;)&#10;                    return&#10;&#10;                # Add the node to our member creation list&#10;                self.member_creation_nodes.append(node_id)&#10;                debug_print(f&quot;Added node {node_id} to member creation (nodes: {self.member_creation_nodes})&quot;)&#10;&#10;                # If we have two nodes, create the member&#10;                if len(self.member_creation_nodes) == 2:&#10;                    self.create_member(self.member_creation_nodes[0], self.member_creation_nodes[1])&#10;                    # Reset for the next member&#10;                    self.member_creation_nodes = []&#10;&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;                &#10;        elif self.mode == 'change_member_nodes':&#10;            # In change_member_nodes mode, we select two nodes to reconnect an existing member&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                # If we already have this node in our selection, ignore the click&#10;                if node_id in self.member_creation_nodes:&#10;                    debug_print(f&quot;Node {node_id} already selected for member reconnection&quot;)&#10;                    return&#10;&#10;                # Add the node to our member creation list&#10;                self.member_creation_nodes.append(node_id)&#10;                debug_print(f&quot;Added node {node_id} to member reconnection (nodes: {self.member_creation_nodes})&quot;)&#10;&#10;                # If we have two nodes, update the member&#10;                if len(self.member_creation_nodes) == 2:&#10;                    self.update_member_nodes(self.selected_member, &#10;                                           self.member_creation_nodes[0], &#10;                                           self.member_creation_nodes[1])&#10;                    # Reset state and mode&#10;                    self.member_creation_nodes = []&#10;                    self.mode = 'edit_member'&#10;                    self.mode_radio.set_active(6)  # Select 'Edit Member' in the UI&#10;&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        elif self.mode == 'delete_member':&#10;            # Try to find a member to delete&#10;            member_id = self.find_closest_member(event)&#10;            if member_id:&#10;                debug_print(f&quot;Selected member {member_id} for deletion&quot;)&#10;                self.selected_member = member_id&#10;                self.delete_member()&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        elif self.mode.startswith('delete_node'):&#10;            # Find closest node to the click&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                debug_print(f&quot;Selected node: {node_id} for deletion&quot;)&#10;                self.selected_node = node_id&#10;                self.delete_node()&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;                &#10;        elif self.mode == 'edit_member':&#10;            # Try to find a member to edit&#10;            member_id = self.find_closest_member(event)&#10;            if member_id:&#10;                debug_print(f&quot;Selected member {member_id} for editing&quot;)&#10;                self.selected_member = member_id&#10;                self.selected_node = None&#10;                self.show_member_editor()&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        else:  # View or other modes&#10;            # Try to find a node first&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                debug_print(f&quot;Selected node: {node_id}&quot;)&#10;                self.selected_node = node_id&#10;                self.selected_member = None&#10;&#10;                # If in move mode, show the position sliders&#10;                if self.mode == 'move':&#10;                    debug_print(f&quot;Move mode active - showing node editor for node {node_id}&quot;)&#10;                    self.show_node_editor()&#10;&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;            else:&#10;                # If no node found, try to find a member&#10;                member_id = self.find_closest_member(event)&#10;                if member_id:&#10;                    debug_print(f&quot;Selected member: {member_id}&quot;)&#10;                    self.selected_member = member_id&#10;                    self.selected_node = None&#10;                    self.update_info_text()&#10;                    self.plot_stairway()&#10;                    plt.draw()&#10;                else:&#10;                    # Clicked empty space - deselect everything&#10;                    if self.selected_node or self.selected_member:&#10;                        debug_print(&quot;Deselecting current selection&quot;)&#10;                        self.selected_node = None&#10;                        self.selected_member = None&#10;                        self.hide_node_editor()&#10;                        self.hide_member_editor()&#10;                        self.update_info_text()&#10;                        self.plot_stairway()&#10;                        plt.draw()&#10;&#10;    def on_motion(self, event):&#10;        &quot;&quot;&quot;Handle mouse motion events&quot;&quot;&quot;&#10;        # Simple implementation to avoid AttributeError&#10;        if not event.inaxes or event.inaxes != self.ax:&#10;            return&#10;&#10;        # Could implement hover highlighting here&#10;        pass&#10;&#10;    def on_key(self, event):&#10;        &quot;&quot;&quot;Handle keyboard events&quot;&quot;&quot;&#10;        debug_print(f&quot;\n##### Key press: {event.key} #####&quot;)&#10;&#10;        if event.key == 'v':&#10;            debug_print(&quot;Switching to View mode&quot;)&#10;            self.mode_radio.set_active(0)&#10;            self.mode = 'view'&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;        elif event.key == 'm':&#10;            debug_print(&quot;Switching to Move mode&quot;)&#10;            self.mode_radio.set_active(1)&#10;            self.mode = 'move'&#10;            if self.selected_node:&#10;                self.show_node_editor()&#10;                self.hide_member_editor()&#10;        elif event.key == 'a':&#10;            debug_print(&quot;Switching to Add Node mode&quot;)&#10;            self.mode_radio.set_active(2)&#10;            self.mode = 'add_node'&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;        elif event.key == 'shift+a':&#10;            debug_print(&quot;Switching to Add Member mode&quot;)&#10;            self.mode_radio.set_active(3)&#10;            self.mode = 'add_member'&#10;            self.member_creation_nodes = []&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;        elif event.key == 'd':&#10;            debug_print(&quot;Switching to Delete Node mode&quot;)&#10;            self.mode_radio.set_active(4)&#10;            self.mode = 'delete_node'&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;            if self.selected_node and self.mode == 'delete_node':&#10;                self.delete_node()&#10;        elif event.key == 'shift+d':&#10;            debug_print(&quot;Switching to Delete Member mode&quot;)&#10;            self.mode_radio.set_active(5)&#10;            self.mode = 'delete_member'&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;            if self.selected_member and self.mode == 'delete_member':&#10;                self.delete_member()&#10;        elif event.key == 'e':&#10;            debug_print(&quot;Switching to Edit Member mode&quot;)&#10;            self.mode_radio.set_active(6)&#10;            self.mode = 'edit_member'&#10;            self.hide_node_editor()&#10;            if self.selected_member:&#10;                self.show_member_editor()&#10;        elif event.key == 'escape':&#10;            debug_print(&quot;Escape pressed - deselecting&quot;)&#10;            self.selected_node = None&#10;            self.selected_member = None&#10;            self.member_creation_nodes = []&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;            self.plot_stairway()  # Redraw without selection highlight&#10;&#10;        self.update_info_text()&#10;        plt.draw()&#10;&#10;    def show_node_editor(self):&#10;        &quot;&quot;&quot;Show the node editor panel with current node position&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            debug_print(&quot;Cannot show node editor: no node selected&quot;)&#10;            return&#10;&#10;        debug_print(f&quot;Showing node editor for node {self.selected_node}&quot;)&#10;        x, y, z = self.node_dict[self.selected_node]&#10;&#10;        # Adjust slider ranges to encompass the current value&#10;        self.x_slider.valmin = max(0, x - 10)&#10;        self.x_slider.valmax = x + 10&#10;        self.y_slider.valmin = max(0, y - 5)&#10;        self.y_slider.valmax = y + 5&#10;        self.z_slider.valmin = max(0, z - 5)&#10;        self.z_slider.valmax = z + 5&#10;&#10;        # Update slider values&#10;        self.x_slider.set_val(x)&#10;        self.y_slider.set_val(y)&#10;        self.z_slider.set_val(z)&#10;&#10;        # Make the editor visible&#10;        debug_print(&quot;Setting editor UI elements to visible&quot;)&#10;        self.node_editor_ax.set_visible(True)&#10;        self.x_slider_ax.set_visible(True)&#10;        self.y_slider_ax.set_visible(True)&#10;        self.z_slider_ax.set_visible(True)&#10;        debug_print(&quot;Calling plt.draw() to update visibility&quot;)&#10;        plt.draw()&#10;        &#10;    def show_member_editor(self):&#10;        &quot;&quot;&quot;Show the member editor panel with current member properties&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot show member editor: no member selected&quot;)&#10;            return&#10;            &#10;        debug_print(f&quot;Showing member editor for member {self.selected_member}&quot;)&#10;        &#10;        # Get current member properties&#10;        member = next((m for m in self.members if m['id'] == self.selected_member), None)&#10;        if not member:&#10;            debug_print(f&quot;Member {self.selected_member} not found in members list&quot;)&#10;            return&#10;            &#10;        # Set the radio button selections to match current properties&#10;        section_idx = member['section'] - 1  # Adjust for 0-based indexing&#10;        material_idx = member['material'] - 1  # Adjust for 0-based indexing&#10;        &#10;        # Set active radio buttons&#10;        for i, circle in enumerate(self.member_section_radio.circles):&#10;            circle.set_facecolor('white')&#10;        self.member_section_radio.circles[section_idx].set_facecolor('blue')&#10;        &#10;        for i, circle in enumerate(self.member_material_radio.circles):&#10;            circle.set_facecolor('white')&#10;        self.member_material_radio.circles[material_idx].set_facecolor('orange')&#10;        &#10;        # Make the editor visible&#10;        self.member_editor_ax.set_visible(True)&#10;        self.member_section_ax.set_visible(True)&#10;        self.member_material_ax.set_visible(True)&#10;        self.change_nodes_ax.set_visible(True)&#10;        &#10;        plt.draw()&#10;&#10;    def hide_node_editor(self):&#10;        &quot;&quot;&quot;Hide the node editor panel&quot;&quot;&quot;&#10;        debug_print(&quot;Hiding node editor&quot;)&#10;        self.node_editor_ax.set_visible(False)&#10;        self.x_slider_ax.set_visible(False)&#10;        self.y_slider_ax.set_visible(False)&#10;        self.z_slider_ax.set_visible(False)&#10;        plt.draw()&#10;        &#10;    def hide_member_editor(self):&#10;        &quot;&quot;&quot;Hide the member editor panel&quot;&quot;&quot;&#10;        debug_print(&quot;Hiding member editor&quot;)&#10;        self.member_editor_ax.set_visible(False)&#10;        self.member_section_ax.set_visible(False)&#10;        self.member_material_ax.set_visible(False)&#10;        self.change_nodes_ax.set_visible(False)&#10;        plt.draw()&#10;&#10;    def update_node_position(self, val):&#10;        &quot;&quot;&quot;Update the selected node's position from slider values&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            debug_print(&quot;Cannot update position: no node selected&quot;)&#10;            return&#10;&#10;        # Get new position from sliders&#10;        x = self.x_slider.val&#10;        y = self.y_slider.val&#10;        z = self.z_slider.val&#10;&#10;        debug_print(f&quot;Updating node {self.selected_node} position to ({x:.2f}, {y:.2f}, {z:.2f})&quot;)&#10;&#10;        # Update node position&#10;        self.node_dict[self.selected_node] = (x, y, z)&#10;&#10;        # Update position in the nodes list too&#10;        for node in self.nodes:&#10;            if node['id'] == self.selected_node:&#10;                node['x'] = f&quot;{x} ft&quot;&#10;                node['y'] = f&quot;{y} ft&quot;&#10;                node['z'] = f&quot;{z} ft&quot;&#10;                break&#10;&#10;        # Redraw structure&#10;        debug_print(&quot;Redrawing structure after position update&quot;)&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;        &#10;    def update_member_section(self, label):&#10;        &quot;&quot;&quot;Update the selected member's section type&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot update section: no member selected&quot;)&#10;            return&#10;            &#10;        section = int(label.split()[-1])  # Extract number from &quot;Section X&quot;&#10;        debug_print(f&quot;Updating member {self.selected_member} section to {section}&quot;)&#10;        &#10;        # Update member section&#10;        for member in self.members:&#10;            if member['id'] == self.selected_member:&#10;                member['section'] = section&#10;                break&#10;                &#10;        # Redraw structure&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;        &#10;    def update_member_material(self, label):&#10;        &quot;&quot;&quot;Update the selected member's material&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot update material: no member selected&quot;)&#10;            return&#10;            &#10;        material = int(label.split()[-1])  # Extract number from &quot;Material X&quot;&#10;        debug_print(f&quot;Updating member {self.selected_member} material to {material}&quot;)&#10;        &#10;        # Update member material&#10;        for member in self.members:&#10;            if member['id'] == self.selected_member:&#10;                member['material'] = material&#10;                break&#10;                &#10;        # Redraw structure&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;        &#10;    def start_change_member_nodes(self, event):&#10;        &quot;&quot;&quot;Start the process of changing a member's nodes&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot change nodes: no member selected&quot;)&#10;            return&#10;            &#10;        debug_print(f&quot;Starting node change for member {self.selected_member}&quot;)&#10;        self.mode = 'change_member_nodes'&#10;        self.member_creation_nodes = []&#10;        self.update_info_text()&#10;        &#10;    def update_member_nodes(self, member_id, new_i_node, new_j_node):&#10;        &quot;&quot;&quot;Update a member's connected nodes&quot;&quot;&quot;&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            debug_print(f&quot;Member {member_id} not found&quot;)&#10;            return&#10;            &#10;        old_i_node = member['i_node']&#10;        old_j_node = member['j_node']&#10;        &#10;        debug_print(f&quot;Updating member {member_id} nodes from {old_i_node}-{old_j_node} to {new_i_node}-{new_j_node}&quot;)&#10;        &#10;        # Remove member from old node connections&#10;        if old_i_node in self.node_connections and member_id in self.node_connections[old_i_node]:&#10;            self.node_connections[old_i_node].remove(member_id)&#10;            &#10;        if old_j_node in self.node_connections and member_id in self.node_connections[old_j_node]:&#10;            self.node_connections[old_j_node].remove(member_id)&#10;            &#10;        # Update member endpoints&#10;        member['i_node'] = new_i_node&#10;        member['j_node'] = new_j_node&#10;        &#10;        # Add to new node connections&#10;        if new_i_node not in self.node_connections:&#10;            self.node_connections[new_i_node] = []&#10;        self.node_connections[new_i_node].append(member_id)&#10;        &#10;        if new_j_node not in self.node_connections:&#10;            self.node_connections[new_j_node] = []&#10;        self.node_connections[new_j_node].append(member_id)&#10;        &#10;        debug_print(f&quot;Member {member_id} nodes updated successfully&quot;)&#10;&#10;    def delete_node(self):&#10;        &quot;&quot;&quot;Delete the selected node and connected members&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            print(&quot;Cannot delete: no node selected&quot;)&#10;            return&#10;&#10;        print(f&quot;Attempting to delete node {self.selected_node}&quot;)&#10;&#10;        # Check if node has any supports&#10;        if self.selected_node in self.supported_nodes:&#10;            print(f&quot;Cannot delete node {self.selected_node} because it has support constraints.&quot;)&#10;            return&#10;&#10;        # Get connected members&#10;        connected_members = self.node_connections[self.selected_node].copy()  # Make a copy to avoid modification during iteration&#10;        if connected_members:&#10;            print(f&quot;Deleting {len(connected_members)} members connected to node {self.selected_node}&quot;)&#10;&#10;            # Delete members&#10;            self.members = [m for m in self.members&#10;                           if m['id'] not in connected_members]&#10;&#10;            # Update connections dict for affected nodes&#10;            for member_id in connected_members:&#10;                member = next((m for m in self.members if m['id'] == member_id), None)&#10;                if member:&#10;                    other_node = member['i_node'] if member['j_node'] == self.selected_node else member['j_node']&#10;                    if other_node in self.node_connections and member_id in self.node_connections[other_node]:&#10;                        self.node_connections[other_node].remove(member_id)&#10;&#10;        # Delete node&#10;        self.nodes = [n for n in self.nodes if n['id'] != self.selected_node]&#10;        if self.selected_node in self.node_dict:&#10;            del self.node_dict[self.selected_node]&#10;        if self.selected_node in self.node_connections:&#10;            del self.node_connections[self.selected_node]&#10;&#10;        # Clear selection&#10;        self.selected_node = None&#10;        self.hide_node_editor()&#10;&#10;        # Redraw structure&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;&#10;    def delete_member(self):&#10;        &quot;&quot;&quot;Delete the selected member&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot delete: no member selected&quot;)&#10;            return&#10;&#10;        member_id = self.selected_member&#10;        debug_print(f&quot;Deleting member {member_id}&quot;)&#10;&#10;        # Find the member&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            debug_print(f&quot;Member {member_id} not found&quot;)&#10;            return&#10;&#10;        # Remove member from connections&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        if i_node in self.node_connections and member_id in self.node_connections[i_node]:&#10;            self.node_connections[i_node].remove(member_id)&#10;&#10;        if j_node in self.node_connections and member_id in self.node_connections[j_node]:&#10;            self.node_connections[j_node].remove(member_id)&#10;&#10;        # Remove member from list&#10;        self.members = [m for m in self.members if m['id'] != member_id]&#10;&#10;        # Clear selection&#10;        self.selected_member = None&#10;        self.hide_member_editor()&#10;&#10;        debug_print(f&quot;Member {member_id} deleted&quot;)&#10;&#10;    def reset_view(self, event):&#10;        &quot;&quot;&quot;Reset the 3D view to default angle&quot;&quot;&quot;&#10;        print(&quot;Resetting view&quot;)&#10;        self.ax.view_init(elev=20, azim=-60)&#10;        plt.draw()&#10;&#10;    def save_structure(self, event):&#10;        &quot;&quot;&quot;Save the modified structure back to a JSON file&quot;&quot;&quot;&#10;        print(&quot;Saving structure...&quot;)&#10;        # Update the structure data with modified nodes&#10;        self.stairway_data['nodes'] = self.nodes&#10;        self.stairway_data['members'] = self.members&#10;&#10;        # Generate a timestamped filename&#10;        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')&#10;        base_name = os.path.splitext(self.json_file)[0]&#10;        output_file = f&quot;{base_name}_edited_{timestamp}.json&quot;&#10;&#10;        try:&#10;            with open(os.path.join(os.path.dirname(__file__), output_file), 'w') as f:&#10;                json.dump(self.stairway_data, f, indent=4)&#10;            print(f&quot;Successfully saved structure to {output_file}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error saving structure: {e}&quot;)&#10;&#10;    def create_member(self, node1, node2):&#10;        &quot;&quot;&quot;Create a new member between two nodes&quot;&quot;&quot;&#10;        # Determine the section type from the radio button&#10;        section_label = self.section_radio.value_selected&#10;        section_number = int(section_label.split()[-1])&#10;&#10;        # Create a new member&#10;        new_member = {&#10;            'id': self.next_member_id,&#10;            'i_node': node1,&#10;            'j_node': node2,&#10;            'material': 1,  # Default material&#10;            'section': section_number&#10;        }&#10;&#10;        debug_print(f&quot;Creating new member: {new_member}&quot;)&#10;&#10;        # Add to members list&#10;        self.members.append(new_member)&#10;&#10;        # Update connections dictionary&#10;        self.node_connections[node1].append(self.next_member_id)&#10;        self.node_connections[node2].append(self.next_member_id)&#10;&#10;        # Increment ID counter for next member&#10;        self.next_member_id += 1&#10;&#10;        # Highlight the new member temporarily&#10;        self.selected_member = new_member['id']&#10;&#10;        # Provide feedback&#10;        debug_print(f&quot;Member {new_member['id']} created between nodes {node1} and {node2}&quot;)&#10;&#10;&#10;# Helper functions for distance calculations&#10;def point_to_line_distance(x, y, x1, y1, x2, y2):&#10;    &quot;&quot;&quot;Calculate the distance from point (x,y) to line segment (x1,y1)-(x2,y2)&quot;&quot;&quot;&#10;    # Line segment length squared&#10;    l2 = (x2 - x1)**2 + (y2 - y1)**2&#10;&#10;    if l2 == 0:  # Line segment is a point&#10;        return np.sqrt((x - x1)**2 + (y - y1)**2)&#10;&#10;    # Calculate projection ratio (0-1 if within segment)&#10;    t = max(0, min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2))&#10;&#10;    # Calculate closest point on segment&#10;    px = x1 + t * (x2 - x1)&#10;    py = y1 + t * (y2 - y1)&#10;&#10;    # Return distance to that point&#10;    return np.sqrt((x - px)**2 + (y - py)**2)&#10;&#10;&#10;# Main execution&#10;if __name__ == &quot;__main__&quot;:&#10;    # Check if a file was provided as a command line argument&#10;    if len(sys.argv) &gt; 1:&#10;        json_file = sys.argv[1]&#10;    else:&#10;        # Default to a sample file if none specified&#10;        json_file = &quot;stairway_structure.json&quot;&#10;        print(f&quot;No file specified, using default: {json_file}&quot;)&#10;        &#10;        # Check if the file exists&#10;        if not os.path.exists(os.path.join(os.path.dirname(__file__), json_file)):&#10;            print(f&quot;Default file {json_file} not found.&quot;)&#10;            available_files = [f for f in os.listdir(os.path.dirname(__file__)) &#10;                              if f.endswith('.json')]&#10;            &#10;            if available_files:&#10;                json_file = available_files[0]&#10;                print(f&quot;Using first available JSON file: {json_file}&quot;)&#10;            else:&#10;                print(&quot;No JSON files found in the current directory.&quot;)&#10;                sys.exit(1)&#10;    &#10;    # Create and run the visualizer&#10;    visualizer = StairwayInteractiveVisualizer(json_file)&#10;    plt.show()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ifc/describe_ifc.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ifc/describe_ifc.py" />
              <option name="originalContent" value="# %% setup&#10;&#10;import sys&#10;import os&#10;import subprocess&#10;from pprint import pprint, pformat&#10;import datetime&#10;&#10;# %% Check ifcopenshell installation status&#10;print(&quot;=== CHECKING IFCOPENSHELL INSTALLATION ===&quot;)&#10;print(&quot;Debug: Python version:&quot;, sys.version)&#10;print(&quot;Debug: Python executable:&quot;, sys.executable)&#10;&#10;# Try basic import&#10;try:&#10;    import ifcopenshell&#10;    print(f&quot;SUCCESS: ifcopenshell imported successfully&quot;)&#10;    print(f&quot;         Version: {ifcopenshell.version}&quot;)&#10;    IFCOPENSHELL_AVAILABLE = True&#10;except ImportError as e:&#10;    print(f&quot;ERROR: Unable to import ifcopenshell: {e}&quot;)&#10;    print(&quot;Please install with: pip install ifcopenshell&quot;)&#10;    IFCOPENSHELL_AVAILABLE = False&#10;    sys.exit(1)&#10;&#10;# Check submodules systematically&#10;print(&quot;\n=== CHECKING SUBMODULES ===&quot;)&#10;modules_status = {}&#10;&#10;# %% Utility modules&#10;util_modules = [&#10;    'ifcopenshell.util',&#10;    'ifcopenshell.util.element',&#10;    'ifcopenshell.util.placement',&#10;    'ifcopenshell.util.classification',&#10;    'ifcopenshell.util.unit',&#10;    'ifcopenshell.util.system'&#10;]&#10;&#10;print(&quot;\nChecking utility modules:&quot;)&#10;for module_name in util_modules:&#10;    try:&#10;        module = __import__(module_name, fromlist=[''])&#10;        modules_status[module_name] = True&#10;        print(f&quot;  [OK] {module_name}&quot;)&#10;        # Debug: Check module path&#10;        if hasattr(module, '__file__'):&#10;            print(f&quot;       Path: {module.__file__}&quot;)&#10;    except ImportError as e:&#10;        modules_status[module_name] = False&#10;        print(f&quot;  [FAIL] {module_name}: {e}&quot;)&#10;&#10;# %% API modules&#10;api_modules = [&#10;    'ifcopenshell.api',&#10;    'ifcopenshell.api.root',&#10;    'ifcopenshell.api.unit',&#10;    'ifcopenshell.api.context',&#10;    'ifcopenshell.api.project',&#10;    'ifcopenshell.api.spatial',&#10;    'ifcopenshell.api.geometry',&#10;    'ifcopenshell.api.aggregate',&#10;    'ifcopenshell.api.sequence'&#10;]&#10;&#10;print(&quot;\nChecking API modules:&quot;)&#10;API_AVAILABLE = True&#10;for module_name in api_modules:&#10;    try:&#10;        module = __import__(module_name, fromlist=[''])&#10;        modules_status[module_name] = True&#10;        print(f&quot;  [OK] {module_name}&quot;)&#10;        # Debug: Check if it's a proper module&#10;        if hasattr(module, '__file__'):&#10;            print(f&quot;       Path: {module.__file__}&quot;)&#10;    except ImportError as e:&#10;        modules_status[module_name] = False&#10;        API_AVAILABLE = False&#10;        print(f&quot;  [FAIL] {module_name}: {e}&quot;)&#10;&#10;# %% Summary&#10;failed_modules = [k for k, v in modules_status.items() if not v]&#10;if failed_modules:&#10;    print(f&quot;\nWARNING: {len(failed_modules)} modules failed to import:&quot;)&#10;    for module in failed_modules:&#10;        print(f&quot;  - {module}&quot;)&#10;    print(&quot;\nThis might be due to:&quot;)&#10;    print(&quot;1. Incomplete installation&quot;)&#10;    print(&quot;2. Version mismatch&quot;)&#10;    print(&quot;3. Missing dependencies&quot;)&#10;    print(&quot;\nTry reinstalling:&quot;)&#10;    print(&quot;  pip uninstall ifcopenshell&quot;)&#10;    print(&quot;  pip install ifcopenshell==0.8.0&quot;)&#10;else:&#10;    print(&quot;\nSUCCESS: All modules imported successfully!&quot;)&#10;&#10;# %% Debug: Check installation directory&#10;print(&quot;\n=== INSTALLATION DEBUG INFO ===&quot;)&#10;print(f&quot;ifcopenshell module path: {ifcopenshell.__file__}&quot;)&#10;print(f&quot;ifcopenshell directory contents:&quot;)&#10;try:&#10;    import_dir = os.path.dirname(ifcopenshell.__file__)&#10;    contents = os.listdir(import_dir)&#10;    for item in sorted(contents)[:20]:  # Show first 20 items&#10;        print(f&quot;  - {item}&quot;)&#10;    if len(contents) &gt; 20:&#10;        print(f&quot;  ... and {len(contents) - 20} more items&quot;)&#10;except Exception as e:&#10;    print(f&quot;  Error listing directory: {e}&quot;)&#10;&#10;# %% Now import what's available&#10;print(&quot;\n=== IMPORTING AVAILABLE MODULES ===&quot;)&#10;&#10;# Import utilities with fallbacks&#10;try:&#10;    import ifcopenshell.util.element&#10;    from ifcopenshell.util.element import get_decomposition&#10;    print(&quot;Debug: ifcopenshell.util.element imported successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Warning: ifcopenshell.util.element not available: {e}&quot;)&#10;    get_decomposition = None&#10;&#10;try:&#10;    import ifcopenshell.util.placement&#10;    from ifcopenshell.util.placement import get_storey_elevation&#10;    print(&quot;Debug: ifcopenshell.util.placement imported successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Warning: ifcopenshell.util.placement not available: {e}&quot;)&#10;    get_storey_elevation = None&#10;&#10;try:&#10;    import ifcopenshell.util.classification&#10;    print(&quot;Debug: ifcopenshell.util.classification imported successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Warning: ifcopenshell.util.classification not available: {e}&quot;)&#10;&#10;try:&#10;    import ifcopenshell.util.unit&#10;    print(&quot;Debug: ifcopenshell.util.unit imported successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Warning: ifcopenshell.util.unit not available: {e}&quot;)&#10;&#10;try:&#10;    import ifcopenshell.util.system&#10;    print(&quot;Debug: ifcopenshell.util.system imported successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Warning: ifcopenshell.util.system not available: {e}&quot;)&#10;&#10;# Import API modules if available - FIXED: Actually import them into global namespace&#10;if API_AVAILABLE:&#10;    try:&#10;        import ifcopenshell.api&#10;        import ifcopenshell.api.root&#10;        import ifcopenshell.api.unit&#10;        import ifcopenshell.api.context&#10;        import ifcopenshell.api.project&#10;        import ifcopenshell.api.spatial&#10;        import ifcopenshell.api.geometry&#10;        import ifcopenshell.api.aggregate&#10;        import ifcopenshell.api.sequence&#10;        print(&quot;Debug: All API modules imported successfully&quot;)&#10;    except ImportError as e:&#10;        API_AVAILABLE = False&#10;        print(f&quot;Error importing API modules: {e}&quot;)&#10;&#10;print(&quot;\n&quot; + &quot;=&quot;*60 + &quot;\n&quot;)&#10;&#10;# %% Method definitions&#10;&#10;def export_to_csv(input_file):&#10;    &quot;&quot;&quot;Export IFC file to CSV using ifcCSV utility&quot;&quot;&quot;&#10;    print(&quot;\n=== EXPORTING TO CSV ===&quot;)&#10;    csv_file = os.path.splitext(input_file)[0] + '.csv'&#10;    &#10;    try:&#10;        # Try to run ifcCSV command&#10;        cmd = ['ifcCSV', input_file, csv_file]&#10;        print(f&quot;Running command: {' '.join(cmd)}&quot;)&#10;        result = subprocess.run(cmd, capture_output=True, text=True)&#10;        &#10;        if result.returncode == 0:&#10;            print(f&quot;Successfully exported to: {csv_file}&quot;)&#10;        else:&#10;            print(f&quot;Error exporting to CSV: {result.stderr}&quot;)&#10;            # Try alternative command formats&#10;            for alt_cmd in [['python', '-m', 'ifccsv', input_file, csv_file],&#10;                          ['python3', '-m', 'ifccsv', input_file, csv_file]]:&#10;                print(f&quot;Trying alternative: {' '.join(alt_cmd)}&quot;)&#10;                result = subprocess.run(alt_cmd, capture_output=True, text=True)&#10;                if result.returncode == 0:&#10;                    print(f&quot;Successfully exported to: {csv_file}&quot;)&#10;                    break&#10;    except FileNotFoundError:&#10;        print(&quot;ifcCSV utility not found. Please ensure it's installed and in PATH&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error running ifcCSV: {e}&quot;)&#10;&#10;&#10;def analyze_basic_entities(model, limit=10):&#10;    &quot;&quot;&quot;Display basic information about entities in the model&quot;&quot;&quot;&#10;    print(&quot;\n=== BASIC ENTITIES (STEP ID ITEMS) ===&quot;)&#10;    print(f&quot;Total entities in model: {len(list(model))}&quot;)&#10;    &#10;    for i, inst in enumerate(model):&#10;        if i &gt;= limit:&#10;            print(f&quot;\n... showing first {limit} entities only ...&quot;)&#10;            break&#10;            &#10;        print(f&quot;\n--- Entity {i+1} ---&quot;)&#10;        print(&quot;The STEP entity is: &quot;, inst)&#10;        print(&quot;Type:&quot;, inst.is_a())&#10;        &#10;        if hasattr(inst, &quot;Name&quot;) and inst.Name:&#10;            print(&quot;Name:&quot;, inst.Name)&#10;        &#10;        # Show entity info&#10;        print(&quot;Entity info:&quot;)&#10;        pprint(inst.get_info())&#10;&#10;&#10;def analyze_wall_types(model):&#10;    &quot;&quot;&quot;Analyze wall types in the model&quot;&quot;&quot;&#10;    print(&quot;\n=== WALL TYPES ANALYSIS ===&quot;)&#10;    &#10;    wall_types = model.by_type(&quot;IfcWallType&quot;)&#10;    print(f&quot;Found {len(wall_types)} wall types&quot;)&#10;    &#10;    for wall_type in wall_types:&#10;        print(f&quot;\nWall type: {wall_type.Name}&quot;)&#10;        print(&quot;The wall type element is&quot;, pformat(wall_type, indent=4))&#10;        pprint(wall_type.get_info())&#10;&#10;&#10;def analyze_door_types(model):&#10;    &quot;&quot;&quot;Analyze door types and their occurrences&quot;&quot;&quot;&#10;    print(&quot;\n=== DOOR TYPES ANALYSIS ===&quot;)&#10;    &#10;    door_types = model.by_type(&quot;IfcDoorType&quot;)&#10;    print(f&quot;Found {len(door_types)} door types&quot;)&#10;    &#10;    for door_type in door_types:&#10;        print(f&quot;\nDoor type: {door_type.Name}&quot;)&#10;        pprint(door_type.get_info())&#10;        &#10;        try:&#10;            if 'ifcopenshell.util.element' in sys.modules:&#10;                doors = ifcopenshell.util.element.get_types(door_type)&#10;                print(f&quot;There are {len(doors)} doors of this type&quot;)&#10;                for door in doors:&#10;                    print(f&quot;  - Door instance: {door.Name}&quot;)&#10;            else:&#10;                print(&quot;  Warning: Cannot get door instances - util.element not available&quot;)&#10;        except Exception as e:&#10;            print(f&quot;  Warning: Error getting door instances: {e}&quot;)&#10;&#10;&#10;def analyze_element_properties(model):&#10;    &quot;&quot;&quot;Analyze properties of elements (example with walls)&quot;&quot;&quot;&#10;    print(&quot;\n=== ELEMENT PROPERTIES ANALYSIS ===&quot;)&#10;    &#10;    walls = model.by_type(&quot;IfcWall&quot;)&#10;    if not walls:&#10;        print(&quot;No walls found in model&quot;)&#10;        return&#10;    &#10;    wall = walls[0]&#10;    print(f&quot;\nAnalyzing wall: {wall.Name}&quot;)&#10;    &#10;    try:&#10;        if 'ifcopenshell.util.element' in sys.modules:&#10;            # Get wall type&#10;            wall_type = ifcopenshell.util.element.get_type(wall)&#10;            if wall_type:&#10;                print(f&quot;Wall type: {wall_type.Name}&quot;)&#10;&#10;            # Get all properties and quantities&#10;            print(&quot;\nAll properties and quantities:&quot;)&#10;            psets = ifcopenshell.util.element.get_psets(wall)&#10;            pprint(psets)&#10;&#10;            # Get only properties&#10;            print(&quot;\nProperties only:&quot;)&#10;            pprint(ifcopenshell.util.element.get_psets(wall, psets_only=True))&#10;&#10;            # Get only quantities&#10;            print(&quot;\nQuantities only:&quot;)&#10;            print(ifcopenshell.util.element.get_psets(wall, qtos_only=True))&#10;        else:&#10;            print(&quot;Warning: util.element module not available, skipping property analysis&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error analyzing properties: {e}&quot;)&#10;        print(&quot;Debug: Available modules:&quot;, list(sys.modules.keys()))&#10;&#10;&#10;def analyze_spatial_structure(model):&#10;    &quot;&quot;&quot;Analyze spatial structure and containment&quot;&quot;&quot;&#10;    print(&quot;\n=== SPATIAL STRUCTURE ANALYSIS ===&quot;)&#10;    &#10;    # Analyze building storeys&#10;    storeys = model.by_type(&quot;IfcBuildingStorey&quot;)&#10;    print(f&quot;\nFound {len(storeys)} building storeys&quot;)&#10;    &#10;    for storey in storeys:&#10;        try:&#10;            # Try to get elements&#10;            if get_decomposition:&#10;                elements = get_decomposition(storey)&#10;                print(f&quot;Debug: Using get_decomposition function&quot;)&#10;            else:&#10;                print(f&quot;Debug: Using fallback method for spatial containment&quot;)&#10;                # Fallback: manually find contained elements&#10;                elements = []&#10;                for rel in model.by_type(&quot;IfcRelContainedInSpatialStructure&quot;):&#10;                    if rel.RelatingStructure == storey:&#10;                        elements.extend(rel.RelatedElements)&#10;&#10;            # Try to get elevation&#10;            elevation = None&#10;            if get_storey_elevation:&#10;                try:&#10;                    elevation = get_storey_elevation(storey)&#10;                except Exception as e:&#10;                    print(f&quot;Debug: Could not get elevation: {e}&quot;)&#10;&#10;            if elevation is not None:&#10;                print(f&quot;\nStorey: {storey.Name} (Elevation: {elevation})&quot;)&#10;            else:&#10;                print(f&quot;\nStorey: {storey.Name} (Elevation: unknown)&quot;)&#10;&#10;            print(f&quot;Contains {len(elements)} elements:&quot;)&#10;&#10;            # Group elements by type&#10;            element_types = {}&#10;            for element in elements:&#10;                elem_type = element.is_a()&#10;                if elem_type not in element_types:&#10;                    element_types[elem_type] = []&#10;                element_types[elem_type].append(element)&#10;&#10;            for elem_type, elems in element_types.items():&#10;                print(f&quot;  - {elem_type}: {len(elems)} elements&quot;)&#10;                for elem in elems[:3]:  # Show first 3&#10;                    print(f&quot;      * {elem.Name}&quot;)&#10;                if len(elems) &gt; 3:&#10;                    print(f&quot;      ... and {len(elems) - 3} more&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error analyzing storey {storey.Name}: {e}&quot;)&#10;            import traceback&#10;            print(&quot;Debug traceback:&quot;)&#10;            traceback.print_exc()&#10;&#10;&#10;def analyze_element_placement(model):&#10;    &quot;&quot;&quot;Analyze placement and coordinates of elements&quot;&quot;&quot;&#10;    print(&quot;\n=== ELEMENT PLACEMENT ANALYSIS ===&quot;)&#10;    &#10;    walls = model.by_type(&quot;IfcWall&quot;)&#10;    if walls:&#10;        wall = walls[0]&#10;        print(f&quot;\nAnalyzing placement of wall: {wall.Name}&quot;)&#10;        &#10;        try:&#10;            if hasattr(wall, 'ObjectPlacement') and wall.ObjectPlacement:&#10;                if 'ifcopenshell.util.placement' in sys.modules:&#10;                    matrix = ifcopenshell.util.placement.get_local_placement(wall.ObjectPlacement)&#10;                    print(&quot;Transformation matrix:&quot;)&#10;                    print(matrix)&#10;                    print(f&quot;Location (XYZ): {matrix[:, 3][:3]}&quot;)&#10;                else:&#10;                    print(&quot;Warning: util.placement module not available&quot;)&#10;&#10;                # Find container&#10;                if 'ifcopenshell.util.element' in sys.modules:&#10;                    container = ifcopenshell.util.element.get_container(wall)&#10;                    if container:&#10;                        print(f&quot;Wall is located in: {container.Name}&quot;)&#10;                else:&#10;                    print(&quot;Warning: Cannot get container - util.element not available&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error analyzing placement: {e}&quot;)&#10;&#10;&#10;def analyze_classification_systems(model):&#10;    &quot;&quot;&quot;Analyze classification systems used in the model&quot;&quot;&quot;&#10;    print(&quot;\n=== CLASSIFICATION SYSTEMS ANALYSIS ===&quot;)&#10;    &#10;    # Get all classifications&#10;    classifications = model.by_type(&quot;IfcClassification&quot;)&#10;    print(f&quot;Found {len(classifications)} classification systems&quot;)&#10;    &#10;    for classification in classifications:&#10;        print(f&quot;  - {classification.Name}&quot;)&#10;    &#10;    # Example: Check wall classifications&#10;    walls = model.by_type(&quot;IfcWall&quot;)&#10;    if walls:&#10;        wall = walls[0]&#10;        print(f&quot;\nChecking classifications for wall: {wall.Name}&quot;)&#10;        &#10;        try:&#10;            if 'ifcopenshell.util.classification' in sys.modules:&#10;                references = ifcopenshell.util.classification.get_references(wall)&#10;                if references:&#10;                    for reference in references:&#10;                        print(f&quot;  - Classification reference: {reference[1]}&quot;)&#10;                        system = ifcopenshell.util.classification.get_classification(reference)&#10;                        if system:&#10;                            print(f&quot;    Part of system: {system.Name}&quot;)&#10;                else:&#10;                    print(&quot;  No classifications found&quot;)&#10;            else:&#10;                print(&quot;  Warning: Cannot check classifications - util.classification not available&quot;)&#10;        except Exception as e:&#10;            print(f&quot;  Warning: Error checking classifications: {e}&quot;)&#10;&#10;&#10;def analyze_units(model):&#10;    &quot;&quot;&quot;Analyze units used in the model&quot;&quot;&quot;&#10;    print(&quot;\n=== UNITS ANALYSIS ===&quot;)&#10;    &#10;    try:&#10;        if 'ifcopenshell.util.unit' in sys.modules:&#10;            unit_scale = ifcopenshell.util.unit.calculate_unit_scale(model)&#10;            print(f&quot;Unit scale factor (to SI): {unit_scale}&quot;)&#10;&#10;            # Example conversion&#10;            ifc_project_length = 1&#10;            si_meters = ifc_project_length * unit_scale&#10;            print(f&quot;1 project unit = {si_meters} meters&quot;)&#10;        else:&#10;            print(&quot;Warning: Cannot calculate unit scale - util.unit not available&quot;)&#10;&#10;        # Get unit assignments&#10;        unit_assignments = model.by_type(&quot;IfcUnitAssignment&quot;)&#10;        if unit_assignments:&#10;            print(&quot;\nUnit assignments found:&quot;)&#10;            for unit_assignment in unit_assignments:&#10;                print(f&quot;  Units in assignment: {len(unit_assignment.Units)}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error analyzing units: {e}&quot;)&#10;&#10;&#10;def analyze_systems(model):&#10;    &quot;&quot;&quot;Analyze MEP systems in the model&quot;&quot;&quot;&#10;    print(&quot;\n=== SYSTEMS ANALYSIS ===&quot;)&#10;    &#10;    # Check for pipe segments&#10;    pipes = model.by_type(&quot;IfcPipeSegment&quot;)&#10;    print(f&quot;Found {len(pipes)} pipe segments&quot;)&#10;    &#10;    if pipes:&#10;        pipe = pipes[0]&#10;        print(f&quot;\nAnalyzing pipe segment: {pipe.Name if hasattr(pipe, 'Name') else 'Unnamed'}&quot;)&#10;        &#10;        try:&#10;            if 'ifcopenshell.util.system' in sys.modules:&#10;                # Get systems&#10;                systems = ifcopenshell.util.system.get_element_systems(pipe)&#10;                if systems:&#10;                    print(&quot;Pipe is part of systems:&quot;)&#10;                    for system in systems:&#10;                        print(f&quot;  - {system.Name}&quot;)&#10;                else:&#10;                    print(&quot;Pipe is not assigned to any system&quot;)&#10;            else:&#10;                print(&quot;Warning: Cannot check systems - util.system not available&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Warning: Error checking systems: {e}&quot;)&#10;&#10;    # Check for all systems&#10;    all_systems = model.by_type(&quot;IfcSystem&quot;)&#10;    print(f&quot;\nTotal systems in model: {len(all_systems)}&quot;)&#10;    for system in all_systems[:10]:  # Show first 10&#10;        print(f&quot;  - {system.Name} ({system.is_a()})&quot;)&#10;&#10;&#10;def create_simple_model_example(output_file=&quot;example_model.ifc&quot;):&#10;    &quot;&quot;&quot;Create a simple IFC model from scratch&quot;&quot;&quot;&#10;    if not API_AVAILABLE:&#10;        print(&quot;\n=== CANNOT CREATE MODEL ===&quot;)&#10;        print(&quot;API modules are not available in your ifcopenshell installation&quot;)&#10;        print(&quot;Debug: API_AVAILABLE =&quot;, API_AVAILABLE)&#10;        print(&quot;Debug: Available modules containing 'ifcopenshell.api':&quot;)&#10;        for module in sys.modules:&#10;            if 'ifcopenshell.api' in module:&#10;                print(f&quot;  - {module}&quot;)&#10;        return None&#10;&#10;    print(&quot;\n=== CREATING SIMPLE MODEL EXAMPLE ===&quot;)&#10;    &#10;    try:&#10;        # Create blank model&#10;        print(&quot;Debug: Creating blank model...&quot;)&#10;        model = ifcopenshell.api.project.create_file()&#10;        print(&quot;Debug: Model created successfully&quot;)&#10;&#10;        # Create project&#10;        project = ifcopenshell.api.root.create_entity(model, ifc_class=&quot;IfcProject&quot;, name=&quot;Example Project&quot;)&#10;&#10;        # Set units&#10;        ifcopenshell.api.unit.assign_unit(model)&#10;&#10;        # Create contexts&#10;        context = ifcopenshell.api.context.add_context(model, context_type=&quot;Model&quot;)&#10;        body = ifcopenshell.api.context.add_context(model, context_type=&quot;Model&quot;,&#10;                                                   context_identifier=&quot;Body&quot;, target_view=&quot;MODEL_VIEW&quot;, parent=context)&#10;&#10;        # Create spatial structure&#10;        site = ifcopenshell.api.root.create_entity(model, ifc_class=&quot;IfcSite&quot;, name=&quot;Example Site&quot;)&#10;        building = ifcopenshell.api.root.create_entity(model, ifc_class=&quot;IfcBuilding&quot;, name=&quot;Example Building&quot;)&#10;        storey = ifcopenshell.api.root.create_entity(model, ifc_class=&quot;IfcBuildingStorey&quot;, name=&quot;Ground Floor&quot;)&#10;&#10;        # Assign hierarchy&#10;        ifcopenshell.api.aggregate.assign_object(model, relating_object=project, products=[site])&#10;        ifcopenshell.api.aggregate.assign_object(model, relating_object=site, products=[building])&#10;        ifcopenshell.api.aggregate.assign_object(model, relating_object=building, products=[storey])&#10;&#10;        # Create wall&#10;        wall = ifcopenshell.api.root.create_entity(model, ifc_class=&quot;IfcWall&quot;)&#10;        ifcopenshell.api.geometry.edit_object_placement(model, product=wall)&#10;&#10;        # Add geometry&#10;        representation = ifcopenshell.api.geometry.add_wall_representation(&#10;            model, context=body, length=5, height=3, thickness=0.2)&#10;        ifcopenshell.api.geometry.assign_representation(model, product=wall, representation=representation)&#10;&#10;        # Place wall in storey&#10;        ifcopenshell.api.spatial.assign_container(model, relating_structure=storey, products=[wall])&#10;&#10;        # Save&#10;        model.write(output_file)&#10;        print(f&quot;Created example model: {output_file}&quot;)&#10;&#10;        return output_file&#10;    except Exception as e:&#10;        print(f&quot;Error creating model: {e}&quot;)&#10;        import traceback&#10;        print(&quot;\nDebug: Full traceback:&quot;)&#10;        traceback.print_exc()&#10;        return None&#10;&#10;&#10;def add_construction_schedule(model, output_file=&quot;model_with_schedule.ifc&quot;):&#10;    &quot;&quot;&quot;Add construction schedule to existing model&quot;&quot;&quot;&#10;    if not API_AVAILABLE:&#10;        print(&quot;\n=== CANNOT ADD SCHEDULE - API NOT AVAILABLE ===&quot;)&#10;        return&#10;&#10;    print(&quot;\n=== ADDING CONSTRUCTION SCHEDULE ===&quot;)&#10;    &#10;    try:&#10;        def add_task(model, name, predecessor, work_schedule):&#10;            task = ifcopenshell.api.sequence.add_task(&#10;                model, work_schedule=work_schedule, name=name, predefined_type=&quot;CONSTRUCTION&quot;)&#10;&#10;            task_time = ifcopenshell.api.sequence.add_task_time(model, task=task)&#10;&#10;            ifcopenshell.api.sequence.edit_task_time(&#10;                model, task_time=task_time,&#10;                attributes={&quot;ScheduleStart&quot;: datetime.date(2000, 1, 1), &quot;ScheduleDuration&quot;: &quot;P1W&quot;})&#10;&#10;            if predecessor:&#10;                ifcopenshell.api.sequence.assign_sequence(&#10;                    model, relating_process=predecessor, related_process=task)&#10;&#10;            return task&#10;&#10;        # Create schedule&#10;        schedule = ifcopenshell.api.sequence.add_work_schedule(model, name=&quot;Construction&quot;)&#10;&#10;        # Site establishment&#10;        task = add_task(model, &quot;Site establishment&quot;, None, schedule)&#10;        start_task = task&#10;&#10;        # Add tasks for each storey&#10;        if get_storey_elevation:&#10;            storeys = sorted(model.by_type(&quot;IfcBuildingStorey&quot;), key=lambda s: get_storey_elevation(s))&#10;        else:&#10;            print(&quot;Warning: get_storey_elevation not available, using unsorted storeys&quot;)&#10;            storeys = model.by_type(&quot;IfcBuildingStorey&quot;)&#10;&#10;        for storey in storeys:&#10;            task = add_task(model, f&quot;Construct {storey.Name}&quot;, task, schedule)&#10;&#10;            # Assign products&#10;            if get_decomposition:&#10;                for product in get_decomposition(storey):&#10;                    ifcopenshell.api.sequence.assign_product(&#10;                        model, relating_product=product, related_object=task)&#10;&#10;        # Calculate schedule&#10;        ifcopenshell.api.sequence.cascade_schedule(model, task=start_task)&#10;        ifcopenshell.api.sequence.recalculate_schedule(model, work_schedule=schedule)&#10;&#10;        # Save&#10;        model.write(output_file)&#10;        print(f&quot;Model with schedule saved to: {output_file}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error adding schedule: {e}&quot;)&#10;        import traceback&#10;        print(&quot;Debug: Full traceback:&quot;)&#10;        traceback.print_exc()&#10;&#10;# %% Main definition&#10;def main():&#10;    &quot;&quot;&quot;Main function to run all analyses&quot;&quot;&quot;&#10;    print(&quot;\n=== STARTING MAIN ANALYSIS ===&quot;)&#10;    print(f&quot;Debug: Script directory: {os.path.dirname(os.path.abspath(__name__))}&quot;)&#10;&#10;    # Get input file from command line or use default&#10;    if len(sys.argv) &gt; 1:&#10;        input_file = sys.argv[1]&#10;    else:&#10;        input_file = os.path.join(os.getenv(&quot;PYMAOS_HOME&quot;),'ifc','AC20-FZK-Haus.ifc')&#10;    &#10;    print(f&quot;Analyzing IFC file: {input_file}&quot;)&#10;&#10;    # Check if file exists&#10;    if not os.path.exists(input_file):&#10;        print(f&quot;Error: File '{input_file}' not found!&quot;)&#10;        if API_AVAILABLE:&#10;            print(&quot;Creating example model instead...&quot;)&#10;            input_file = create_simple_model_example()&#10;            if not input_file:&#10;                print(&quot;Failed to create example model&quot;)&#10;                return&#10;        else:&#10;            print(&quot;Cannot create example model - API not available&quot;)&#10;            return&#10;&#10;    # Open model&#10;    try:&#10;        model = ifcopenshell.open(input_file)&#10;        print(f&quot;Successfully opened IFC file (Schema: {model.schema})&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error opening IFC file: {e}&quot;)&#10;        return&#10;    &#10;    # Run all analyses&#10;    analyze_basic_entities(model, limit=5)&#10;    analyze_wall_types(model)&#10;    analyze_door_types(model)&#10;    analyze_element_properties(model)&#10;    analyze_spatial_structure(model)&#10;    analyze_element_placement(model)&#10;    analyze_classification_systems(model)&#10;    analyze_units(model)&#10;    analyze_systems(model)&#10;    &#10;    # Add construction schedule&#10;    add_construction_schedule(model)&#10;&#10;    # Export to CSV&#10;    export_to_csv(input_file)&#10;    &#10;    print(&quot;\n=== ANALYSIS COMPLETE ===&quot;)&#10;&#10;# %% Run&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="# %% setup&#10;&#10;import sys&#10;import os&#10;import subprocess&#10;from pprint import pprint, pformat&#10;import datetime&#10;&#10;# %% Check ifcopenshell installation status&#10;print(&quot;=== CHECKING IFCOPENSHELL INSTALLATION ===&quot;)&#10;print(&quot;Debug: Python version:&quot;, sys.version)&#10;print(&quot;Debug: Python executable:&quot;, sys.executable)&#10;print(&quot;Debug: sys.path:&quot;)&#10;for p in sys.path[:5]:  # Show first 5 paths&#10;    print(f&quot;  - {p}&quot;)&#10;&#10;# Try basic import&#10;try:&#10;    import ifcopenshell&#10;    print(f&quot;SUCCESS: ifcopenshell imported successfully&quot;)&#10;    print(f&quot;         Version: {ifcopenshell.version}&quot;)&#10;    IFCOPENSHELL_AVAILABLE = True&#10;except ImportError as e:&#10;    print(f&quot;ERROR: Unable to import ifcopenshell: {e}&quot;)&#10;    print(&quot;Please install with: pip install ifcopenshell&quot;)&#10;    IFCOPENSHELL_AVAILABLE = False&#10;    sys.exit(1)&#10;&#10;# Check submodules systematically&#10;print(&quot;\n=== CHECKING SUBMODULES ===&quot;)&#10;modules_status = {}&#10;&#10;# %% Utility modules&#10;util_modules = [&#10;    'ifcopenshell.util',&#10;    'ifcopenshell.util.element',&#10;    'ifcopenshell.util.placement',&#10;    'ifcopenshell.util.classification',&#10;    'ifcopenshell.util.unit',&#10;    'ifcopenshell.util.system'&#10;]&#10;&#10;print(&quot;\nChecking utility modules:&quot;)&#10;for module_name in util_modules:&#10;    try:&#10;        module = __import__(module_name, fromlist=[''])&#10;        modules_status[module_name] = True&#10;        print(f&quot;  [OK] {module_name}&quot;)&#10;        # Debug: Check module path&#10;        if hasattr(module, '__file__'):&#10;            print(f&quot;       Path: {module.__file__}&quot;)&#10;    except ImportError as e:&#10;        modules_status[module_name] = False&#10;        print(f&quot;  [FAIL] {module_name}: {e}&quot;)&#10;&#10;# %% API modules - Fixed import mechanism&#10;api_modules = [&#10;    'ifcopenshell.api',&#10;    'ifcopenshell.api.root',&#10;    'ifcopenshell.api.unit',&#10;    'ifcopenshell.api.context',&#10;    'ifcopenshell.api.project',&#10;    'ifcopenshell.api.spatial',&#10;    'ifcopenshell.api.geometry',&#10;    'ifcopenshell.api.aggregate',&#10;    'ifcopenshell.api.sequence'&#10;]&#10;&#10;print(&quot;\nChecking API modules:&quot;)&#10;API_AVAILABLE = True&#10;&#10;# First, try to import the base API module&#10;try:&#10;    import ifcopenshell.api&#10;    print(f&quot;  [OK] ifcopenshell.api&quot;)&#10;    if hasattr(ifcopenshell.api, '__file__'):&#10;        print(f&quot;       Path: {ifcopenshell.api.__file__}&quot;)&#10;    modules_status['ifcopenshell.api'] = True&#10;except Exception as e:&#10;    print(f&quot;  [FAIL] ifcopenshell.api: {e}&quot;)&#10;    modules_status['ifcopenshell.api'] = False&#10;    API_AVAILABLE = False&#10;&#10;# Now import the rest&#10;if API_AVAILABLE:&#10;    for module_name in api_modules[1:]:  # Skip the first one we already imported&#10;        try:&#10;            # Use exec to ensure proper import&#10;            exec(f&quot;import {module_name}&quot;)&#10;            # Verify it's actually imported&#10;            module = sys.modules.get(module_name)&#10;            if module:&#10;                modules_status[module_name] = True&#10;                print(f&quot;  [OK] {module_name}&quot;)&#10;                if hasattr(module, '__file__'):&#10;                    print(f&quot;       Path: {module.__file__}&quot;)&#10;            else:&#10;                raise ImportError(f&quot;Module {module_name} not found in sys.modules after import&quot;)&#10;        except Exception as e:&#10;            modules_status[module_name] = False&#10;            API_AVAILABLE = False&#10;            print(f&quot;  [FAIL] {module_name}: {e}&quot;)&#10;            print(f&quot;        Debug: Exception type: {type(e).__name__}&quot;)&#10;            import traceback&#10;            print(&quot;        Debug: Traceback:&quot;)&#10;            for line in traceback.format_exc().split('\n'):&#10;                if line.strip():&#10;                    print(f&quot;          {line}&quot;)&#10;&#10;# %% Summary&#10;failed_modules = [k for k, v in modules_status.items() if not v]&#10;if failed_modules:&#10;    print(f&quot;\nWARNING: {len(failed_modules)} modules failed to import:&quot;)&#10;    for module in failed_modules:&#10;        print(f&quot;  - {module}&quot;)&#10;    print(&quot;\nThis might be due to:&quot;)&#10;    print(&quot;1. Incomplete installation&quot;)&#10;    print(&quot;2. Version mismatch&quot;)&#10;    print(&quot;3. Missing dependencies&quot;)&#10;    print(&quot;\nTry reinstalling:&quot;)&#10;    print(&quot;  pip uninstall ifcopenshell&quot;)&#10;    print(&quot;  pip install ifcopenshell==0.8.0&quot;)&#10;else:&#10;    print(&quot;\nSUCCESS: All modules imported successfully!&quot;)&#10;&#10;# %% Debug: Check installation directory&#10;print(&quot;\n=== INSTALLATION DEBUG INFO ===&quot;)&#10;print(f&quot;ifcopenshell module path: {ifcopenshell.__file__}&quot;)&#10;print(f&quot;ifcopenshell directory contents:&quot;)&#10;try:&#10;    import_dir = os.path.dirname(ifcopenshell.__file__)&#10;    contents = os.listdir(import_dir)&#10;    for item in sorted(contents)[:20]:  # Show first 20 items&#10;        print(f&quot;  - {item}&quot;)&#10;    if len(contents) &gt; 20:&#10;        print(f&quot;  ... and {len(contents) - 20} more items&quot;)&#10;except Exception as e:&#10;    print(f&quot;  Error listing directory: {e}&quot;)&#10;&#10;# %% Now import what's available&#10;print(&quot;\n=== IMPORTING AVAILABLE MODULES ===&quot;)&#10;&#10;# Import utilities with fallbacks&#10;try:&#10;    import ifcopenshell.util.element&#10;    from ifcopenshell.util.element import get_decomposition&#10;    print(&quot;Debug: ifcopenshell.util.element imported successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Warning: ifcopenshell.util.element not available: {e}&quot;)&#10;    get_decomposition = None&#10;&#10;try:&#10;    import ifcopenshell.util.placement&#10;    from ifcopenshell.util.placement import get_storey_elevation&#10;    print(&quot;Debug: ifcopenshell.util.placement imported successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Warning: ifcopenshell.util.placement not available: {e}&quot;)&#10;    get_storey_elevation = None&#10;&#10;try:&#10;    import ifcopenshell.util.classification&#10;    print(&quot;Debug: ifcopenshell.util.classification imported successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Warning: ifcopenshell.util.classification not available: {e}&quot;)&#10;&#10;try:&#10;    import ifcopenshell.util.unit&#10;    print(&quot;Debug: ifcopenshell.util.unit imported successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Warning: ifcopenshell.util.unit not available: {e}&quot;)&#10;&#10;try:&#10;    import ifcopenshell.util.system&#10;    print(&quot;Debug: ifcopenshell.util.system imported successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Warning: ifcopenshell.util.system not available: {e}&quot;)&#10;&#10;# Import API modules if available - More robust import&#10;if API_AVAILABLE:&#10;    print(&quot;\nImporting API modules into global namespace...&quot;)&#10;    try:&#10;        # Import them explicitly one by one&#10;        import ifcopenshell.api&#10;        import ifcopenshell.api.root&#10;        import ifcopenshell.api.unit&#10;        import ifcopenshell.api.context&#10;        import ifcopenshell.api.project&#10;        import ifcopenshell.api.spatial&#10;        import ifcopenshell.api.geometry&#10;        import ifcopenshell.api.aggregate&#10;        import ifcopenshell.api.sequence&#10;        print(&quot;Debug: All API modules imported successfully into global namespace&quot;)&#10;        &#10;        # Verify they're actually available&#10;        for module_name in api_modules:&#10;            if module_name not in sys.modules:&#10;                print(f&quot;Warning: {module_name} not in sys.modules despite import&quot;)&#10;                API_AVAILABLE = False&#10;    except Exception as e:&#10;        API_AVAILABLE = False&#10;        print(f&quot;Error importing API modules into global namespace: {e}&quot;)&#10;        import traceback&#10;        print(&quot;Debug: Full traceback:&quot;)&#10;        traceback.print_exc()&#10;&#10;print(&quot;\n&quot; + &quot;=&quot;*60 + &quot;\n&quot;)&#10;&#10;# %% Method definitions&#10;&#10;def export_to_csv(input_file):&#10;    &quot;&quot;&quot;Export IFC file to CSV using ifcCSV utility&quot;&quot;&quot;&#10;    print(&quot;\n=== EXPORTING TO CSV ===&quot;)&#10;    csv_file = os.path.splitext(input_file)[0] + '.csv'&#10;    &#10;    try:&#10;        # Try to run ifcCSV command&#10;        cmd = ['ifcCSV', input_file, csv_file]&#10;        print(f&quot;Running command: {' '.join(cmd)}&quot;)&#10;        result = subprocess.run(cmd, capture_output=True, text=True)&#10;        &#10;        if result.returncode == 0:&#10;            print(f&quot;Successfully exported to: {csv_file}&quot;)&#10;        else:&#10;            print(f&quot;Error exporting to CSV: {result.stderr}&quot;)&#10;            # Try alternative command formats&#10;            for alt_cmd in [['python', '-m', 'ifccsv', input_file, csv_file],&#10;                          ['python3', '-m', 'ifccsv', input_file, csv_file]]:&#10;                print(f&quot;Trying alternative: {' '.join(alt_cmd)}&quot;)&#10;                result = subprocess.run(alt_cmd, capture_output=True, text=True)&#10;                if result.returncode == 0:&#10;                    print(f&quot;Successfully exported to: {csv_file}&quot;)&#10;                    break&#10;    except FileNotFoundError:&#10;        print(&quot;ifcCSV utility not found. Please ensure it's installed and in PATH&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error running ifcCSV: {e}&quot;)&#10;&#10;&#10;def analyze_basic_entities(model, limit=10):&#10;    &quot;&quot;&quot;Display basic information about entities in the model&quot;&quot;&quot;&#10;    print(&quot;\n=== BASIC ENTITIES (STEP ID ITEMS) ===&quot;)&#10;    print(f&quot;Total entities in model: {len(list(model))}&quot;)&#10;    &#10;    for i, inst in enumerate(model):&#10;        if i &gt;= limit:&#10;            print(f&quot;\n... showing first {limit} entities only ...&quot;)&#10;            break&#10;            &#10;        print(f&quot;\n--- Entity {i+1} ---&quot;)&#10;        print(&quot;The STEP entity is: &quot;, inst)&#10;        print(&quot;Type:&quot;, inst.is_a())&#10;        &#10;        if hasattr(inst, &quot;Name&quot;) and inst.Name:&#10;            print(&quot;Name:&quot;, inst.Name)&#10;        &#10;        # Show entity info&#10;        print(&quot;Entity info:&quot;)&#10;        pprint(inst.get_info())&#10;&#10;&#10;def analyze_wall_types(model):&#10;    &quot;&quot;&quot;Analyze wall types in the model&quot;&quot;&quot;&#10;    print(&quot;\n=== WALL TYPES ANALYSIS ===&quot;)&#10;    &#10;    wall_types = model.by_type(&quot;IfcWallType&quot;)&#10;    print(f&quot;Found {len(wall_types)} wall types&quot;)&#10;    &#10;    for wall_type in wall_types:&#10;        print(f&quot;\nWall type: {wall_type.Name}&quot;)&#10;        print(&quot;The wall type element is&quot;, pformat(wall_type, indent=4))&#10;        pprint(wall_type.get_info())&#10;&#10;&#10;def analyze_door_types(model):&#10;    &quot;&quot;&quot;Analyze door types and their occurrences&quot;&quot;&quot;&#10;    print(&quot;\n=== DOOR TYPES ANALYSIS ===&quot;)&#10;    &#10;    door_types = model.by_type(&quot;IfcDoorType&quot;)&#10;    print(f&quot;Found {len(door_types)} door types&quot;)&#10;    &#10;    for door_type in door_types:&#10;        print(f&quot;\nDoor type: {door_type.Name}&quot;)&#10;        pprint(door_type.get_info())&#10;        &#10;        try:&#10;            if 'ifcopenshell.util.element' in sys.modules:&#10;                doors = ifcopenshell.util.element.get_types(door_type)&#10;                print(f&quot;There are {len(doors)} doors of this type&quot;)&#10;                for door in doors:&#10;                    print(f&quot;  - Door instance: {door.Name}&quot;)&#10;            else:&#10;                print(&quot;  Warning: Cannot get door instances - util.element not available&quot;)&#10;        except Exception as e:&#10;            print(f&quot;  Warning: Error getting door instances: {e}&quot;)&#10;&#10;&#10;def analyze_element_properties(model):&#10;    &quot;&quot;&quot;Analyze properties of elements (example with walls)&quot;&quot;&quot;&#10;    print(&quot;\n=== ELEMENT PROPERTIES ANALYSIS ===&quot;)&#10;    &#10;    walls = model.by_type(&quot;IfcWall&quot;)&#10;    if not walls:&#10;        print(&quot;No walls found in model&quot;)&#10;        return&#10;    &#10;    wall = walls[0]&#10;    print(f&quot;\nAnalyzing wall: {wall.Name}&quot;)&#10;    &#10;    try:&#10;        if 'ifcopenshell.util.element' in sys.modules:&#10;            # Get wall type&#10;            wall_type = ifcopenshell.util.element.get_type(wall)&#10;            if wall_type:&#10;                print(f&quot;Wall type: {wall_type.Name}&quot;)&#10;&#10;            # Get all properties and quantities&#10;            print(&quot;\nAll properties and quantities:&quot;)&#10;            psets = ifcopenshell.util.element.get_psets(wall)&#10;            pprint(psets)&#10;&#10;            # Get only properties&#10;            print(&quot;\nProperties only:&quot;)&#10;            pprint(ifcopenshell.util.element.get_psets(wall, psets_only=True))&#10;&#10;            # Get only quantities&#10;            print(&quot;\nQuantities only:&quot;)&#10;            print(ifcopenshell.util.element.get_psets(wall, qtos_only=True))&#10;        else:&#10;            print(&quot;Warning: util.element module not available, skipping property analysis&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error analyzing properties: {e}&quot;)&#10;        print(&quot;Debug: Available modules:&quot;, list(sys.modules.keys()))&#10;&#10;&#10;def analyze_spatial_structure(model):&#10;    &quot;&quot;&quot;Analyze spatial structure and containment&quot;&quot;&quot;&#10;    print(&quot;\n=== SPATIAL STRUCTURE ANALYSIS ===&quot;)&#10;    &#10;    # Analyze building storeys&#10;    storeys = model.by_type(&quot;IfcBuildingStorey&quot;)&#10;    print(f&quot;\nFound {len(storeys)} building storeys&quot;)&#10;    &#10;    for storey in storeys:&#10;        try:&#10;            # Try to get elements&#10;            if get_decomposition:&#10;                elements = get_decomposition(storey)&#10;                print(f&quot;Debug: Using get_decomposition function&quot;)&#10;            else:&#10;                print(f&quot;Debug: Using fallback method for spatial containment&quot;)&#10;                # Fallback: manually find contained elements&#10;                elements = []&#10;                for rel in model.by_type(&quot;IfcRelContainedInSpatialStructure&quot;):&#10;                    if rel.RelatingStructure == storey:&#10;                        elements.extend(rel.RelatedElements)&#10;&#10;            # Try to get elevation&#10;            elevation = None&#10;            if get_storey_elevation:&#10;                try:&#10;                    elevation = get_storey_elevation(storey)&#10;                except Exception as e:&#10;                    print(f&quot;Debug: Could not get elevation: {e}&quot;)&#10;&#10;            if elevation is not None:&#10;                print(f&quot;\nStorey: {storey.Name} (Elevation: {elevation})&quot;)&#10;            else:&#10;                print(f&quot;\nStorey: {storey.Name} (Elevation: unknown)&quot;)&#10;&#10;            print(f&quot;Contains {len(elements)} elements:&quot;)&#10;&#10;            # Group elements by type&#10;            element_types = {}&#10;            for element in elements:&#10;                elem_type = element.is_a()&#10;                if elem_type not in element_types:&#10;                    element_types[elem_type] = []&#10;                element_types[elem_type].append(element)&#10;&#10;            for elem_type, elems in element_types.items():&#10;                print(f&quot;  - {elem_type}: {len(elems)} elements&quot;)&#10;                for elem in elems[:3]:  # Show first 3&#10;                    print(f&quot;      * {elem.Name}&quot;)&#10;                if len(elems) &gt; 3:&#10;                    print(f&quot;      ... and {len(elems) - 3} more&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error analyzing storey {storey.Name}: {e}&quot;)&#10;            import traceback&#10;            print(&quot;Debug traceback:&quot;)&#10;            traceback.print_exc()&#10;&#10;&#10;def analyze_element_placement(model):&#10;    &quot;&quot;&quot;Analyze placement and coordinates of elements&quot;&quot;&quot;&#10;    print(&quot;\n=== ELEMENT PLACEMENT ANALYSIS ===&quot;)&#10;    &#10;    walls = model.by_type(&quot;IfcWall&quot;)&#10;    if walls:&#10;        wall = walls[0]&#10;        print(f&quot;\nAnalyzing placement of wall: {wall.Name}&quot;)&#10;        &#10;        try:&#10;            if hasattr(wall, 'ObjectPlacement') and wall.ObjectPlacement:&#10;                if 'ifcopenshell.util.placement' in sys.modules:&#10;                    matrix = ifcopenshell.util.placement.get_local_placement(wall.ObjectPlacement)&#10;                    print(&quot;Transformation matrix:&quot;)&#10;                    print(matrix)&#10;                    print(f&quot;Location (XYZ): {matrix[:, 3][:3]}&quot;)&#10;                else:&#10;                    print(&quot;Warning: util.placement module not available&quot;)&#10;&#10;                # Find container&#10;                if 'ifcopenshell.util.element' in sys.modules:&#10;                    container = ifcopenshell.util.element.get_container(wall)&#10;                    if container:&#10;                        print(f&quot;Wall is located in: {container.Name}&quot;)&#10;                else:&#10;                    print(&quot;Warning: Cannot get container - util.element not available&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error analyzing placement: {e}&quot;)&#10;&#10;&#10;def analyze_classification_systems(model):&#10;    &quot;&quot;&quot;Analyze classification systems used in the model&quot;&quot;&quot;&#10;    print(&quot;\n=== CLASSIFICATION SYSTEMS ANALYSIS ===&quot;)&#10;    &#10;    # Get all classifications&#10;    classifications = model.by_type(&quot;IfcClassification&quot;)&#10;    print(f&quot;Found {len(classifications)} classification systems&quot;)&#10;    &#10;    for classification in classifications:&#10;        print(f&quot;  - {classification.Name}&quot;)&#10;    &#10;    # Example: Check wall classifications&#10;    walls = model.by_type(&quot;IfcWall&quot;)&#10;    if walls:&#10;        wall = walls[0]&#10;        print(f&quot;\nChecking classifications for wall: {wall.Name}&quot;)&#10;        &#10;        try:&#10;            if 'ifcopenshell.util.classification' in sys.modules:&#10;                references = ifcopenshell.util.classification.get_references(wall)&#10;                if references:&#10;                    for reference in references:&#10;                        print(f&quot;  - Classification reference: {reference[1]}&quot;)&#10;                        system = ifcopenshell.util.classification.get_classification(reference)&#10;                        if system:&#10;                            print(f&quot;    Part of system: {system.Name}&quot;)&#10;                else:&#10;                    print(&quot;  No classifications found&quot;)&#10;            else:&#10;                print(&quot;  Warning: Cannot check classifications - util.classification not available&quot;)&#10;        except Exception as e:&#10;            print(f&quot;  Warning: Error checking classifications: {e}&quot;)&#10;&#10;&#10;def analyze_units(model):&#10;    &quot;&quot;&quot;Analyze units used in the model&quot;&quot;&quot;&#10;    print(&quot;\n=== UNITS ANALYSIS ===&quot;)&#10;    &#10;    try:&#10;        if 'ifcopenshell.util.unit' in sys.modules:&#10;            unit_scale = ifcopenshell.util.unit.calculate_unit_scale(model)&#10;            print(f&quot;Unit scale factor (to SI): {unit_scale}&quot;)&#10;&#10;            # Example conversion&#10;            ifc_project_length = 1&#10;            si_meters = ifc_project_length * unit_scale&#10;            print(f&quot;1 project unit = {si_meters} meters&quot;)&#10;        else:&#10;            print(&quot;Warning: Cannot calculate unit scale - util.unit not available&quot;)&#10;&#10;        # Get unit assignments&#10;        unit_assignments = model.by_type(&quot;IfcUnitAssignment&quot;)&#10;        if unit_assignments:&#10;            print(&quot;\nUnit assignments found:&quot;)&#10;            for unit_assignment in unit_assignments:&#10;                print(f&quot;  Units in assignment: {len(unit_assignment.Units)}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error analyzing units: {e}&quot;)&#10;&#10;&#10;def analyze_systems(model):&#10;    &quot;&quot;&quot;Analyze MEP systems in the model&quot;&quot;&quot;&#10;    print(&quot;\n=== SYSTEMS ANALYSIS ===&quot;)&#10;    &#10;    # Check for pipe segments&#10;    pipes = model.by_type(&quot;IfcPipeSegment&quot;)&#10;    print(f&quot;Found {len(pipes)} pipe segments&quot;)&#10;    &#10;    if pipes:&#10;        pipe = pipes[0]&#10;        print(f&quot;\nAnalyzing pipe segment: {pipe.Name if hasattr(pipe, 'Name') else 'Unnamed'}&quot;)&#10;        &#10;        try:&#10;            if 'ifcopenshell.util.system' in sys.modules:&#10;                # Get systems&#10;                systems = ifcopenshell.util.system.get_element_systems(pipe)&#10;                if systems:&#10;                    print(&quot;Pipe is part of systems:&quot;)&#10;                    for system in systems:&#10;                        print(f&quot;  - {system.Name}&quot;)&#10;                else:&#10;                    print(&quot;Pipe is not assigned to any system&quot;)&#10;            else:&#10;                print(&quot;Warning: Cannot check systems - util.system not available&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Warning: Error checking systems: {e}&quot;)&#10;&#10;    # Check for all systems&#10;    all_systems = model.by_type(&quot;IfcSystem&quot;)&#10;    print(f&quot;\nTotal systems in model: {len(all_systems)}&quot;)&#10;    for system in all_systems[:10]:  # Show first 10&#10;        print(f&quot;  - {system.Name} ({system.is_a()})&quot;)&#10;&#10;&#10;def create_simple_model_example(output_file=&quot;example_model.ifc&quot;):&#10;    &quot;&quot;&quot;Create a simple IFC model from scratch&quot;&quot;&quot;&#10;    if not API_AVAILABLE:&#10;        print(&quot;\n=== CANNOT CREATE MODEL ===&quot;)&#10;        print(&quot;API modules are not available in your ifcopenshell installation&quot;)&#10;        print(&quot;Debug: API_AVAILABLE =&quot;, API_AVAILABLE)&#10;        print(&quot;Debug: Available modules containing 'ifcopenshell.api':&quot;)&#10;        for module in sys.modules:&#10;            if 'ifcopenshell.api' in module:&#10;                print(f&quot;  - {module}&quot;)&#10;        return None&#10;&#10;    print(&quot;\n=== CREATING SIMPLE MODEL EXAMPLE ===&quot;)&#10;    &#10;    try:&#10;        # Create blank model&#10;        print(&quot;Debug: Creating blank model...&quot;)&#10;        model = ifcopenshell.api.project.create_file()&#10;        print(&quot;Debug: Model created successfully&quot;)&#10;&#10;        # Create project&#10;        project = ifcopenshell.api.root.create_entity(model, ifc_class=&quot;IfcProject&quot;, name=&quot;Example Project&quot;)&#10;&#10;        # Set units&#10;        ifcopenshell.api.unit.assign_unit(model)&#10;&#10;        # Create contexts&#10;        context = ifcopenshell.api.context.add_context(model, context_type=&quot;Model&quot;)&#10;        body = ifcopenshell.api.context.add_context(model, context_type=&quot;Model&quot;,&#10;                                                   context_identifier=&quot;Body&quot;, target_view=&quot;MODEL_VIEW&quot;, parent=context)&#10;&#10;        # Create spatial structure&#10;        site = ifcopenshell.api.root.create_entity(model, ifc_class=&quot;IfcSite&quot;, name=&quot;Example Site&quot;)&#10;        building = ifcopenshell.api.root.create_entity(model, ifc_class=&quot;IfcBuilding&quot;, name=&quot;Example Building&quot;)&#10;        storey = ifcopenshell.api.root.create_entity(model, ifc_class=&quot;IfcBuildingStorey&quot;, name=&quot;Ground Floor&quot;)&#10;&#10;        # Assign hierarchy&#10;        ifcopenshell.api.aggregate.assign_object(model, relating_object=project, products=[site])&#10;        ifcopenshell.api.aggregate.assign_object(model, relating_object=site, products=[building])&#10;        ifcopenshell.api.aggregate.assign_object(model, relating_object=building, products=[storey])&#10;&#10;        # Create wall&#10;        wall = ifcopenshell.api.root.create_entity(model, ifc_class=&quot;IfcWall&quot;)&#10;        ifcopenshell.api.geometry.edit_object_placement(model, product=wall)&#10;&#10;        # Add geometry&#10;        representation = ifcopenshell.api.geometry.add_wall_representation(&#10;            model, context=body, length=5, height=3, thickness=0.2)&#10;        ifcopenshell.api.geometry.assign_representation(model, product=wall, representation=representation)&#10;&#10;        # Place wall in storey&#10;        ifcopenshell.api.spatial.assign_container(model, relating_structure=storey, products=[wall])&#10;&#10;        # Save&#10;        model.write(output_file)&#10;        print(f&quot;Created example model: {output_file}&quot;)&#10;&#10;        return output_file&#10;    except Exception as e:&#10;        print(f&quot;Error creating model: {e}&quot;)&#10;        import traceback&#10;        print(&quot;\nDebug: Full traceback:&quot;)&#10;        traceback.print_exc()&#10;        return None&#10;&#10;&#10;def add_construction_schedule(model, output_file=&quot;model_with_schedule.ifc&quot;):&#10;    &quot;&quot;&quot;Add construction schedule to existing model&quot;&quot;&quot;&#10;    if not API_AVAILABLE:&#10;        print(&quot;\n=== CANNOT ADD SCHEDULE - API NOT AVAILABLE ===&quot;)&#10;        return&#10;&#10;    print(&quot;\n=== ADDING CONSTRUCTION SCHEDULE ===&quot;)&#10;    &#10;    try:&#10;        def add_task(model, name, predecessor, work_schedule):&#10;            task = ifcopenshell.api.sequence.add_task(&#10;                model, work_schedule=work_schedule, name=name, predefined_type=&quot;CONSTRUCTION&quot;)&#10;&#10;            task_time = ifcopenshell.api.sequence.add_task_time(model, task=task)&#10;&#10;            ifcopenshell.api.sequence.edit_task_time(&#10;                model, task_time=task_time,&#10;                attributes={&quot;ScheduleStart&quot;: datetime.date(2000, 1, 1), &quot;ScheduleDuration&quot;: &quot;P1W&quot;})&#10;&#10;            if predecessor:&#10;                ifcopenshell.api.sequence.assign_sequence(&#10;                    model, relating_process=predecessor, related_process=task)&#10;&#10;            return task&#10;&#10;        # Create schedule&#10;        schedule = ifcopenshell.api.sequence.add_work_schedule(model, name=&quot;Construction&quot;)&#10;&#10;        # Site establishment&#10;        task = add_task(model, &quot;Site establishment&quot;, None, schedule)&#10;        start_task = task&#10;&#10;        # Add tasks for each storey&#10;        if get_storey_elevation:&#10;            storeys = sorted(model.by_type(&quot;IfcBuildingStorey&quot;), key=lambda s: get_storey_elevation(s))&#10;        else:&#10;            print(&quot;Warning: get_storey_elevation not available, using unsorted storeys&quot;)&#10;            storeys = model.by_type(&quot;IfcBuildingStorey&quot;)&#10;&#10;        for storey in storeys:&#10;            task = add_task(model, f&quot;Construct {storey.Name}&quot;, task, schedule)&#10;&#10;            # Assign products&#10;            if get_decomposition:&#10;                for product in get_decomposition(storey):&#10;                    ifcopenshell.api.sequence.assign_product(&#10;                        model, relating_product=product, related_object=task)&#10;&#10;        # Calculate schedule&#10;        ifcopenshell.api.sequence.cascade_schedule(model, task=start_task)&#10;        ifcopenshell.api.sequence.recalculate_schedule(model, work_schedule=schedule)&#10;&#10;        # Save&#10;        model.write(output_file)&#10;        print(f&quot;Model with schedule saved to: {output_file}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error adding schedule: {e}&quot;)&#10;        import traceback&#10;        print(&quot;Debug: Full traceback:&quot;)&#10;        traceback.print_exc()&#10;&#10;# %% Main definition&#10;def main():&#10;    &quot;&quot;&quot;Main function to run all analyses&quot;&quot;&quot;&#10;    print(&quot;\n=== STARTING MAIN ANALYSIS ===&quot;)&#10;    print(f&quot;Debug: Script directory: {os.path.dirname(os.path.abspath(__file__ if '__file__' in globals() else sys.argv[0]))}&quot;)&#10;    print(f&quot;Debug: Current working directory: {os.getcwd()}&quot;)&#10;&#10;    # Get input file from command line or use default&#10;    if len(sys.argv) &gt; 1:&#10;        input_file = sys.argv[1]&#10;    else:&#10;        # Try multiple possible locations&#10;        possible_paths = [&#10;            os.path.join(os.getenv(&quot;PYMAOS_HOME&quot;, &quot;&quot;), 'ifc', 'AC20-FZK-Haus.ifc'),&#10;            'AC20-FZK-Haus.ifc',&#10;            os.path.join('ifc', 'AC20-FZK-Haus.ifc'),&#10;            os.path.join('..', 'ifc', 'AC20-FZK-Haus.ifc')&#10;        ]&#10;        &#10;        input_file = None&#10;        for path in possible_paths:&#10;            if os.path.exists(path):&#10;                input_file = path&#10;                break&#10;        &#10;        if not input_file:&#10;            input_file = possible_paths[0]  # Use first as default&#10;    &#10;    print(f&quot;Analyzing IFC file: {input_file}&quot;)&#10;&#10;    # Check if file exists&#10;    if not os.path.exists(input_file):&#10;        print(f&quot;Error: File '{input_file}' not found!&quot;)&#10;        if API_AVAILABLE:&#10;            print(&quot;Creating example model instead...&quot;)&#10;            input_file = create_simple_model_example()&#10;            if not input_file:&#10;                print(&quot;Failed to create example model&quot;)&#10;                return&#10;        else:&#10;            print(&quot;Cannot create example model - API not available&quot;)&#10;            return&#10;&#10;    # Open model&#10;    try:&#10;        model = ifcopenshell.open(input_file)&#10;        print(f&quot;Successfully opened IFC file (Schema: {model.schema})&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error opening IFC file: {e}&quot;)&#10;        return&#10;    &#10;    # Run all analyses&#10;    analyze_basic_entities(model, limit=5)&#10;    analyze_wall_types(model)&#10;    analyze_door_types(model)&#10;    analyze_element_properties(model)&#10;    analyze_spatial_structure(model)&#10;    analyze_element_placement(model)&#10;    analyze_classification_systems(model)&#10;    analyze_units(model)&#10;    analyze_systems(model)&#10;    &#10;    # Add construction schedule&#10;    add_construction_schedule(model)&#10;&#10;    # Export to CSV&#10;    export_to_csv(input_file)&#10;    &#10;    print(&quot;\n=== ANALYSIS COMPLETE ===&quot;)&#10;&#10;# %% Run&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Baltimore_Space_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Baltimore_Space_Truss.YAML" />
              <option name="updatedContent" value="# Baltimore space truss bridge example with units&#10;# This structure consists of two parallel Baltimore trusses connected with transverse members&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # First truss - Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Intermediate nodes for sub-diagonals&#10;  - id: 13&#10;    x: 10 ft&#10;    y: 10 ft&#10;    z: 0 ft&#10;  - id: 14&#10;    x: 30 ft&#10;    y: 10 ft&#10;    z: 0 ft&#10;  - id: 15&#10;    x: 50 ft&#10;    y: 10 ft&#10;    z: 0 ft&#10;  - id: 16&#10;    x: 70 ft&#10;    y: 10 ft&#10;    z: 0 ft&#10;  - id: 17&#10;    x: 90 ft&#10;    y: 10 ft&#10;    z: 0 ft&#10;&#10;  # Second truss - Bottom chord nodes&#10;  - id: 18&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 19&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 20&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 21&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 22&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 23&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Top chord nodes&#10;  - id: 24&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 25&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 26&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 27&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 28&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 29&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Intermediate nodes for sub-diagonals&#10;  - id: 30&#10;    x: 10 ft&#10;    y: 10 ft&#10;    z: 20 ft&#10;  - id: 31&#10;    x: 30 ft&#10;    y: 10 ft&#10;    z: 20 ft&#10;  - id: 32&#10;    x: 50 ft&#10;    y: 10 ft&#10;    z: 20 ft&#10;  - id: 33&#10;    x: 70 ft&#10;    y: 10 ft&#10;    z: 20 ft&#10;  - id: 34&#10;    x: 90 ft&#10;    y: 10 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # First truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Fixed support at left end of first truss&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of first truss&#10;  &#10;  # Second truss supports&#10;  - node: 18&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at left end of second truss&#10;  - node: 23&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of second truss&#10;&#10;members:&#10;  # First truss - Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # First truss - Diagonal members&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # First truss - Sub-diagonal members&#10;  - id: 22&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 24&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Bottom chord members&#10;  - id: 26&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 27&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 22&#10;    j_node: 23&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Top chord members&#10;  - id: 31&#10;    i_node: 24&#10;    j_node: 25&#10;    material: 1&#10;    section: 1&#10;  - id: 32&#10;    i_node: 25&#10;    j_node: 26&#10;    material: 1&#10;    section: 1&#10;  - id: 33&#10;    i_node: 26&#10;    j_node: 27&#10;    material: 1&#10;    section: 1&#10;  - id: 34&#10;    i_node: 27&#10;    j_node: 28&#10;    material: 1&#10;    section: 1&#10;  - id: 35&#10;    i_node: 28&#10;    j_node: 29&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Vertical members&#10;  - id: 36&#10;    i_node: 18&#10;    j_node: 24&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 19&#10;    j_node: 25&#10;    material: 1&#10;    section: 2&#10;  - id: 38&#10;    i_node: 20&#10;    j_node: 26&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 21&#10;    j_node: 27&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 22&#10;    j_node: 28&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 23&#10;    j_node: 29&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Diagonal members&#10;  - id: 42&#10;    i_node: 24&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 43&#10;    i_node: 25&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 44&#10;    i_node: 26&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 45&#10;    i_node: 27&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  - id: 46&#10;    i_node: 28&#10;    j_node: 23&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Sub-diagonal members&#10;  - id: 47&#10;    i_node: 19&#10;    j_node: 30&#10;    material: 1&#10;    section: 2&#10;  - id: 48&#10;    i_node: 30&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 49&#10;    i_node: 21&#10;    j_node: 32&#10;    material: 1&#10;    section: 2&#10;  - id: 50&#10;    i_node: 32&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;&#10;  # Transverse members connecting bottom chords&#10;  - id: 51&#10;    i_node: 1&#10;    j_node: 18&#10;    material: 1&#10;    section: 3  # HSS6x6x3/8 for transverse members&#10;  - id: 52&#10;    i_node: 2&#10;    j_node: 19&#10;    material: 1&#10;    section: 3&#10;  - id: 53&#10;    i_node: 3&#10;    j_node: 20&#10;    material: 1&#10;    section: 3&#10;  - id: 54&#10;    i_node: 4&#10;    j_node: 21&#10;    material: 1&#10;    section: 3&#10;  - id: 55&#10;    i_node: 5&#10;    j_node: 22&#10;    material: 1&#10;    section: 3&#10;  - id: 56&#10;    i_node: 6&#10;    j_node: 23&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting top chords&#10;  - id: 57&#10;    i_node: 7&#10;    j_node: 24&#10;    material: 1&#10;    section: 3&#10;  - id: 58&#10;    i_node: 8&#10;    j_node: 25&#10;    material: 1&#10;    section: 3&#10;  - id: 59&#10;    i_node: 9&#10;    j_node: 26&#10;    material: 1&#10;    section: 3&#10;  - id: 60&#10;    i_node: 10&#10;    j_node: 27&#10;    material: 1&#10;    section: 3&#10;  - id: 61&#10;    i_node: 11&#10;    j_node: 28&#10;    material: 1&#10;    section: 3&#10;  - id: 62&#10;    i_node: 12&#10;    j_node: 29&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting intermediate nodes&#10;  - id: 63&#10;    i_node: 13&#10;    j_node: 30&#10;    material: 1&#10;    section: 3&#10;  - id: 64&#10;    i_node: 14&#10;    j_node: 31&#10;    material: 1&#10;    section: 3&#10;  - id: 65&#10;    i_node: 15&#10;    j_node: 32&#10;    material: 1&#10;    section: 3&#10;  - id: 66&#10;    i_node: 16&#10;    j_node: 33&#10;    material: 1&#10;    section: 3&#10;  - id: 67&#10;    i_node: 17&#10;    j_node: 34&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing for lateral stability - Bottom plane&#10;  - id: 68&#10;    i_node: 1&#10;    j_node: 19&#10;    material: 1&#10;    section: 4  # L4x4x1/2 angle for bracing&#10;  - id: 69&#10;    i_node: 2&#10;    j_node: 20&#10;    material: 1&#10;    section: 4&#10;  - id: 70&#10;    i_node: 3&#10;    j_node: 21&#10;    material: 1&#10;    section: 4&#10;  - id: 71&#10;    i_node: 4&#10;    j_node: 22&#10;    material: 1&#10;    section: 4&#10;  - id: 72&#10;    i_node: 5&#10;    j_node: 23&#10;    material: 1&#10;    section: 4&#10;&#10;  # Diagonal bracing for lateral stability - Top plane&#10;  - id: 73&#10;    i_node: 7&#10;    j_node: 25&#10;    material: 1&#10;    section: 4&#10;  - id: 74&#10;    i_node: 8&#10;    j_node: 26&#10;    material: 1&#10;    section: 4&#10;  - id: 75&#10;    i_node: 9&#10;    j_node: 27&#10;    material: 1&#10;    section: 4&#10;  - id: 76&#10;    i_node: 10&#10;    j_node: 28&#10;    material: 1&#10;    section: 4&#10;  - id: 77&#10;    i_node: 11&#10;    j_node: 29&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord of first truss&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord of second truss&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 27&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 28&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 29&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 30&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse member loads&#10;  - member_uid: 51&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 52&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 53&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 54&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 55&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 56&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Baltimore_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Baltimore_Truss.YAML" />
              <option name="originalContent" value="# Baltimore truss bridge example with units&#10;# This truss is a variation of the Pratt truss with additional bracing for longer spans.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;  # Intermediate nodes for sub-diagonals&#10;  - id: 13&#10;    x: 10 ft&#10;    y: 10 ft&#10;  - id: 14&#10;    x: 30 ft&#10;    y: 10 ft&#10;  - id: 15&#10;    x: 50 ft&#10;    y: 10 ft&#10;  - id: 16&#10;    x: 70 ft&#10;    y: 10 ft&#10;  - id: 17&#10;    x: 90 ft&#10;    y: 10 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # Sub-diagonal members&#10;  - id: 22&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 24&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
              <option name="updatedContent" value="# Baltimore truss bridge example with units&#10;# This truss is a variation of the Pratt truss with additional bracing for longer spans.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;  # Intermediate nodes for sub-diagonals&#10;  - id: 13&#10;    x: 10 ft&#10;    y: 10 ft&#10;  - id: 14&#10;    x: 30 ft&#10;    y: 10 ft&#10;  - id: 15&#10;    x: 50 ft&#10;    y: 10 ft&#10;  - id: 16&#10;    x: 70 ft&#10;    y: 10 ft&#10;  - id: 17&#10;    x: 90 ft&#10;    y: 10 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel (29000 ksi)&#10;    section: 1   # W12x26 (7.65 in^2, Ixx=204 in^4)&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31 (9.13 in^2, Ixx=110 in^4)&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # Sub-diagonal members&#10;  - id: 22&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 24&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Howe_Space_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Howe_Space_Truss.YAML" />
              <option name="updatedContent" value="# Howe space truss bridge example with units&#10;# This structure consists of two parallel Howe trusses connected with transverse members&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # First truss - Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # Second truss - Bottom chord nodes&#10;  - id: 13&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 14&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 15&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 16&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 17&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 18&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Top chord nodes&#10;  - id: 19&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 20&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 21&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 22&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 23&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 24&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # First truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Fixed support at left end of first truss&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of first truss&#10;  &#10;  # Second truss supports&#10;  - node: 13&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at left end of second truss&#10;  - node: 18&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of second truss&#10;&#10;members:&#10;  # First truss - Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # First truss - Diagonal members (sloping up toward center - Howe pattern)&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 6&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Bottom chord members&#10;  - id: 22&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 17&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Top chord members&#10;  - id: 27&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 22&#10;    j_node: 23&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 23&#10;    j_node: 24&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Vertical members&#10;  - id: 32&#10;    i_node: 13&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 14&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 15&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 16&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 17&#10;    j_node: 23&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 18&#10;    j_node: 24&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Diagonal members (sloping up toward center - Howe pattern)&#10;  - id: 38&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 17&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 18&#10;    j_node: 23&#10;    material: 1&#10;    section: 2&#10;&#10;  # Transverse members connecting bottom chords&#10;  - id: 43&#10;    i_node: 1&#10;    j_node: 13&#10;    material: 1&#10;    section: 3  # HSS6x6x3/8 for transverse members&#10;  - id: 44&#10;    i_node: 2&#10;    j_node: 14&#10;    material: 1&#10;    section: 3&#10;  - id: 45&#10;    i_node: 3&#10;    j_node: 15&#10;    material: 1&#10;    section: 3&#10;  - id: 46&#10;    i_node: 4&#10;    j_node: 16&#10;    material: 1&#10;    section: 3&#10;  - id: 47&#10;    i_node: 5&#10;    j_node: 17&#10;    material: 1&#10;    section: 3&#10;  - id: 48&#10;    i_node: 6&#10;    j_node: 18&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting top chords&#10;  - id: 49&#10;    i_node: 7&#10;    j_node: 19&#10;    material: 1&#10;    section: 3&#10;  - id: 50&#10;    i_node: 8&#10;    j_node: 20&#10;    material: 1&#10;    section: 3&#10;  - id: 51&#10;    i_node: 9&#10;    j_node: 21&#10;    material: 1&#10;    section: 3&#10;  - id: 52&#10;    i_node: 10&#10;    j_node: 22&#10;    material: 1&#10;    section: 3&#10;  - id: 53&#10;    i_node: 11&#10;    j_node: 23&#10;    material: 1&#10;    section: 3&#10;  - id: 54&#10;    i_node: 12&#10;    j_node: 24&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing for lateral stability - Bottom plane&#10;  - id: 55&#10;    i_node: 1&#10;    j_node: 14&#10;    material: 1&#10;    section: 4  # L4x4x1/2 angle for bracing&#10;  - id: 56&#10;    i_node: 2&#10;    j_node: 15&#10;    material: 1&#10;    section: 4&#10;  - id: 57&#10;    i_node: 3&#10;    j_node: 16&#10;    material: 1&#10;    section: 4&#10;  - id: 58&#10;    i_node: 4&#10;    j_node: 17&#10;    material: 1&#10;    section: 4&#10;  - id: 59&#10;    i_node: 5&#10;    j_node: 18&#10;    material: 1&#10;    section: 4&#10;&#10;  # Diagonal bracing for lateral stability - Top plane&#10;  - id: 60&#10;    i_node: 7&#10;    j_node: 20&#10;    material: 1&#10;    section: 4&#10;  - id: 61&#10;    i_node: 8&#10;    j_node: 21&#10;    material: 1&#10;    section: 4&#10;  - id: 62&#10;    i_node: 9&#10;    j_node: 22&#10;    material: 1&#10;    section: 4&#10;  - id: 63&#10;    i_node: 10&#10;    j_node: 23&#10;    material: 1&#10;    section: 4&#10;  - id: 64&#10;    i_node: 11&#10;    j_node: 24&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord of first truss&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord of second truss&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse member loads&#10;  - member_uid: 43&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 44&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 45&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 46&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 47&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 48&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Howe_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Howe_Truss.YAML" />
              <option name="originalContent" value="# Howe truss bridge example with units&#10;# This truss has diagonal members that slope upward toward the center, typically placing diagonals in compression under vertical loads.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (sloping up toward center - Howe pattern)&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 6&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
              <option name="updatedContent" value="# Howe truss bridge example with units&#10;# This truss has diagonal members that slope upward toward the center, typically placing diagonals in compression under vertical loads.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel (29000 ksi)&#10;    section: 1   # W12x26 (7.65 in^2, Ixx=204 in^4)&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31 (9.13 in^2, Ixx=110 in^4)&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (sloping up toward center - Howe pattern)&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 6&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/K_Space_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/K_Space_Truss.YAML" />
              <option name="updatedContent" value="# K-Space-Truss bridge example with units&#10;# This structure consists of two parallel K-trusses connected with transverse members&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # First truss - Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # Second truss - Bottom chord nodes&#10;  - id: 12&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 13&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 14&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 15&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 16&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 17&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Top chord nodes&#10;  - id: 18&#10;    x: 10 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 19&#10;    x: 30 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 20&#10;    x: 50 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 21&#10;    x: 70 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 22&#10;    x: 90 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # First truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  &#10;  # Second truss supports&#10;  - node: 12&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;&#10;members:&#10;  # First truss - Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Vertical members&#10;  - id: 10&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 11&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;  # First truss - Diagonal members (K-pattern)&#10;  - id: 14&#10;    i_node: 7&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 8&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 9&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Bottom chord members&#10;  - id: 20&#10;    i_node: 12&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 21&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 22&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Top chord members&#10;  - id: 25&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 27&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Vertical members&#10;  - id: 29&#10;    i_node: 13&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 30&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 31&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 32&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Diagonal members (K-pattern)&#10;  - id: 33&#10;    i_node: 18&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 19&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 20&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 13&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 14&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 38&#10;    i_node: 15&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;&#10;  # Transverse members connecting bottom chords&#10;  - id: 39&#10;    i_node: 1&#10;    j_node: 12&#10;    material: 1&#10;    section: 3  # HSS6x6x3/8 for transverse members&#10;  - id: 40&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 3&#10;  - id: 41&#10;    i_node: 3&#10;    j_node: 14&#10;    material: 1&#10;    section: 3&#10;  - id: 42&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 3&#10;  - id: 43&#10;    i_node: 5&#10;    j_node: 16&#10;    material: 1&#10;    section: 3&#10;  - id: 44&#10;    i_node: 6&#10;    j_node: 17&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting top chords&#10;  - id: 45&#10;    i_node: 7&#10;    j_node: 18&#10;    material: 1&#10;    section: 3&#10;  - id: 46&#10;    i_node: 8&#10;    j_node: 19&#10;    material: 1&#10;    section: 3&#10;  - id: 47&#10;    i_node: 9&#10;    j_node: 20&#10;    material: 1&#10;    section: 3&#10;  - id: 48&#10;    i_node: 10&#10;    j_node: 21&#10;    material: 1&#10;    section: 3&#10;  - id: 49&#10;    i_node: 11&#10;    j_node: 22&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing for lateral stability - Bottom plane&#10;  - id: 50&#10;    i_node: 1&#10;    j_node: 13&#10;    material: 1&#10;    section: 4  # L4x4x1/2 angle for bracing&#10;  - id: 51&#10;    i_node: 2&#10;    j_node: 14&#10;    material: 1&#10;    section: 4&#10;  - id: 52&#10;    i_node: 3&#10;    j_node: 15&#10;    material: 1&#10;    section: 4&#10;  - id: 53&#10;    i_node: 4&#10;    j_node: 16&#10;    material: 1&#10;    section: 4&#10;  - id: 54&#10;    i_node: 5&#10;    j_node: 17&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord of first truss&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord of second truss&#10;  - member_uid: 20&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 21&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse member loads&#10;  - member_uid: 39&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 40&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 41&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 42&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 43&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 44&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/K_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/K_Truss.YAML" />
              <option name="originalContent" value="# K-Truss bridge example with units&#10;# This truss has diagonal members forming a &quot;K&quot; shape, which helps distribute loads efficiently.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 10&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 11&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (K-pattern)&#10;  - id: 14&#10;    i_node: 7&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 8&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 9&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
              <option name="updatedContent" value="# K-Truss bridge example with units&#10;# This truss has diagonal members forming a &quot;K&quot; shape, which helps distribute loads efficiently.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel (29000 ksi)&#10;    section: 1   # W12x26 (7.65 in^2, Ixx=204 in^4)&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 10&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31 (9.13 in^2, Ixx=110 in^4)&#10;  - id: 11&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (K-pattern)&#10;  - id: 14&#10;    i_node: 7&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 8&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 9&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Pratt_Bridge.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Pratt_Bridge.YAML" />
              <option name="originalContent" value="# Pratt bridge example with two spans and units&#10;# Both spans have diagonals sloping toward the center (which places diagonals in tension under vertical loads)&#10;# Key design features:&#10;#&#10;#&#10;# The bridge has two 100 ft spans (200 ft total length)&#10;# Central node 6 serves as the pier connection point for both spans&#10;# Diagonals in the left span slope down toward the center (right)&#10;# Diagonals in the right span slope down toward the center (left)&#10;# Supports are at node 1 (pinned), node 6 (pinned pier), and node 17 (roller)&#10;# Both spans use the same materials, sections, and loading&#10;# This arrangement ensures that diagonals in both spans will primarily experience tension under vertical loads, which is the main characteristic of a Pratt truss design.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # LEFT SPAN&#10;  # Bottom chord nodes (left span)&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;  # Top chord nodes (left span)&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;  # RIGHT SPAN&#10;  # Bottom chord nodes (right span)&#10;  - id: 13&#10;    x: 120 ft&#10;    y: 0 ft&#10;  - id: 14&#10;    x: 140 ft&#10;    y: 0 ft&#10;  - id: 15&#10;    x: 160 ft&#10;    y: 0 ft&#10;  - id: 16&#10;    x: 180 ft&#10;    y: 0 ft&#10;  - id: 17&#10;    x: 200 ft&#10;    y: 0 ft&#10;  # Top chord nodes (right span) - renumbered to be sequential&#10;  - id: 18&#10;    x: 120 ft&#10;    y: 20 ft&#10;  - id: 19&#10;    x: 140 ft&#10;    y: 20 ft&#10;  - id: 20&#10;    x: 160 ft&#10;    y: 20 ft&#10;  - id: 21&#10;    x: 180 ft&#10;    y: 20 ft&#10;  - id: 22&#10;    x: 200 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pier support at center (bottom chord)&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # LEFT SPAN&#10;  # Bottom chord members (left span)&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members (left span)&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members (left span)&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (left span - sloping down toward center)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # RIGHT SPAN&#10;  # Bottom chord members (right span)&#10;  - id: 22&#10;    i_node: 6&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members (right span) - updated node references&#10;  - id: 27&#10;    i_node: 12&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members (right span)&#10;  - id: 32&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 13&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 17&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (right span - sloping down toward center/left)&#10;  - id: 38&#10;    i_node: 18&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 19&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 20&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 21&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 22&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord (left span)&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span)&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
              <option name="updatedContent" value="# Pratt bridge example with two spans and units&#10;# Both spans have diagonals sloping toward the center (which places diagonals in tension under vertical loads)&#10;# Key design features:&#10;#&#10;#&#10;# The bridge has two 100 ft spans (200 ft total length)&#10;# Central node 6 serves as the pier connection point for both spans&#10;# Diagonals in the left span slope down toward the center (right)&#10;# Diagonals in the right span slope down toward the center (left)&#10;# Supports are at node 1 (pinned), node 6 (pinned pier), and node 17 (roller)&#10;# Both spans use the same materials, sections, and loading&#10;# This arrangement ensures that diagonals in both spans will primarily experience tension under vertical loads, which is the main characteristic of a Pratt truss design.&#10;&#10;# DESIGN PARAMETERS&#10;design_parameters:&#10;  min_safety_factor: 1.2&#10;  deck_load: 0.5 kip/ft  # Reduced from 2.0 to achieve reasonable safety factors&#10;&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # LEFT SPAN&#10;  # Bottom chord nodes (left span)&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;  # Top chord nodes (left span)&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;  # RIGHT SPAN&#10;  # Bottom chord nodes (right span)&#10;  - id: 13&#10;    x: 120 ft&#10;    y: 0 ft&#10;  - id: 14&#10;    x: 140 ft&#10;    y: 0 ft&#10;  - id: 15&#10;    x: 160 ft&#10;    y: 0 ft&#10;  - id: 16&#10;    x: 180 ft&#10;    y: 0 ft&#10;  - id: 17&#10;    x: 200 ft&#10;    y: 0 ft&#10;  # Top chord nodes (right span) - renumbered to be sequential&#10;  - id: 18&#10;    x: 120 ft&#10;    y: 20 ft&#10;  - id: 19&#10;    x: 140 ft&#10;    y: 20 ft&#10;  - id: 20&#10;    x: 160 ft&#10;    y: 20 ft&#10;  - id: 21&#10;    x: 180 ft&#10;    y: 20 ft&#10;  - id: 22&#10;    x: 200 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pier support at center (bottom chord)&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # LEFT SPAN&#10;  # Bottom chord members (left span)&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members (left span)&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members (left span)&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (left span - sloping down toward center)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # RIGHT SPAN&#10;  # Bottom chord members (right span)&#10;  - id: 22&#10;    i_node: 6&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members (right span) - updated node references&#10;  - id: 27&#10;    i_node: 12&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members (right span)&#10;  - id: 32&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 13&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 17&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (right span - sloping down toward center/left)&#10;  - id: 38&#10;    i_node: 18&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 19&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 20&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 21&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 22&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord (left span) - reduced loading&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span) - reduced loading&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;sections:&#10;  - id: 1&#10;    area: 15.3 in^2     # W14x51 - doubled from W12x26 for chord members&#10;    r: 5.02 in&#10;  - id: 2  &#10;    area: 13.3 in^2     # W10x45 - increased from W8x31 for verticals/diagonals&#10;    r: 3.93 in" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Pratt_Bridge_3D.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Pratt_Bridge_3D.YAML" />
              <option name="originalContent" value="# 3D Pratt bridge with parallel trusses and transverse members&#10;# Both spans have diagonals sloping toward the center&#10;&#10;design_parameters:&#10;  min_safety_factor: 1.2&#10;  deck_load: 0.5 kip/ft&#10;&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # LEFT TRUSS (front truss, z=0)&#10;  # Bottom chord nodes (left span, front)&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Top chord nodes (left span, front)&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  # Intermediate bottom chord node (front)&#10;  - id: 13&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Bottom chord nodes (right span, front)&#10;  - id: 14&#10;    x: 140 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 15&#10;    x: 160 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 16&#10;    x: 180 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 17&#10;    x: 200 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Top chord nodes (right span, front)&#10;  - id: 18&#10;    x: 120 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 19&#10;    x: 140 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 20&#10;    x: 160 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 21&#10;    x: 180 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 22&#10;    x: 200 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # RIGHT TRUSS (back truss, z=20)&#10;  # Bottom chord nodes (left span, back)&#10;  - id: 101&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 102&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 103&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 104&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 105&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 106&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Top chord nodes (left span, back)&#10;  - id: 107&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 108&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 109&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 110&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 111&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 112&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  # Intermediate bottom chord node (back)&#10;  - id: 113&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Bottom chord nodes (right span, back)&#10;  - id: 114&#10;    x: 140 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 115&#10;    x: 160 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 116&#10;    x: 180 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 117&#10;    x: 200 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Top chord nodes (right span, back)&#10;  - id: 118&#10;    x: 120 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 119&#10;    x: 140 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 120&#10;    x: 160 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 121&#10;    x: 180 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 122&#10;    x: 200 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;# Add intermediate bottom chord nodes at 120ft for proper connectivity&#10;  - id: 13&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 113&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # Front truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 6&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  # Back truss supports&#10;  - node: 101&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 106&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 117&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;&#10;members:&#10;  # FRONT TRUSS (original)&#10;  # Bottom chord members (left span)&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (left span)&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (left span)&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (left span)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  # Bottom chord members (right span) - updated to use merged nodes&#10;  - id: 22&#10;    i_node: 6&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (right span)&#10;  - id: 27&#10;    i_node: 12&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (right span) - updated&#10;  - id: 32&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 13&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 17&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (right span) - updated&#10;  - id: 38&#10;    i_node: 18&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 19&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 20&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 21&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 22&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;&#10;  # BACK TRUSS (parallel truss)&#10;  # Bottom chord members (left span)&#10;  - id: 101&#10;    i_node: 101&#10;    j_node: 102&#10;    material: 1&#10;    section: 1&#10;  - id: 102&#10;    i_node: 102&#10;    j_node: 103&#10;    material: 1&#10;    section: 1&#10;  - id: 103&#10;    i_node: 103&#10;    j_node: 104&#10;    material: 1&#10;    section: 1&#10;  - id: 104&#10;    i_node: 104&#10;    j_node: 105&#10;    material: 1&#10;    section: 1&#10;  - id: 105&#10;    i_node: 105&#10;    j_node: 106&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (left span)&#10;  - id: 106&#10;    i_node: 107&#10;    j_node: 108&#10;    material: 1&#10;    section: 1&#10;  - id: 107&#10;    i_node: 108&#10;    j_node: 109&#10;    material: 1&#10;    section: 1&#10;  - id: 108&#10;    i_node: 109&#10;    j_node: 110&#10;    material: 1&#10;    section: 1&#10;  - id: 109&#10;    i_node: 110&#10;    j_node: 111&#10;    material: 1&#10;    section: 1&#10;  - id: 110&#10;    i_node: 111&#10;    j_node: 112&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (left span)&#10;  - id: 111&#10;    i_node: 101&#10;    j_node: 107&#10;    material: 1&#10;    section: 2&#10;  - id: 112&#10;    i_node: 102&#10;    j_node: 108&#10;    material: 1&#10;    section: 2&#10;  - id: 113&#10;    i_node: 103&#10;    j_node: 109&#10;    material: 1&#10;    section: 2&#10;  - id: 114&#10;    i_node: 104&#10;    j_node: 110&#10;    material: 1&#10;    section: 2&#10;  - id: 115&#10;    i_node: 105&#10;    j_node: 111&#10;    material: 1&#10;    section: 2&#10;  - id: 116&#10;    i_node: 106&#10;    j_node: 112&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (left span)&#10;  - id: 117&#10;    i_node: 107&#10;    j_node: 102&#10;    material: 1&#10;    section: 2&#10;  - id: 118&#10;    i_node: 108&#10;    j_node: 103&#10;    material: 1&#10;    section: 2&#10;  - id: 119&#10;    i_node: 109&#10;    j_node: 104&#10;    material: 1&#10;    section: 2&#10;  - id: 120&#10;    i_node: 110&#10;    j_node: 105&#10;    material: 1&#10;    section: 2&#10;  - id: 121&#10;    i_node: 111&#10;    j_node: 106&#10;    material: 1&#10;    section: 2&#10;  # Bottom chord members (right span) - updated to use merged nodes&#10;  - id: 122&#10;    i_node: 106&#10;    j_node: 113&#10;    material: 1&#10;    section: 1&#10;  - id: 123&#10;    i_node: 113&#10;    j_node: 114&#10;    material: 1&#10;    section: 1&#10;  - id: 124&#10;    i_node: 114&#10;    j_node: 115&#10;    material: 1&#10;    section: 1&#10;  - id: 125&#10;    i_node: 115&#10;    j_node: 116&#10;    material: 1&#10;    section: 1&#10;  - id: 126&#10;    i_node: 116&#10;    j_node: 117&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (right span)&#10;  - id: 127&#10;    i_node: 112&#10;    j_node: 118&#10;    material: 1&#10;    section: 1&#10;  - id: 128&#10;    i_node: 118&#10;    j_node: 119&#10;    material: 1&#10;    section: 1&#10;  - id: 129&#10;    i_node: 119&#10;    j_node: 120&#10;    material: 1&#10;    section: 1&#10;  - id: 130&#10;    i_node: 120&#10;    j_node: 121&#10;    material: 1&#10;    section: 1&#10;  - id: 131&#10;    i_node: 121&#10;    j_node: 122&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (right span) - updated&#10;  - id: 132&#10;    i_node: 106&#10;    j_node: 112&#10;    material: 1&#10;    section: 2&#10;  - id: 133&#10;    i_node: 113&#10;    j_node: 118&#10;    material: 1&#10;    section: 2&#10;  - id: 134&#10;    i_node: 114&#10;    j_node: 119&#10;    material: 1&#10;    section: 2&#10;  - id: 135&#10;    i_node: 115&#10;    j_node: 120&#10;    material: 1&#10;    section: 2&#10;  - id: 136&#10;    i_node: 116&#10;    j_node: 121&#10;    material: 1&#10;    section: 2&#10;  - id: 137&#10;    i_node: 117&#10;    j_node: 122&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (right span) - updated&#10;  - id: 138&#10;    i_node: 118&#10;    j_node: 106&#10;    material: 1&#10;    section: 2&#10;  - id: 139&#10;    i_node: 119&#10;    j_node: 113&#10;    material: 1&#10;    section: 2&#10;  - id: 140&#10;    i_node: 120&#10;    j_node: 114&#10;    material: 1&#10;    section: 2&#10;  - id: 141&#10;    i_node: 121&#10;    j_node: 115&#10;    material: 1&#10;    section: 2&#10;  - id: 142&#10;    i_node: 122&#10;    j_node: 116&#10;    material: 1&#10;    section: 2&#10;&#10;  # TRANSVERSE MEMBERS (connecting front and back trusses)&#10;  # Bottom chord transverse members&#10;  - id: 201&#10;    i_node: 1&#10;    j_node: 101&#10;    material: 1&#10;    section: 3&#10;  - id: 202&#10;    i_node: 2&#10;    j_node: 102&#10;    material: 1&#10;    section: 3&#10;  - id: 203&#10;    i_node: 3&#10;    j_node: 103&#10;    material: 1&#10;    section: 3&#10;  - id: 204&#10;    i_node: 4&#10;    j_node: 104&#10;    material: 1&#10;    section: 3&#10;  - id: 205&#10;    i_node: 5&#10;    j_node: 105&#10;    material: 1&#10;    section: 3&#10;  - id: 206&#10;    i_node: 6&#10;    j_node: 106&#10;    material: 1&#10;    section: 3&#10;  - id: 207&#10;    i_node: 13&#10;    j_node: 113&#10;    material: 1&#10;    section: 3&#10;  - id: 208&#10;    i_node: 14&#10;    j_node: 114&#10;    material: 1&#10;    section: 3&#10;  - id: 209&#10;    i_node: 15&#10;    j_node: 115&#10;    material: 1&#10;    section: 3&#10;  - id: 210&#10;    i_node: 16&#10;    j_node: 116&#10;    material: 1&#10;    section: 3&#10;  - id: 211&#10;    i_node: 17&#10;    j_node: 117&#10;    material: 1&#10;    section: 3&#10;&#10;  # Top chord transverse members&#10;  - id: 212&#10;    i_node: 7&#10;    j_node: 107&#10;    material: 1&#10;    section: 3&#10;  - id: 213&#10;    i_node: 8&#10;    j_node: 108&#10;    material: 1&#10;    section: 3&#10;  - id: 214&#10;    i_node: 9&#10;    j_node: 109&#10;    material: 1&#10;    section: 3&#10;  - id: 215&#10;    i_node: 10&#10;    j_node: 110&#10;    material: 1&#10;    section: 3&#10;  - id: 216&#10;    i_node: 11&#10;    j_node: 111&#10;    material: 1&#10;    section: 3&#10;  - id: 217&#10;    i_node: 12&#10;    j_node: 112&#10;    material: 1&#10;    section: 3&#10;  - id: 218&#10;    i_node: 18&#10;    j_node: 118&#10;    material: 1&#10;    section: 3&#10;  - id: 219&#10;    i_node: 19&#10;    j_node: 119&#10;    material: 1&#10;    section: 3&#10;  - id: 220&#10;    i_node: 20&#10;    j_node: 120&#10;    material: 1&#10;    section: 3&#10;  - id: 221&#10;    i_node: 21&#10;    j_node: 121&#10;    material: 1&#10;    section: 3&#10;  - id: 222&#10;    i_node: 22&#10;    j_node: 122&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing in transverse planes (X-bracing for lateral stability)&#10;  # Left span&#10;  - id: 223&#10;    i_node: 1&#10;    j_node: 107&#10;    material: 1&#10;    section: 4&#10;  - id: 224&#10;    i_node: 101&#10;    j_node: 7&#10;    material: 1&#10;    section: 4&#10;  - id: 225&#10;    i_node: 2&#10;    j_node: 108&#10;    material: 1&#10;    section: 4&#10;  - id: 226&#10;    i_node: 102&#10;    j_node: 8&#10;    material: 1&#10;    section: 4&#10;  - id: 227&#10;    i_node: 3&#10;    j_node: 109&#10;    material: 1&#10;    section: 4&#10;  - id: 228&#10;    i_node: 103&#10;    j_node: 9&#10;    material: 1&#10;    section: 4&#10;  - id: 229&#10;    i_node: 4&#10;    j_node: 110&#10;    material: 1&#10;    section: 4&#10;  - id: 230&#10;    i_node: 104&#10;    j_node: 10&#10;    material: 1&#10;    section: 4&#10;  - id: 231&#10;    i_node: 5&#10;    j_node: 111&#10;    material: 1&#10;    section: 4&#10;  - id: 232&#10;    i_node: 105&#10;    j_node: 11&#10;    material: 1&#10;    section: 4&#10;  - id: 233&#10;    i_node: 6&#10;    j_node: 112&#10;    material: 1&#10;    section: 4&#10;&#10;  # Right span&#10;  - id: 235&#10;    i_node: 13&#10;    j_node: 118&#10;    material: 1&#10;    section: 4&#10;  - id: 236&#10;    i_node: 113&#10;    j_node: 18&#10;    material: 1&#10;    section: 4&#10;  - id: 237&#10;    i_node: 14&#10;    j_node: 119&#10;    material: 1&#10;    section: 4&#10;  - id: 238&#10;    i_node: 114&#10;    j_node: 19&#10;    material: 1&#10;    section: 4&#10;  - id: 239&#10;    i_node: 15&#10;    j_node: 120&#10;    material: 1&#10;    section: 4&#10;  - id: 240&#10;    i_node: 115&#10;    j_node: 20&#10;    material: 1&#10;    section: 4&#10;  - id: 241&#10;    i_node: 16&#10;    j_node: 121&#10;    material: 1&#10;    section: 4&#10;  - id: 242&#10;    i_node: 116&#10;    j_node: 21&#10;    material: 1&#10;    section: 4&#10;  - id: 243&#10;    i_node: 17&#10;    j_node: 122&#10;    material: 1&#10;    section: 4&#10;  - id: 244&#10;    i_node: 117&#10;    j_node: 22&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord (left span, front truss)&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span, front truss)&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (left span, back truss)&#10;  - member_uid: 101&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 102&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 103&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 104&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 105&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span, back truss)&#10;  - member_uid: 122&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 123&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 124&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 125&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 126&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse loads&#10;  - member_uid: 201&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 206&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 211&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;sections:&#10;  - id: 1&#10;    area: 15.3 in^2     # W14x51 - Chord members&#10;    r: 5.02 in&#10;  - id: 2&#10;    area: 13.3 in^2     # W10x45 - Verticals/diagonals&#10;    r: 3.93 in&#10;  - id: 3&#10;    area: 14.4 in^2     # W12x48 - Transverse beams&#10;    r: 4.85 in&#10;  - id: 4&#10;    area: 9.13 in^2     # W8x31 - Transverse bracing&#10;    r: 3.47 in" />
              <option name="updatedContent" value="# 3D Pratt bridge with parallel trusses and transverse members&#10;# Both spans have diagonals sloping toward the center&#10;&#10;design_parameters:&#10;  min_safety_factor: 1.2&#10;  deck_load: 0.5 kip/ft&#10;&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # LEFT TRUSS (front truss, z=0)&#10;  # Bottom chord nodes (left span, front)&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Top chord nodes (left span, front)&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  # Intermediate bottom chord node (front)&#10;  - id: 13&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Bottom chord nodes (right span, front)&#10;  - id: 14&#10;    x: 140 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 15&#10;    x: 160 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 16&#10;    x: 180 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 17&#10;    x: 200 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Top chord nodes (right span, front)&#10;  - id: 18&#10;    x: 120 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 19&#10;    x: 140 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 20&#10;    x: 160 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 21&#10;    x: 180 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 22&#10;    x: 200 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # RIGHT TRUSS (back truss, z=20)&#10;  # Bottom chord nodes (left span, back)&#10;  - id: 101&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 102&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 103&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 104&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 105&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 106&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Top chord nodes (left span, back)&#10;  - id: 107&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 108&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 109&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 110&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 111&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 112&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  # Intermediate bottom chord node (back)&#10;  - id: 113&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Bottom chord nodes (right span, back)&#10;  - id: 114&#10;    x: 140 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 115&#10;    x: 160 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 116&#10;    x: 180 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 117&#10;    x: 200 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Top chord nodes (right span, back)&#10;  - id: 118&#10;    x: 120 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 119&#10;    x: 140 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 120&#10;    x: 160 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 121&#10;    x: 180 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 122&#10;    x: 200 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # Front truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 6&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  # Back truss supports&#10;  - node: 101&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 106&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 117&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;&#10;members:&#10;  # FRONT TRUSS (original)&#10;  # Bottom chord members (left span)&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (left span)&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (left span)&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (left span)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  # Bottom chord members (right span) - updated to use merged nodes&#10;  - id: 22&#10;    i_node: 6&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (right span)&#10;  - id: 27&#10;    i_node: 12&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (right span) - updated&#10;  - id: 32&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 13&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 17&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (right span) - updated&#10;  - id: 38&#10;    i_node: 18&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 19&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 20&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 21&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 22&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;&#10;  # BACK TRUSS (parallel truss)&#10;  # Bottom chord members (left span)&#10;  - id: 101&#10;    i_node: 101&#10;    j_node: 102&#10;    material: 1&#10;    section: 1&#10;  - id: 102&#10;    i_node: 102&#10;    j_node: 103&#10;    material: 1&#10;    section: 1&#10;  - id: 103&#10;    i_node: 103&#10;    j_node: 104&#10;    material: 1&#10;    section: 1&#10;  - id: 104&#10;    i_node: 104&#10;    j_node: 105&#10;    material: 1&#10;    section: 1&#10;  - id: 105&#10;    i_node: 105&#10;    j_node: 106&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (left span)&#10;  - id: 106&#10;    i_node: 107&#10;    j_node: 108&#10;    material: 1&#10;    section: 1&#10;  - id: 107&#10;    i_node: 108&#10;    j_node: 109&#10;    material: 1&#10;    section: 1&#10;  - id: 108&#10;    i_node: 109&#10;    j_node: 110&#10;    material: 1&#10;    section: 1&#10;  - id: 109&#10;    i_node: 110&#10;    j_node: 111&#10;    material: 1&#10;    section: 1&#10;  - id: 110&#10;    i_node: 111&#10;    j_node: 112&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (left span)&#10;  - id: 111&#10;    i_node: 101&#10;    j_node: 107&#10;    material: 1&#10;    section: 2&#10;  - id: 112&#10;    i_node: 102&#10;    j_node: 108&#10;    material: 1&#10;    section: 2&#10;  - id: 113&#10;    i_node: 103&#10;    j_node: 109&#10;    material: 1&#10;    section: 2&#10;  - id: 114&#10;    i_node: 104&#10;    j_node: 110&#10;    material: 1&#10;    section: 2&#10;  - id: 115&#10;    i_node: 105&#10;    j_node: 111&#10;    material: 1&#10;    section: 2&#10;  - id: 116&#10;    i_node: 106&#10;    j_node: 112&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (left span)&#10;  - id: 117&#10;    i_node: 107&#10;    j_node: 102&#10;    material: 1&#10;    section: 2&#10;  - id: 118&#10;    i_node: 108&#10;    j_node: 103&#10;    material: 1&#10;    section: 2&#10;  - id: 119&#10;    i_node: 109&#10;    j_node: 104&#10;    material: 1&#10;    section: 2&#10;  - id: 120&#10;    i_node: 110&#10;    j_node: 105&#10;    material: 1&#10;    section: 2&#10;  - id: 121&#10;    i_node: 111&#10;    j_node: 106&#10;    material: 1&#10;    section: 2&#10;  # Bottom chord members (right span) - updated to use merged nodes&#10;  - id: 122&#10;    i_node: 106&#10;    j_node: 113&#10;    material: 1&#10;    section: 1&#10;  - id: 123&#10;    i_node: 113&#10;    j_node: 114&#10;    material: 1&#10;    section: 1&#10;  - id: 124&#10;    i_node: 114&#10;    j_node: 115&#10;    material: 1&#10;    section: 1&#10;  - id: 125&#10;    i_node: 115&#10;    j_node: 116&#10;    material: 1&#10;    section: 1&#10;  - id: 126&#10;    i_node: 116&#10;    j_node: 117&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (right span)&#10;  - id: 127&#10;    i_node: 112&#10;    j_node: 118&#10;    material: 1&#10;    section: 1&#10;  - id: 128&#10;    i_node: 118&#10;    j_node: 119&#10;    material: 1&#10;    section: 1&#10;  - id: 129&#10;    i_node: 119&#10;    j_node: 120&#10;    material: 1&#10;    section: 1&#10;  - id: 130&#10;    i_node: 120&#10;    j_node: 121&#10;    material: 1&#10;    section: 1&#10;  - id: 131&#10;    i_node: 121&#10;    j_node: 122&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (right span) - updated&#10;  - id: 132&#10;    i_node: 106&#10;    j_node: 112&#10;    material: 1&#10;    section: 2&#10;  - id: 133&#10;    i_node: 113&#10;    j_node: 118&#10;    material: 1&#10;    section: 2&#10;  - id: 134&#10;    i_node: 114&#10;    j_node: 119&#10;    material: 1&#10;    section: 2&#10;  - id: 135&#10;    i_node: 115&#10;    j_node: 120&#10;    material: 1&#10;    section: 2&#10;  - id: 136&#10;    i_node: 116&#10;    j_node: 121&#10;    material: 1&#10;    section: 2&#10;  - id: 137&#10;    i_node: 117&#10;    j_node: 122&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (right span) - updated&#10;  - id: 138&#10;    i_node: 118&#10;    j_node: 106&#10;    material: 1&#10;    section: 2&#10;  - id: 139&#10;    i_node: 119&#10;    j_node: 113&#10;    material: 1&#10;    section: 2&#10;  - id: 140&#10;    i_node: 120&#10;    j_node: 114&#10;    material: 1&#10;    section: 2&#10;  - id: 141&#10;    i_node: 121&#10;    j_node: 115&#10;    material: 1&#10;    section: 2&#10;  - id: 142&#10;    i_node: 122&#10;    j_node: 116&#10;    material: 1&#10;    section: 2&#10;&#10;  # TRANSVERSE MEMBERS (connecting front and back trusses)&#10;  # Bottom chord transverse members&#10;  - id: 201&#10;    i_node: 1&#10;    j_node: 101&#10;    material: 1&#10;    section: 3&#10;  - id: 202&#10;    i_node: 2&#10;    j_node: 102&#10;    material: 1&#10;    section: 3&#10;  - id: 203&#10;    i_node: 3&#10;    j_node: 103&#10;    material: 1&#10;    section: 3&#10;  - id: 204&#10;    i_node: 4&#10;    j_node: 104&#10;    material: 1&#10;    section: 3&#10;  - id: 205&#10;    i_node: 5&#10;    j_node: 105&#10;    material: 1&#10;    section: 3&#10;  - id: 206&#10;    i_node: 6&#10;    j_node: 106&#10;    material: 1&#10;    section: 3&#10;  - id: 207&#10;    i_node: 13&#10;    j_node: 113&#10;    material: 1&#10;    section: 3&#10;  - id: 208&#10;    i_node: 14&#10;    j_node: 114&#10;    material: 1&#10;    section: 3&#10;  - id: 209&#10;    i_node: 15&#10;    j_node: 115&#10;    material: 1&#10;    section: 3&#10;  - id: 210&#10;    i_node: 16&#10;    j_node: 116&#10;    material: 1&#10;    section: 3&#10;  - id: 211&#10;    i_node: 17&#10;    j_node: 117&#10;    material: 1&#10;    section: 3&#10;&#10;  # Top chord transverse members&#10;  - id: 212&#10;    i_node: 7&#10;    j_node: 107&#10;    material: 1&#10;    section: 3&#10;  - id: 213&#10;    i_node: 8&#10;    j_node: 108&#10;    material: 1&#10;    section: 3&#10;  - id: 214&#10;    i_node: 9&#10;    j_node: 109&#10;    material: 1&#10;    section: 3&#10;  - id: 215&#10;    i_node: 10&#10;    j_node: 110&#10;    material: 1&#10;    section: 3&#10;  - id: 216&#10;    i_node: 11&#10;    j_node: 111&#10;    material: 1&#10;    section: 3&#10;  - id: 217&#10;    i_node: 12&#10;    j_node: 112&#10;    material: 1&#10;    section: 3&#10;  - id: 218&#10;    i_node: 18&#10;    j_node: 118&#10;    material: 1&#10;    section: 3&#10;  - id: 219&#10;    i_node: 19&#10;    j_node: 119&#10;    material: 1&#10;    section: 3&#10;  - id: 220&#10;    i_node: 20&#10;    j_node: 120&#10;    material: 1&#10;    section: 3&#10;  - id: 221&#10;    i_node: 21&#10;    j_node: 121&#10;    material: 1&#10;    section: 3&#10;  - id: 222&#10;    i_node: 22&#10;    j_node: 122&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing in transverse planes (X-bracing for lateral stability)&#10;  # Left span&#10;  - id: 223&#10;    i_node: 1&#10;    j_node: 107&#10;    material: 1&#10;    section: 4&#10;  - id: 224&#10;    i_node: 101&#10;    j_node: 7&#10;    material: 1&#10;    section: 4&#10;  - id: 225&#10;    i_node: 2&#10;    j_node: 108&#10;    material: 1&#10;    section: 4&#10;  - id: 226&#10;    i_node: 102&#10;    j_node: 8&#10;    material: 1&#10;    section: 4&#10;  - id: 227&#10;    i_node: 3&#10;    j_node: 109&#10;    material: 1&#10;    section: 4&#10;  - id: 228&#10;    i_node: 103&#10;    j_node: 9&#10;    material: 1&#10;    section: 4&#10;  - id: 229&#10;    i_node: 4&#10;    j_node: 110&#10;    material: 1&#10;    section: 4&#10;  - id: 230&#10;    i_node: 104&#10;    j_node: 10&#10;    material: 1&#10;    section: 4&#10;  - id: 231&#10;    i_node: 5&#10;    j_node: 111&#10;    material: 1&#10;    section: 4&#10;  - id: 232&#10;    i_node: 105&#10;    j_node: 11&#10;    material: 1&#10;    section: 4&#10;  - id: 233&#10;    i_node: 6&#10;    j_node: 112&#10;    material: 1&#10;    section: 4&#10;  - id: 234&#10;    i_node: 106&#10;    j_node: 12&#10;    material: 1&#10;    section: 4&#10;&#10;  # Right span&#10;  - id: 235&#10;    i_node: 13&#10;    j_node: 118&#10;    material: 1&#10;    section: 4&#10;  - id: 236&#10;    i_node: 113&#10;    j_node: 18&#10;    material: 1&#10;    section: 4&#10;  - id: 237&#10;    i_node: 14&#10;    j_node: 119&#10;    material: 1&#10;    section: 4&#10;  - id: 238&#10;    i_node: 114&#10;    j_node: 19&#10;    material: 1&#10;    section: 4&#10;  - id: 239&#10;    i_node: 15&#10;    j_node: 120&#10;    material: 1&#10;    section: 4&#10;  - id: 240&#10;    i_node: 115&#10;    j_node: 20&#10;    material: 1&#10;    section: 4&#10;  - id: 241&#10;    i_node: 16&#10;    j_node: 121&#10;    material: 1&#10;    section: 4&#10;  - id: 242&#10;    i_node: 116&#10;    j_node: 21&#10;    material: 1&#10;    section: 4&#10;  - id: 243&#10;    i_node: 17&#10;    j_node: 122&#10;    material: 1&#10;    section: 4&#10;  - id: 244&#10;    i_node: 117&#10;    j_node: 22&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord (left span, front truss)&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span, front truss)&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (left span, back truss)&#10;  - member_uid: 101&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 102&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 103&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 104&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 105&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span, back truss)&#10;  - member_uid: 122&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 123&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 124&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 125&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 126&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse loads&#10;  - member_uid: 201&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 206&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 211&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;sections:&#10;  - id: 1&#10;    area: 15.3 in^2     # W14x51 - Chord members&#10;    r: 5.02 in&#10;  - id: 2&#10;    area: 13.3 in^2     # W10x45 - Verticals/diagonals&#10;    r: 3.93 in&#10;  - id: 3&#10;    area: 14.4 in^2     # W12x48 - Transverse beams&#10;    r: 4.85 in&#10;  - id: 4&#10;    area: 9.13 in^2     # W8x31 - Transverse bracing&#10;    r: 3.47 in" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Pratt_Space_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Pratt_Space_Truss.YAML" />
              <option name="updatedContent" value="# Pratt space truss bridge example with units&#10;# This structure consists of two parallel Pratt trusses connected with transverse members&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # First truss - Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # Second truss - Bottom chord nodes&#10;  - id: 13&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 14&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 15&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 16&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 17&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 18&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Top chord nodes&#10;  - id: 19&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 20&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 21&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 22&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 23&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 24&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # First truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1  # Restrain Z direction&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Fixed support at left end of first truss&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0  # Allow Z translation&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of first truss&#10;  &#10;  # Second truss supports&#10;  - node: 13&#10;    ux: 0  # Allow X translation&#10;    uy: 1&#10;    uz: 1  # Restrain Z direction&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at left end of second truss&#10;  - node: 18&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0  # Allow Z translation&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of second truss&#10;&#10;members:&#10;  # First truss - Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # First truss - Diagonal members (sloping down toward center)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Bottom chord members&#10;  - id: 22&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 17&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Top chord members&#10;  - id: 27&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 22&#10;    j_node: 23&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 23&#10;    j_node: 24&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Vertical members&#10;  - id: 32&#10;    i_node: 13&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 14&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 15&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 16&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 17&#10;    j_node: 23&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 18&#10;    j_node: 24&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Diagonal members (sloping down toward center)&#10;  - id: 38&#10;    i_node: 19&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 20&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 21&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 22&#10;    j_node: 17&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 23&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;&#10;  # Transverse members connecting bottom chords&#10;  - id: 43&#10;    i_node: 1&#10;    j_node: 13&#10;    material: 1&#10;    section: 3  # HSS6x6x3/8 for transverse members&#10;  - id: 44&#10;    i_node: 2&#10;    j_node: 14&#10;    material: 1&#10;    section: 3&#10;  - id: 45&#10;    i_node: 3&#10;    j_node: 15&#10;    material: 1&#10;    section: 3&#10;  - id: 46&#10;    i_node: 4&#10;    j_node: 16&#10;    material: 1&#10;    section: 3&#10;  - id: 47&#10;    i_node: 5&#10;    j_node: 17&#10;    material: 1&#10;    section: 3&#10;  - id: 48&#10;    i_node: 6&#10;    j_node: 18&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting top chords&#10;  - id: 49&#10;    i_node: 7&#10;    j_node: 19&#10;    material: 1&#10;    section: 3&#10;  - id: 50&#10;    i_node: 8&#10;    j_node: 20&#10;    material: 1&#10;    section: 3&#10;  - id: 51&#10;    i_node: 9&#10;    j_node: 21&#10;    material: 1&#10;    section: 3&#10;  - id: 52&#10;    i_node: 10&#10;    j_node: 22&#10;    material: 1&#10;    section: 3&#10;  - id: 53&#10;    i_node: 11&#10;    j_node: 23&#10;    material: 1&#10;    section: 3&#10;  - id: 54&#10;    i_node: 12&#10;    j_node: 24&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing for lateral stability - Bottom&#10;  - id: 55&#10;    i_node: 1&#10;    j_node: 14&#10;    material: 1&#10;    section: 4  # L4x4x1/2 angle for bracing&#10;  - id: 56&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 4&#10;  - id: 57&#10;    i_node: 3&#10;    j_node: 16&#10;    material: 1&#10;    section: 4&#10;  - id: 58&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 4&#10;  - id: 59&#10;    i_node: 5&#10;    j_node: 18&#10;    material: 1&#10;    section: 4&#10;  - id: 60&#10;    i_node: 6&#10;    j_node: 17&#10;    material: 1&#10;    section: 4&#10;&#10;  # Diagonal bracing for lateral stability - Top&#10;  - id: 61&#10;    i_node: 7&#10;    j_node: 20&#10;    material: 1&#10;    section: 4&#10;  - id: 62&#10;    i_node: 8&#10;    j_node: 19&#10;    material: 1&#10;    section: 4&#10;  - id: 63&#10;    i_node: 9&#10;    j_node: 22&#10;    material: 1&#10;    section: 4&#10;  - id: 64&#10;    i_node: 10&#10;    j_node: 21&#10;    material: 1&#10;    section: 4&#10;  - id: 65&#10;    i_node: 11&#10;    j_node: 24&#10;    material: 1&#10;    section: 4&#10;  - id: 66&#10;    i_node: 12&#10;    j_node: 23&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord of first truss&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord of second truss&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse member loads&#10;  - member_uid: 43&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 44&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 45&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 46&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 47&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 48&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Pratt_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Pratt_Truss.YAML" />
              <option name="originalContent" value="# Pratt truss bridge example with units&#10;# This truss has diagonal members that slope downward toward the center, typically placing diagonals in tension under vertical loads&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (sloping down toward center)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
              <option name="updatedContent" value="# Pratt truss bridge example with units&#10;# This truss has diagonal members that slope downward toward the center, typically placing diagonals in tension under vertical loads&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel (29000 ksi)&#10;    section: 1   # W12x26 (7.65 in^2, Ixx=204 in^4)&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31 (9.13 in^2, Ixx=110 in^4)&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (sloping down toward center)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Warren_Space_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Warren_Space_Truss.YAML" />
              <option name="updatedContent" value="# Warren space truss bridge example with units&#10;# This structure consists of two Warren trusses connected with transverse members&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # First truss - Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 17.32 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 17.32 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 17.32 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 17.32 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 17.32 ft&#10;    z: 0 ft&#10;&#10;  # Second truss - Bottom chord nodes&#10;  - id: 12&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 13&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 14&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 15&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 16&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 17&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Top chord nodes&#10;  - id: 18&#10;    x: 10 ft&#10;    y: 17.32 ft&#10;    z: 20 ft&#10;  - id: 19&#10;    x: 30 ft&#10;    y: 17.32 ft&#10;    z: 20 ft&#10;  - id: 20&#10;    x: 50 ft&#10;    y: 17.32 ft&#10;    z: 20 ft&#10;  - id: 21&#10;    x: 70 ft&#10;    y: 17.32 ft&#10;    z: 20 ft&#10;  - id: 22&#10;    x: 90 ft&#10;    y: 17.32 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # First truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Fixed support at left end of first truss&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of first truss&#10;  &#10;  # Second truss supports&#10;  - node: 12&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at left end of second truss&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of second truss&#10;&#10;members:&#10;  # First truss - Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Diagonal members (Warren pattern)&#10;  - id: 10&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 11&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 17&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Bottom chord members&#10;  - id: 20&#10;    i_node: 12&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 21&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 22&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Top chord members&#10;  - id: 25&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 27&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Diagonal members (Warren pattern)&#10;  - id: 29&#10;    i_node: 12&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 30&#10;    i_node: 18&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 31&#10;    i_node: 13&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 32&#10;    i_node: 19&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 14&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 20&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 15&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 21&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 16&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  - id: 38&#10;    i_node: 22&#10;    j_node: 17&#10;    material: 1&#10;    section: 2&#10;&#10;  # Transverse members connecting bottom chords&#10;  - id: 39&#10;    i_node: 1&#10;    j_node: 12&#10;    material: 1&#10;    section: 3  # HSS6x6x3/8 for transverse members&#10;  - id: 40&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 3&#10;  - id: 41&#10;    i_node: 3&#10;    j_node: 14&#10;    material: 1&#10;    section: 3&#10;  - id: 42&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 3&#10;  - id: 43&#10;    i_node: 5&#10;    j_node: 16&#10;    material: 1&#10;    section: 3&#10;  - id: 44&#10;    i_node: 6&#10;    j_node: 17&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting top chords&#10;  - id: 45&#10;    i_node: 7&#10;    j_node: 18&#10;    material: 1&#10;    section: 3&#10;  - id: 46&#10;    i_node: 8&#10;    j_node: 19&#10;    material: 1&#10;    section: 3&#10;  - id: 47&#10;    i_node: 9&#10;    j_node: 20&#10;    material: 1&#10;    section: 3&#10;  - id: 48&#10;    i_node: 10&#10;    j_node: 21&#10;    material: 1&#10;    section: 3&#10;  - id: 49&#10;    i_node: 11&#10;    j_node: 22&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing for lateral stability&#10;  - id: 50&#10;    i_node: 1&#10;    j_node: 13&#10;    material: 1&#10;    section: 4  # L4x4x1/2 angle for bracing&#10;  - id: 51&#10;    i_node: 2&#10;    j_node: 12&#10;    material: 1&#10;    section: 4&#10;  - id: 52&#10;    i_node: 3&#10;    j_node: 15&#10;    material: 1&#10;    section: 4&#10;  - id: 53&#10;    i_node: 4&#10;    j_node: 14&#10;    material: 1&#10;    section: 4&#10;  - id: 54&#10;    i_node: 5&#10;    j_node: 17&#10;    material: 1&#10;    section: 4&#10;  - id: 55&#10;    i_node: 6&#10;    j_node: 16&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord of first truss&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord of second truss&#10;  - member_uid: 20&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 21&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse member loads&#10;  - member_uid: 39&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 40&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 41&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 42&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 43&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 44&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Warren_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Warren_Truss.YAML" />
              <option name="originalContent" value="# Warren truss bridge example with units&#10;# This truss uses equilateral triangles with diagonal members that alternate between compression and tension.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 17.32 ft  # Height based on equilateral triangle&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 17.32 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 17.32 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 17.32 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 17.32 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;&#10;  # Diagonal members (Warren pattern)&#10;  - id: 10&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 11&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 17&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
              <option name="updatedContent" value="# Warren truss bridge example with units&#10;# This truss uses equilateral triangles with diagonal members that alternate between compression and tension.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 17.32 ft  # Height based on equilateral triangle&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 17.32 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 17.32 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 17.32 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 17.32 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel (29000 ksi)&#10;    section: 1   # W12x26 (7.65 in^2, Ixx=204 in^4)&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;&#10;  # Diagonal members (Warren pattern)&#10;  - id: 10&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31 (9.13 in^2, Ixx=110 in^4)&#10;  - id: 11&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 13&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 14&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 15&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 16&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 17&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 18&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 19&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/run_Pratt_bridge.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/run_Pratt_bridge.py" />
              <option name="originalContent" value="import sys&#10;import yaml&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;import os&#10;from matplotlib.backends.backend_pdf import PdfPages&#10;import datetime&#10;import matplotlib.gridspec as gridspec&#10;import matplotlib.cm as cm&#10;&#10;# Load the bridge definition&#10;bridge_file = 'Pratt_Bridge.YAML'&#10;print(f&quot;Loading bridge from {bridge_file}&quot;)&#10;with open(os.path.join(os.path.dirname(__file__), bridge_file), 'r') as file:&#10;    bridge = yaml.safe_load(file)&#10;&#10;# Extract design parameters if present&#10;design_params = bridge.get('design_parameters', {})&#10;min_safety_factor = design_params.get('min_safety_factor', 1.0)&#10;print(f&quot;\nDesign minimum safety factor: {min_safety_factor}&quot;)&#10;&#10;# Extract nodes and members&#10;nodes = bridge['nodes']&#10;members = bridge['members']&#10;supports = bridge['supports']&#10;&#10;# Create a dictionary for easier node lookup&#10;node_dict = {}&#10;for node in nodes:&#10;    node_id = node['id']&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;    z = float(str(node.get('z', '0 ft')).split()[0])  # Default to 0 if z not present&#10;    node_dict[node_id] = (x, y, z)&#10;&#10;# Check for duplicate nodes&#10;print(&quot;\nChecking for duplicate nodes...&quot;)&#10;node_positions = {}&#10;for node_id, pos in node_dict.items():&#10;    pos_key = (pos[0], pos[1])  # Use only x,y for 2D&#10;    if pos_key in node_positions:&#10;        raise ValueError(f&quot;WARNING: Nodes {node_positions[pos_key]} and {node_id} are at the same position {pos_key}&quot;+&quot;This will cause numerical instability!&quot;)&#10;    else:&#10;        node_positions[pos_key] = node_id&#10;&#10;# Define function to get DOF indices for a node&#10;def get_dof(node_id):&#10;    return 2 * (node_id - 1), 2 * (node_id - 1) + 1&#10;&#10;# Initialize global stiffness matrix and force vector&#10;num_nodes = len(nodes)&#10;dof = 2 * num_nodes  # Degrees of freedom (x and y for each node)&#10;K_global = np.zeros((dof, dof))&#10;F_global = np.zeros(dof)&#10;&#10;# Material properties (A36 steel)&#10;E = 29000.0  # ksi - Young's modulus&#10;&#10;# Define section properties - now load from YAML if available&#10;if 'sections' in bridge:&#10;    sections = {}&#10;    for section in bridge['sections']:&#10;        sec_id = section['id']&#10;        area_str = str(section['area']).split()[0]  # Extract numeric part&#10;        r_str = str(section['r']).split()[0]        # Extract numeric part&#10;        sections[sec_id] = {&#10;            &quot;area&quot;: float(area_str),&#10;            &quot;r&quot;: float(r_str)&#10;        }&#10;    print(&quot;\nLoaded section properties from YAML:&quot;)&#10;    for sec_id, props in sections.items():&#10;        print(f&quot;  Section {sec_id}: Area = {props['area']} in^2, r = {props['r']} in&quot;)&#10;else:&#10;    # Default section properties if not in YAML&#10;    sections = {&#10;        1: {&quot;area&quot;: 7.65, &quot;r&quot;: 4.32},  # W12x26 - area in in^2, r is radius of gyration in inches&#10;        2: {&quot;area&quot;: 9.13, &quot;r&quot;: 3.47}   # W8x31 - area in in^2, r is radius of gyration in inches&#10;    }&#10;    print(&quot;\nUsing default section properties&quot;)&#10;&#10;# Store member data for later reference&#10;member_data = {}&#10;&#10;# Calculate axial stiffness for each member&#10;print(&quot;\nAssembling stiffness matrix...&quot;)&#10;for member in members:&#10;    member_id = member['id']&#10;    start = member['i_node']&#10;    end = member['j_node']&#10;    section_id = member['section']&#10;&#10;    # Get section properties&#10;    section_area = sections[section_id][&quot;area&quot;]  # in&#10;&#10;    # Calculate EA in kip-in (E in ksi, A in in =&gt; EA in kip)&#10;    EA = E * section_area&#10;&#10;    # Get coordinates&#10;    x1, y1, _ = node_dict[start]&#10;    x2, y2, _ = node_dict[end]&#10;&#10;    # Calculate length in ft&#10;    dx = x2 - x1&#10;    dy = y2 - y1&#10;    length_ft = np.sqrt(dx**2 + dy**2)&#10;&#10;    # Check for zero-length members&#10;    if length_ft &lt; 1e-6:&#10;        print(f&quot;ERROR: Member {member_id} has zero length (nodes {start} to {end})&quot;)&#10;        print(f&quot;  Node {start}: ({x1}, {y1})&quot;)&#10;        print(f&quot;  Node {end}: ({x2}, {y2})&quot;)&#10;        sys.exit(1)&#10;&#10;    length_in = length_ft * 12.0  # Convert to inches&#10;&#10;    # Calculate direction cosines&#10;    cos = dx / length_ft&#10;    sin = dy / length_ft&#10;&#10;    # Store member properties&#10;    member_data[member_id] = {&#10;        &quot;start&quot;: start,&#10;        &quot;end&quot;: end,&#10;        &quot;length_ft&quot;: length_ft,&#10;        &quot;length_in&quot;: length_in,&#10;        &quot;EA&quot;: EA,&#10;        &quot;cos&quot;: cos,&#10;        &quot;sin&quot;: sin,&#10;        &quot;section_id&quot;: section_id,&#10;        &quot;section_area&quot;: section_area&#10;    }&#10;&#10;    # Debug info for first few members&#10;    if member_id &lt;= 3:&#10;        print(f&quot;Member {member_id}: Length = {length_ft:.2f} ft ({length_in:.2f} in), EA = {EA:.2f} kip&quot;)&#10;        print(f&quot;  Direction: cos = {cos:.4f}, sin = {sin:.4f}&quot;)&#10;&#10;    # Local to global transformation matrix&#10;    T = np.array([&#10;        [ cos, sin, 0,   0],&#10;        [-sin, cos, 0,   0],&#10;        [0,   0,   cos, sin],&#10;        [0,   0,  -sin, cos]&#10;    ])&#10;&#10;    # Element stiffness matrix in local coordinates (for a truss element)&#10;    # k = EA/L in kip/in&#10;    k_axial = EA / length_in&#10;&#10;    k_local = np.array([&#10;        [ k_axial, 0, -k_axial, 0],&#10;        [0, 0,  0, 0],&#10;        [-k_axial, 0, k_axial, 0],&#10;        [0, 0,  0, 0]&#10;    ])&#10;&#10;    # Transform to global coordinates&#10;    k_global = T.T @ k_local @ T&#10;    print(f&quot;member id: {member_id}&quot;, k_global, sep=&quot;\n&quot;)&#10;    # Map local DOFs to global DOFs&#10;    dof_start = get_dof(start)&#10;    dof_end = get_dof(end)&#10;    dof_indices = [*dof_start, *dof_end]; print(f&quot;dof_indices: {dof_indices}&quot;)&#10;&#10;    # Assemble into global stiffness matrix&#10;    for i in range(4):&#10;        for j in range(4):&#10;            K_global[dof_indices[i], dof_indices[j]] += k_global[i, j]&#10;&#10;# Apply external forces from member loads&#10;print(&quot;\nApplying loads...&quot;)&#10;if 'member_loads' in bridge:&#10;    for load in bridge['member_loads']:&#10;        member_id = load['member_uid']&#10;        if member_id not in member_data:&#10;            print(f&quot;WARNING: Load references non-existent member {member_id}&quot;)&#10;            continue&#10;&#10;        member = next(m for m in members if m['id'] == member_id)&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        # Convert distributed load to equivalent nodal loads&#10;        wi = float(str(load['wi']).split()[0])  # kips/ft&#10;        wj = float(str(load['wj']).split()[0])  # kips/ft&#10;        length = member_data[member_id][&quot;length_ft&quot;]  # ft&#10;&#10;        # For uniform load, apply half to each node in y-direction&#10;        if abs(wi - wj) &lt; 1e-6:  # Uniform load&#10;            force = abs(wi) * length / 2  # kips (make positive)&#10;            _, dof_yi = get_dof(i_node)&#10;            _, dof_yj = get_dof(j_node)&#10;&#10;            # Debug info for first few loads&#10;            if member_id &lt;= 3:&#10;                print(f&quot;Load on member {member_id}: w = {wi} kips/ft, L = {length:.2f} ft&quot;)&#10;                print(f&quot;  Equivalent nodal forces: {force:.2f} kips (downward) at nodes {i_node} and {j_node}&quot;)&#10;&#10;            # Apply downward forces (negative in typical structural convention)&#10;            F_global[dof_yi] -= force  # Negative for downward&#10;            F_global[dof_yj] -= force  # Negative for downward&#10;        else:&#10;            # For non-uniform load (simplified approach)&#10;            force_i = abs(wi) * length / 3  # kips&#10;            force_j = abs(wj) * length / 3  # kips&#10;            _, dof_yi = get_dof(i_node)&#10;            _, dof_yj = get_dof(j_node)&#10;            F_global[dof_yi] -= force_i  # Negative for downward&#10;            F_global[dof_yj] -= force_j  # Negative for downward&#10;&#10;# Apply support constraints&#10;print(&quot;\nApplying support constraints:&quot;)&#10;constrained_dofs = []&#10;for support in supports:&#10;    node_id = support['node']&#10;    dof_x, dof_y = get_dof(node_id)&#10;&#10;    print(f&quot;Support at node {node_id}: ux={support['ux']}, uy={support['uy']}&quot;)&#10;&#10;    if support['ux'] == 1:  # Fixed in x-direction&#10;        constrained_dofs.append(dof_x)&#10;        K_global[dof_x, :] = 0&#10;        K_global[:, dof_x] = 0&#10;        K_global[dof_x, dof_x] = 1&#10;        F_global[dof_x] = 0&#10;&#10;    if support['uy'] == 1:  # Fixed in y-direction&#10;        constrained_dofs.append(dof_y)&#10;        K_global[dof_y, :] = 0&#10;        K_global[:, dof_y] = 0&#10;        K_global[dof_y, dof_y] = 1&#10;        F_global[dof_y] = 0&#10;&#10;print(f&quot;Total constrained DOFs: {len(constrained_dofs)}&quot;)&#10;print(f&quot;Free DOFs: {dof - len(constrained_dofs)}&quot;)&#10;&#10;# Check for zero diagonal elements (indicates singularity)&#10;diag_zeros = np.where(np.abs(np.diag(K_global)) &lt; 1e-10)[0]&#10;if len(diag_zeros) &gt; 0:&#10;    print(f&quot;\nWARNING: Zero diagonal elements detected at DOFs: {diag_zeros}&quot;)&#10;    for dof_idx in diag_zeros:&#10;        node_id = dof_idx // 2 + 1&#10;        dof_type = &quot;x&quot; if dof_idx % 2 == 0 else &quot;y&quot;&#10;        print(f&quot;  Node {node_id}, direction {dof_type}&quot;)&#10;&#10;        # Check if this DOF is connected to any members&#10;        connected_members = []&#10;        for mem_id, mem_data in member_data.items():&#10;            if mem_data[&quot;start&quot;] == node_id or mem_data[&quot;end&quot;] == node_id:&#10;                connected_members.append(mem_id)&#10;        print(f&quot;    Connected to members: {connected_members}&quot;)&#10;&#10;# Check if the stiffness matrix is symmetric (it should be)&#10;is_symmetric = np.allclose(K_global, K_global.T, rtol=1e-5, atol=1e-8)&#10;print(f&quot;\nStiffness matrix is symmetric: {is_symmetric}&quot;)&#10;&#10;# Analyze the condition of the matrix&#10;try:&#10;    # Compute the condition number&#10;    cond = np.linalg.cond(K_global)&#10;    print(f&quot;Condition number of stiffness matrix: {cond:.2e}&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        print(&quot;\nWARNING: Very high condition number detected!&quot;)&#10;        print(&quot;The structure may have:&quot;)&#10;        print(&quot;1. Duplicate nodes at the same location&quot;)&#10;        print(&quot;2. Insufficient supports (mechanism)&quot;)&#10;        print(&quot;3. Disconnected parts&quot;)&#10;        print(&quot;4. Numerical scaling issues&quot;)&#10;&#10;        # Find the ratio between max and min non-zero diagonal elements&#10;        diag = np.abs(np.diag(K_global))&#10;        nonzero_diag = diag[diag &gt; 1e-10]&#10;        if len(nonzero_diag) &gt; 0:&#10;            diag_ratio = np.max(nonzero_diag) / np.min(nonzero_diag)&#10;            print(f&quot;\nDiagonal scaling ratio: {diag_ratio:.2e}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;Could not compute condition number: {e}&quot;)&#10;    cond = float('inf')&#10;&#10;# Apply scaling to improve conditioning&#10;print(&quot;\nAttempting to solve the system...&quot;)&#10;try:&#10;    # Use a more robust solver from scipy&#10;    from scipy import linalg&#10;&#10;    # For very ill-conditioned systems, try regularization&#10;    if cond &gt; 1e14:&#10;        print(&quot;System is extremely ill-conditioned. Applying regularization...&quot;)&#10;        # Add small diagonal perturbation to improve conditioning&#10;        reg_factor = 1e-8 * np.max(np.abs(np.diag(K_global)))&#10;        K_regularized = K_global + reg_factor * np.eye(dof)&#10;&#10;        try:&#10;            displacements = linalg.solve(K_regularized, F_global, assume_a='sym')&#10;            print(&quot;Regularized solution successful&quot;)&#10;        except:&#10;            # Fall back to least squares&#10;            displacements, residuals, rank, s = linalg.lstsq(K_global, F_global)&#10;            print(f&quot;Least squares solution: rank={rank}/{dof}&quot;)&#10;    else:&#10;        # Try direct solution&#10;        displacements = linalg.solve(K_global, F_global, assume_a='sym')&#10;        print(&quot;Direct solution successful&quot;)&#10;&#10;    # Convert displacements from inches to feet for consistency&#10;    # Actually, the displacements are already in feet since we used consistent units&#10;&#10;    # Print first few displacement values for debugging&#10;    print(&quot;\nNodal displacements:&quot;)&#10;    print(&quot;Node | dx (in) | dy (in)&quot;)&#10;    print(&quot;-&quot; * 30)&#10;    for i in range(1, min(11, num_nodes + 1)):&#10;        dof_x, dof_y = get_dof(i)&#10;        # Convert to inches for display&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        print(f&quot;{i:4} | {dx_in:7.4f} | {dy_in:7.4f}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;All solution methods failed: {e}&quot;)&#10;    print(&quot;Using zero displacements as fallback&quot;)&#10;    displacements = np.zeros(dof)&#10;&#10;# Find maximum vertical displacement&#10;max_vert_disp = 0&#10;max_disp_node = None&#10;for node_id in node_dict:&#10;    _, dof_y = get_dof(node_id)&#10;    # Skip nodes that are supported&#10;    is_supported = any(s['node'] == node_id and s['uy'] == 1 for s in supports)&#10;    if not is_supported:&#10;        disp = abs(displacements[dof_y])&#10;        if disp &gt; max_vert_disp:&#10;            max_vert_disp = disp&#10;            max_disp_node = node_id&#10;&#10;# Convert to inches for display&#10;max_vert_disp_in = max_vert_disp * 12&#10;print(f&quot;\nMaximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}&quot;)&#10;&#10;# Calculate member forces&#10;member_forces = {}&#10;member_stresses = {}&#10;&#10;# Material properties (A36 steel)&#10;Fy = 36.0    # ksi - Yield strength&#10;Fu = 58.0    # ksi - Ultimate strength&#10;safety_factor_tension = 1.67&#10;safety_factor_compression = 1.67&#10;allowable_tension_stress = Fy / safety_factor_tension      # ksi&#10;allowable_compression_stress_max = Fy / safety_factor_compression  # ksi&#10;&#10;# Calculate forces and stresses for each member&#10;for member in members:&#10;    member_id = member['id']&#10;    if member_id not in member_data:&#10;        continue  # Skip members with zero length&#10;&#10;    mem_data = member_data[member_id]&#10;    start = mem_data[&quot;start&quot;]&#10;    end = mem_data[&quot;end&quot;]&#10;    area = mem_data[&quot;section_area&quot;]  # in&#10;    cos = mem_data[&quot;cos&quot;]&#10;    sin = mem_data[&quot;sin&quot;]&#10;&#10;    # Get displacements at both nodes (in feet)&#10;    dof_x1, dof_y1 = get_dof(start)&#10;    dof_x2, dof_y2 = get_dof(end)&#10;&#10;    # Calculate relative displacement in the axial direction (in feet)&#10;    delta_u1 = displacements[dof_x1] * cos + displacements[dof_y1] * sin&#10;    delta_u2 = displacements[dof_x2] * cos + displacements[dof_y2] * sin&#10;    delta_axial = delta_u2 - delta_u1&#10;&#10;    # Convert to inches for force calculation&#10;    delta_axial_in = delta_axial * 12&#10;&#10;    # Calculate axial force (F = EA/L * delta)&#10;    EA = mem_data[&quot;EA&quot;]  # kip&#10;    force = (EA / mem_data[&quot;length_in&quot;]) * delta_axial_in  # kips&#10;    member_forces[member_id] = force&#10;&#10;    # Calculate axial stress&#10;    stress = force / area  # kips/in = ksi&#10;    member_stresses[member_id] = stress&#10;&#10;    # Debug output for the first few members&#10;    if member_id &lt;= 3 or member_id == 32:&#10;        print(f&quot;\nMember {member_id} analysis:&quot;)&#10;        print(f&quot;  Length = {mem_data['length_ft']:.2f} ft&quot;)&#10;        print(f&quot;  Node {start}: dx = {displacements[dof_x1]*12:.4f} in, dy = {displacements[dof_y1]*12:.4f} in&quot;)&#10;        print(f&quot;  Node {end}: dx = {displacements[dof_x2]*12:.4f} in, dy = {displacements[dof_y2]*12:.4f} in&quot;)&#10;        print(f&quot;  Delta axial = {delta_axial_in:.4f} in&quot;)&#10;        print(f&quot;  Force = {force:.2f} kips&quot;)&#10;        print(f&quot;  Stress = {stress:.2f} ksi&quot;)&#10;&#10;# Calculate safety factors for all members&#10;member_safety_factors = {}&#10;member_status = {}&#10;&#10;# Define zero force threshold&#10;ZERO_FORCE_THRESHOLD = 0.1  # Consider forces below this threshold as &quot;zero&quot;&#10;&#10;# Replace the problematic part in the safety factors calculation&#10;for member_id, stress in member_stresses.items():&#10;    section_id = member_data[member_id][&quot;section_id&quot;]&#10;    section = sections[section_id]&#10;&#10;    if abs(stress) &lt; ZERO_FORCE_THRESHOLD / section[&quot;area&quot;]:&#10;        # Zero/near-zero stress&#10;        safety_factor = float('inf')&#10;        limit = allowable_tension_stress  # Arbitrary for zero-force members&#10;        status = &quot;OK&quot;&#10;    elif stress &gt;= 0:  # Tension&#10;        safety_factor = allowable_tension_stress / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_tension_stress&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;    else:  # Compression&#10;        # Calculate allowable compression stress based on slenderness&#10;        length_inches = member_data[member_id][&quot;length_in&quot;]&#10;        slenderness = length_inches / section[&quot;r&quot;]&#10;&#10;        if slenderness &gt; 100:  # For slender members&#10;            critical_stress = (np.pi**2 * E) / (slenderness**2)&#10;            allowable_compression = min(allowable_compression_stress_max, critical_stress/safety_factor_compression)&#10;        else:  # For stocky members&#10;            allowable_compression = allowable_compression_stress_max&#10;&#10;        safety_factor = allowable_compression / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_compression&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;&#10;    member_safety_factors[member_id] = safety_factor&#10;    member_status[member_id] = {&#10;        &quot;stress&quot;: stress,&#10;        &quot;allowable&quot;: limit,&#10;        &quot;safety_factor&quot;: safety_factor,&#10;        &quot;status&quot;: status&#10;    }&#10;&#10;# After calculating safety factors, add a summary of members below minimum&#10;members_below_min_sf = []&#10;for member_id, status_info in member_status.items():&#10;    if status_info[&quot;safety_factor&quot;] &lt; min_safety_factor and status_info[&quot;safety_factor&quot;] &lt; 100:&#10;        members_below_min_sf.append({&#10;            'id': member_id,&#10;            'sf': status_info[&quot;safety_factor&quot;],&#10;            'stress': status_info[&quot;stress&quot;],&#10;            'allowable': status_info[&quot;allowable&quot;]&#10;        })&#10;&#10;if members_below_min_sf:&#10;    print(f&quot;\n{len(members_below_min_sf)} members have safety factor below {min_safety_factor}:&quot;)&#10;    for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:10]:  # Show worst 10&#10;        print(f&quot;  Member {mem['id']}: SF = {mem['sf']:.2f}, Stress = {abs(mem['stress']):.1f} ksi&quot;)&#10;&#10;# Create figure for the PDF - add timestamp to filenames&#10;timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M%S')&#10;pdf_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_Analysis_{timestamp}.pdf&quot;)&#10;text_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_Analysis_{timestamp}.txt&quot;)&#10;&#10;# Open the text file for writing the report&#10;with open(text_filename, 'w') as txt_report:&#10;    # Write header information&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(&quot;PRATT BRIDGE STRUCTURAL ANALYSIS REPORT\n&quot;)&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(f&quot;Analysis Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}\n&quot;)&#10;    txt_report.write(f&quot;Input File: {bridge_file}\n&quot;)&#10;    txt_report.write(f&quot;Design Minimum Safety Factor: {min_safety_factor}\n\n&quot;)&#10;&#10;    # Write model statistics&#10;    txt_report.write(&quot;MODEL STATISTICS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Number of nodes: {num_nodes}\n&quot;)&#10;    txt_report.write(f&quot;Number of members: {len(members)}\n&quot;)&#10;    txt_report.write(f&quot;Number of supports: {len(supports)}\n&quot;)&#10;    txt_report.write(f&quot;Degrees of freedom: {dof}\n&quot;)&#10;    txt_report.write(f&quot;Constrained DOFs: {len(constrained_dofs)}\n&quot;)&#10;    txt_report.write(f&quot;Free DOFs: {dof - len(constrained_dofs)}\n\n&quot;)&#10;&#10;    # Write material properties&#10;    txt_report.write(&quot;MATERIAL PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Material: A36 Steel\n&quot;)&#10;    txt_report.write(f&quot;Young's modulus: {E} ksi\n&quot;)&#10;    txt_report.write(f&quot;Yield strength: {Fy} ksi\n&quot;)&#10;    txt_report.write(f&quot;Ultimate strength: {Fu} ksi\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (tension): {safety_factor_tension}\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (compression): {safety_factor_compression}\n\n&quot;)&#10;&#10;    # Write section properties&#10;    txt_report.write(&quot;SECTION PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    for sec_id, props in sections.items():&#10;        txt_report.write(f&quot;Section {sec_id}: Area = {props['area']} in, r = {props['r']} in\n&quot;)&#10;    txt_report.write(&quot;\n&quot;)&#10;&#10;    # Write analysis results summary&#10;    txt_report.write(&quot;ANALYSIS RESULTS SUMMARY\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Maximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}\n&quot;)&#10;&#10;    # Calculate critical values&#10;    critical_sf = float('inf')&#10;    critical_member = None&#10;    overstressed_count = 0&#10;    for member_id, status_info in member_status.items():&#10;        sf = status_info[&quot;safety_factor&quot;]&#10;        if sf &lt; critical_sf and sf &lt; 100:&#10;            critical_sf = sf&#10;            critical_member = member_id&#10;        if status_info[&quot;status&quot;] == &quot;OVERSTRESSED&quot;:&#10;            overstressed_count += 1&#10;&#10;    txt_report.write(f&quot;Number of tension members: {sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of compression members: {sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of zero-force members: {sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Overstressed members: {overstressed_count}\n&quot;)&#10;    txt_report.write(f&quot;Maximum member force: {max(abs(f) for f in member_forces.values()):.2f} kips\n&quot;)&#10;    txt_report.write(f&quot;Maximum member stress: {max(abs(s) for s in member_stresses.values()):.2f} ksi\n&quot;)&#10;    txt_report.write(f&quot;Minimum safety factor: {critical_sf:.2f} (Member #{critical_member})\n\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;WARNING: High condition number indicates numerical instability.\n&quot;)&#10;        txt_report.write(&quot;The structure may have:\n&quot;)&#10;        txt_report.write(&quot;1. Duplicate nodes at the same location\n&quot;)&#10;        txt_report.write(&quot;2. Insufficient supports (mechanism)\n&quot;)&#10;        txt_report.write(&quot;3. Disconnected parts\n&quot;)&#10;        txt_report.write(&quot;4. Numerical scaling issues\n\n&quot;)&#10;&#10;    # Write detailed member results&#10;    txt_report.write(&quot;DETAILED MEMBER RESULTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Member | Nodes (i-j) | Force (kips) | Stress (ksi) | Type | S.F. | Status\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 80 + &quot;\n&quot;)&#10;&#10;    for member in sorted(members, key=lambda m: m['id']):&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;        stress = member_stresses[member_id]&#10;        sf = member_safety_factors[member_id]&#10;        status = member_status[member_id][&quot;status&quot;]&#10;&#10;        # Fix the text report formatting to use only ASCII&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            force_type = &quot;ZERO&quot;&#10;            sf_text = &quot;inf&quot;&#10;        elif force &gt; 0:&#10;            force_type = &quot;TENSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;        else:&#10;            force_type = &quot;COMPRESSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;&#10;        txt_report.write(&#10;            f&quot;{member_id:6} | {i_node:2}-{j_node:&lt;2} | {abs(force):11.2f} | {abs(stress):10.2f} | {force_type:10} | {sf_text:&gt;5} | {status}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;&#10;    # Write nodal displacements&#10;    txt_report.write(&quot;NODAL DISPLACEMENTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Node | dx (inches) | dy (inches)\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 35 + &quot;\n&quot;)&#10;&#10;    for node_id in sorted(node_dict.keys()):&#10;        dof_x, dof_y = get_dof(node_id)&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        txt_report.write(f&quot;{node_id:4} | {dx_in:11.4f} | {dy_in:11.4f}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;    txt_report.write(&quot;RECOMMENDATIONS FOR STRUCTURE REFINEMENT\n&quot;)&#10;    txt_report.write(&quot;----------------------------------------\n&quot;)&#10;&#10;    if members_below_min_sf:&#10;        txt_report.write(f&quot;1. {len(members_below_min_sf)} members have safety factor below the design minimum of {min_safety_factor}:\n&quot;)&#10;        for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:20]:  # Show worst 20&#10;            member = next(m for m in members if m['id'] == mem['id'])&#10;            txt_report.write(f&quot;   - Member {mem['id']} (nodes {member['i_node']}-{member['j_node']}): SF = {mem['sf']:.2f}\n&quot;)&#10;&#10;        # Calculate required section increase&#10;        worst_sf = min(mem['sf'] for mem in members_below_min_sf)&#10;        required_increase = min_safety_factor / worst_sf&#10;        txt_report.write(f&quot;\n   Worst member requires approximately {required_increase:.1f}x increase in capacity.\n&quot;)&#10;        txt_report.write(f&quot;   Consider using larger sections or reducing the loading.\n&quot;)&#10;    else:&#10;        txt_report.write(&quot;1. All members meet the minimum safety factor requirement.\n&quot;)&#10;        txt_report.write(&quot;   Consider optimizing the structure by reducing sections for members with high safety factors.\n&quot;)&#10;&#10;    if max_vert_disp_in &gt; 2.0:  # Assuming 2 inches as a reasonable deflection limit&#10;        txt_report.write(f&quot;2. Consider stiffening the structure to reduce the maximum deflection (currently {max_vert_disp_in:.4f} inches).\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;3. Fix numerical stability issues by reviewing structure connectivity and supports.\n&quot;)&#10;&#10;    txt_report.write(&quot;\nReport generated by pyMAOS Truss Analysis Tool\n&quot;)&#10;&#10;print(f&quot;Text report saved to: {text_filename}&quot;)&#10;&#10;with PdfPages(pdf_filename) as pdf:&#10;    # 1. BRIDGE ANALYSIS SUMMARY page&#10;    fig = plt.figure(figsize=(8.5, 11))&#10;    plt.axis('off')&#10;&#10;    # Add overall bridge status text - avoid using unicode characters&#10;    if overstressed_count == 0:&#10;        status_text = &quot;BRIDGE IS STRUCTURALLY ADEQUATE&quot;&#10;        status_color = 'green'&#10;    else:&#10;        status_text = f&quot;WARNING: BRIDGE HAS {overstressed_count} OVERSTRESSED MEMBERS&quot;&#10;        status_color = 'red'&#10;&#10;    plt.figtext(0.5, 0.9, &quot;BRIDGE ANALYSIS SUMMARY&quot;, ha='center', fontsize=16, weight='bold')&#10;    plt.figtext(0.5, 0.85, status_text, ha='center', fontsize=14, weight='bold', color=status_color)&#10;&#10;    # Add displacement information&#10;    plt.figtext(0.5, 0.78, f&quot;Maximum Vertical Displacement: {max_vert_disp_in:.4f} inches at Node {max_disp_node}&quot;,&#10;                ha='center', fontsize=12)&#10;&#10;    # Add summary statistics&#10;    critical_text = f&quot;Most critical member: #{critical_member} (Safety Factor: {critical_sf:.2f})&quot;&#10;    plt.figtext(0.5, 0.73, critical_text, ha='center', fontsize=12)&#10;&#10;    # Add a summary table of key statistics&#10;    summary_data = [&#10;        [&quot;Total Members&quot;, f&quot;{len(members)}&quot;],&#10;        [&quot;Tension Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Compression Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Zero-Force Members&quot;, f&quot;{sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Overstressed Members&quot;, f&quot;{overstressed_count}&quot;],&#10;        [&quot;Maximum Member Force&quot;, f&quot;{max(abs(f) for f in member_forces.values()):.2f} kips&quot;],&#10;        [&quot;Maximum Member Stress&quot;, f&quot;{max(abs(s) for s in member_stresses.values()):.2f} ksi&quot;],&#10;        [&quot;Minimum Safety Factor&quot;, f&quot;{critical_sf:.2f}&quot;],&#10;        [&quot;Maximum Displacement&quot;, f&quot;{max_vert_disp_in:.4f} inches&quot;],&#10;    ]&#10;&#10;    # Create a table in the middle of the page&#10;    ax = plt.subplot(111)&#10;    ax.axis('off')&#10;    tbl = plt.table(cellText=summary_data, colLabels=[&quot;Metric&quot;, &quot;Value&quot;],&#10;                    loc='center', cellLoc='left')&#10;    tbl.auto_set_font_size(False)&#10;    tbl.set_fontsize(10)&#10;    tbl.scale(1, 1.5)&#10;&#10;    # Add design criteria info&#10;    criteria = (&#10;        f&quot;Design Criteria:\n&quot;&#10;        f&quot;- Material: A36 Steel (Fy = 36 ksi)\n&quot;&#10;        f&quot;- Allowable tension stress: {allowable_tension_stress:.1f} ksi\n&quot;&#10;        f&quot;- Allowable compression stress: Based on member slenderness\n&quot;&#10;        f&quot;- Safety factor: {safety_factor_tension:.2f}&quot;&#10;    )&#10;    plt.figtext(0.5, 0.2, criteria, ha='center', fontsize=10,&#10;                bbox=dict(facecolor='#eeeeee', alpha=0.7, boxstyle='round,pad=0.5'))&#10;&#10;    # Add timestamp&#10;    plt.figtext(0.5, 0.1, f&quot;Analysis completed on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    # Save the summary page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 2. Reliability Analysis - Safety Factors plot&#10;    fig, ax = plt.subplots(figsize=(11, 8.5))  # Changed to landscape orientation&#10;&#10;    # Use plt.colormaps instead of cm.get_cmap to avoid deprecation warning&#10;    cmap = plt.colormaps['RdYlGn']  # Red-Yellow-Green colormap&#10;    norm = plt.Normalize(0.5, 2.0)&#10;&#10;    # Plot members with color based on safety factors&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        safety_factor = member_safety_factors[member_id]&#10;        safety_factor_capped = min(safety_factor, 5.0)  # Cap extremely high values for visualization&#10;&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        x = [x1, x2]&#10;        y = [y1, y2]&#10;&#10;        color = cmap(norm(safety_factor_capped))&#10;        linewidth = 3  # Consistent line width&#10;&#10;        ax.plot(x, y, color=color, linewidth=linewidth)&#10;&#10;        # Add safety factor label at midpoint&#10;        mid_x = (x1 + x2) / 2&#10;        mid_y = (y1 + y2) / 2&#10;&#10;        # Format infinity as &quot;&quot;&#10;        sf_text = &quot;&quot; if safety_factor &gt; 100 else f&quot;{safety_factor:.1f}&quot;&#10;&#10;        ax.text(mid_x, mid_y, sf_text,&#10;                fontsize=6, ha='center', va='center',&#10;                bbox=dict(facecolor='white', alpha=0.7, pad=1))&#10;&#10;    # Plot nodes and supports&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        ax.plot(x, y, 'ko', markersize=5)&#10;        ax.text(x+1, y+1, f&quot;{node_id}&quot;, fontsize=7)&#10;&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, _ = node_dict[node_id]&#10;        if support['ux'] == 1 and support['uy'] == 1:&#10;            ax.plot(x, y-2, 'ks', markersize=8)&#10;        elif support['ux'] == 0 and support['uy'] == 1:&#10;            ax.plot(x, y-2, 'ko', markersize=8)&#10;&#10;    # Add a colorbar&#10;    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)&#10;    sm.set_array([])&#10;    cbar = plt.colorbar(sm, ax=ax, label='Safety Factor', shrink=0.8)&#10;    cbar.set_ticks([0.5, 1.0, 1.5, 2.0])&#10;    cbar.set_ticklabels(['0.5', '1.0 (Limit)', '1.5', ' 2.0'])&#10;&#10;    # Set plot limits and labels&#10;    max_x = max(node_dict[n][0] for n in node_dict)&#10;    max_y = max(node_dict[n][1] for n in node_dict)&#10;    ax.set_xlim(-5, max_x + 15)&#10;    ax.set_ylim(-5, max_y + 5)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;    ax.set_title('Pratt Truss Bridge Reliability Analysis - Safety Factors', fontsize=12)&#10;    ax.grid(True)&#10;    plt.tight_layout(pad=2.0, rect=[0, 0, 1, 0.95])&#10;&#10;    # Save the safety factor visualization to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 3. Member Forces Summary Tables (split across pages) with node IDs&#10;    rows_per_page = 20  # Adjust as needed&#10;    all_members = sorted(members, key=lambda m: m['id'])&#10;    member_chunks = [all_members[i:i+rows_per_page] for i in range(0, len(all_members), rows_per_page)]&#10;&#10;    for page_idx, member_chunk in enumerate(member_chunks):&#10;        fig = plt.figure(figsize=(8.5, 11))&#10;        gs = gridspec.GridSpec(1, 1)&#10;        ax = plt.subplot(gs[0])&#10;        ax.axis('tight')&#10;        ax.axis('off')&#10;&#10;        # Create summary data for this chunk&#10;        table_data = []&#10;        table_data.append(['Member', 'Nodes (i-j)', 'Force (kips)', 'Type'])&#10;&#10;        for member in member_chunk:&#10;            member_id = member['id']&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;            force = member_forces[member_id]&#10;&#10;            if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;                force_type = &quot;ZERO&quot;&#10;            elif force &gt; 0:&#10;                force_type = &quot;TENSION&quot;&#10;            else:&#10;                force_type = &quot;COMPRESSION&quot;&#10;&#10;            table_data.append([str(member_id), f&quot;{i_node}-{j_node}&quot;, f&quot;{abs(force):.2f}&quot;, force_type])&#10;&#10;        # Create table with smaller font&#10;        table = ax.table(cellText=table_data, loc='center', cellLoc='center')&#10;        table.auto_set_font_size(False)&#10;        table.set_fontsize(8)&#10;        table.scale(1, 1.4)&#10;&#10;        # Add title with page number but more space at the top&#10;        plt.title(f&quot;Member Forces Summary (Page {page_idx+1} of {len(member_chunks)})&quot;,&#10;                  fontsize=14, y=0.98, pad=20)&#10;&#10;        # Add metadata&#10;        plt.figtext(0.5, 0.03,&#10;                    f&quot;Pratt Bridge Analysis - Generated on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                    ha='center', fontsize=6)&#10;&#10;        # Save the page to PDF&#10;        pdf.savefig(fig)&#10;        plt.close(fig)&#10;&#10;    # 4. Member Forces plot&#10;    fig, ax = plt.subplots(figsize=(11, 8.5))  # Changed to landscape orientation&#10;&#10;    # Plot members with color based on tension/compression/zero&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;&#10;        # Find the coordinates for both nodes&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        x = [x1, x2]&#10;        y = [y1, y2]&#10;&#10;        # Color: red for tension, blue for compression, black for zero/near-zero&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            color = 'black'  # Zero force&#10;            linestyle = '-'&#10;            linewidth = 1.5&#10;        elif force &gt; 0:&#10;            color = 'red'  # Tension&#10;            linestyle = '-'&#10;            linewidth = 2 + min(5, abs(force)/100)  # Scale width with force magnitude&#10;        else:&#10;            color = 'blue'  # Compression&#10;            linestyle = '-'&#10;            linewidth = 2 + min(5, abs(force)/100)  # Scale width with force magnitude&#10;&#10;        # Plot the member&#10;        ax.plot(x, y, color=color, linestyle=linestyle, linewidth=linewidth)&#10;&#10;        # Add force label at midpoint - reduced font size&#10;        mid_x = (x1 + x2) / 2&#10;        mid_y = (y1 + y2) / 2&#10;        ax.text(mid_x, mid_y, f&quot;{abs(force):.1f}&quot;,&#10;                fontsize=6, ha='center', va='center',&#10;                bbox=dict(facecolor='white', alpha=0.7, pad=1))&#10;&#10;    # Plot nodes&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        ax.plot(x, y, 'ko', markersize=6)&#10;        ax.text(x+1, y+1, f&quot;{node_id}&quot;, fontsize=7)&#10;&#10;    # Plot supports&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, _ = node_dict[node_id]&#10;&#10;        # Different markers for different support types&#10;        if support['ux'] == 1 and support['uy'] == 1:&#10;            # Pinned support - triangle&#10;            ax.plot(x, y-2, 'ks', markersize=10)&#10;        elif support['ux'] == 0 and support['uy'] == 1:&#10;            # Roller support - circle&#10;            ax.plot(x, y-2, 'ko', markersize=10)&#10;&#10;    # Add legend&#10;    red_line = plt.Line2D([0], [0], color='red', linewidth=3, label='Tension')&#10;    blue_line = plt.Line2D([0], [0], color='blue', linewidth=3, label='Compression')&#10;    black_line = plt.Line2D([0], [0], color='black', linewidth=2, label='Zero Force')&#10;    ax.legend(handles=[red_line, blue_line, black_line], loc='upper right', fontsize=8)&#10;&#10;    # Set plot limits and labels&#10;    ax.set_xlim(-5, max_x + 15)  # Extra space on right for labels&#10;    ax.set_ylim(-5, max_y + 5)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;    ax.set_title('Pratt Truss Bridge Analysis - Member Forces', fontsize=12)&#10;    ax.grid(True)&#10;&#10;    # Use tight_layout with adjusted parameters&#10;    plt.tight_layout(pad=2.0, rect=[0, 0, 1, 0.95])&#10;&#10;    # Save the member forces plot to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 5. Displacement visualization&#10;    fig, ax = plt.subplots(figsize=(12, 9))  # Increased figure size for better visibility&#10;&#10;    # Draw original structure in light gray&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        ax.plot([x1, x2], [y1, y2], color='lightgray', linestyle='-', linewidth=1, alpha=0.5)&#10;&#10;    # Calculate max displacement for proper scaling&#10;    max_disp_magnitude = 0&#10;    for node_id in node_dict:&#10;        dof_x, dof_y = get_dof(node_id)&#10;        disp_magnitude = np.sqrt(displacements[dof_x]**2 + displacements[dof_y]**2)&#10;        max_disp_magnitude = max(max_disp_magnitude, disp_magnitude)&#10;&#10;    # More reasonable scale factor - aim for approximately 5-10% of bridge span&#10;    max_span = max(node_dict[n][0] for n in node_dict) - min(node_dict[n][0] for n in node_dict)&#10;    bridge_height = max(node_dict[n][1] for n in node_dict) - min(node_dict[n][1] for n in node_dict)&#10;    target_max_disp = min(max_span, bridge_height) * 0.05  # More conservative scaling&#10;&#10;    # Calculate scale factor (with protection against division by zero)&#10;    if max_disp_magnitude &gt; 1e-10:&#10;        scale_factor = target_max_disp / max_disp_magnitude&#10;        # Ensure scale factor is rounded to a clean number for display&#10;        scale_magnitude = 10 ** int(np.log10(scale_factor))&#10;        scale_factor = round(scale_factor / scale_magnitude) * scale_magnitude&#10;    else:&#10;        scale_factor = 50.0  # Default if displacements are effectively zero&#10;&#10;    # Print debug info for node 12 (central top chord)&#10;    if 12 in node_dict:&#10;        dof_x12, dof_y12 = get_dof(12)&#10;        print(f&quot;\nDebug - Node 12 displacement:&quot;)&#10;        print(f&quot;  Original position: ({node_dict[12][0]}, {node_dict[12][1]})&quot;)&#10;        print(f&quot;  Displacement: dx={displacements[dof_x12]*12:.6f} in, dy={displacements[dof_y12]*12:.6f} in&quot;)&#10;        print(f&quot;  Scaled displacement: dx={displacements[dof_x12]*scale_factor:.4f} ft, dy={displacements[dof_y12]*scale_factor:.4f} ft&quot;)&#10;&#10;    # Precalculate the max and min coordinates after displacement to ensure proper plot limits&#10;    min_x_disp = float('inf')&#10;    min_y_disp = float('inf')&#10;    max_x_disp = float('-inf')&#10;    max_y_disp = float('-inf')&#10;&#10;    # First pass - calculate extents of displaced structure&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        dof_x, dof_y = get_dof(node_id)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;&#10;        min_x_disp = min(min_x_disp, x_new)&#10;        min_y_disp = min(min_y_disp, y_new)&#10;        max_x_disp = max(max_x_disp, x_new)&#10;        max_y_disp = max(max_y_disp, y_new)&#10;&#10;    # Draw displaced structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;&#10;        # Get displacements&#10;        dof_x1, dof_y1 = get_dof(i_node)&#10;        dof_x2, dof_y2 = get_dof(j_node)&#10;&#10;        # Apply displacements&#10;        x1_new = x1 + displacements[dof_x1] * scale_factor&#10;        y1_new = y1 + displacements[dof_y1] * scale_factor&#10;        x2_new = x2 + displacements[dof_x2] * scale_factor&#10;        y2_new = y2 + displacements[dof_y2] * scale_factor&#10;&#10;        # Draw displaced member&#10;        ax.plot([x1_new, x2_new], [y1_new, y2_new], color='blue', linestyle='-', linewidth=1.5)&#10;&#10;        # Add small markers at displaced node positions for clarity&#10;        ax.plot(x1_new, y1_new, 'b.', markersize=4)&#10;        ax.plot(x2_new, y2_new, 'b.', markersize=4)&#10;&#10;    # Highlight the node with maximum displacement - directly on the plot without a box&#10;    if max_disp_node:&#10;        x, y, _ = node_dict[max_disp_node]&#10;        dof_x, dof_y = get_dof(max_disp_node)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;&#10;        # Use a more visible marker directly on the plot&#10;        ax.plot(x_new, y_new, 'ro', markersize=8)&#10;&#10;        # Add the label directly at the node with smaller text and no box&#10;        label_x = x_new + 0.03 * max_span&#10;        label_y = y_new + 0.02 * max_span&#10;        ax.text(label_x, label_y, f&quot;Node {max_disp_node}: {max_vert_disp_in:.2f} in&quot;,&#10;                fontsize=8, color='red', ha='left', va='bottom',&#10;                path_effects=[plt.matplotlib.patheffects.withStroke(linewidth=3, foreground='white')])&#10;&#10;    # Add legend&#10;    orig = plt.Line2D([0], [0], color='lightgray', linestyle='-', linewidth=1, alpha=0.5, label='Original Structure')&#10;    disp = plt.Line2D([0], [0], color='blue', linestyle='-', linewidth=1.5, label='Displaced Structure')&#10;    ax.legend(handles=[orig, disp], loc='upper right', fontsize=8)&#10;&#10;    # Set plot limits to ensure complete structure visibility, with additional padding&#10;    min_x = min(node_dict[n][0] for n in node_dict)&#10;    min_y = min(node_dict[n][1] for n in node_dict)&#10;    max_x = max(node_dict[n][0] for n in node_dict)&#10;    max_y = max(node_dict[n][1] for n in node_dict)&#10;&#10;    # Ensure we include both original and displaced structures with padding&#10;    plot_min_x = min(min_x, min_x_disp) - 0.1 * max_span&#10;    plot_min_y = min(min_y, min_y_disp) - 0.15 * bridge_height&#10;    plot_max_x = max(max_x, max_x_disp) + 0.1 * max_span&#10;    plot_max_y = max(max_y, max_y_disp) + 0.1 * bridge_height&#10;&#10;    ax.set_xlim(plot_min_x, plot_max_x)&#10;    ax.set_ylim(plot_min_y, plot_max_y)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;&#10;    # Format scale factor nicely&#10;    if scale_factor &gt;= 1000:&#10;        scale_factor_text = f&quot;{scale_factor/1000:.1f}k&quot;&#10;    elif scale_factor &gt;= 100:&#10;        scale_factor_text = f&quot;{int(scale_factor)}&quot;&#10;    else:&#10;        scale_factor_text = f&quot;{scale_factor:.1f}&quot;&#10;&#10;    ax.set_title(f'Pratt Truss Bridge - Displacement Analysis (Scale Factor: {scale_factor_text})', fontsize=12)&#10;&#10;    # Add note about displacement scale&#10;    plt.figtext(0.5, 0.01,&#10;                f&quot;Note: Displacements are scaled by a factor of {scale_factor_text} for visibility. &quot;&#10;                f&quot;Actual maximum displacement: {max_vert_disp_in:.4f} inches.&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    ax.grid(True)&#10;    plt.tight_layout(pad=2.0, rect=[0, 0.02, 1, 0.98])&#10;&#10;    # Save the displacement page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # Add PDF metadata&#10;    d = pdf.infodict()&#10;    d['Title'] = 'Pratt Bridge Structural Analysis'&#10;    d['Author'] = 'pyMAOS Truss Analysis Tool'&#10;    d['Subject'] = 'Structural analysis and reliability assessment'&#10;    d['Keywords'] = 'truss, structural analysis, bridge, reliability'&#10;    d['CreationDate'] = datetime.datetime.now()&#10;    d['ModDate'] = datetime.datetime.now()&#10;&#10;# Print summary of results to console&#10;print(&quot;\nMember Forces Summary:&quot;)&#10;print(&quot;----------------------&quot;)&#10;print(&quot;Member | Force (kips) | Type&quot;)&#10;print(&quot;----------------------&quot;)&#10;for member in sorted(members, key=lambda m: m['id']):&#10;    member_id = member['id']&#10;    force = member_forces[member_id]&#10;    if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;        force_type = &quot;ZERO&quot;&#10;    elif force &gt; 0:&#10;        force_type = &quot;TENSION&quot;&#10;    else:&#10;        force_type = &quot;COMPRESSION&quot;&#10;    print(f&quot;{member_id:6} | {abs(force):11.2f} | {force_type}&quot;)&#10;&#10;# Print numerical stability information&#10;print(&quot;\nNumerical Stability Info:&quot;)&#10;print(&quot;-----------------------&quot;)&#10;print(f&quot;Matrix size: {dof}{dof}&quot;)&#10;print(f&quot;Condition number: {cond:.2e}&quot;)&#10;print(f&quot;Number of members: {len(member_data)}&quot;)&#10;print(f&quot;Maximum force magnitude: {max(abs(f) for f in member_forces.values()):.2f} kips&quot;)&#10;print(f&quot;Maximum displacement: {max_vert_disp_in:.4f} inches&quot;)&#10;&#10;if cond &gt; 1e12:&#10;    print(&quot;\nWARNING: High condition number indicates numerical instability.&quot;)&#10;    print(&quot;\nRECOMMENDATIONS:&quot;)&#10;    print(&quot;1. The duplicate nodes 6 and 13 at (100, 0) should be merged into a single node&quot;)&#10;    print(&quot;2. Update member connectivity to reference the merged node&quot;)&#10;    print(&quot;3. Ensure all supports are properly defined&quot;)&#10;    print(&quot;4. Check for any disconnected parts of the structure&quot;)&#10;&#10;# Display the plot on screen&#10;plt.show()&#10;" />
              <option name="updatedContent" value="import sys&#10;import yaml&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;import os&#10;from matplotlib.backends.backend_pdf import PdfPages&#10;import datetime&#10;import matplotlib.gridspec as gridspec&#10;import matplotlib.cm as cm&#10;&#10;# Load the bridge definition&#10;bridge_file = 'Pratt_Bridge.YAML'&#10;print(f&quot;Loading bridge from {bridge_file}&quot;)&#10;with open(os.path.join(os.path.dirname(__file__), bridge_file), 'r') as file:&#10;    bridge = yaml.safe_load(file)&#10;&#10;# Extract design parameters if present&#10;design_params = bridge.get('design_parameters', {})&#10;min_safety_factor = design_params.get('min_safety_factor', 1.0)&#10;print(f&quot;\nDesign minimum safety factor: {min_safety_factor}&quot;)&#10;&#10;# Extract nodes and members&#10;nodes = bridge['nodes']&#10;members = bridge['members']&#10;supports = bridge['supports']&#10;&#10;# Create a dictionary for easier node lookup&#10;node_dict = {}&#10;for node in nodes:&#10;    node_id = node['id']&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;    z = float(str(node.get('z', '0 ft')).split()[0])  # Default to 0 if z not present&#10;    node_dict[node_id] = (x, y, z)&#10;&#10;# Check for duplicate nodes&#10;print(&quot;\nChecking for duplicate nodes...&quot;)&#10;node_positions = {}&#10;for node_id, pos in node_dict.items():&#10;    pos_key = (pos[0], pos[1])  # Use only x,y for 2D&#10;    if pos_key in node_positions:&#10;        raise ValueError(f&quot;WARNING: Nodes {node_positions[pos_key]} and {node_id} are at the same position {pos_key}&quot;+&quot;This will cause numerical instability!&quot;)&#10;    else:&#10;        node_positions[pos_key] = node_id&#10;&#10;# Define function to get DOF indices for a node&#10;def get_dof(node_id):&#10;    return 2 * (node_id - 1), 2 * (node_id - 1) + 1&#10;&#10;# Initialize global stiffness matrix and force vector&#10;num_nodes = len(nodes)&#10;dof = 2 * num_nodes  # Degrees of freedom (x and y for each node)&#10;K_global = np.zeros((dof, dof))&#10;F_global = np.zeros(dof)&#10;&#10;# Material properties (A36 steel)&#10;E = 29000.0  # ksi - Young's modulus&#10;&#10;# Define section properties - now load from YAML if available&#10;if 'sections' in bridge:&#10;    sections = {}&#10;    for section in bridge['sections']:&#10;        sec_id = section['id']&#10;        area_str = str(section['area']).split()[0]  # Extract numeric part&#10;        r_str = str(section['r']).split()[0]        # Extract numeric part&#10;        sections[sec_id] = {&#10;            &quot;area&quot;: float(area_str),&#10;            &quot;r&quot;: float(r_str)&#10;        }&#10;    print(&quot;\nLoaded section properties from YAML:&quot;)&#10;    for sec_id, props in sections.items():&#10;        print(f&quot;  Section {sec_id}: Area = {props['area']} in^2, r = {props['r']} in&quot;)&#10;else:&#10;    # Default section properties if not in YAML&#10;    sections = {&#10;        1: {&quot;area&quot;: 7.65, &quot;r&quot;: 4.32},  # W12x26 - area in in^2, r is radius of gyration in inches&#10;        2: {&quot;area&quot;: 9.13, &quot;r&quot;: 3.47}   # W8x31 - area in in^2, r is radius of gyration in inches&#10;    }&#10;    print(&quot;\nUsing default section properties&quot;)&#10;&#10;# Store member data for later reference&#10;member_data = {}&#10;&#10;# Calculate axial stiffness for each member&#10;print(&quot;\nAssembling stiffness matrix...&quot;)&#10;for member in members:&#10;    member_id = member['id']&#10;    start = member['i_node']&#10;    end = member['j_node']&#10;    section_id = member['section']&#10;&#10;    # Get section properties&#10;    section_area = sections[section_id][&quot;area&quot;]  # in&#10;&#10;    # Calculate EA in kip-in (E in ksi, A in in =&gt; EA in kip)&#10;    EA = E * section_area&#10;&#10;    # Get coordinates&#10;    x1, y1, _ = node_dict[start]&#10;    x2, y2, _ = node_dict[end]&#10;&#10;    # Calculate length in ft&#10;    dx = x2 - x1&#10;    dy = y2 - y1&#10;    length_ft = np.sqrt(dx**2 + dy**2)&#10;&#10;    # Check for zero-length members&#10;    if length_ft &lt; 1e-6:&#10;        print(f&quot;ERROR: Member {member_id} has zero length (nodes {start} to {end})&quot;)&#10;        print(f&quot;  Node {start}: ({x1}, {y1})&quot;)&#10;        print(f&quot;  Node {end}: ({x2}, {y2})&quot;)&#10;        sys.exit(1)&#10;&#10;    length_in = length_ft * 12.0  # Convert to inches&#10;&#10;    # Calculate direction cosines&#10;    cos = dx / length_ft&#10;    sin = dy / length_ft&#10;&#10;    # Store member properties&#10;    member_data[member_id] = {&#10;        &quot;start&quot;: start,&#10;        &quot;end&quot;: end,&#10;        &quot;length_ft&quot;: length_ft,&#10;        &quot;length_in&quot;: length_in,&#10;        &quot;EA&quot;: EA,&#10;        &quot;cos&quot;: cos,&#10;        &quot;sin&quot;: sin,&#10;        &quot;section_id&quot;: section_id,&#10;        &quot;section_area&quot;: section_area&#10;    }&#10;&#10;    # Debug info for first few members&#10;    if member_id &lt;= 3:&#10;        print(f&quot;Member {member_id}: Length = {length_ft:.2f} ft ({length_in:.2f} in), EA = {EA:.2f} kip&quot;)&#10;        print(f&quot;  Direction: cos = {cos:.4f}, sin = {sin:.4f}&quot;)&#10;&#10;    # Local to global transformation matrix&#10;    T = np.array([&#10;        [ cos, sin, 0,   0],&#10;        [-sin, cos, 0,   0],&#10;        [0,   0,   cos, sin],&#10;        [0,   0,  -sin, cos]&#10;    ])&#10;&#10;    # Element stiffness matrix in local coordinates (for a truss element)&#10;    # k = EA/L in kip/in&#10;    k_axial = EA / length_in&#10;&#10;    k_local = np.array([&#10;        [ k_axial, 0, -k_axial, 0],&#10;        [0, 0,  0, 0],&#10;        [-k_axial, 0, k_axial, 0],&#10;        [0, 0,  0, 0]&#10;    ])&#10;&#10;    # Transform to global coordinates&#10;    k_global = T.T @ k_local @ T&#10;    print(f&quot;member id: {member_id}&quot;, k_global, sep=&quot;\n&quot;)&#10;    # Map local DOFs to global DOFs&#10;    dof_start = get_dof(start)&#10;    dof_end = get_dof(end)&#10;    dof_indices = [*dof_start, *dof_end]; print(f&quot;dof_indices: {dof_indices}&quot;)&#10;&#10;    # Assemble into global stiffness matrix&#10;    for i in range(4):&#10;        for j in range(4):&#10;            K_global[dof_indices[i], dof_indices[j]] += k_global[i, j]&#10;&#10;# Apply external forces from member loads&#10;print(&quot;\nApplying loads...&quot;)&#10;if 'member_loads' in bridge:&#10;    for load in bridge['member_loads']:&#10;        member_id = load['member_uid']&#10;        if member_id not in member_data:&#10;            print(f&quot;WARNING: Load references non-existent member {member_id}&quot;)&#10;            continue&#10;&#10;        member = next(m for m in members if m['id'] == member_id)&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        # Convert distributed load to equivalent nodal loads&#10;        wi = float(str(load['wi']).split()[0])  # kips/ft&#10;        wj = float(str(load['wj']).split()[0])  # kips/ft&#10;        length = member_data[member_id][&quot;length_ft&quot;]  # ft&#10;&#10;        # For uniform load, apply half to each node in y-direction&#10;        if abs(wi - wj) &lt; 1e-6:  # Uniform load&#10;            force = abs(wi) * length / 2  # kips (make positive)&#10;            _, dof_yi = get_dof(i_node)&#10;            _, dof_yj = get_dof(j_node)&#10;&#10;            # Debug info for first few loads&#10;            if member_id &lt;= 3:&#10;                print(f&quot;Load on member {member_id}: w = {wi} kips/ft, L = {length:.2f} ft&quot;)&#10;                print(f&quot;  Equivalent nodal forces: {force:.2f} kips (downward) at nodes {i_node} and {j_node}&quot;)&#10;&#10;            # Apply downward forces (negative in typical structural convention)&#10;            F_global[dof_yi] -= force  # Negative for downward&#10;            F_global[dof_yj] -= force  # Negative for downward&#10;        else:&#10;            # For non-uniform load (simplified approach)&#10;            force_i = abs(wi) * length / 3  # kips&#10;            force_j = abs(wj) * length / 3  # kips&#10;            _, dof_yi = get_dof(i_node)&#10;            _, dof_yj = get_dof(j_node)&#10;            F_global[dof_yi] -= force_i  # Negative for downward&#10;            F_global[dof_yj] -= force_j  # Negative for downward&#10;&#10;# Apply support constraints&#10;print(&quot;\nApplying support constraints:&quot;)&#10;constrained_dofs = []&#10;for support in supports:&#10;    node_id = support['node']&#10;    dof_x, dof_y = get_dof(node_id)&#10;&#10;    print(f&quot;Support at node {node_id}: ux={support['ux']}, uy={support['uy']}&quot;)&#10;&#10;    if support['ux'] == 1:  # Fixed in x-direction&#10;        constrained_dofs.append(dof_x)&#10;        K_global[dof_x, :] = 0&#10;        K_global[:, dof_x] = 0&#10;        K_global[dof_x, dof_x] = 1&#10;        F_global[dof_x] = 0&#10;&#10;    if support['uy'] == 1:  # Fixed in y-direction&#10;        constrained_dofs.append(dof_y)&#10;        K_global[dof_y, :] = 0&#10;        K_global[:, dof_y] = 0&#10;        K_global[dof_y, dof_y] = 1&#10;        F_global[dof_y] = 0&#10;&#10;print(f&quot;Total constrained DOFs: {len(constrained_dofs)}&quot;)&#10;print(f&quot;Free DOFs: {dof - len(constrained_dofs)}&quot;)&#10;&#10;# Check for zero diagonal elements (indicates singularity)&#10;diag_zeros = np.where(np.abs(np.diag(K_global)) &lt; 1e-10)[0]&#10;if len(diag_zeros) &gt; 0:&#10;    print(f&quot;\nWARNING: Zero diagonal elements detected at DOFs: {diag_zeros}&quot;)&#10;    for dof_idx in diag_zeros:&#10;        node_id = dof_idx // 2 + 1&#10;        dof_type = &quot;x&quot; if dof_idx % 2 == 0 else &quot;y&quot;&#10;        print(f&quot;  Node {node_id}, direction {dof_type}&quot;)&#10;&#10;        # Check if this DOF is connected to any members&#10;        connected_members = []&#10;        for mem_id, mem_data in member_data.items():&#10;            if mem_data[&quot;start&quot;] == node_id or mem_data[&quot;end&quot;] == node_id:&#10;                connected_members.append(mem_id)&#10;        print(f&quot;    Connected to members: {connected_members}&quot;)&#10;&#10;# Check if the stiffness matrix is symmetric (it should be)&#10;is_symmetric = np.allclose(K_global, K_global.T, rtol=1e-5, atol=1e-8)&#10;print(f&quot;\nStiffness matrix is symmetric: {is_symmetric}&quot;)&#10;&#10;# Analyze the condition of the matrix&#10;try:&#10;    # Compute the condition number&#10;    cond = np.linalg.cond(K_global)&#10;    print(f&quot;Condition number of stiffness matrix: {cond:.2e}&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        print(&quot;\nWARNING: Very high condition number detected!&quot;)&#10;        print(&quot;The structure may have:&quot;)&#10;        print(&quot;1. Duplicate nodes at the same location&quot;)&#10;        print(&quot;2. Insufficient supports (mechanism)&quot;)&#10;        print(&quot;3. Disconnected parts&quot;)&#10;        print(&quot;4. Numerical scaling issues&quot;)&#10;&#10;        # Find the ratio between max and min non-zero diagonal elements&#10;        diag = np.abs(np.diag(K_global))&#10;        nonzero_diag = diag[diag &gt; 1e-10]&#10;        if len(nonzero_diag) &gt; 0:&#10;            diag_ratio = np.max(nonzero_diag) / np.min(nonzero_diag)&#10;            print(f&quot;\nDiagonal scaling ratio: {diag_ratio:.2e}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;Could not compute condition number: {e}&quot;)&#10;    cond = float('inf')&#10;&#10;# Apply scaling to improve conditioning&#10;print(&quot;\nAttempting to solve the system...&quot;)&#10;try:&#10;    # Use a more robust solver from scipy&#10;    from scipy import linalg&#10;&#10;    # For very ill-conditioned systems, try regularization&#10;    if cond &gt; 1e14:&#10;        print(&quot;System is extremely ill-conditioned. Applying regularization...&quot;)&#10;        # Add small diagonal perturbation to improve conditioning&#10;        reg_factor = 1e-8 * np.max(np.abs(np.diag(K_global)))&#10;        K_regularized = K_global + reg_factor * np.eye(dof)&#10;&#10;        try:&#10;            displacements = linalg.solve(K_regularized, F_global, assume_a='sym')&#10;            print(&quot;Regularized solution successful&quot;)&#10;        except:&#10;            # Fall back to least squares&#10;            displacements, residuals, rank, s = linalg.lstsq(K_global, F_global)&#10;            print(f&quot;Least squares solution: rank={rank}/{dof}&quot;)&#10;    else:&#10;        # Try direct solution&#10;        displacements = linalg.solve(K_global, F_global, assume_a='sym')&#10;        print(&quot;Direct solution successful&quot;)&#10;&#10;    # Convert displacements from inches to feet for consistency&#10;    # Actually, the displacements are already in feet since we used consistent units&#10;&#10;    # Print first few displacement values for debugging&#10;    print(&quot;\nNodal displacements:&quot;)&#10;    print(&quot;Node | dx (in) | dy (in)&quot;)&#10;    print(&quot;-&quot; * 30)&#10;    for i in range(1, min(11, num_nodes + 1)):&#10;        dof_x, dof_y = get_dof(i)&#10;        # Convert to inches for display&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        print(f&quot;{i:4} | {dx_in:7.4f} | {dy_in:7.4f}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;All solution methods failed: {e}&quot;)&#10;    print(&quot;Using zero displacements as fallback&quot;)&#10;    displacements = np.zeros(dof)&#10;&#10;# Find maximum vertical displacement&#10;max_vert_disp = 0&#10;max_disp_node = None&#10;for node_id in node_dict:&#10;    _, dof_y = get_dof(node_id)&#10;    # Skip nodes that are supported&#10;    is_supported = any(s['node'] == node_id and s['uy'] == 1 for s in supports)&#10;    if not is_supported:&#10;        disp = abs(displacements[dof_y])&#10;        if disp &gt; max_vert_disp:&#10;            max_vert_disp = disp&#10;            max_disp_node = node_id&#10;&#10;# Convert to inches for display&#10;max_vert_disp_in = max_vert_disp * 12&#10;print(f&quot;\nMaximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}&quot;)&#10;&#10;# Calculate member forces&#10;member_forces = {}&#10;member_stresses = {}&#10;&#10;# Material properties (A36 steel)&#10;Fy = 36.0    # ksi - Yield strength&#10;Fu = 58.0    # ksi - Ultimate strength&#10;safety_factor_tension = 1.67&#10;safety_factor_compression = 1.67&#10;allowable_tension_stress = Fy / safety_factor_tension      # ksi&#10;allowable_compression_stress_max = Fy / safety_factor_compression  # ksi&#10;&#10;# Calculate forces and stresses for each member&#10;for member in members:&#10;    member_id = member['id']&#10;    if member_id not in member_data:&#10;        continue  # Skip members with zero length&#10;&#10;    mem_data = member_data[member_id]&#10;    start = mem_data[&quot;start&quot;]&#10;    end = mem_data[&quot;end&quot;]&#10;    area = mem_data[&quot;section_area&quot;]  # in&#10;    cos = mem_data[&quot;cos&quot;]&#10;    sin = mem_data[&quot;sin&quot;]&#10;&#10;    # Get displacements at both nodes (in feet)&#10;    dof_x1, dof_y1 = get_dof(start)&#10;    dof_x2, dof_y2 = get_dof(end)&#10;&#10;    # Calculate relative displacement in the axial direction (in feet)&#10;    delta_u1 = displacements[dof_x1] * cos + displacements[dof_y1] * sin&#10;    delta_u2 = displacements[dof_x2] * cos + displacements[dof_y2] * sin&#10;    delta_axial = delta_u2 - delta_u1&#10;&#10;    # Convert to inches for force calculation&#10;    delta_axial_in = delta_axial * 12&#10;&#10;    # Calculate axial force (F = EA/L * delta)&#10;    EA = mem_data[&quot;EA&quot;]  # kip&#10;    force = (EA / mem_data[&quot;length_in&quot;]) * delta_axial_in  # kips&#10;    member_forces[member_id] = force&#10;&#10;    # Calculate axial stress&#10;    stress = force / area  # kips/in = ksi&#10;    member_stresses[member_id] = stress&#10;&#10;    # Debug output for the first few members&#10;    if member_id &lt;= 3 or member_id == 32:&#10;        print(f&quot;\nMember {member_id} analysis:&quot;)&#10;        print(f&quot;  Length = {mem_data['length_ft']:.2f} ft&quot;)&#10;        print(f&quot;  Node {start}: dx = {displacements[dof_x1]*12:.4f} in, dy = {displacements[dof_y1]*12:.4f} in&quot;)&#10;        print(f&quot;  Node {end}: dx = {displacements[dof_x2]*12:.4f} in, dy = {displacements[dof_y2]*12:.4f} in&quot;)&#10;        print(f&quot;  Delta axial = {delta_axial_in:.4f} in&quot;)&#10;        print(f&quot;  Force = {force:.2f} kips&quot;)&#10;        print(f&quot;  Stress = {stress:.2f} ksi&quot;)&#10;&#10;# Calculate safety factors for all members&#10;member_safety_factors = {}&#10;member_status = {}&#10;&#10;# Define zero force threshold&#10;ZERO_FORCE_THRESHOLD = 0.1  # Consider forces below this threshold as &quot;zero&quot;&#10;&#10;# Replace the problematic part in the safety factors calculation&#10;for member_id, stress in member_stresses.items():&#10;    section_id = member_data[member_id][&quot;section_id&quot;]&#10;    section = sections[section_id]&#10;&#10;    if abs(stress) &lt; ZERO_FORCE_THRESHOLD / section[&quot;area&quot;]:&#10;        # Zero/near-zero stress&#10;        safety_factor = float('inf')&#10;        limit = allowable_tension_stress  # Arbitrary for zero-force members&#10;        status = &quot;OK&quot;&#10;    elif stress &gt;= 0:  # Tension&#10;        safety_factor = allowable_tension_stress / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_tension_stress&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;    else:  # Compression&#10;        # Calculate allowable compression stress based on slenderness&#10;        length_inches = member_data[member_id][&quot;length_in&quot;]&#10;        slenderness = length_inches / section[&quot;r&quot;]&#10;&#10;        if slenderness &gt; 100:  # For slender members&#10;            critical_stress = (np.pi**2 * E) / (slenderness**2)&#10;            allowable_compression = min(allowable_compression_stress_max, critical_stress/safety_factor_compression)&#10;        else:  # For stocky members&#10;            allowable_compression = allowable_compression_stress_max&#10;&#10;        safety_factor = allowable_compression / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_compression&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;&#10;    member_safety_factors[member_id] = safety_factor&#10;    member_status[member_id] = {&#10;        &quot;stress&quot;: stress,&#10;        &quot;allowable&quot;: limit,&#10;        &quot;safety_factor&quot;: safety_factor,&#10;        &quot;status&quot;: status&#10;    }&#10;&#10;# After calculating safety factors, add a summary of members below minimum&#10;members_below_min_sf = []&#10;for member_id, status_info in member_status.items():&#10;    if status_info[&quot;safety_factor&quot;] &lt; min_safety_factor and status_info[&quot;safety_factor&quot;] &lt; 100:&#10;        members_below_min_sf.append({&#10;            'id': member_id,&#10;            'sf': status_info[&quot;safety_factor&quot;],&#10;            'stress': status_info[&quot;stress&quot;],&#10;            'allowable': status_info[&quot;allowable&quot;]&#10;        })&#10;&#10;if members_below_min_sf:&#10;    print(f&quot;\n{len(members_below_min_sf)} members have safety factor below {min_safety_factor}:&quot;)&#10;    for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:10]:  # Show worst 10&#10;        print(f&quot;  Member {mem['id']}: SF = {mem['sf']:.2f}, Stress = {abs(mem['stress']):.1f} ksi&quot;)&#10;&#10;# Create figure for the PDF - add timestamp to filenames&#10;timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M%S')&#10;pdf_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_Analysis_{timestamp}.pdf&quot;)&#10;text_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_Analysis_{timestamp}.txt&quot;)&#10;&#10;# Open the text file for writing the report&#10;with open(text_filename, 'w') as txt_report:&#10;    # Write header information&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(&quot;PRATT BRIDGE STRUCTURAL ANALYSIS REPORT\n&quot;)&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(f&quot;Analysis Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}\n&quot;)&#10;    txt_report.write(f&quot;Input File: {bridge_file}\n&quot;)&#10;    txt_report.write(f&quot;Design Minimum Safety Factor: {min_safety_factor}\n\n&quot;)&#10;&#10;    # Write model statistics&#10;    txt_report.write(&quot;MODEL STATISTICS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Number of nodes: {num_nodes}\n&quot;)&#10;    txt_report.write(f&quot;Number of members: {len(members)}\n&quot;)&#10;    txt_report.write(f&quot;Number of supports: {len(supports)}\n&quot;)&#10;    txt_report.write(f&quot;Degrees of freedom: {dof}\n&quot;)&#10;    txt_report.write(f&quot;Constrained DOFs: {len(constrained_dofs)}\n&quot;)&#10;    txt_report.write(f&quot;Free DOFs: {dof - len(constrained_dofs)}\n\n&quot;)&#10;&#10;    # Write material properties&#10;    txt_report.write(&quot;MATERIAL PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Material: A36 Steel\n&quot;)&#10;    txt_report.write(f&quot;Young's modulus: {E} ksi\n&quot;)&#10;    txt_report.write(f&quot;Yield strength: {Fy} ksi\n&quot;)&#10;    txt_report.write(f&quot;Ultimate strength: {Fu} ksi\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (tension): {safety_factor_tension}\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (compression): {safety_factor_compression}\n\n&quot;)&#10;&#10;    # Write section properties&#10;    txt_report.write(&quot;SECTION PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    for sec_id, props in sections.items():&#10;        txt_report.write(f&quot;Section {sec_id}: Area = {props['area']} in, r = {props['r']} in\n&quot;)&#10;    txt_report.write(&quot;\n&quot;)&#10;&#10;    # Write analysis results summary&#10;    txt_report.write(&quot;ANALYSIS RESULTS SUMMARY\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Maximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}\n&quot;)&#10;&#10;    # Calculate critical values&#10;    critical_sf = float('inf')&#10;    critical_member = None&#10;    overstressed_count = 0&#10;    for member_id, status_info in member_status.items():&#10;        sf = status_info[&quot;safety_factor&quot;]&#10;        if sf &lt; critical_sf and sf &lt; 100:&#10;            critical_sf = sf&#10;            critical_member = member_id&#10;        if status_info[&quot;status&quot;] == &quot;OVERSTRESSED&quot;:&#10;            overstressed_count += 1&#10;&#10;    txt_report.write(f&quot;Number of tension members: {sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of compression members: {sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of zero-force members: {sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Overstressed members: {overstressed_count}\n&quot;)&#10;    txt_report.write(f&quot;Maximum member force: {max(abs(f) for f in member_forces.values()):.2f} kips\n&quot;)&#10;    txt_report.write(f&quot;Maximum member stress: {max(abs(s) for s in member_stresses.values()):.2f} ksi\n&quot;)&#10;    txt_report.write(f&quot;Minimum safety factor: {critical_sf:.2f} (Member #{critical_member})\n\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;WARNING: High condition number indicates numerical instability.\n&quot;)&#10;        txt_report.write(&quot;The structure may have:\n&quot;)&#10;        txt_report.write(&quot;1. Duplicate nodes at the same location\n&quot;)&#10;        txt_report.write(&quot;2. Insufficient supports (mechanism)\n&quot;)&#10;        txt_report.write(&quot;3. Disconnected parts\n&quot;)&#10;        txt_report.write(&quot;4. Numerical scaling issues\n\n&quot;)&#10;&#10;    # Write detailed member results&#10;    txt_report.write(&quot;DETAILED MEMBER RESULTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Member | Nodes (i-j) | Force (kips) | Stress (ksi) | Type | S.F. | Status\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 80 + &quot;\n&quot;)&#10;&#10;    for member in sorted(members, key=lambda m: m['id']):&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;        stress = member_stresses[member_id]&#10;        sf = member_safety_factors[member_id]&#10;        status = member_status[member_id][&quot;status&quot;]&#10;&#10;        # Fix the text report formatting to use only ASCII&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            force_type = &quot;ZERO&quot;&#10;            sf_text = &quot;inf&quot;&#10;        elif force &gt; 0:&#10;            force_type = &quot;TENSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;        else:&#10;            force_type = &quot;COMPRESSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;&#10;        txt_report.write(&#10;            f&quot;{member_id:6} | {i_node:2}-{j_node:&lt;2} | {abs(force):11.2f} | {abs(stress):10.2f} | {force_type:10} | {sf_text:&gt;5} | {status}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;&#10;    # Write nodal displacements&#10;    txt_report.write(&quot;NODAL DISPLACEMENTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Node | dx (inches) | dy (inches)\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 35 + &quot;\n&quot;)&#10;&#10;    for node_id in sorted(node_dict.keys()):&#10;        dof_x, dof_y = get_dof(node_id)&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        txt_report.write(f&quot;{node_id:4} | {dx_in:11.4f} | {dy_in:11.4f}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;    txt_report.write(&quot;RECOMMENDATIONS FOR STRUCTURE REFINEMENT\n&quot;)&#10;    txt_report.write(&quot;----------------------------------------\n&quot;)&#10;&#10;    if members_below_min_sf:&#10;        txt_report.write(f&quot;1. {len(members_below_min_sf)} members have safety factor below the design minimum of {min_safety_factor}:\n&quot;)&#10;        for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:20]:  # Show worst 20&#10;            member = next(m for m in members if m['id'] == mem['id'])&#10;            txt_report.write(f&quot;   - Member {mem['id']} (nodes {member['i_node']}-{member['j_node']}): SF = {mem['sf']:.2f}\n&quot;)&#10;&#10;        # Calculate required section increase&#10;        worst_sf = min(mem['sf'] for mem in members_below_min_sf)&#10;        required_increase = min_safety_factor / worst_sf&#10;        txt_report.write(f&quot;\n   Worst member requires approximately {required_increase:.1f}x increase in capacity.\n&quot;)&#10;        txt_report.write(f&quot;   Consider using larger sections or reducing the loading.\n&quot;)&#10;    else:&#10;        txt_report.write(&quot;1. All members meet the minimum safety factor requirement.\n&quot;)&#10;        txt_report.write(&quot;   Consider optimizing the structure by reducing sections for members with high safety factors.\n&quot;)&#10;&#10;    if max_vert_disp_in &gt; 2.0:  # Assuming 2 inches as a reasonable deflection limit&#10;        txt_report.write(f&quot;2. Consider stiffening the structure to reduce the maximum deflection (currently {max_vert_disp_in:.4f} inches).\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;3. Fix numerical stability issues by reviewing structure connectivity and supports.\n&quot;)&#10;&#10;    txt_report.write(&quot;\nReport generated by pyMAOS Truss Analysis Tool\n&quot;)&#10;&#10;print(f&quot;Text report saved to: {text_filename}&quot;)&#10;&#10;with PdfPages(pdf_filename) as pdf:&#10;    # 1. BRIDGE ANALYSIS SUMMARY page&#10;    fig = plt.figure(figsize=(8.5, 11))&#10;    plt.axis('off')&#10;&#10;    # Add overall bridge status text - avoid using unicode characters&#10;    if overstressed_count == 0:&#10;        status_text = &quot;BRIDGE IS STRUCTURALLY ADEQUATE&quot;&#10;        status_color = 'green'&#10;    else:&#10;        status_text = f&quot;WARNING: BRIDGE HAS {overstressed_count} OVERSTRESSED MEMBERS&quot;&#10;        status_color = 'red'&#10;&#10;    plt.figtext(0.5, 0.9, &quot;BRIDGE ANALYSIS SUMMARY&quot;, ha='center', fontsize=16, weight='bold')&#10;    plt.figtext(0.5, 0.85, status_text, ha='center', fontsize=14, weight='bold', color=status_color)&#10;&#10;    # Add displacement information&#10;    plt.figtext(0.5, 0.78, f&quot;Maximum Vertical Displacement: {max_vert_disp_in:.4f} inches at Node {max_disp_node}&quot;,&#10;                ha='center', fontsize=12)&#10;&#10;    # Add summary statistics&#10;    critical_text = f&quot;Most critical member: #{critical_member} (Safety Factor: {critical_sf:.2f})&quot;&#10;    plt.figtext(0.5, 0.73, critical_text, ha='center', fontsize=12)&#10;&#10;    # Add a summary table of key statistics&#10;    summary_data = [&#10;        [&quot;Total Members&quot;, f&quot;{len(members)}&quot;],&#10;        [&quot;Tension Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Compression Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Zero-Force Members&quot;, f&quot;{sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Overstressed Members&quot;, f&quot;{overstressed_count}&quot;],&#10;        [&quot;Maximum Member Force&quot;, f&quot;{max(abs(f) for f in member_forces.values()):.2f} kips&quot;],&#10;        [&quot;Maximum Member Stress&quot;, f&quot;{max(abs(s) for s in member_stresses.values()):.2f} ksi&quot;],&#10;        [&quot;Minimum Safety Factor&quot;, f&quot;{critical_sf:.2f}&quot;],&#10;        [&quot;Maximum Displacement&quot;, f&quot;{max_vert_disp_in:.4f} inches&quot;],&#10;    ]&#10;&#10;    # Create a table in the middle of the page&#10;    ax = plt.subplot(111)&#10;    ax.axis('off')&#10;    tbl = plt.table(cellText=summary_data, colLabels=[&quot;Metric&quot;, &quot;Value&quot;],&#10;                    loc='center', cellLoc='left')&#10;    tbl.auto_set_font_size(False)&#10;    tbl.set_fontsize(10)&#10;    tbl.scale(1, 1.5)&#10;&#10;    # Add design criteria info&#10;    criteria = (&#10;        f&quot;Design Criteria:\n&quot;&#10;        f&quot;- Material: A36 Steel (Fy = 36 ksi)\n&quot;&#10;        f&quot;- Allowable tension stress: {allowable_tension_stress:.1f} ksi\n&quot;&#10;        f&quot;- Allowable compression stress: Based on member slenderness\n&quot;&#10;        f&quot;- Safety factor: {safety_factor_tension:.2f}&quot;&#10;    )&#10;    plt.figtext(0.5, 0.2, criteria, ha='center', fontsize=10,&#10;                bbox=dict(facecolor='#eeeeee', alpha=0.7, boxstyle='round,pad=0.5'))&#10;&#10;    # Add timestamp&#10;    plt.figtext(0.5, 0.1, f&quot;Analysis completed on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    # Save the summary page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 2. Reliability Analysis - Safety Factors plot&#10;    fig, ax = plt.subplots(figsize=(11, 8.5))  # Changed to landscape orientation&#10;&#10;    # Use plt.colormaps instead of cm.get_cmap to avoid deprecation warning&#10;    cmap = plt.colormaps['RdYlGn']  # Red-Yellow-Green colormap&#10;    norm = plt.Normalize(0.5, 2.0)&#10;&#10;    # Plot members with color based on safety factors&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        safety_factor = member_safety_factors[member_id]&#10;        safety_factor_capped = min(safety_factor, 5.0)  # Cap extremely high values for visualization&#10;&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        x = [x1, x2]&#10;        y = [y1, y2]&#10;&#10;        color = cmap(norm(safety_factor_capped))&#10;        linewidth = 3  # Consistent line width&#10;&#10;        ax.plot(x, y, color=color, linewidth=linewidth)&#10;&#10;        # Add safety factor label at midpoint&#10;        mid_x = (x1 + x2) / 2&#10;        mid_y = (y1 + y2) / 2&#10;&#10;        # Format infinity as &quot;&quot;&#10;        sf_text = &quot;&quot; if safety_factor &gt; 100 else f&quot;{safety_factor:.1f}&quot;&#10;&#10;        ax.text(mid_x, mid_y, sf_text,&#10;                fontsize=6, ha='center', va='center',&#10;                bbox=dict(facecolor='white', alpha=0.7, pad=1))&#10;&#10;    # Plot nodes and supports&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        ax.plot(x, y, 'ko', markersize=5)&#10;        ax.text(x+1, y+1, f&quot;{node_id}&quot;, fontsize=7)&#10;&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, _ = node_dict[node_id]&#10;        if support['ux'] == 1 and support['uy'] == 1:&#10;            ax.plot(x, y-2, 'ks', markersize=8)&#10;        elif support['ux'] == 0 and support['uy'] == 1:&#10;            ax.plot(x, y-2, 'ko', markersize=8)&#10;&#10;    # Add a colorbar&#10;    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)&#10;    sm.set_array([])&#10;    cbar = plt.colorbar(sm, ax=ax, label='Safety Factor', shrink=0.8)&#10;    cbar.set_ticks([0.5, 1.0, 1.5, 2.0])&#10;    cbar.set_ticklabels(['0.5', '1.0 (Limit)', '1.5', ' 2.0'])&#10;&#10;    # Set plot limits and labels&#10;    max_x = max(node_dict[n][0] for n in node_dict)&#10;    max_y = max(node_dict[n][1] for n in node_dict)&#10;    ax.set_xlim(-5, max_x + 15)&#10;    ax.set_ylim(-5, max_y + 5)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;    ax.set_title('Pratt Truss Bridge Reliability Analysis - Safety Factors', fontsize=12)&#10;    ax.grid(True)&#10;    plt.tight_layout(pad=2.0, rect=[0, 0, 1, 0.95])&#10;&#10;    # Save the safety factor visualization to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 3. Member Forces Summary Tables (split across pages) with node IDs&#10;    rows_per_page = 20  # Adjust as needed&#10;    all_members = sorted(members, key=lambda m: m['id'])&#10;    member_chunks = [all_members[i:i+rows_per_page] for i in range(0, len(all_members), rows_per_page)]&#10;&#10;    for page_idx, member_chunk in enumerate(member_chunks):&#10;        fig = plt.figure(figsize=(8.5, 11))&#10;        gs = gridspec.GridSpec(1, 1)&#10;        ax = plt.subplot(gs[0])&#10;        ax.axis('tight')&#10;        ax.axis('off')&#10;&#10;        # Create summary data for this chunk&#10;        table_data = []&#10;        table_data.append(['Member', 'Nodes (i-j)', 'Force (kips)', 'Type'])&#10;&#10;        for member in member_chunk:&#10;            member_id = member['id']&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;            force = member_forces[member_id]&#10;&#10;            if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;                force_type = &quot;ZERO&quot;&#10;            elif force &gt; 0:&#10;                force_type = &quot;TENSION&quot;&#10;            else:&#10;                force_type = &quot;COMPRESSION&quot;&#10;&#10;            table_data.append([str(member_id), f&quot;{i_node}-{j_node}&quot;, f&quot;{abs(force):.2f}&quot;, force_type])&#10;&#10;        # Create table with smaller font&#10;        table = ax.table(cellText=table_data, loc='center', cellLoc='center')&#10;        table.auto_set_font_size(False)&#10;        table.set_fontsize(8)&#10;        table.scale(1, 1.4)&#10;&#10;        # Add title with page number but more space at the top&#10;        plt.title(f&quot;Member Forces Summary (Page {page_idx+1} of {len(member_chunks)})&quot;,&#10;                  fontsize=14, y=0.98, pad=20)&#10;&#10;        # Add metadata&#10;        plt.figtext(0.5, 0.03,&#10;                    f&quot;Pratt Bridge Analysis - Generated on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                    ha='center', fontsize=6)&#10;&#10;        # Save the page to PDF&#10;        pdf.savefig(fig)&#10;        plt.close(fig)&#10;&#10;    # 4. Member Forces plot&#10;    fig, ax = plt.subplots(figsize=(11, 8.5))  # Changed to landscape orientation&#10;&#10;    # Plot members with color based on tension/compression/zero&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;&#10;        # Find the coordinates for both nodes&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        x = [x1, x2]&#10;        y = [y1, y2]&#10;&#10;        # Color: red for tension, blue for compression, black for zero/near-zero&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            color = 'black'  # Zero force&#10;            linestyle = '-'&#10;            linewidth = 1.5&#10;        elif force &gt; 0:&#10;            color = 'red'  # Tension&#10;            linestyle = '-'&#10;            linewidth = 2 + min(5, abs(force)/100)  # Scale width with force magnitude&#10;        else:&#10;            color = 'blue'  # Compression&#10;            linestyle = '-'&#10;            linewidth = 2 + min(5, abs(force)/100)  # Scale width with force magnitude&#10;&#10;        # Plot the member&#10;        ax.plot(x, y, color=color, linestyle=linestyle, linewidth=linewidth)&#10;&#10;        # Add force label at midpoint - reduced font size&#10;        mid_x = (x1 + x2) / 2&#10;        mid_y = (y1 + y2) / 2&#10;        ax.text(mid_x, mid_y, f&quot;{abs(force):.1f}&quot;,&#10;                fontsize=6, ha='center', va='center',&#10;                bbox=dict(facecolor='white', alpha=0.7, pad=1))&#10;&#10;    # Plot nodes&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        ax.plot(x, y, 'ko', markersize=6)&#10;        ax.text(x+1, y+1, f&quot;{node_id}&quot;, fontsize=7)&#10;&#10;    # Plot supports&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, _ = node_dict[node_id]&#10;&#10;        # Different markers for different support types&#10;        if support['ux'] == 1 and support['uy'] == 1:&#10;            # Pinned support - triangle&#10;            ax.plot(x, y-2, 'ks', markersize=10)&#10;        elif support['ux'] == 0 and support['uy'] == 1:&#10;            # Roller support - circle&#10;            ax.plot(x, y-2, 'ko', markersize=10)&#10;&#10;    # Add legend&#10;    red_line = plt.Line2D([0], [0], color='red', linewidth=3, label='Tension')&#10;    blue_line = plt.Line2D([0], [0], color='blue', linewidth=3, label='Compression')&#10;    black_line = plt.Line2D([0], [0], color='black', linewidth=2, label='Zero Force')&#10;    ax.legend(handles=[red_line, blue_line, black_line], loc='upper right', fontsize=8)&#10;&#10;    # Set plot limits and labels&#10;    ax.set_xlim(-5, max_x + 15)  # Extra space on right for labels&#10;    ax.set_ylim(-5, max_y + 5)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;    ax.set_title('Pratt Truss Bridge Analysis - Member Forces', fontsize=12)&#10;    ax.grid(True)&#10;&#10;    # Use tight_layout with adjusted parameters&#10;    plt.tight_layout(pad=2.0, rect=[0, 0, 1, 0.95])&#10;&#10;    # Save the member forces plot to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 5. Displacement visualization&#10;    fig, ax = plt.subplots(figsize=(12, 9))  # Increased figure size for better visibility&#10;&#10;    # Draw original structure in light gray&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        ax.plot([x1, x2], [y1, y2], color='lightgray', linestyle='-', linewidth=1, alpha=0.5)&#10;&#10;    # Calculate max displacement for proper scaling&#10;    max_disp_magnitude = 0&#10;    for node_id in node_dict:&#10;        dof_x, dof_y = get_dof(node_id)&#10;        disp_magnitude = np.sqrt(displacements[dof_x]**2 + displacements[dof_y]**2)&#10;        max_disp_magnitude = max(max_disp_magnitude, disp_magnitude)&#10;&#10;    # More reasonable scale factor - aim for approximately 5-10% of bridge span&#10;    max_span = max(node_dict[n][0] for n in node_dict) - min(node_dict[n][0] for n in node_dict)&#10;    bridge_height = max(node_dict[n][1] for n in node_dict) - min(node_dict[n][1] for n in node_dict)&#10;    target_max_disp = min(max_span, bridge_height) * 0.05  # More conservative scaling&#10;&#10;    # Calculate scale factor (with protection against division by zero)&#10;    if max_disp_magnitude &gt; 1e-10:&#10;        scale_factor = target_max_disp / max_disp_magnitude&#10;        # Ensure scale factor is rounded to a clean number for display&#10;        scale_magnitude = 10 ** int(np.log10(scale_factor))&#10;        scale_factor = round(scale_factor / scale_magnitude) * scale_magnitude&#10;    else:&#10;        scale_factor = 50.0  # Default if displacements are effectively zero&#10;&#10;    # Print debug info for node 12 (central top chord)&#10;    if 12 in node_dict:&#10;        dof_x12, dof_y12 = get_dof(12)&#10;        print(f&quot;\nDebug - Node 12 displacement:&quot;)&#10;        print(f&quot;  Original position: ({node_dict[12][0]}, {node_dict[12][1]})&quot;)&#10;        print(f&quot;  Displacement: dx={displacements[dof_x12]*12:.6f} in, dy={displacements[dof_y12]*12:.6f} in&quot;)&#10;        print(f&quot;  Scaled displacement: dx={displacements[dof_x12]*scale_factor:.4f} ft, dy={displacements[dof_y12]*scale_factor:.4f} ft&quot;)&#10;&#10;    # Precalculate the max and min coordinates after displacement to ensure proper plot limits&#10;    min_x_disp = float('inf')&#10;    min_y_disp = float('inf')&#10;    max_x_disp = float('-inf')&#10;    max_y_disp = float('-inf')&#10;&#10;    # First pass - calculate extents of displaced structure&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        dof_x, dof_y = get_dof(node_id)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;&#10;        min_x_disp = min(min_x_disp, x_new)&#10;        min_y_disp = min(min_y_disp, y_new)&#10;        max_x_disp = max(max_x_disp, x_new)&#10;        max_y_disp = max(max_y_disp, y_new)&#10;&#10;    # Draw displaced structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;&#10;        # Get displacements&#10;        dof_x1, dof_y1 = get_dof(i_node)&#10;        dof_x2, dof_y2 = get_dof(j_node)&#10;&#10;        # Apply displacements&#10;        x1_new = x1 + displacements[dof_x1] * scale_factor&#10;        y1_new = y1 + displacements[dof_y1] * scale_factor&#10;        x2_new = x2 + displacements[dof_x2] * scale_factor&#10;        y2_new = y2 + displacements[dof_y2] * scale_factor&#10;&#10;        # Draw displaced member&#10;        ax.plot([x1_new, x2_new], [y1_new, y2_new], color='blue', linestyle='-', linewidth=1.5)&#10;&#10;        # Add small markers at displaced node positions for clarity&#10;        ax.plot(x1_new, y1_new, 'b.', markersize=4)&#10;        ax.plot(x2_new, y2_new, 'b.', markersize=4)&#10;&#10;    # Highlight the node with maximum displacement - directly on the plot without a box&#10;    if max_disp_node:&#10;        x, y, _ = node_dict[max_disp_node]&#10;        dof_x, dof_y = get_dof(max_disp_node)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;&#10;        # Use a more visible marker directly on the plot&#10;        ax.plot(x_new, y_new, 'ro', markersize=8)&#10;&#10;        # Add the label directly at the node with smaller text and no box&#10;        label_x = x_new + 0.03 * max_span&#10;        label_y = y_new + 0.02 * max_span&#10;        ax.text(label_x, label_y, f&quot;Node {max_disp_node}: {max_vert_disp_in:.2f} in&quot;,&#10;                fontsize=8, color='red', ha='left', va='bottom',&#10;                path_effects=[plt.matplotlib.patheffects.withStroke(linewidth=3, foreground='white')])&#10;&#10;    # Add legend&#10;    orig = plt.Line2D([0], [0], color='lightgray', linestyle='-', linewidth=1, alpha=0.5, label='Original Structure')&#10;    disp = plt.Line2D([0], [0], color='blue', linestyle='-', linewidth=1.5, label='Displaced Structure')&#10;    ax.legend(handles=[orig, disp], loc='upper right', fontsize=8)&#10;&#10;    # Set plot limits to ensure complete structure visibility, with additional padding&#10;    min_x = min(node_dict[n][0] for n in node_dict)&#10;    min_y = min(node_dict[n][1] for n in node_dict)&#10;    max_x = max(node_dict[n][0] for n in node_dict)&#10;    max_y = max(node_dict[n][1] for n in node_dict)&#10;&#10;    # Ensure we include both original and displaced structures with padding&#10;    plot_min_x = min(min_x, min_x_disp) - 0.1 * max_span&#10;    plot_min_y = min(min_y, min_y_disp) - 0.15 * bridge_height&#10;    plot_max_x = max(max_x, max_x_disp) + 0.1 * max_span&#10;    plot_max_y = max(max_y, max_y_disp) + 0.1 * bridge_height&#10;&#10;    ax.set_xlim(plot_min_x, plot_max_x)&#10;    ax.set_ylim(plot_min_y, plot_max_y)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;&#10;    # Format scale factor nicely&#10;    if scale_factor &gt;= 1000:&#10;        scale_factor_text = f&quot;{scale_factor/1000:.1f}k&quot;&#10;    elif scale_factor &gt;= 100:&#10;        scale_factor_text = f&quot;{int(scale_factor)}&quot;&#10;    else:&#10;        scale_factor_text = f&quot;{scale_factor:.1f}&quot;&#10;&#10;    ax.set_title(f'Pratt Truss Bridge - Displacement Analysis (Scale Factor: {scale_factor_text})', fontsize=12)&#10;&#10;    # Add note about displacement scale&#10;    plt.figtext(0.5, 0.01,&#10;                f&quot;Note: Displacements are scaled by a factor of {scale_factor_text} for visibility. &quot;&#10;                f&quot;Actual maximum displacement: {max_vert_disp_in:.4f} inches.&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    ax.grid(True)&#10;    plt.tight_layout(pad=2.0, rect=[0, 0.02, 1, 0.98])&#10;&#10;    # Save the displacement page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # Add PDF metadata&#10;    d = pdf.infodict()&#10;    d['Title'] = 'Pratt Bridge Structural Analysis'&#10;    d['Author'] = 'pyMAOS Truss Analysis Tool'&#10;    d['Subject'] = 'Structural analysis and reliability assessment'&#10;    d['Keywords'] = 'truss, structural analysis, bridge, reliability'&#10;    d['CreationDate'] = datetime.datetime.now()&#10;    d['ModDate'] = datetime.datetime.now()&#10;&#10;# Print summary of results to console&#10;print(&quot;\nMember Forces Summary:&quot;)&#10;print(&quot;----------------------&quot;)&#10;print(&quot;Member | Force (kips) | Type&quot;)&#10;print(&quot;----------------------&quot;)&#10;for member in sorted(members, key=lambda m: m['id']):&#10;    member_id = member['id']&#10;    force = member_forces[member_id]&#10;    if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;        force_type = &quot;ZERO&quot;&#10;    elif force &gt; 0:&#10;        force_type = &quot;TENSION&quot;&#10;    else:&#10;        force_type = &quot;COMPRESSION&quot;&#10;    print(f&quot;{member_id:6} | {abs(force):11.2f} | {force_type}&quot;)&#10;&#10;# Print numerical stability information&#10;print(&quot;\nNumerical Stability Info:&quot;)&#10;print(&quot;-----------------------&quot;)&#10;print(f&quot;Matrix size: {dof}{dof}&quot;)&#10;print(f&quot;Condition number: {cond:.2e}&quot;)&#10;print(f&quot;Number of members: {len(member_data)}&quot;)&#10;print(f&quot;Maximum force magnitude: {max(abs(f) for f in member_forces.values()):.2f} kips&quot;)&#10;print(f&quot;Maximum displacement: {max_vert_disp_in:.4f} inches&quot;)&#10;&#10;if cond &gt; 1e12:&#10;    print(&quot;\nWARNING: High condition number indicates numerical instability.&quot;)&#10;    print(&quot;\nRECOMMENDATIONS:&quot;)&#10;    print(&quot;1. The duplicate nodes 6 and 13 at (100, 0) should be merged into a single node&quot;)&#10;    print(&quot;2. Update member connectivity to reference the merged node&quot;)&#10;    print(&quot;3. Ensure all supports are properly defined&quot;)&#10;    print(&quot;4. Check for any disconnected parts of the structure&quot;)&#10;&#10;# Display the plot on screen&#10;plt.show()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/run_Pratt_bridge_3d.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/run_Pratt_bridge_3d.py" />
              <option name="originalContent" value="import sys&#10;import yaml&#10;import matplotlib.pyplot as plt&#10;from mpl_toolkits.mplot3d import Axes3D&#10;import numpy as np&#10;import os&#10;from matplotlib.backends.backend_pdf import PdfPages&#10;import datetime&#10;import matplotlib.gridspec as gridspec&#10;import matplotlib.cm as cm&#10;from scipy import linalg&#10;&#10;# Load the bridge definition&#10;bridge_file = 'Pratt_Bridge_3D.YAML'&#10;print(f&quot;Loading 3D bridge from {bridge_file}&quot;)&#10;with open(os.path.join(os.path.dirname(__file__), bridge_file), 'r') as file:&#10;    bridge = yaml.safe_load(file)&#10;&#10;# Extract design parameters if present&#10;design_params = bridge.get('design_parameters', {})&#10;min_safety_factor = design_params.get('min_safety_factor', 1.0)&#10;print(f&quot;\nDesign minimum safety factor: {min_safety_factor}&quot;)&#10;&#10;# Extract nodes and members&#10;nodes = bridge['nodes']&#10;members = bridge['members']&#10;supports = bridge['supports']&#10;&#10;# Create a dictionary for easier node lookup and a node_id to index mapping&#10;node_dict = {}&#10;node_to_index = {}  # Maps node_id to its position index (0-based)&#10;for i, node in enumerate(nodes):&#10;    node_id = node['id']&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;    z = float(str(node.get('z', '0 ft')).split()[0])  # Default to 0 if z not present&#10;    node_dict[node_id] = (x, y, z)&#10;    node_to_index[node_id] = i  # Store 0-based index for each node&#10;&#10;print(f&quot;Created node index mapping for {len(node_to_index)} nodes&quot;)&#10;print(f&quot;First few mappings: {list(node_to_index.items())[:5]}&quot;)&#10;print(f&quot;Highest node ID: {max(node_to_index.keys())}&quot;)&#10;&#10;# Check for duplicate nodes with higher precision&#10;print(&quot;\nChecking for duplicate nodes (high precision check)...&quot;)&#10;node_positions = {}&#10;duplicate_nodes = []&#10;duplicate_tolerance = 1e-6  # Tolerance for considering nodes as duplicates (in feet)&#10;&#10;for node_id, pos in node_dict.items():&#10;    # Round to handle potential floating point precision issues&#10;    pos_key = (round(pos[0]/duplicate_tolerance)*duplicate_tolerance,&#10;               round(pos[1]/duplicate_tolerance)*duplicate_tolerance,&#10;               round(pos[2]/duplicate_tolerance)*duplicate_tolerance)&#10;&#10;    if pos_key in node_positions:&#10;        other_node = node_positions[pos_key]&#10;        print(f&quot;WARNING: Nodes {other_node} and {node_id} are at the same position {pos}&quot;)&#10;        print(f&quot;  Node {other_node}: ({node_dict[other_node][0]}, {node_dict[other_node][1]}, {node_dict[other_node][2]})&quot;)&#10;        print(f&quot;  Node {node_id}: ({pos[0]}, {pos[1]}, {pos[2]})&quot;)&#10;        print(&quot;This will cause numerical instability!&quot;)&#10;        duplicate_nodes.append((other_node, node_id))&#10;    else:&#10;        node_positions[pos_key] = node_id&#10;&#10;# Report structural connectivity&#10;print(&quot;\nStructural connectivity check:&quot;)&#10;print(f&quot;Total nodes: {len(node_dict)}&quot;)&#10;print(f&quot;Unique positions: {len(node_positions)}&quot;)&#10;if duplicate_nodes:&#10;    print(f&quot;Found {len(duplicate_nodes)} duplicate node pairs:&quot;)&#10;    for node1, node2 in duplicate_nodes:&#10;        pos = node_dict[node1]&#10;        print(f&quot;  Nodes {node1} and {node2} at position ({pos[0]}, {pos[1]}, {pos[2]})&quot;)&#10;    print(&quot;Duplicate nodes should be merged for numerical stability&quot;)&#10;else:&#10;    print(&quot;No duplicate nodes found - good!&quot;)&#10;&#10;# Check for disconnected parts&#10;print(&quot;\nChecking for member connectivity...&quot;)&#10;node_connections = {node_id: set() for node_id in node_dict}&#10;for member in members:&#10;    if member['i_node'] in node_dict and member['j_node'] in node_dict:&#10;        node_connections[member['i_node']].add(member['j_node'])&#10;        node_connections[member['j_node']].add(member['i_node'])&#10;&#10;# Find isolated nodes&#10;isolated_nodes = [node_id for node_id, connections in node_connections.items() if len(connections) == 0]&#10;if isolated_nodes:&#10;    print(f&quot;WARNING: Found {len(isolated_nodes)} isolated nodes: {isolated_nodes}&quot;)&#10;&#10;# Check connectivity between the two spans&#10;# Nodes at x=100 ft should connect the left and right spans&#10;nodes_at_pier = [node_id for node_id, pos in node_dict.items() if abs(pos[0] - 100) &lt; 0.1]&#10;print(f&quot;\nNodes at center pier (x=100 ft): {sorted(nodes_at_pier)}&quot;)&#10;&#10;# Check for members that should exist but don't&#10;print(&quot;\nVerifying critical connections:&quot;)&#10;critical_connections = [&#10;    (6, 12, &quot;Central vertical at x=100ft, front&quot;),&#10;    (106, 112, &quot;Central vertical at x=100ft, back&quot;),&#10;    (106, 12, &quot;Diagonal bracing at center pier&quot;)&#10;]&#10;&#10;for i_node, j_node, description in critical_connections:&#10;    found = any((m['i_node'] == i_node and m['j_node'] == j_node) or&#10;                (m['i_node'] == j_node and m['j_node'] == i_node)&#10;                for m in members)&#10;    if not found:&#10;        print(f&quot;  WARNING: Missing critical member {description} between nodes {i_node} and {j_node}&quot;)&#10;    else:&#10;        print(f&quot;  OK: Found {description}&quot;)&#10;&#10;# Define function to get DOF indices for a node (3D: 3 DOFs per node)&#10;def get_dof(node_id):&#10;    if node_id not in node_to_index:&#10;        raise ValueError(f&quot;Node ID {node_id} not found in node index mapping&quot;)&#10;    base = 3 * node_to_index[node_id]  # Use the node index, not the ID&#10;    return base, base + 1, base + 2  # x, y, z DOFs&#10;&#10;# Initialize global stiffness matrix and force vector&#10;num_nodes = len(nodes)&#10;dof = 3 * num_nodes  # Degrees of freedom (x, y, z for each node)&#10;K_global = np.zeros((dof, dof))&#10;F_global = np.zeros(dof)&#10;&#10;print(f&quot;\n3D Analysis: {num_nodes} nodes, {dof} DOFs&quot;)&#10;&#10;# Material properties (A36 steel)&#10;E = 29000.0  # ksi - Young's modulus&#10;&#10;# Define section properties - now load from YAML if available&#10;if 'sections' in bridge:&#10;    sections = {}&#10;    for section in bridge['sections']:&#10;        sec_id = section['id']&#10;        area_str = str(section['area']).split()[0]  # Extract numeric part&#10;        r_str = str(section['r']).split()[0]        # Extract numeric part&#10;        sections[sec_id] = {&#10;            &quot;area&quot;: float(area_str),&#10;            &quot;r&quot;: float(r_str)&#10;        }&#10;    print(&quot;\nLoaded section properties from YAML:&quot;)&#10;    for sec_id, props in sections.items():&#10;        print(f&quot;  Section {sec_id}: Area = {props['area']} in^2, r = {props['r']} in&quot;)&#10;else:&#10;    # Default section properties if not in YAML&#10;    sections = {&#10;        1: {&quot;area&quot;: 7.65, &quot;r&quot;: 4.32},  # W12x26 - area in in^2, r is radius of gyration in inches&#10;        2: {&quot;area&quot;: 9.13, &quot;r&quot;: 3.47}   # W8x31 - area in in^2, r is radius of gyration in inches&#10;    }&#10;    print(&quot;\nUsing default section properties&quot;)&#10;&#10;# Store member data for later reference&#10;member_data = {}&#10;&#10;# Calculate axial stiffness for each member&#10;print(&quot;\nAssembling 3D stiffness matrix...&quot;)&#10;for member in members:&#10;    member_id = member['id']&#10;    start = member['i_node']&#10;    end = member['j_node']&#10;&#10;    # Verify nodes exist in our mapping&#10;    if start not in node_to_index:&#10;        print(f&quot;ERROR: Member {member_id} references non-existent node {start}&quot;)&#10;        continue&#10;    if end not in node_to_index:&#10;        print(f&quot;ERROR: Member {member_id} references non-existent node {end}&quot;)&#10;        continue&#10;&#10;    section_id = member['section']&#10;&#10;    # Get section properties&#10;    section_area = sections[section_id][&quot;area&quot;]  # in&#10;&#10;    # Calculate EA in kip-in (E in ksi, A in in =&gt; EA in kip)&#10;    EA = E * section_area&#10;&#10;    # Get coordinates&#10;    x1, y1, z1 = node_dict[start]&#10;    x2, y2, z2 = node_dict[end]&#10;&#10;    # Calculate length in ft&#10;    dx = x2 - x1&#10;    dy = y2 - y1&#10;    dz = z2 - z1&#10;    length_ft = np.sqrt(dx**2 + dy**2 + dz**2)&#10;&#10;    # Check for zero-length members&#10;    if length_ft &lt; 1e-6:&#10;        print(f&quot;ERROR: Member {member_id} has zero length (nodes {start} to {end})&quot;)&#10;        print(f&quot;  Node {start}: ({x1}, {y1}, {z1})&quot;)&#10;        print(f&quot;  Node {end}: ({x2}, {y2}, {z2})&quot;)&#10;        continue  # Skip this member instead of exiting&#10;&#10;    length_in = length_ft * 12.0  # Convert to inches&#10;&#10;    # Calculate direction cosines for 3D&#10;    cx = dx / length_ft&#10;    cy = dy / length_ft&#10;    cz = dz / length_ft&#10;&#10;    # Store member properties&#10;    member_data[member_id] = {&#10;        &quot;start&quot;: start,&#10;        &quot;end&quot;: end,&#10;        &quot;length_ft&quot;: length_ft,&#10;        &quot;length_in&quot;: length_in,&#10;        &quot;EA&quot;: EA,&#10;        &quot;cx&quot;: cx,&#10;        &quot;cy&quot;: cy,&#10;        &quot;cz&quot;: cz,&#10;        &quot;section_id&quot;: section_id,&#10;        &quot;section_area&quot;: section_area&#10;    }&#10;&#10;    # Debug info for first few members&#10;    if member_id &lt;= 3:&#10;        print(f&quot;Member {member_id}: Length = {length_ft:.2f} ft ({length_in:.2f} in), EA = {EA:.2f} kip&quot;)&#10;        print(f&quot;  Direction cosines: cx = {cx:.4f}, cy = {cy:.4f}, cz = {cz:.4f}&quot;)&#10;&#10;    # Local to global transformation matrix for 3D truss element&#10;    # The transformation matrix is 6x6 for 3D (3 DOFs per node)&#10;    T = np.array([&#10;        [cx, cy, cz, 0,  0,  0],&#10;        [0,  0,  0, cx, cy, cz]&#10;    ])&#10;&#10;    # Element stiffness matrix in local coordinates (for a 3D truss element)&#10;    # k = EA/L in kip/in&#10;    k_axial = EA / length_in&#10;&#10;    k_local = k_axial * np.array([&#10;        [ 1, -1],&#10;        [-1,  1]&#10;    ])&#10;&#10;    # Transform to global coordinates: k_global = T^T * k_local * T&#10;    k_global = T.T @ k_local @ T&#10;&#10;    # Map local DOFs to global DOFs using node indices, not IDs&#10;    dof_start = get_dof(start)&#10;    dof_end = get_dof(end)&#10;    dof_indices = [*dof_start, *dof_end]&#10;&#10;    if member_id &lt;= 3:&#10;        print(f&quot;  DOF indices: {dof_indices}&quot;)&#10;&#10;    # Assemble into global stiffness matrix&#10;    for i in range(6):&#10;        for j in range(6):&#10;            K_global[dof_indices[i], dof_indices[j]] += k_global[i, j]&#10;&#10;# Apply external forces from member loads&#10;print(&quot;\nApplying loads...&quot;)&#10;if 'member_loads' in bridge:&#10;    for load in bridge['member_loads']:&#10;        member_id = load['member_uid']&#10;        if member_id not in member_data:&#10;            print(f&quot;WARNING: Load references non-existent member {member_id}&quot;)&#10;            continue&#10;&#10;        member = next(m for m in members if m['id'] == member_id)&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        # Convert distributed load to equivalent nodal loads&#10;        wi = float(str(load['wi']).split()[0])  # kips/ft&#10;        wj = float(str(load['wj']).split()[0])  # kips/ft&#10;        length = member_data[member_id][&quot;length_ft&quot;]  # ft&#10;&#10;        # For uniform load, apply half to each node in y-direction&#10;        if abs(wi - wj) &lt; 1e-6:  # Uniform load&#10;            force = abs(wi) * length / 2  # kips (make positive)&#10;            _, dof_yi, _ = get_dof(i_node)&#10;            _, dof_yj, _ = get_dof(j_node)&#10;&#10;            # Debug info for first few loads&#10;            if member_id &lt;= 3:&#10;                print(f&quot;Load on member {member_id}: w = {wi} kips/ft, L = {length:.2f} ft&quot;)&#10;                print(f&quot;  Equivalent nodal forces: {force:.2f} kips (downward) at nodes {i_node} and {j_node}&quot;)&#10;&#10;            # Apply downward forces (negative in typical structural convention)&#10;            F_global[dof_yi] -= force  # Negative for downward&#10;            F_global[dof_yj] -= force  # Negative for downward&#10;        else:&#10;            # For non-uniform load (simplified approach)&#10;            force_i = abs(wi) * length / 3  # kips&#10;            force_j = abs(wj) * length / 3  # kips&#10;            _, dof_yi, _ = get_dof(i_node)&#10;            _, dof_yj, _ = get_dof(j_node)&#10;            F_global[dof_yi] -= force_i  # Negative for downward&#10;            F_global[dof_yj] -= force_j  # Negative for downward&#10;&#10;# Apply support constraints&#10;print(&quot;\nApplying support constraints:&quot;)&#10;constrained_dofs = []&#10;for support in supports:&#10;    node_id = support['node']&#10;&#10;    if node_id not in node_to_index:&#10;        print(f&quot;WARNING: Support references non-existent node {node_id}&quot;)&#10;        continue&#10;&#10;    dof_x, dof_y, dof_z = get_dof(node_id)&#10;&#10;    print(f&quot;Support at node {node_id}: ux={support['ux']}, uy={support['uy']}, uz={support.get('uz', 0)}&quot;)&#10;&#10;    if support['ux'] == 1:  # Fixed in x-direction&#10;        constrained_dofs.append(dof_x)&#10;        K_global[dof_x, :] = 0&#10;        K_global[:, dof_x] = 0&#10;        K_global[dof_x, dof_x] = 1&#10;        F_global[dof_x] = 0&#10;&#10;    if support['uy'] == 1:  # Fixed in y-direction&#10;        constrained_dofs.append(dof_y)&#10;        K_global[dof_y, :] = 0&#10;        K_global[:, dof_y] = 0&#10;        K_global[dof_y, dof_y] = 1&#10;        F_global[dof_y] = 0&#10;&#10;    if support.get('uz', 0) == 1:  # Fixed in z-direction&#10;        constrained_dofs.append(dof_z)&#10;        K_global[dof_z, :] = 0&#10;        K_global[:, dof_z] = 0&#10;        K_global[dof_z, dof_z] = 1&#10;        F_global[dof_z] = 0&#10;&#10;print(f&quot;Total constrained DOFs: {len(constrained_dofs)}&quot;)&#10;print(f&quot;Free DOFs: {dof - len(constrained_dofs)}&quot;)&#10;&#10;# Check for zero diagonal elements (indicates singularity)&#10;diag_zeros = np.where(np.abs(np.diag(K_global)) &lt; 1e-10)[0]&#10;if len(diag_zeros) &gt; 0:&#10;    print(f&quot;\nWARNING: Zero diagonal elements detected at DOFs: {diag_zeros}&quot;)&#10;    for dof_idx in diag_zeros:&#10;        # Find which node this DOF belongs to&#10;        node_idx = dof_idx // 3&#10;        # Find the node_id from the index&#10;        node_id = None&#10;        for nid, idx in node_to_index.items():&#10;            if idx == node_idx:&#10;                node_id = nid&#10;                break&#10;        dof_type = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;][dof_idx % 3]&#10;        print(f&quot;  DOF {dof_idx} (Node {node_id}, {dof_type}-direction)&quot;)&#10;&#10;# Check if the stiffness matrix is symmetric (it should be)&#10;is_symmetric = np.allclose(K_global, K_global.T, rtol=1e-5, atol=1e-8)&#10;print(f&quot;\nStiffness matrix is symmetric: {is_symmetric}&quot;)&#10;&#10;# Check for rows/columns that are all zeros (except diagonal)&#10;print(&quot;\nChecking for zero rows/columns in stiffness matrix...&quot;)&#10;zero_rows = []&#10;for i in range(dof):&#10;    row = K_global[i, :]&#10;    if np.sum(np.abs(row)) - np.abs(row[i]) &lt; 1e-10:  # Row has only diagonal element&#10;        zero_rows.append(i)&#10;        # Find which node this DOF belongs to&#10;        node_idx = i // 3&#10;        # Find the node_id from the index&#10;        node_id = None&#10;        for nid, idx in node_to_index.items():&#10;            if idx == node_idx:&#10;                node_id = nid&#10;                break&#10;        dof_type = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;][i % 3]&#10;        print(f&quot;  DOF {i} (Node {node_id}, {dof_type}-direction) has no off-diagonal connections&quot;)&#10;&#10;# Analyze the condition of the matrix&#10;try:&#10;    # Compute the condition number&#10;    cond = np.linalg.cond(K_global)&#10;    print(f&quot;Condition number of stiffness matrix: {cond:.2e}&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        print(&quot;\nWARNING: Very high condition number detected!&quot;)&#10;        print(&quot;The structure may have:&quot;)&#10;        print(&quot;1. Insufficient supports (mechanism)&quot;)&#10;        print(&quot;2. Disconnected parts&quot;)&#10;        print(&quot;3. Numerical scaling issues&quot;)&#10;        print(&quot;4. Duplicate nodes at the same location&quot;)&#10;&#10;        # Additional diagnostics&#10;        print(&quot;\nDiagnostic information:&quot;)&#10;        print(f&quot;- Number of duplicate node positions: {len(duplicate_nodes)}&quot;)&#10;        print(f&quot;- Number of isolated nodes: {len(isolated_nodes)}&quot;)&#10;        print(f&quot;- Number of zero rows/columns: {len(zero_rows)}&quot;)&#10;&#10;        # Check for specific problematic DOFs&#10;        if len(zero_rows) &gt; 0:&#10;            print(&quot;\nNodes with unconnected DOFs:&quot;)&#10;            problematic_nodes = set()&#10;            for dof_idx in zero_rows:&#10;                node_idx = dof_idx // 3&#10;                for nid, idx in node_to_index.items():&#10;                    if idx == node_idx:&#10;                        problematic_nodes.add(nid)&#10;                        break&#10;            print(f&quot;  Nodes with issues: {sorted(problematic_nodes)}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;Could not compute condition number: {e}&quot;)&#10;    cond = float('inf')&#10;&#10;# Apply scaling to improve conditioning&#10;print(&quot;\nAttempting to solve the system...&quot;)&#10;try:&#10;    # For very ill-conditioned systems, try regularization&#10;    if cond &gt; 1e14:&#10;        print(&quot;System is extremely ill-conditioned. Applying regularization...&quot;)&#10;        # Add small diagonal perturbation to improve conditioning&#10;        reg_factor = 1e-8 * np.max(np.abs(np.diag(K_global)))&#10;        K_regularized = K_global + reg_factor * np.eye(dof)&#10;&#10;        try:&#10;            displacements = linalg.solve(K_regularized, F_global, assume_a='sym')&#10;            print(&quot;Regularized solution successful&quot;)&#10;        except:&#10;            # Fall back to least squares&#10;            displacements, residuals, rank, s = linalg.lstsq(K_global, F_global)&#10;            print(f&quot;Least squares solution: rank={rank}/{dof}&quot;)&#10;    else:&#10;        # Try direct solution&#10;        displacements = linalg.solve(K_global, F_global, assume_a='sym')&#10;        print(&quot;Direct solution successful&quot;)&#10;&#10;    # Print first few displacement values for debugging&#10;    print(&quot;\nNodal displacements:&quot;)&#10;    print(&quot;Node | dx (in) | dy (in) | dz (in)&quot;)&#10;    print(&quot;-&quot; * 40)&#10;    for node_id in sorted(list(node_dict.keys()))[:10]:  # First 10 nodes&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        # Convert to inches for display&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        dz_in = displacements[dof_z] * 12&#10;        print(f&quot;{node_id:4} | {dx_in:7.4f} | {dy_in:7.4f} | {dz_in:7.4f}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;All solution methods failed: {e}&quot;)&#10;    print(&quot;Using zero displacements as fallback&quot;)&#10;    displacements = np.zeros(dof)&#10;&#10;# Find maximum vertical displacement&#10;max_vert_disp = 0&#10;max_disp_node = None&#10;for node_id in node_dict:&#10;    _, dof_y, _ = get_dof(node_id)&#10;    # Skip nodes that are supported&#10;    is_supported = any(s['node'] == node_id and s['uy'] == 1 for s in supports)&#10;    if not is_supported:&#10;        disp = abs(displacements[dof_y])&#10;        if disp &gt; max_vert_disp:&#10;            max_vert_disp = disp&#10;            max_disp_node = node_id&#10;&#10;# Convert to inches for display&#10;max_vert_disp_in = max_vert_disp * 12&#10;print(f&quot;\nMaximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}&quot;)&#10;&#10;# Calculate member forces&#10;member_forces = {}&#10;member_stresses = {}&#10;&#10;# Material properties (A36 steel)&#10;Fy = 36.0    # ksi - Yield strength&#10;Fu = 58.0    # ksi - Ultimate strength&#10;safety_factor_tension = 1.67&#10;safety_factor_compression = 1.67&#10;allowable_tension_stress = Fy / safety_factor_tension      # ksi&#10;allowable_compression_stress_max = Fy / safety_factor_compression  # ksi&#10;&#10;# Calculate forces and stresses for each member&#10;for member in members:&#10;    member_id = member['id']&#10;    if member_id not in member_data:&#10;        continue  # Skip members with zero length or missing data&#10;&#10;    mem_data = member_data[member_id]&#10;    start = mem_data[&quot;start&quot;]&#10;    end = mem_data[&quot;end&quot;]&#10;    area = mem_data[&quot;section_area&quot;]  # in&#10;    cx = mem_data[&quot;cx&quot;]&#10;    cy = mem_data[&quot;cy&quot;]&#10;    cz = mem_data[&quot;cz&quot;]&#10;&#10;    # Get displacements at both nodes (in feet)&#10;    dof_x1, dof_y1, dof_z1 = get_dof(start)&#10;    dof_x2, dof_y2, dof_z2 = get_dof(end)&#10;&#10;    # Calculate relative displacement in the axial direction (in feet)&#10;    delta_u1 = displacements[dof_x1] * cx + displacements[dof_y1] * cy + displacements[dof_z1] * cz&#10;    delta_u2 = displacements[dof_x2] * cx + displacements[dof_y2] * cy + displacements[dof_z2] * cz&#10;    delta_axial = delta_u2 - delta_u1&#10;&#10;    # Convert to inches for force calculation&#10;    delta_axial_in = delta_axial * 12&#10;&#10;    # Calculate axial force (F = EA/L * delta)&#10;    EA = mem_data[&quot;EA&quot;]  # kip&#10;    force = (EA / mem_data[&quot;length_in&quot;]) * delta_axial_in  # kips&#10;    member_forces[member_id] = force&#10;&#10;    # Calculate axial stress&#10;    stress = force / area  # kips/in = ksi&#10;    member_stresses[member_id] = stress&#10;&#10;    # Debug output for selected members&#10;    if member_id &lt;= 3 or member_id == 32:&#10;        print(f&quot;\nMember {member_id} analysis:&quot;)&#10;        print(f&quot;  Length = {mem_data['length_ft']:.2f} ft&quot;)&#10;        print(f&quot;  Node {start}: dx = {displacements[dof_x1]*12:.4f} in, dy = {displacements[dof_y1]*12:.4f} in, dz = {displacements[dof_z1]*12:.4f} in&quot;)&#10;        print(f&quot;  Node {end}: dx = {displacements[dof_x2]*12:.4f} in, dy = {displacements[dof_y2]*12:.4f} in, dz = {displacements[dof_z2]*12:.4f} in&quot;)&#10;        print(f&quot;  Delta axial = {delta_axial_in:.4f} in&quot;)&#10;        print(f&quot;  Force = {force:.2f} kips&quot;)&#10;        print(f&quot;  Stress = {stress:.2f} ksi&quot;)&#10;&#10;# Calculate safety factors for all members&#10;member_safety_factors = {}&#10;member_status = {}&#10;&#10;# Define zero force threshold&#10;ZERO_FORCE_THRESHOLD = 0.1  # Consider forces below this threshold as &quot;zero&quot;&#10;&#10;# Replace the problematic part in the safety factors calculation&#10;for member_id, stress in member_stresses.items():&#10;    section_id = member_data[member_id][&quot;section_id&quot;]&#10;    section = sections[section_id]&#10;&#10;    if abs(stress) &lt; ZERO_FORCE_THRESHOLD / section[&quot;area&quot;]:&#10;        # Zero/near-zero stress&#10;        safety_factor = float('inf')&#10;        limit = allowable_tension_stress  # Arbitrary for zero-force members&#10;        status = &quot;OK&quot;&#10;    elif stress &gt;= 0:  # Tension&#10;        safety_factor = allowable_tension_stress / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_tension_stress&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;    else:  # Compression&#10;        # Calculate allowable compression stress based on slenderness&#10;        length_inches = member_data[member_id][&quot;length_in&quot;]&#10;        slenderness = length_inches / section[&quot;r&quot;]&#10;&#10;        if slenderness &gt; 100:  # For slender members&#10;            critical_stress = (np.pi**2 * E) / (slenderness**2)&#10;            allowable_compression = min(allowable_compression_stress_max, critical_stress/safety_factor_compression)&#10;        else:  # For stocky members&#10;            allowable_compression = allowable_compression_stress_max&#10;&#10;        safety_factor = allowable_compression / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_compression&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;&#10;    member_safety_factors[member_id] = safety_factor&#10;    member_status[member_id] = {&#10;        &quot;stress&quot;: stress,&#10;        &quot;allowable&quot;: limit,&#10;        &quot;safety_factor&quot;: safety_factor,&#10;        &quot;status&quot;: status&#10;    }&#10;&#10;# After calculating safety factors, add a summary of members below minimum&#10;members_below_min_sf = []&#10;zero_force_members = []&#10;for member_id, status_info in member_status.items():&#10;    if status_info[&quot;safety_factor&quot;] &lt; min_safety_factor and status_info[&quot;safety_factor&quot;] &lt; 100:&#10;        members_below_min_sf.append({&#10;            'id': member_id,&#10;            'sf': status_info[&quot;safety_factor&quot;],&#10;            'stress': status_info[&quot;stress&quot;],&#10;            'allowable': status_info[&quot;allowable&quot;]&#10;        })&#10;    if abs(member_forces[member_id]) &lt; ZERO_FORCE_THRESHOLD:&#10;        zero_force_members.append(member_id)&#10;&#10;if members_below_min_sf:&#10;    print(f&quot;\n{len(members_below_min_sf)} members have safety factor below {min_safety_factor}:&quot;)&#10;    for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:10]:  # Show worst 10&#10;        print(f&quot;  Member {mem['id']}: SF = {mem['sf']:.2f}, Stress = {abs(mem['stress']):.1f} ksi&quot;)&#10;&#10;if zero_force_members:&#10;    print(f&quot;\n{len(zero_force_members)} zero-force members detected:&quot;)&#10;    print(f&quot;  Members: {sorted(zero_force_members)[:20]}&quot;)  # Show first 20&#10;&#10;# Create figure for the PDF - add timestamp to filenames&#10;timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M%S')&#10;pdf_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_3D_Analysis_{timestamp}.pdf&quot;)&#10;text_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_3D_Analysis_{timestamp}.txt&quot;)&#10;&#10;# Open the text file for writing the report&#10;with open(text_filename, 'w') as txt_report:&#10;    # Write header information&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(&quot;PRATT BRIDGE STRUCTURAL ANALYSIS REPORT\n&quot;)&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(f&quot;Analysis Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}\n&quot;)&#10;    txt_report.write(f&quot;Input File: {bridge_file}\n&quot;)&#10;    txt_report.write(f&quot;Design Minimum Safety Factor: {min_safety_factor}\n\n&quot;)&#10;&#10;    # Write model statistics&#10;    txt_report.write(&quot;MODEL STATISTICS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Number of nodes: {num_nodes}\n&quot;)&#10;    txt_report.write(f&quot;Number of members: {len(members)}\n&quot;)&#10;    txt_report.write(f&quot;Number of supports: {len(supports)}\n&quot;)&#10;    txt_report.write(f&quot;Degrees of freedom: {dof}\n&quot;)&#10;    txt_report.write(f&quot;Constrained DOFs: {len(constrained_dofs)}\n&quot;)&#10;    txt_report.write(f&quot;Free DOFs: {dof - len(constrained_dofs)}\n\n&quot;)&#10;&#10;    # Write material properties&#10;    txt_report.write(&quot;MATERIAL PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Material: A36 Steel\n&quot;)&#10;    txt_report.write(f&quot;Young's modulus: {E} ksi\n&quot;)&#10;    txt_report.write(f&quot;Yield strength: {Fy} ksi\n&quot;)&#10;    txt_report.write(f&quot;Ultimate strength: {Fu} ksi\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (tension): {safety_factor_tension}\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (compression): {safety_factor_compression}\n\n&quot;)&#10;&#10;    # Write section properties&#10;    txt_report.write(&quot;SECTION PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    for sec_id, props in sections.items():&#10;        txt_report.write(f&quot;Section {sec_id}: Area = {props['area']} in, r = {props['r']} in\n&quot;)&#10;    txt_report.write(&quot;\n&quot;)&#10;&#10;    # Write analysis results summary&#10;    txt_report.write(&quot;ANALYSIS RESULTS SUMMARY\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Maximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}\n&quot;)&#10;    txt_report.write(f&quot;Stiffness matrix condition number: {cond:.2e}\n&quot;)&#10;&#10;    # Calculate critical values&#10;    critical_sf = float('inf')&#10;    critical_member = None&#10;    overstressed_count = 0&#10;    for member_id, status_info in member_status.items():&#10;        sf = status_info[&quot;safety_factor&quot;]&#10;        if sf &lt; critical_sf and sf &lt; 100:&#10;            critical_sf = sf&#10;            critical_member = member_id&#10;        if status_info[&quot;status&quot;] == &quot;OVERSTRESSED&quot;:&#10;            overstressed_count += 1&#10;&#10;    txt_report.write(f&quot;Number of tension members: {sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of compression members: {sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of zero-force members: {sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Overstressed members: {overstressed_count}\n&quot;)&#10;    txt_report.write(f&quot;Maximum member force: {max(abs(f) for f in member_forces.values()):.2f} kips\n&quot;)&#10;    txt_report.write(f&quot;Maximum member stress: {max(abs(s) for s in member_stresses.values()):.2f} ksi\n&quot;)&#10;    txt_report.write(f&quot;Minimum safety factor: {critical_sf:.2f} (Member #{critical_member})\n\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;\nNUMERICAL STABILITY WARNING:\n&quot;)&#10;        txt_report.write(&quot;--------------------------------\n&quot;)&#10;        txt_report.write(f&quot;Condition number ({cond:.2e}) indicates severe numerical instability.\n&quot;)&#10;        txt_report.write(&quot;\nPossible causes:\n&quot;)&#10;        if duplicate_nodes:&#10;            txt_report.write(f&quot;1. Found {len(duplicate_nodes)} duplicate node pairs:\n&quot;)&#10;            for node1, node2 in duplicate_nodes[:5]:  # Show first 5&#10;                txt_report.write(f&quot;   - Nodes {node1} and {node2} at position {node_dict[node1]}\n&quot;)&#10;        if isolated_nodes:&#10;            txt_report.write(f&quot;2. Found {len(isolated_nodes)} isolated nodes\n&quot;)&#10;        if zero_rows:&#10;            txt_report.write(f&quot;3. Found {len(zero_rows)} DOFs with no off-diagonal connections\n&quot;)&#10;        txt_report.write(&quot;\nRecommended fixes:\n&quot;)&#10;        txt_report.write(&quot;- Merge duplicate nodes into single nodes\n&quot;)&#10;        txt_report.write(&quot;- Ensure proper connectivity between structural parts\n&quot;)&#10;        txt_report.write(&quot;- Verify all supports are correctly defined\n&quot;)&#10;        txt_report.write(&quot;- Check member connectivity references\n\n&quot;)&#10;&#10;    # Write detailed member results&#10;    txt_report.write(&quot;DETAILED MEMBER RESULTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Member | Nodes (i-j) | Force (kips) | Stress (ksi) | Type | S.F. | Status\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 80 + &quot;\n&quot;)&#10;&#10;    for member in sorted(members, key=lambda m: m['id']):&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;        stress = member_stresses[member_id]&#10;        sf = member_safety_factors[member_id]&#10;        status = member_status[member_id][&quot;status&quot;]&#10;&#10;        # Fix the text report formatting to use only ASCII&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            force_type = &quot;ZERO&quot;&#10;            sf_text = &quot;inf&quot;&#10;        elif force &gt; 0:&#10;            force_type = &quot;TENSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;        else:&#10;            force_type = &quot;COMPRESSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;&#10;        txt_report.write(&#10;            f&quot;{member_id:6} | {i_node:2}-{j_node:&lt;2} | {abs(force):11.2f} | {abs(stress):10.2f} | {force_type:10} | {sf_text:&gt;5} | {status}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;&#10;    # Write nodal displacements&#10;    txt_report.write(&quot;NODAL DISPLACEMENTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Node | dx (inches) | dy (inches) | dz (inches)\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 40 + &quot;\n&quot;)&#10;&#10;    for node_id in sorted(node_dict.keys()):&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        dz_in = displacements[dof_z] * 12&#10;        txt_report.write(f&quot;{node_id:4} | {dx_in:11.4f} | {dy_in:11.4f} | {dz_in:11.4f}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;    txt_report.write(&quot;RECOMMENDATIONS FOR STRUCTURE REFINEMENT\n&quot;)&#10;    txt_report.write(&quot;----------------------------------------\n&quot;)&#10;&#10;    if members_below_min_sf:&#10;        txt_report.write(f&quot;1. {len(members_below_min_sf)} members have safety factor below the design minimum of {min_safety_factor}:\n&quot;)&#10;        for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:20]:  # Show worst 20&#10;            member = next(m for m in members if m['id'] == mem['id'])&#10;            txt_report.write(f&quot;   - Member {mem['id']} (nodes {member['i_node']}-{member['j_node']}): SF = {mem['sf']:.2f}\n&quot;)&#10;&#10;        # Calculate required section increase&#10;        worst_sf = min(mem['sf'] for mem in members_below_min_sf)&#10;        required_increase = min_safety_factor / worst_sf&#10;        txt_report.write(f&quot;\n   Worst member requires approximately {required_increase:.1f}x increase in capacity.\n&quot;)&#10;        txt_report.write(f&quot;   Consider using larger sections or reducing the loading.\n&quot;)&#10;    else:&#10;        txt_report.write(&quot;1. All members meet the minimum safety factor requirement.\n&quot;)&#10;        txt_report.write(&quot;   Consider optimizing the structure by reducing sections for members with high safety factors.\n&quot;)&#10;&#10;    if max_vert_disp_in &gt; 2.0:  # Assuming 2 inches as a reasonable deflection limit&#10;        txt_report.write(f&quot;2. Consider stiffening the structure to reduce the maximum deflection (currently {max_vert_disp_in:.4f} inches).\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;3. Fix numerical stability issues by reviewing structure connectivity and supports.\n&quot;)&#10;&#10;    txt_report.write(&quot;\nReport generated by pyMAOS Truss Analysis Tool\n&quot;)&#10;&#10;print(f&quot;Text report saved to: {text_filename}&quot;)&#10;&#10;with PdfPages(pdf_filename) as pdf:&#10;    # 1. BRIDGE ANALYSIS SUMMARY page&#10;    fig = plt.figure(figsize=(8.5, 11))&#10;    plt.axis('off')&#10;&#10;    # Add overall bridge status text - avoid using unicode characters&#10;    if overstressed_count == 0:&#10;        status_text = &quot;BRIDGE IS STRUCTURALLY ADEQUATE&quot;&#10;        status_color = 'green'&#10;    else:&#10;        status_text = f&quot;WARNING: BRIDGE HAS {overstressed_count} OVERSTRESSED MEMBERS&quot;&#10;        status_color = 'red'&#10;&#10;    plt.figtext(0.5, 0.9, &quot;BRIDGE ANALYSIS SUMMARY&quot;, ha='center', fontsize=16, weight='bold')&#10;    plt.figtext(0.5, 0.85, status_text, ha='center', fontsize=14, weight='bold', color=status_color)&#10;&#10;    # Add displacement information&#10;    plt.figtext(0.5, 0.78, f&quot;Maximum Vertical Displacement: {max_vert_disp_in:.4f} inches at Node {max_disp_node}&quot;,&#10;                ha='center', fontsize=12)&#10;&#10;    # Add summary statistics&#10;    critical_text = f&quot;Most critical member: #{critical_member} (Safety Factor: {critical_sf:.2f})&quot;&#10;    plt.figtext(0.5, 0.73, critical_text, ha='center', fontsize=12)&#10;&#10;    # Add a summary table of key statistics&#10;    summary_data = [&#10;        [&quot;Total Members&quot;, f&quot;{len(members)}&quot;],&#10;        [&quot;Tension Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Compression Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Zero-Force Members&quot;, f&quot;{sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Overstressed Members&quot;, f&quot;{overstressed_count}&quot;],&#10;        [&quot;Maximum Member Force&quot;, f&quot;{max(abs(f) for f in member_forces.values()):.2f} kips&quot;],&#10;        [&quot;Maximum Member Stress&quot;, f&quot;{max(abs(s) for s in member_stresses.values()):.2f} ksi&quot;],&#10;        [&quot;Minimum Safety Factor&quot;, f&quot;{critical_sf:.2f}&quot;],&#10;        [&quot;Maximum Displacement&quot;, f&quot;{max_vert_disp_in:.4f} inches&quot;],&#10;    ]&#10;&#10;    # Create a table in the middle of the page&#10;    ax = plt.subplot(111)&#10;    ax.axis('off')&#10;    tbl = plt.table(cellText=summary_data, colLabels=[&quot;Metric&quot;, &quot;Value&quot;],&#10;                    loc='center', cellLoc='left')&#10;    tbl.auto_set_font_size(False)&#10;    tbl.set_fontsize(10)&#10;    tbl.scale(1, 1.5)&#10;&#10;    # Add design criteria info&#10;    criteria = (&#10;        f&quot;Design Criteria:\n&quot;&#10;        f&quot;- Material: A36 Steel (Fy = 36 ksi)\n&quot;&#10;        f&quot;- Allowable tension stress: {allowable_tension_stress:.1f} ksi\n&quot;&#10;        f&quot;- Allowable compression stress: Based on member slenderness\n&quot;&#10;        f&quot;- Safety factor: {safety_factor_tension:.2f}&quot;&#10;    )&#10;    plt.figtext(0.5, 0.2, criteria, ha='center', fontsize=10,&#10;                bbox=dict(facecolor='#eeeeee', alpha=0.7, boxstyle='round,pad=0.5'))&#10;&#10;    # Add timestamp&#10;    plt.figtext(0.5, 0.1, f&quot;Analysis completed on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    # Save the summary page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 2. 3D Structure Visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Plot members with color based on safety factors&#10;    cmap = plt.colormaps['RdYlGn']  # Red-Yellow-Green colormap&#10;    norm = plt.Normalize(0.5, 2.0)&#10;&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        safety_factor = member_safety_factors[member_id]&#10;        safety_factor_capped = min(safety_factor, 5.0)  # Cap extremely high values&#10;&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        color = cmap(norm(safety_factor_capped))&#10;&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color=color, linewidth=2)&#10;&#10;    # Plot nodes&#10;    for node_id, (x, y, z) in node_dict.items():&#10;        ax.scatter(x, y, z, c='black', s=20)&#10;&#10;    # Plot supports with different markers&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, z = node_dict[node_id]&#10;        if support['ux'] == 1 and support['uy'] == 1 and support.get('uz', 0) == 1:&#10;            ax.scatter(x, y-5, z, c='red', s=100, marker='s')  # Fixed support&#10;        else:&#10;            ax.scatter(x, y-5, z, c='blue', s=100, marker='o')  # Roller support&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title('3D Pratt Truss Bridge - Safety Factor Visualization')&#10;&#10;    # Add colorbar&#10;    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)&#10;    sm.set_array([])&#10;    cbar = plt.colorbar(sm, ax=ax, label='Safety Factor', shrink=0.6)&#10;&#10;    # Set aspect ratio&#10;    ax.set_box_aspect([2, 0.5, 0.5])  # Adjust based on bridge proportions&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 3. Member Forces - 3D visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Plot members with color based on tension/compression&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        # Color based on force type&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            color = 'black'&#10;            linewidth = 1&#10;        elif force &gt; 0:&#10;            color = 'red'  # Tension&#10;            linewidth = 2 + min(3, abs(force)/50)&#10;        else:&#10;            color = 'blue'  # Compression&#10;            linewidth = 2 + min(3, abs(force)/50)&#10;&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color=color, linewidth=linewidth)&#10;&#10;    # Add legend&#10;    from matplotlib.lines import Line2D&#10;    red_line = Line2D([0], [0], color='red', linewidth=3, label='Tension')&#10;    blue_line = Line2D([0], [0], color='blue', linewidth=3, label='Compression')&#10;    black_line = Line2D([0], [0], color='black', linewidth=1, label='Zero Force')&#10;    ax.legend(handles=[red_line, blue_line, black_line], loc='upper right')&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title('3D Pratt Truss Bridge - Member Forces')&#10;    ax.set_box_aspect([2, 0.5, 0.5])&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 4. 3D Displacement visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Calculate max displacement for scaling&#10;    max_disp_magnitude = 0&#10;    for node_id in node_dict:&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        disp_magnitude = np.sqrt(displacements[dof_x]**2 + displacements[dof_y]**2 + displacements[dof_z]**2)&#10;        max_disp_magnitude = max(max_disp_magnitude, disp_magnitude)&#10;&#10;    # Calculate scale factor&#10;    max_span = max(node_dict[n][0] for n in node_dict) - min(node_dict[n][0] for n in node_dict)&#10;    target_max_disp = max_span * 0.05&#10;&#10;    if max_disp_magnitude &gt; 1e-10:&#10;        scale_factor = target_max_disp / max_disp_magnitude&#10;        scale_magnitude = 10 ** int(np.log10(scale_factor))&#10;        scale_factor = round(scale_factor / scale_magnitude) * scale_magnitude&#10;    else:&#10;        scale_factor = 50.0&#10;&#10;    # Draw original structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color='lightgray', linewidth=1, alpha=0.5)&#10;&#10;    # Draw displaced structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        # Get displacements&#10;        dof_x1, dof_y1, dof_z1 = get_dof(i_node)&#10;        dof_x2, dof_y2, dof_z2 = get_dof(j_node)&#10;&#10;        # Apply scaled displacements&#10;        x1_new = x1 + displacements[dof_x1] * scale_factor&#10;        y1_new = y1 + displacements[dof_y1] * scale_factor&#10;        z1_new = z1 + displacements[dof_z1] * scale_factor&#10;        x2_new = x2 + displacements[dof_x2] * scale_factor&#10;        y2_new = y2 + displacements[dof_y2] * scale_factor&#10;        z2_new = z2 + displacements[dof_z2] * scale_factor&#10;&#10;        ax.plot([x1_new, x2_new], [y1_new, y2_new], [z1_new, z2_new], color='blue', linewidth=1.5)&#10;&#10;    # Highlight max displacement node&#10;    if max_disp_node:&#10;        x, y, z = node_dict[max_disp_node]&#10;        dof_x, dof_y, dof_z = get_dof(max_disp_node)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;        z_new = z + displacements[dof_z] * scale_factor&#10;        ax.scatter(x_new, y_new, z_new, c='red', s=100)&#10;&#10;    # Format scale factor&#10;    if scale_factor &gt;= 1000:&#10;        scale_factor_text = f&quot;{scale_factor/1000:.1f}k&quot;&#10;    elif scale_factor &gt;= 100:&#10;        scale_factor_text = f&quot;{int(scale_factor)}&quot;&#10;    else:&#10;        scale_factor_text = f&quot;{scale_factor:.1f}&quot;&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title(f'3D Pratt Truss Bridge - Displacement (Scale Factor: {scale_factor_text}x)')&#10;    ax.set_box_aspect([2, 0.5, 0.5])&#10;&#10;    # Add legend&#10;    gray_line = Line2D([0], [0], color='lightgray', linewidth=1, alpha=0.5, label='Original')&#10;    blue_line = Line2D([0], [0], color='blue', linewidth=1.5, label='Displaced')&#10;    ax.legend(handles=[gray_line, blue_line], loc='upper right')&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # Add PDF metadata&#10;    d = pdf.infodict()&#10;    d['Title'] = 'Pratt Bridge Structural Analysis'&#10;    d['Author'] = 'pyMAOS Truss Analysis Tool'&#10;    d['Subject'] = 'Structural analysis and reliability assessment'&#10;    d['Keywords'] = 'truss, structural analysis, bridge, reliability'&#10;    d['CreationDate'] = datetime.datetime.now()&#10;    d['ModDate'] = datetime.datetime.now()&#10;&#10;# Print summary of results to console&#10;print(&quot;\nMember Forces Summary:&quot;)&#10;print(&quot;----------------------&quot;)&#10;print(&quot;Member | Force (kips) | Type&quot;)&#10;print(&quot;----------------------&quot;)&#10;for member in sorted(members, key=lambda m: m['id']):&#10;    member_id = member['id']&#10;    force = member_forces[member_id]&#10;    if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;        force_type = &quot;ZERO&quot;&#10;    elif force &gt; 0:&#10;        force_type = &quot;TENSION&quot;&#10;    else:&#10;        force_type = &quot;COMPRESSION&quot;&#10;    print(f&quot;{member_id:6} | {abs(force):11.2f} | {force_type}&quot;)&#10;&#10;# Print numerical stability information&#10;print(&quot;\nNumerical Stability Info:&quot;)&#10;print(&quot;-----------------------&quot;)&#10;print(f&quot;Matrix size: {dof}{dof}&quot;)&#10;print(f&quot;Condition number: {cond:.2e}&quot;)&#10;print(f&quot;Number of members: {len(member_data)}&quot;)&#10;print(f&quot;Maximum force magnitude: {max(abs(f) for f in member_forces.values()):.2f} kips&quot;)&#10;print(f&quot;Maximum displacement: {max_vert_disp_in:.4f} inches&quot;)&#10;&#10;if cond &gt; 1e12:&#10;    print(&quot;\nWARNING: High condition number indicates numerical instability.&quot;)&#10;    print(&quot;\nRECOMMENDATIONS:&quot;)&#10;    if duplicate_nodes:&#10;        for node1, node2 in duplicate_nodes[:3]:  # Show first 3 duplicates&#10;            pos = node_dict[node1]&#10;            print(f&quot;1. The duplicate nodes {node1} and {node2} at ({pos[0]}, {pos[1]}, {pos[2]}) should be merged&quot;)&#10;        print(&quot;2. Update member connectivity to reference the merged nodes&quot;)&#10;    else:&#10;        print(&quot;1. Check for nearly-coincident nodes that might be causing instability&quot;)&#10;        print(&quot;2. Verify member connectivity for proper structural integrity&quot;)&#10;    print(&quot;3. Ensure all supports are properly defined&quot;)&#10;    print(&quot;4. Check for any disconnected parts of the structure&quot;)&#10;&#10;# Display the plot on screen&#10;plt.show()&#10;" />
              <option name="updatedContent" value="import sys&#10;import yaml&#10;import matplotlib.pyplot as plt&#10;from mpl_toolkits.mplot3d import Axes3D&#10;import numpy as np&#10;import os&#10;from matplotlib.backends.backend_pdf import PdfPages&#10;import datetime&#10;import matplotlib.gridspec as gridspec&#10;import matplotlib.cm as cm&#10;from scipy import linalg&#10;&#10;# Load the bridge definition&#10;bridge_file = 'Pratt_Bridge_3D.YAML'&#10;print(f&quot;Loading 3D bridge from {bridge_file}&quot;)&#10;with open(os.path.join(os.path.dirname(__file__), bridge_file), 'r') as file:&#10;    bridge = yaml.safe_load(file)&#10;&#10;# Extract design parameters if present&#10;design_params = bridge.get('design_parameters', {})&#10;min_safety_factor = design_params.get('min_safety_factor', 1.0)&#10;print(f&quot;\nDesign minimum safety factor: {min_safety_factor}&quot;)&#10;&#10;# Extract nodes and members&#10;nodes = bridge['nodes']&#10;members = bridge['members']&#10;supports = bridge['supports']&#10;&#10;# Create a dictionary for easier node lookup and a node_id to index mapping&#10;node_dict = {}&#10;node_to_index = {}  # Maps node_id to its position index (0-based)&#10;for i, node in enumerate(nodes):&#10;    node_id = node['id']&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;    z = float(str(node.get('z', '0 ft')).split()[0])  # Default to 0 if z not present&#10;    node_dict[node_id] = (x, y, z)&#10;    node_to_index[node_id] = i  # Store 0-based index for each node&#10;&#10;print(f&quot;Created node index mapping for {len(node_to_index)} nodes&quot;)&#10;print(f&quot;First few mappings: {list(node_to_index.items())[:5]}&quot;)&#10;print(f&quot;Highest node ID: {max(node_to_index.keys())}&quot;)&#10;&#10;# Check for duplicate nodes with higher precision&#10;print(&quot;\nChecking for duplicate nodes (high precision check)...&quot;)&#10;node_positions = {}&#10;duplicate_nodes = []&#10;duplicate_tolerance = 1e-6  # Tolerance for considering nodes as duplicates (in feet)&#10;&#10;for node_id, pos in node_dict.items():&#10;    # Round to handle potential floating point precision issues&#10;    pos_key = (round(pos[0]/duplicate_tolerance)*duplicate_tolerance,&#10;               round(pos[1]/duplicate_tolerance)*duplicate_tolerance,&#10;               round(pos[2]/duplicate_tolerance)*duplicate_tolerance)&#10;&#10;    if pos_key in node_positions:&#10;        other_node = node_positions[pos_key]&#10;        print(f&quot;WARNING: Nodes {other_node} and {node_id} are at the same position {pos}&quot;)&#10;        print(f&quot;  Node {other_node}: ({node_dict[other_node][0]}, {node_dict[other_node][1]}, {node_dict[other_node][2]})&quot;)&#10;        print(f&quot;  Node {node_id}: ({pos[0]}, {pos[1]}, {pos[2]})&quot;)&#10;        print(&quot;This will cause numerical instability!&quot;)&#10;        duplicate_nodes.append((other_node, node_id))&#10;    else:&#10;        node_positions[pos_key] = node_id&#10;&#10;# Report structural connectivity&#10;print(&quot;\nStructural connectivity check:&quot;)&#10;print(f&quot;Total nodes: {len(node_dict)}&quot;)&#10;print(f&quot;Unique positions: {len(node_positions)}&quot;)&#10;if duplicate_nodes:&#10;    print(f&quot;Found {len(duplicate_nodes)} duplicate node pairs:&quot;)&#10;    for node1, node2 in duplicate_nodes:&#10;        pos = node_dict[node1]&#10;        print(f&quot;  Nodes {node1} and {node2} at position ({pos[0]}, {pos[1]}, {pos[2]})&quot;)&#10;    print(&quot;Duplicate nodes should be merged for numerical stability&quot;)&#10;else:&#10;    print(&quot;No duplicate nodes found - good!&quot;)&#10;&#10;# Check for disconnected parts&#10;print(&quot;\nChecking for member connectivity...&quot;)&#10;node_connections = {node_id: set() for node_id in node_dict}&#10;for member in members:&#10;    if member['i_node'] in node_dict and member['j_node'] in node_dict:&#10;        node_connections[member['i_node']].add(member['j_node'])&#10;        node_connections[member['j_node']].add(member['i_node'])&#10;&#10;# Find isolated nodes&#10;isolated_nodes = [node_id for node_id, connections in node_connections.items() if len(connections) == 0]&#10;if isolated_nodes:&#10;    print(f&quot;WARNING: Found {len(isolated_nodes)} isolated nodes: {isolated_nodes}&quot;)&#10;&#10;# Check connectivity between the two spans&#10;# Nodes at x=100 ft should connect the left and right spans&#10;nodes_at_pier = [node_id for node_id, pos in node_dict.items() if abs(pos[0] - 100) &lt; 0.1]&#10;print(f&quot;\nNodes at center pier (x=100 ft): {sorted(nodes_at_pier)}&quot;)&#10;&#10;# Add function to calculate distances between node pairs&#10;def calculate_distance(point1, point2):&#10;    &quot;&quot;&quot;Calculate Euclidean distance between two 3D points&quot;&quot;&quot;&#10;    dx = point2[0] - point1[0]&#10;    dy = point2[1] - point1[1]&#10;    dz = point2[2] - point1[2]&#10;    return np.sqrt(dx**2 + dy**2 + dz**2)&#10;&#10;def print_all_node_distances(node_dict, output_file=None):&#10;    &quot;&quot;&quot;Calculate and print distances between all node pairs&quot;&quot;&quot;&#10;    # Generate all pairs of nodes&#10;    node_pairs = []&#10;    node_ids = sorted(node_dict.keys())&#10;    &#10;    print(&quot;\nCalculating distances between all node pairs...&quot;)&#10;    total_pairs = len(node_ids) * (len(node_ids) - 1) // 2&#10;    print(f&quot;Total {total_pairs} unique node pairs&quot;)&#10;    &#10;    for i, node1 in enumerate(node_ids):&#10;        for node2 in node_ids[i+1:]:  # Start from i+1 to avoid duplicates&#10;            point1 = node_dict[node1]&#10;            point2 = node_dict[node2]&#10;            distance = calculate_distance(point1, point2)&#10;            node_pairs.append((node1, node2, distance))&#10;    &#10;    # Sort by distance (ascending)&#10;    node_pairs.sort(key=lambda x: x[2])&#10;    &#10;    # Print results (show only first 20 pairs to avoid flooding console)&#10;    print(f&quot;\nNode pair distances (sorted by distance, showing first 20):&quot;)&#10;    print(f&quot;{'Node 1':&lt;6} {'Node 2':&lt;6} {'Distance (ft)':&lt;12}&quot;)&#10;    print(&quot;-&quot; * 30)&#10;    &#10;    for node1, node2, dist in node_pairs[:20]:&#10;        print(f&quot;{node1:&lt;6} {node2:&lt;6} {dist:&lt;12.3f}&quot;)&#10;    &#10;    # Save all results to file if requested&#10;    if output_file:&#10;        with open(output_file, 'w') as f:&#10;            f.write(f&quot;{'Node 1':&lt;6} {'Node 2':&lt;6} {'Distance (ft)':&lt;12}\n&quot;)&#10;            f.write(&quot;-&quot; * 30 + &quot;\n&quot;)&#10;            for node1, node2, dist in node_pairs:&#10;                f.write(f&quot;{node1:&lt;6} {node2:&lt;6} {dist:&lt;12.3f}\n&quot;)&#10;        print(f&quot;\nAll node distances saved to {output_file}&quot;)&#10;    &#10;    return node_pairs&#10;&#10;# Calculate and save distances between all node pairs&#10;timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M%S')&#10;node_distances_file = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_3D_Node_Distances_{timestamp}.txt&quot;)&#10;node_pairs = print_all_node_distances(node_dict, node_distances_file)&#10;&#10;# Check for members that should exist but don't&#10;print(&quot;\nVerifying critical connections:&quot;)&#10;critical_connections = [&#10;    (6, 12, &quot;Central vertical at x=100ft, front&quot;),&#10;    (106, 112, &quot;Central vertical at x=100ft, back&quot;),&#10;    (106, 12, &quot;Diagonal bracing at center pier&quot;)&#10;]&#10;&#10;for i_node, j_node, description in critical_connections:&#10;    found = any((m['i_node'] == i_node and m['j_node'] == j_node) or&#10;                (m['i_node'] == j_node and m['j_node'] == i_node)&#10;                for m in members)&#10;    if not found:&#10;        print(f&quot;  WARNING: Missing critical member {description} between nodes {i_node} and {j_node}&quot;)&#10;    else:&#10;        print(f&quot;  OK: Found {description}&quot;)&#10;&#10;# Define function to get DOF indices for a node (3D: 3 DOFs per node)&#10;def get_dof(node_id):&#10;    if node_id not in node_to_index:&#10;        raise ValueError(f&quot;Node ID {node_id} not found in node index mapping&quot;)&#10;    base = 3 * node_to_index[node_id]  # Use the node index, not the ID&#10;    return base, base + 1, base + 2  # x, y, z DOFs&#10;&#10;# Initialize global stiffness matrix and force vector&#10;num_nodes = len(nodes)&#10;dof = 3 * num_nodes  # Degrees of freedom (x, y, z for each node)&#10;K_global = np.zeros((dof, dof))&#10;F_global = np.zeros(dof)&#10;&#10;print(f&quot;\n3D Analysis: {num_nodes} nodes, {dof} DOFs&quot;)&#10;&#10;# Material properties (A36 steel)&#10;E = 29000.0  # ksi - Young's modulus&#10;&#10;# Define section properties - now load from YAML if available&#10;if 'sections' in bridge:&#10;    sections = {}&#10;    for section in bridge['sections']:&#10;        sec_id = section['id']&#10;        area_str = str(section['area']).split()[0]  # Extract numeric part&#10;        r_str = str(section['r']).split()[0]        # Extract numeric part&#10;        sections[sec_id] = {&#10;            &quot;area&quot;: float(area_str),&#10;            &quot;r&quot;: float(r_str)&#10;        }&#10;    print(&quot;\nLoaded section properties from YAML:&quot;)&#10;    for sec_id, props in sections.items():&#10;        print(f&quot;  Section {sec_id}: Area = {props['area']} in^2, r = {props['r']} in&quot;)&#10;else:&#10;    # Default section properties if not in YAML&#10;    sections = {&#10;        1: {&quot;area&quot;: 7.65, &quot;r&quot;: 4.32},  # W12x26 - area in in^2, r is radius of gyration in inches&#10;        2: {&quot;area&quot;: 9.13, &quot;r&quot;: 3.47}   # W8x31 - area in in^2, r is radius of gyration in inches&#10;    }&#10;    print(&quot;\nUsing default section properties&quot;)&#10;&#10;# Store member data for later reference&#10;member_data = {}&#10;&#10;# Calculate axial stiffness for each member&#10;print(&quot;\nAssembling 3D stiffness matrix...&quot;)&#10;for member in members:&#10;    member_id = member['id']&#10;    start = member['i_node']&#10;    end = member['j_node']&#10;&#10;    # Verify nodes exist in our mapping&#10;    if start not in node_to_index:&#10;        print(f&quot;ERROR: Member {member_id} references non-existent node {start}&quot;)&#10;        continue&#10;    if end not in node_to_index:&#10;        print(f&quot;ERROR: Member {member_id} references non-existent node {end}&quot;)&#10;        continue&#10;&#10;    section_id = member['section']&#10;&#10;    # Get section properties&#10;    section_area = sections[section_id][&quot;area&quot;]  # in&#10;&#10;    # Calculate EA in kip-in (E in ksi, A in in =&gt; EA in kip)&#10;    EA = E * section_area&#10;&#10;    # Get coordinates&#10;    x1, y1, z1 = node_dict[start]&#10;    x2, y2, z2 = node_dict[end]&#10;&#10;    # Calculate length in ft&#10;    dx = x2 - x1&#10;    dy = y2 - y1&#10;    dz = z2 - z1&#10;    length_ft = np.sqrt(dx**2 + dy**2 + dz**2)&#10;&#10;    # Check for zero-length members&#10;    if length_ft &lt; 1e-6:&#10;        print(f&quot;ERROR: Member {member_id} has zero length (nodes {start} to {end})&quot;)&#10;        print(f&quot;  Node {start}: ({x1}, {y1}, {z1})&quot;)&#10;        print(f&quot;  Node {end}: ({x2}, {y2}, {z2})&quot;)&#10;        continue  # Skip this member instead of exiting&#10;&#10;    length_in = length_ft * 12.0  # Convert to inches&#10;&#10;    # Calculate direction cosines for 3D&#10;    cx = dx / length_ft&#10;    cy = dy / length_ft&#10;    cz = dz / length_ft&#10;&#10;    # Store member properties&#10;    member_data[member_id] = {&#10;        &quot;start&quot;: start,&#10;        &quot;end&quot;: end,&#10;        &quot;length_ft&quot;: length_ft,&#10;        &quot;length_in&quot;: length_in,&#10;        &quot;EA&quot;: EA,&#10;        &quot;cx&quot;: cx,&#10;        &quot;cy&quot;: cy,&#10;        &quot;cz&quot;: cz,&#10;        &quot;section_id&quot;: section_id,&#10;        &quot;section_area&quot;: section_area&#10;    }&#10;&#10;    # Debug info for first few members&#10;    if member_id &lt;= 3:&#10;        print(f&quot;Member {member_id}: Length = {length_ft:.2f} ft ({length_in:.2f} in), EA = {EA:.2f} kip&quot;)&#10;        print(f&quot;  Direction cosines: cx = {cx:.4f}, cy = {cy:.4f}, cz = {cz:.4f}&quot;)&#10;&#10;    # Local to global transformation matrix for 3D truss element&#10;    # The transformation matrix is 6x6 for 3D (3 DOFs per node)&#10;    T = np.array([&#10;        [cx, cy, cz, 0,  0,  0],&#10;        [0,  0,  0, cx, cy, cz]&#10;    ])&#10;&#10;    # Element stiffness matrix in local coordinates (for a 3D truss element)&#10;    # k = EA/L in kip/in&#10;    k_axial = EA / length_in&#10;&#10;    k_local = k_axial * np.array([&#10;        [ 1, -1],&#10;        [-1,  1]&#10;    ])&#10;&#10;    # Transform to global coordinates: k_global = T^T * k_local * T&#10;    k_global = T.T @ k_local @ T&#10;&#10;    # Map local DOFs to global DOFs using node indices, not IDs&#10;    dof_start = get_dof(start)&#10;    dof_end = get_dof(end)&#10;    dof_indices = [*dof_start, *dof_end]&#10;&#10;    if member_id &lt;= 3:&#10;        print(f&quot;  DOF indices: {dof_indices}&quot;)&#10;&#10;    # Assemble into global stiffness matrix&#10;    for i in range(6):&#10;        for j in range(6):&#10;            K_global[dof_indices[i], dof_indices[j]] += k_global[i, j]&#10;&#10;# Apply external forces from member loads&#10;print(&quot;\nApplying loads...&quot;)&#10;if 'member_loads' in bridge:&#10;    for load in bridge['member_loads']:&#10;        member_id = load['member_uid']&#10;        if member_id not in member_data:&#10;            print(f&quot;WARNING: Load references non-existent member {member_id}&quot;)&#10;            continue&#10;&#10;        member = next(m for m in members if m['id'] == member_id)&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        # Convert distributed load to equivalent nodal loads&#10;        wi = float(str(load['wi']).split()[0])  # kips/ft&#10;        wj = float(str(load['wj']).split()[0])  # kips/ft&#10;        length = member_data[member_id][&quot;length_ft&quot;]  # ft&#10;&#10;        # For uniform load, apply half to each node in y-direction&#10;        if abs(wi - wj) &lt; 1e-6:  # Uniform load&#10;            force = abs(wi) * length / 2  # kips (make positive)&#10;            _, dof_yi, _ = get_dof(i_node)&#10;            _, dof_yj, _ = get_dof(j_node)&#10;&#10;            # Debug info for first few loads&#10;            if member_id &lt;= 3:&#10;                print(f&quot;Load on member {member_id}: w = {wi} kips/ft, L = {length:.2f} ft&quot;)&#10;                print(f&quot;  Equivalent nodal forces: {force:.2f} kips (downward) at nodes {i_node} and {j_node}&quot;)&#10;&#10;            # Apply downward forces (negative in typical structural convention)&#10;            F_global[dof_yi] -= force  # Negative for downward&#10;            F_global[dof_yj] -= force  # Negative for downward&#10;        else:&#10;            # For non-uniform load (simplified approach)&#10;            force_i = abs(wi) * length / 3  # kips&#10;            force_j = abs(wj) * length / 3  # kips&#10;            _, dof_yi, _ = get_dof(i_node)&#10;            _, dof_yj, _ = get_dof(j_node)&#10;            F_global[dof_yi] -= force_i  # Negative for downward&#10;            F_global[dof_yj] -= force_j  # Negative for downward&#10;&#10;# Apply support constraints&#10;print(&quot;\nApplying support constraints:&quot;)&#10;constrained_dofs = []&#10;for support in supports:&#10;    node_id = support['node']&#10;&#10;    if node_id not in node_to_index:&#10;        print(f&quot;WARNING: Support references non-existent node {node_id}&quot;)&#10;        continue&#10;&#10;    dof_x, dof_y, dof_z = get_dof(node_id)&#10;&#10;    print(f&quot;Support at node {node_id}: ux={support['ux']}, uy={support['uy']}, uz={support.get('uz', 0)}&quot;)&#10;&#10;    if support['ux'] == 1:  # Fixed in x-direction&#10;        constrained_dofs.append(dof_x)&#10;        K_global[dof_x, :] = 0&#10;        K_global[:, dof_x] = 0&#10;        K_global[dof_x, dof_x] = 1&#10;        F_global[dof_x] = 0&#10;&#10;    if support['uy'] == 1:  # Fixed in y-direction&#10;        constrained_dofs.append(dof_y)&#10;        K_global[dof_y, :] = 0&#10;        K_global[:, dof_y] = 0&#10;        K_global[dof_y, dof_y] = 1&#10;        F_global[dof_y] = 0&#10;&#10;    if support.get('uz', 0) == 1:  # Fixed in z-direction&#10;        constrained_dofs.append(dof_z)&#10;        K_global[dof_z, :] = 0&#10;        K_global[:, dof_z] = 0&#10;        K_global[dof_z, dof_z] = 1&#10;        F_global[dof_z] = 0&#10;&#10;print(f&quot;Total constrained DOFs: {len(constrained_dofs)}&quot;)&#10;print(f&quot;Free DOFs: {dof - len(constrained_dofs)}&quot;)&#10;&#10;# Check for zero diagonal elements (indicates singularity)&#10;diag_zeros = np.where(np.abs(np.diag(K_global)) &lt; 1e-10)[0]&#10;if len(diag_zeros) &gt; 0:&#10;    print(f&quot;\nWARNING: Zero diagonal elements detected at DOFs: {diag_zeros}&quot;)&#10;    for dof_idx in diag_zeros:&#10;        # Find which node this DOF belongs to&#10;        node_idx = dof_idx // 3&#10;        # Find the node_id from the index&#10;        node_id = None&#10;        for nid, idx in node_to_index.items():&#10;            if idx == node_idx:&#10;                node_id = nid&#10;                break&#10;        dof_type = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;][dof_idx % 3]&#10;        print(f&quot;  DOF {dof_idx} (Node {node_id}, {dof_type}-direction)&quot;)&#10;&#10;# Check if the stiffness matrix is symmetric (it should be)&#10;is_symmetric = np.allclose(K_global, K_global.T, rtol=1e-5, atol=1e-8)&#10;print(f&quot;\nStiffness matrix is symmetric: {is_symmetric}&quot;)&#10;&#10;# Check for rows/columns that are all zeros (except diagonal)&#10;print(&quot;\nChecking for zero rows/columns in stiffness matrix...&quot;)&#10;zero_rows = []&#10;for i in range(dof):&#10;    row = K_global[i, :]&#10;    if np.sum(np.abs(row)) - np.abs(row[i]) &lt; 1e-10:  # Row has only diagonal element&#10;        zero_rows.append(i)&#10;        # Find which node this DOF belongs to&#10;        node_idx = i // 3&#10;        # Find the node_id from the index&#10;        node_id = None&#10;        for nid, idx in node_to_index.items():&#10;            if idx == node_idx:&#10;                node_id = nid&#10;                break&#10;        dof_type = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;][i % 3]&#10;        print(f&quot;  DOF {i} (Node {node_id}, {dof_type}-direction) has no off-diagonal connections&quot;)&#10;&#10;# Analyze the condition of the matrix&#10;try:&#10;    # Compute the condition number&#10;    cond = np.linalg.cond(K_global)&#10;    print(f&quot;Condition number of stiffness matrix: {cond:.2e}&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        print(&quot;\nWARNING: Very high condition number detected!&quot;)&#10;        print(&quot;The structure may have:&quot;)&#10;        print(&quot;1. Insufficient supports (mechanism)&quot;)&#10;        print(&quot;2. Disconnected parts&quot;)&#10;        print(&quot;3. Numerical scaling issues&quot;)&#10;        print(&quot;4. Duplicate nodes at the same location&quot;)&#10;&#10;        # Additional diagnostics&#10;        print(&quot;\nDiagnostic information:&quot;)&#10;        print(f&quot;- Number of duplicate node positions: {len(duplicate_nodes)}&quot;)&#10;        print(f&quot;- Number of isolated nodes: {len(isolated_nodes)}&quot;)&#10;        print(f&quot;- Number of zero rows/columns: {len(zero_rows)}&quot;)&#10;&#10;        # Check for specific problematic DOFs&#10;        if len(zero_rows) &gt; 0:&#10;            print(&quot;\nNodes with unconnected DOFs:&quot;)&#10;            problematic_nodes = set()&#10;            for dof_idx in zero_rows:&#10;                node_idx = dof_idx // 3&#10;                for nid, idx in node_to_index.items():&#10;                    if idx == node_idx:&#10;                        problematic_nodes.add(nid)&#10;                        break&#10;            print(f&quot;  Nodes with issues: {sorted(problematic_nodes)}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;Could not compute condition number: {e}&quot;)&#10;    cond = float('inf')&#10;&#10;# Apply scaling to improve conditioning&#10;print(&quot;\nAttempting to solve the system...&quot;)&#10;try:&#10;    # For very ill-conditioned systems, try regularization&#10;    if cond &gt; 1e14:&#10;        print(&quot;System is extremely ill-conditioned. Applying regularization...&quot;)&#10;        # Add small diagonal perturbation to improve conditioning&#10;        reg_factor = 1e-8 * np.max(np.abs(np.diag(K_global)))&#10;        K_regularized = K_global + reg_factor * np.eye(dof)&#10;&#10;        try:&#10;            displacements = linalg.solve(K_regularized, F_global, assume_a='sym')&#10;            print(&quot;Regularized solution successful&quot;)&#10;        except:&#10;            # Fall back to least squares&#10;            displacements, residuals, rank, s = linalg.lstsq(K_global, F_global)&#10;            print(f&quot;Least squares solution: rank={rank}/{dof}&quot;)&#10;    else:&#10;        # Try direct solution&#10;        displacements = linalg.solve(K_global, F_global, assume_a='sym')&#10;        print(&quot;Direct solution successful&quot;)&#10;&#10;    # Print first few displacement values for debugging&#10;    print(&quot;\nNodal displacements:&quot;)&#10;    print(&quot;Node | dx (in) | dy (in) | dz (in)&quot;)&#10;    print(&quot;-&quot; * 40)&#10;    for node_id in sorted(list(node_dict.keys()))[:10]:  # First 10 nodes&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        # Convert to inches for display&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        dz_in = displacements[dof_z] * 12&#10;        print(f&quot;{node_id:4} | {dx_in:7.4f} | {dy_in:7.4f} | {dz_in:7.4f}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;All solution methods failed: {e}&quot;)&#10;    print(&quot;Using zero displacements as fallback&quot;)&#10;    displacements = np.zeros(dof)&#10;&#10;# Find maximum vertical displacement&#10;max_vert_disp = 0&#10;max_disp_node = None&#10;for node_id in node_dict:&#10;    _, dof_y, _ = get_dof(node_id)&#10;    # Skip nodes that are supported&#10;    is_supported = any(s['node'] == node_id and s['uy'] == 1 for s in supports)&#10;    if not is_supported:&#10;        disp = abs(displacements[dof_y])&#10;        if disp &gt; max_vert_disp:&#10;            max_vert_disp = disp&#10;            max_disp_node = node_id&#10;&#10;# Convert to inches for display&#10;max_vert_disp_in = max_vert_disp * 12&#10;print(f&quot;\nMaximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}&quot;)&#10;&#10;# Calculate member forces&#10;member_forces = {}&#10;member_stresses = {}&#10;&#10;# Material properties (A36 steel)&#10;Fy = 36.0    # ksi - Yield strength&#10;Fu = 58.0    # ksi - Ultimate strength&#10;safety_factor_tension = 1.67&#10;safety_factor_compression = 1.67&#10;allowable_tension_stress = Fy / safety_factor_tension      # ksi&#10;allowable_compression_stress_max = Fy / safety_factor_compression  # ksi&#10;&#10;# Calculate forces and stresses for each member&#10;for member in members:&#10;    member_id = member['id']&#10;    if member_id not in member_data:&#10;        continue  # Skip members with zero length or missing data&#10;&#10;    mem_data = member_data[member_id]&#10;    start = mem_data[&quot;start&quot;]&#10;    end = mem_data[&quot;end&quot;]&#10;    area = mem_data[&quot;section_area&quot;]  # in&#10;    cx = mem_data[&quot;cx&quot;]&#10;    cy = mem_data[&quot;cy&quot;]&#10;    cz = mem_data[&quot;cz&quot;]&#10;&#10;    # Get displacements at both nodes (in feet)&#10;    dof_x1, dof_y1, dof_z1 = get_dof(start)&#10;    dof_x2, dof_y2, dof_z2 = get_dof(end)&#10;&#10;    # Calculate relative displacement in the axial direction (in feet)&#10;    delta_u1 = displacements[dof_x1] * cx + displacements[dof_y1] * cy + displacements[dof_z1] * cz&#10;    delta_u2 = displacements[dof_x2] * cx + displacements[dof_y2] * cy + displacements[dof_z2] * cz&#10;    delta_axial = delta_u2 - delta_u1&#10;&#10;    # Convert to inches for force calculation&#10;    delta_axial_in = delta_axial * 12&#10;&#10;    # Calculate axial force (F = EA/L * delta)&#10;    EA = mem_data[&quot;EA&quot;]  # kip&#10;    force = (EA / mem_data[&quot;length_in&quot;]) * delta_axial_in  # kips&#10;    member_forces[member_id] = force&#10;&#10;    # Calculate axial stress&#10;    stress = force / area  # kips/in = ksi&#10;    member_stresses[member_id] = stress&#10;&#10;    # Debug output for selected members&#10;    if member_id &lt;= 3 or member_id == 32:&#10;        print(f&quot;\nMember {member_id} analysis:&quot;)&#10;        print(f&quot;  Length = {mem_data['length_ft']:.2f} ft&quot;)&#10;        print(f&quot;  Node {start}: dx = {displacements[dof_x1]*12:.4f} in, dy = {displacements[dof_y1]*12:.4f} in, dz = {displacements[dof_z1]*12:.4f} in&quot;)&#10;        print(f&quot;  Node {end}: dx = {displacements[dof_x2]*12:.4f} in, dy = {displacements[dof_y2]*12:.4f} in, dz = {displacements[dof_z2]*12:.4f} in&quot;)&#10;        print(f&quot;  Delta axial = {delta_axial_in:.4f} in&quot;)&#10;        print(f&quot;  Force = {force:.2f} kips&quot;)&#10;        print(f&quot;  Stress = {stress:.2f} ksi&quot;)&#10;&#10;# Calculate safety factors for all members&#10;member_safety_factors = {}&#10;member_status = {}&#10;&#10;# Define zero force threshold&#10;ZERO_FORCE_THRESHOLD = 0.1  # Consider forces below this threshold as &quot;zero&quot;&#10;&#10;# Replace the problematic part in the safety factors calculation&#10;for member_id, stress in member_stresses.items():&#10;    section_id = member_data[member_id][&quot;section_id&quot;]&#10;    section = sections[section_id]&#10;&#10;    if abs(stress) &lt; ZERO_FORCE_THRESHOLD / section[&quot;area&quot;]:&#10;        # Zero/near-zero stress&#10;        safety_factor = float('inf')&#10;        limit = allowable_tension_stress  # Arbitrary for zero-force members&#10;        status = &quot;OK&quot;&#10;    elif stress &gt;= 0:  # Tension&#10;        safety_factor = allowable_tension_stress / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_tension_stress&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;    else:  # Compression&#10;        # Calculate allowable compression stress based on slenderness&#10;        length_inches = member_data[member_id][&quot;length_in&quot;]&#10;        slenderness = length_inches / section[&quot;r&quot;]&#10;&#10;        if slenderness &gt; 100:  # For slender members&#10;            critical_stress = (np.pi**2 * E) / (slenderness**2)&#10;            allowable_compression = min(allowable_compression_stress_max, critical_stress/safety_factor_compression)&#10;        else:  # For stocky members&#10;            allowable_compression = allowable_compression_stress_max&#10;&#10;        safety_factor = allowable_compression / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_compression&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;&#10;    member_safety_factors[member_id] = safety_factor&#10;    member_status[member_id] = {&#10;        &quot;stress&quot;: stress,&#10;        &quot;allowable&quot;: limit,&#10;        &quot;safety_factor&quot;: safety_factor,&#10;        &quot;status&quot;: status&#10;    }&#10;&#10;# After calculating safety factors, add a summary of members below minimum&#10;members_below_min_sf = []&#10;zero_force_members = []&#10;for member_id, status_info in member_status.items():&#10;    if status_info[&quot;safety_factor&quot;] &lt; min_safety_factor and status_info[&quot;safety_factor&quot;] &lt; 100:&#10;        members_below_min_sf.append({&#10;            'id': member_id,&#10;            'sf': status_info[&quot;safety_factor&quot;],&#10;            'stress': status_info[&quot;stress&quot;],&#10;            'allowable': status_info[&quot;allowable&quot;]&#10;        })&#10;    if abs(member_forces[member_id]) &lt; ZERO_FORCE_THRESHOLD:&#10;        zero_force_members.append(member_id)&#10;&#10;if members_below_min_sf:&#10;    print(f&quot;\n{len(members_below_min_sf)} members have safety factor below {min_safety_factor}:&quot;)&#10;    for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:10]:  # Show worst 10&#10;        print(f&quot;  Member {mem['id']}: SF = {mem['sf']:.2f}, Stress = {abs(mem['stress']):.1f} ksi&quot;)&#10;&#10;if zero_force_members:&#10;    print(f&quot;\n{len(zero_force_members)} zero-force members detected:&quot;)&#10;    print(f&quot;  Members: {sorted(zero_force_members)[:20]}&quot;)  # Show first 20&#10;&#10;# Create figure for the PDF - add timestamp to filenames&#10;# timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M%S')  # Now defined earlier&#10;pdf_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_3D_Analysis_{timestamp}.pdf&quot;)&#10;text_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_3D_Analysis_{timestamp}.txt&quot;)&#10;&#10;# Open the text file for writing the report&#10;with open(text_filename, 'w') as txt_report:&#10;    # Write header information&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(&quot;PRATT BRIDGE STRUCTURAL ANALYSIS REPORT\n&quot;)&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(f&quot;Analysis Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}\n&quot;)&#10;    txt_report.write(f&quot;Input File: {bridge_file}\n&quot;)&#10;    txt_report.write(f&quot;Design Minimum Safety Factor: {min_safety_factor}\n\n&quot;)&#10;&#10;    # Write model statistics&#10;    txt_report.write(&quot;MODEL STATISTICS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Number of nodes: {num_nodes}\n&quot;)&#10;    txt_report.write(f&quot;Number of members: {len(members)}\n&quot;)&#10;    txt_report.write(f&quot;Number of supports: {len(supports)}\n&quot;)&#10;    txt_report.write(f&quot;Degrees of freedom: {dof}\n&quot;)&#10;    txt_report.write(f&quot;Constrained DOFs: {len(constrained_dofs)}\n&quot;)&#10;    txt_report.write(f&quot;Free DOFs: {dof - len(constrained_dofs)}\n\n&quot;)&#10;&#10;    # Write material properties&#10;    txt_report.write(&quot;MATERIAL PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Material: A36 Steel\n&quot;)&#10;    txt_report.write(f&quot;Young's modulus: {E} ksi\n&quot;)&#10;    txt_report.write(f&quot;Yield strength: {Fy} ksi\n&quot;)&#10;    txt_report.write(f&quot;Ultimate strength: {Fu} ksi\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (tension): {safety_factor_tension}\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (compression): {safety_factor_compression}\n\n&quot;)&#10;&#10;    # Write section properties&#10;    txt_report.write(&quot;SECTION PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    for sec_id, props in sections.items():&#10;        txt_report.write(f&quot;Section {sec_id}: Area = {props['area']} in, r = {props['r']} in\n&quot;)&#10;    txt_report.write(&quot;\n&quot;)&#10;&#10;    # Write analysis results summary&#10;    txt_report.write(&quot;ANALYSIS RESULTS SUMMARY\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Maximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}\n&quot;)&#10;    txt_report.write(f&quot;Stiffness matrix condition number: {cond:.2e}\n&quot;)&#10;&#10;    # Calculate critical values&#10;    critical_sf = float('inf')&#10;    critical_member = None&#10;    overstressed_count = 0&#10;    for member_id, status_info in member_status.items():&#10;        sf = status_info[&quot;safety_factor&quot;]&#10;        if sf &lt; critical_sf and sf &lt; 100:&#10;            critical_sf = sf&#10;            critical_member = member_id&#10;        if status_info[&quot;status&quot;] == &quot;OVERSTRESSED&quot;:&#10;            overstressed_count += 1&#10;&#10;    txt_report.write(f&quot;Number of tension members: {sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of compression members: {sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of zero-force members: {sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Overstressed members: {overstressed_count}\n&quot;)&#10;    txt_report.write(f&quot;Maximum member force: {max(abs(f) for f in member_forces.values()):.2f} kips\n&quot;)&#10;    txt_report.write(f&quot;Maximum member stress: {max(abs(s) for s in member_stresses.values()):.2f} ksi\n&quot;)&#10;    txt_report.write(f&quot;Minimum safety factor: {critical_sf:.2f} (Member #{critical_member})\n\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;\nNUMERICAL STABILITY WARNING:\n&quot;)&#10;        txt_report.write(&quot;--------------------------------\n&quot;)&#10;        txt_report.write(f&quot;Condition number ({cond:.2e}) indicates severe numerical instability.\n&quot;)&#10;        txt_report.write(&quot;\nPossible causes:\n&quot;)&#10;        if duplicate_nodes:&#10;            txt_report.write(f&quot;1. Found {len(duplicate_nodes)} duplicate node pairs:\n&quot;)&#10;            for node1, node2 in duplicate_nodes[:5]:  # Show first 5&#10;                txt_report.write(f&quot;   - Nodes {node1} and {node2} at position {node_dict[node1]}\n&quot;)&#10;        if isolated_nodes:&#10;            txt_report.write(f&quot;2. Found {len(isolated_nodes)} isolated nodes\n&quot;)&#10;        if zero_rows:&#10;            txt_report.write(f&quot;3. Found {len(zero_rows)} DOFs with no off-diagonal connections\n&quot;)&#10;        txt_report.write(&quot;\nRecommended fixes:\n&quot;)&#10;        txt_report.write(&quot;- Merge duplicate nodes into single nodes\n&quot;)&#10;        txt_report.write(&quot;- Ensure proper connectivity between structural parts\n&quot;)&#10;        txt_report.write(&quot;- Verify all supports are correctly defined\n&quot;)&#10;        txt_report.write(&quot;- Check member connectivity references\n\n&quot;)&#10;&#10;    # Write detailed member results&#10;    txt_report.write(&quot;DETAILED MEMBER RESULTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Member | Nodes (i-j) | Force (kips) | Stress (ksi) | Type | S.F. | Status\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 80 + &quot;\n&quot;)&#10;&#10;    for member in sorted(members, key=lambda m: m['id']):&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;        stress = member_stresses[member_id]&#10;        sf = member_safety_factors[member_id]&#10;        status = member_status[member_id][&quot;status&quot;]&#10;&#10;        # Fix the text report formatting to use only ASCII&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            force_type = &quot;ZERO&quot;&#10;            sf_text = &quot;inf&quot;&#10;        elif force &gt; 0:&#10;            force_type = &quot;TENSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;        else:&#10;            force_type = &quot;COMPRESSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;&#10;        txt_report.write(&#10;            f&quot;{member_id:6} | {i_node:2}-{j_node:&lt;2} | {abs(force):11.2f} | {abs(stress):10.2f} | {force_type:10} | {sf_text:&gt;5} | {status}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;&#10;    # Write nodal displacements&#10;    txt_report.write(&quot;NODAL DISPLACEMENTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Node | dx (inches) | dy (inches) | dz (inches)\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 40 + &quot;\n&quot;)&#10;&#10;    for node_id in sorted(node_dict.keys()):&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        dz_in = displacements[dof_z] * 12&#10;        txt_report.write(f&quot;{node_id:4} | {dx_in:11.4f} | {dy_in:11.4f} | {dz_in:11.4f}\n&quot;)&#10;&#10;    # Add a section for closest node pairs&#10;    txt_report.write(&quot;\n\nCLOSEST NODE PAIRS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Node 1 | Node 2 | Distance (ft)\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 40 + &quot;\n&quot;)&#10;    &#10;    # Print the 30 closest pairs (excluding zero distances which might be duplicates)&#10;    closest_pairs = [pair for pair in node_pairs if pair[2] &gt; 1e-6]&#10;    for node1, node2, dist in closest_pairs[:30]:&#10;        txt_report.write(f&quot;{node1:6} | {node2:6} | {dist:10.3f}\n&quot;)&#10;        &#10;    txt_report.write(f&quot;\nNote: Complete list of node distances available in {os.path.basename(node_distances_file)}\n\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;    txt_report.write(&quot;RECOMMENDATIONS FOR STRUCTURE REFINEMENT\n&quot;)&#10;    txt_report.write(&quot;----------------------------------------\n&quot;)&#10;&#10;    if members_below_min_sf:&#10;        txt_report.write(f&quot;1. {len(members_below_min_sf)} members have safety factor below the design minimum of {min_safety_factor}:\n&quot;)&#10;        for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:20]:  # Show worst 20&#10;            member = next(m for m in members if m['id'] == mem['id'])&#10;            txt_report.write(f&quot;   - Member {mem['id']} (nodes {member['i_node']}-{member['j_node']}): SF = {mem['sf']:.2f}\n&quot;)&#10;&#10;        # Calculate required section increase&#10;        worst_sf = min(mem['sf'] for mem in members_below_min_sf)&#10;        required_increase = min_safety_factor / worst_sf&#10;        txt_report.write(f&quot;\n   Worst member requires approximately {required_increase:.1f}x increase in capacity.\n&quot;)&#10;        txt_report.write(f&quot;   Consider using larger sections or reducing the loading.\n&quot;)&#10;    else:&#10;        txt_report.write(&quot;1. All members meet the minimum safety factor requirement.\n&quot;)&#10;        txt_report.write(&quot;   Consider optimizing the structure by reducing sections for members with high safety factors.\n&quot;)&#10;&#10;    if max_vert_disp_in &gt; 2.0:  # Assuming 2 inches as a reasonable deflection limit&#10;        txt_report.write(f&quot;2. Consider stiffening the structure to reduce the maximum deflection (currently {max_vert_disp_in:.4f} inches).\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;3. Fix numerical stability issues by reviewing structure connectivity and supports.\n&quot;)&#10;&#10;    txt_report.write(&quot;\nReport generated by pyMAOS Truss Analysis Tool\n&quot;)&#10;&#10;print(f&quot;Text report saved to: {text_filename}&quot;)&#10;&#10;with PdfPages(pdf_filename) as pdf:&#10;    # 1. BRIDGE ANALYSIS SUMMARY page&#10;    fig = plt.figure(figsize=(8.5, 11))&#10;    plt.axis('off')&#10;&#10;    # Add overall bridge status text - avoid using unicode characters&#10;    if overstressed_count == 0:&#10;        status_text = &quot;BRIDGE IS STRUCTURALLY ADEQUATE&quot;&#10;        status_color = 'green'&#10;    else:&#10;        status_text = f&quot;WARNING: BRIDGE HAS {overstressed_count} OVERSTRESSED MEMBERS&quot;&#10;        status_color = 'red'&#10;&#10;    plt.figtext(0.5, 0.9, &quot;BRIDGE ANALYSIS SUMMARY&quot;, ha='center', fontsize=16, weight='bold')&#10;    plt.figtext(0.5, 0.85, status_text, ha='center', fontsize=14, weight='bold', color=status_color)&#10;&#10;    # Add displacement information&#10;    plt.figtext(0.5, 0.78, f&quot;Maximum Vertical Displacement: {max_vert_disp_in:.4f} inches at Node {max_disp_node}&quot;,&#10;                ha='center', fontsize=12)&#10;&#10;    # Add summary statistics&#10;    critical_text = f&quot;Most critical member: #{critical_member} (Safety Factor: {critical_sf:.2f})&quot;&#10;    plt.figtext(0.5, 0.73, critical_text, ha='center', fontsize=12)&#10;&#10;    # Add a summary table of key statistics&#10;    summary_data = [&#10;        [&quot;Total Members&quot;, f&quot;{len(members)}&quot;],&#10;        [&quot;Tension Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Compression Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Zero-Force Members&quot;, f&quot;{sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Overstressed Members&quot;, f&quot;{overstressed_count}&quot;],&#10;        [&quot;Maximum Member Force&quot;, f&quot;{max(abs(f) for f in member_forces.values()):.2f} kips&quot;],&#10;        [&quot;Maximum Member Stress&quot;, f&quot;{max(abs(s) for s in member_stresses.values()):.2f} ksi&quot;],&#10;        [&quot;Minimum Safety Factor&quot;, f&quot;{critical_sf:.2f}&quot;],&#10;        [&quot;Maximum Displacement&quot;, f&quot;{max_vert_disp_in:.4f} inches&quot;],&#10;    ]&#10;&#10;    # Create a table in the middle of the page&#10;    ax = plt.subplot(111)&#10;    ax.axis('off')&#10;    tbl = plt.table(cellText=summary_data, colLabels=[&quot;Metric&quot;, &quot;Value&quot;],&#10;                    loc='center', cellLoc='left')&#10;    tbl.auto_set_font_size(False)&#10;    tbl.set_fontsize(10)&#10;    tbl.scale(1, 1.5)&#10;&#10;    # Add design criteria info&#10;    criteria = (&#10;        f&quot;Design Criteria:\n&quot;&#10;        f&quot;- Material: A36 Steel (Fy = 36 ksi)\n&quot;&#10;        f&quot;- Allowable tension stress: {allowable_tension_stress:.1f} ksi\n&quot;&#10;        f&quot;- Allowable compression stress: Based on member slenderness\n&quot;&#10;        f&quot;- Safety factor: {safety_factor_tension:.2f}&quot;&#10;    )&#10;    plt.figtext(0.5, 0.2, criteria, ha='center', fontsize=10,&#10;                bbox=dict(facecolor='#eeeeee', alpha=0.7, boxstyle='round,pad=0.5'))&#10;&#10;    # Add timestamp&#10;    plt.figtext(0.5, 0.1, f&quot;Analysis completed on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    # Save the summary page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 2. 3D Structure Visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Plot members with color based on safety factors&#10;    cmap = plt.colormaps['RdYlGn']  # Red-Yellow-Green colormap&#10;    norm = plt.Normalize(0.5, 2.0)&#10;&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        safety_factor = member_safety_factors[member_id]&#10;        safety_factor_capped = min(safety_factor, 5.0)  # Cap extremely high values&#10;&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        color = cmap(norm(safety_factor_capped))&#10;&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color=color, linewidth=2)&#10;&#10;    # Plot nodes&#10;    for node_id, (x, y, z) in node_dict.items():&#10;        ax.scatter(x, y, z, c='black', s=20)&#10;&#10;    # Plot supports with different markers&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, z = node_dict[node_id]&#10;        if support['ux'] == 1 and support['uy'] == 1 and support.get('uz', 0) == 1:&#10;            ax.scatter(x, y-5, z, c='red', s=100, marker='s')  # Fixed support&#10;        else:&#10;            ax.scatter(x, y-5, z, c='blue', s=100, marker='o')  # Roller support&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title('3D Pratt Truss Bridge - Safety Factor Visualization')&#10;&#10;    # Add colorbar&#10;    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)&#10;    sm.set_array([])&#10;    cbar = plt.colorbar(sm, ax=ax, label='Safety Factor', shrink=0.6)&#10;&#10;    # Set aspect ratio&#10;    ax.set_box_aspect([2, 0.5, 0.5])  # Adjust based on bridge proportions&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 3. Member Forces - 3D visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Plot members with color based on tension/compression&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        # Color based on force type&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            color = 'black'&#10;            linewidth = 1&#10;        elif force &gt; 0:&#10;            color = 'red'  # Tension&#10;            linewidth = 2 + min(3, abs(force)/50)&#10;        else:&#10;            color = 'blue'  # Compression&#10;            linewidth = 2 + min(3, abs(force)/50)&#10;&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color=color, linewidth=linewidth)&#10;&#10;    # Add legend&#10;    from matplotlib.lines import Line2D&#10;    red_line = Line2D([0], [0], color='red', linewidth=3, label='Tension')&#10;    blue_line = Line2D([0], [0], color='blue', linewidth=3, label='Compression')&#10;    black_line = Line2D([0], [0], color='black', linewidth=1, label='Zero Force')&#10;    ax.legend(handles=[red_line, blue_line, black_line], loc='upper right')&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title('3D Pratt Truss Bridge - Member Forces')&#10;    ax.set_box_aspect([2, 0.5, 0.5])&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 4. 3D Displacement visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Calculate max displacement for scaling&#10;    max_disp_magnitude = 0&#10;    for node_id in node_dict:&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        disp_magnitude = np.sqrt(displacements[dof_x]**2 + displacements[dof_y]**2 + displacements[dof_z]**2)&#10;        max_disp_magnitude = max(max_disp_magnitude, disp_magnitude)&#10;&#10;    # Calculate scale factor&#10;    max_span = max(node_dict[n][0] for n in node_dict) - min(node_dict[n][0] for n in node_dict)&#10;    target_max_disp = max_span * 0.05&#10;&#10;    if max_disp_magnitude &gt; 1e-10:&#10;        scale_factor = target_max_disp / max_disp_magnitude&#10;        scale_magnitude = 10 ** int(np.log10(scale_factor))&#10;        scale_factor = round(scale_factor / scale_magnitude) * scale_magnitude&#10;    else:&#10;        scale_factor = 50.0&#10;&#10;    # Draw original structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color='lightgray', linewidth=1, alpha=0.5)&#10;&#10;    # Draw displaced structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        # Get displacements&#10;        dof_x1, dof_y1, dof_z1 = get_dof(i_node)&#10;        dof_x2, dof_y2, dof_z2 = get_dof(j_node)&#10;&#10;        # Apply scaled displacements&#10;        x1_new = x1 + displacements[dof_x1] * scale_factor&#10;        y1_new = y1 + displacements[dof_y1] * scale_factor&#10;        z1_new = z1 + displacements[dof_z1] * scale_factor&#10;        x2_new = x2 + displacements[dof_x2] * scale_factor&#10;        y2_new = y2 + displacements[dof_y2] * scale_factor&#10;        z2_new = z2 + displacements[dof_z2] * scale_factor&#10;&#10;        ax.plot([x1_new, x2_new], [y1_new, y2_new], [z1_new, z2_new], color='blue', linewidth=1.5)&#10;&#10;    # Highlight max displacement node&#10;    if max_disp_node:&#10;        x, y, z = node_dict[max_disp_node]&#10;        dof_x, dof_y, dof_z = get_dof(max_disp_node)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;        z_new = z + displacements[dof_z] * scale_factor&#10;        ax.scatter(x_new, y_new, z_new, c='red', s=100)&#10;&#10;    # Format scale factor&#10;    if scale_factor &gt;= 1000:&#10;        scale_factor_text = f&quot;{scale_factor/1000:.1f}k&quot;&#10;    elif scale_factor &gt;= 100:&#10;        scale_factor_text = f&quot;{int(scale_factor)}&quot;&#10;    else:&#10;        scale_factor_text = f&quot;{scale_factor:.1f}&quot;&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title(f'3D Pratt Truss Bridge - Displacement (Scale Factor: {scale_factor_text}x)')&#10;    ax.set_box_aspect([2, 0.5, 0.5])&#10;&#10;    # Add legend&#10;    gray_line = Line2D([0], [0], color='lightgray', linewidth=1, alpha=0.5, label='Original')&#10;    blue_line = Line2D([0], [0], color='blue', linewidth=1.5, label='Displaced')&#10;    ax.legend(handles=[gray_line, blue_line], loc='upper right')&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # Add PDF metadata&#10;    d = pdf.infodict()&#10;    d['Title'] = 'Pratt Bridge Structural Analysis'&#10;    d['Author'] = 'pyMAOS Truss Analysis Tool'&#10;    d['Subject'] = 'Structural analysis and reliability assessment'&#10;    d['Keywords'] = 'truss, structural analysis, bridge, reliability'&#10;    d['CreationDate'] = datetime.datetime.now()&#10;    d['ModDate'] = datetime.datetime.now()&#10;&#10;# Print summary of results to console&#10;print(&quot;\nMember Forces Summary:&quot;)&#10;print(&quot;----------------------&quot;)&#10;print(&quot;Member | Force (kips) | Type&quot;)&#10;print(&quot;----------------------&quot;)&#10;for member in sorted(members, key=lambda m: m['id']):&#10;    member_id = member['id']&#10;    force = member_forces[member_id]&#10;    if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;        force_type = &quot;ZERO&quot;&#10;    elif force &gt; 0:&#10;        force_type = &quot;TENSION&quot;&#10;    else:&#10;        force_type = &quot;COMPRESSION&quot;&#10;    print(f&quot;{member_id:6} | {abs(force):11.2f} | {force_type}&quot;)&#10;&#10;# Print numerical stability information&#10;print(&quot;\nNumerical Stability Info:&quot;)&#10;print(&quot;-----------------------&quot;)&#10;print(f&quot;Matrix size: {dof}{dof}&quot;)&#10;print(f&quot;Condition number: {cond:.2e}&quot;)&#10;print(f&quot;Number of members: {len(member_data)}&quot;)&#10;print(f&quot;Maximum force magnitude: {max(abs(f) for f in member_forces.values()):.2f} kips&quot;)&#10;print(f&quot;Maximum displacement: {max_vert_disp_in:.4f} inches&quot;)&#10;&#10;if cond &gt; 1e12:&#10;    print(&quot;\nWARNING: High condition number indicates numerical instability.&quot;)&#10;    print(&quot;\nRECOMMENDATIONS:&quot;)&#10;    if duplicate_nodes:&#10;        for node1, node2 in duplicate_nodes[:3]:  # Show first 3 duplicates&#10;            pos = node_dict[node1]&#10;            print(f&quot;1. The duplicate nodes {node1} and {node2} at ({pos[0]}, {pos[1]}, {pos[2]}) should be merged&quot;)&#10;        print(&quot;2. Update member connectivity to reference the merged nodes&quot;)&#10;    else:&#10;        print(&quot;1. Check for nearly-coincident nodes that might be causing instability&quot;)&#10;        print(&quot;2. Verify member connectivity for proper structural integrity&quot;)&#10;    print(&quot;3. Ensure all supports are properly defined&quot;)&#10;    print(&quot;4. Check for any disconnected parts of the structure&quot;)&#10;&#10;# Display the plot on screen&#10;plt.show()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/show_Pratt_bridge.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/show_Pratt_bridge.py" />
              <option name="originalContent" value="import yaml&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;&#10;# Load the bridge definition&#10;with open('Pratt_Bridge.YAML', 'r') as file:&#10;    bridge = yaml.safe_load(file)&#10;&#10;# Extract nodes and members&#10;nodes = bridge['nodes']&#10;members = bridge['members']&#10;supports = bridge['supports']&#10;&#10;# Create figure&#10;fig, ax = plt.subplots(figsize=(12, 6))&#10;&#10;# Plot members&#10;for member in members:&#10;    i_node = member['i_node']&#10;    j_node = member['j_node']&#10;&#10;    # Find the coordinates for both nodes&#10;    node_i = next(node for node in nodes if node['id'] == i_node)&#10;    node_j = next(node for node in nodes if node['id'] == j_node)&#10;&#10;    # Extract x and y coordinates (removing the 'ft' unit)&#10;    x = [float(str(node_i['x']).split()[0]), float(str(node_j['x']).split()[0])]&#10;    y = [float(str(node_i['y']).split()[0]), float(str(node_j['y']).split()[0])]&#10;&#10;    # Plot the member&#10;    ax.plot(x, y, 'b-', linewidth=2)&#10;&#10;# Plot nodes&#10;for node in nodes:&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;    ax.plot(x, y, 'ro', markersize=6)&#10;&#10;# Plot supports&#10;for support in supports:&#10;    node_id = support['node']&#10;    node = next(node for node in nodes if node['id'] == node_id)&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;&#10;    # Different markers for different support types&#10;    if support['ux'] == 1 and support['uy'] == 1:&#10;        # Pinned support - triangle&#10;        ax.plot(x, y-1, 'ks', markersize=10)&#10;    elif support['ux'] == 0 and support['uy'] == 1:&#10;        # Roller support - circle&#10;        ax.plot(x, y-1, 'ko', markersize=10)&#10;&#10;# Set plot limits and labels&#10;ax.set_xlim(-5, 205)&#10;ax.set_ylim(-5, 25)&#10;ax.set_aspect('equal')&#10;ax.set_xlabel('Length (ft)')&#10;ax.set_ylabel('Height (ft)')&#10;ax.set_title('Pratt Bridge Structure')&#10;ax.grid(True)&#10;&#10;plt.show()" />
              <option name="updatedContent" value="import yaml&#13;&#10;import matplotlib.pyplot as plt&#13;&#10;import numpy as np&#13;&#10;import os&#13;&#10;&#13;&#10;# Load the bridge definition&#13;&#10;bridge_file = 'Pratt_Truss.YAML'&#13;&#10;print(f&quot;Loading bridge from {bridge_file}&quot;)&#13;&#10;with open(os.path.join(os.path.dirname(__file__), bridge_file), 'r') as file:&#13;&#10;    bridge = yaml.safe_load(file)&#13;&#10;&#13;&#10;# Extract nodes and members&#13;&#10;nodes = bridge['nodes']&#13;&#10;members = bridge['members']&#13;&#10;supports = bridge['supports']&#13;&#10;&#13;&#10;# Create a dictionary for easier node lookup&#13;&#10;node_dict = {}&#13;&#10;for node in nodes:&#13;&#10;    node_id = node['id']&#13;&#10;    x = float(str(node['x']).split()[0])&#13;&#10;    y = float(str(node['y']).split()[0])&#13;&#10;    z = float(str(node.get('z', '0 ft')).split()[0])  # Default to 0 if z not present&#13;&#10;    node_dict[node_id] = (x, y, z)&#13;&#10;&#13;&#10;# Define function to get DOF indices for a node&#13;&#10;def get_dof(node_id):&#13;&#10;    return 2 * (node_id - 1), 2 * (node_id - 1) + 1&#13;&#10;&#13;&#10;# Initialize global stiffness matrix and force vector&#13;&#10;num_nodes = len(nodes)&#13;&#10;dof = 2 * num_nodes  # Degrees of freedom (x and y for each node)&#13;&#10;K_global = np.zeros((dof, dof))&#13;&#10;F_global = np.zeros(dof)&#13;&#10;&#13;&#10;# Calculate axial stiffness for each member (assuming EA=1 for simplicity)&#13;&#10;EA = 29000 * 7.65  # ksi * in = kip&#13;&#10;&#13;&#10;# Assemble global stiffness matrix&#13;&#10;for member in members:&#13;&#10;    start = member['i_node']&#13;&#10;    end = member['j_node']&#13;&#10;    x1, y1, _ = node_dict[start]&#13;&#10;    x2, y2, _ = node_dict[end]&#13;&#10;    length = ((x2 - x1)**2 + (y2 - y1)**2)**0.5&#13;&#10;    cos = (x2 - x1) / length&#13;&#10;    sin = (y2 - y1) / length&#13;&#10;&#13;&#10;    # Local stiffness matrix for the member&#13;&#10;    k_local = (EA / length) * np.array([&#13;&#10;        [cos**2, cos*sin, -cos**2, -cos*sin],&#13;&#10;        [cos*sin, sin**2, -cos*sin, -sin**2],&#13;&#10;        [-cos**2, -cos*sin, cos**2, cos*sin],&#13;&#10;        [-cos*sin, -sin**2, cos*sin, sin**2]&#13;&#10;    ])&#13;&#10;&#13;&#10;    # Map local stiffness to global stiffness&#13;&#10;    dof_start = get_dof(start)&#13;&#10;    dof_end = get_dof(end)&#13;&#10;    dof_indices = [*dof_start, *dof_end]&#13;&#10;    for i in range(4):&#13;&#10;        for j in range(4):&#13;&#10;            K_global[dof_indices[i], dof_indices[j]] += k_local[i, j]&#13;&#10;&#13;&#10;# Apply external forces - add loads from member_loads&#13;&#10;F_global = np.zeros(dof)&#13;&#10;if 'member_loads' in bridge:&#13;&#10;    for load in bridge['member_loads']:&#13;&#10;        member_id = load['member_uid']&#13;&#10;        member = next(m for m in members if m['id'] == member_id)&#13;&#10;        i_node = member['i_node']&#13;&#10;        j_node = member['j_node']&#13;&#10;        &#13;&#10;        # Convert distributed load to equivalent nodal loads&#13;&#10;        # Assuming vertical loads only for simplicity&#13;&#10;        wi = float(str(load['wi']).split()[0])&#13;&#10;        wj = float(str(load['wj']).split()[0])&#13;&#10;        length = np.linalg.norm(np.array(node_dict[j_node][:2]) - np.array(node_dict[i_node][:2]))&#13;&#10;        &#13;&#10;        # For uniform load, apply half to each node&#13;&#10;        if abs(wi - wj) &lt; 1e-6:  # Uniform load&#13;&#10;            force = wi * length / 2&#13;&#10;            _, dof_yi = get_dof(i_node)&#13;&#10;            _, dof_yj = get_dof(j_node)&#13;&#10;            F_global[dof_yi] -= force&#13;&#10;            F_global[dof_yj] -= force&#13;&#10;        else:&#13;&#10;            # For non-uniform load (simplified)&#13;&#10;            force_i = wi * length / 3&#13;&#10;            force_j = wj * length / 3&#13;&#10;            _, dof_yi = get_dof(i_node)&#13;&#10;            _, dof_yj = get_dof(j_node)&#13;&#10;            F_global[dof_yi] -= force_i&#13;&#10;            F_global[dof_yj] -= force_j&#13;&#10;&#13;&#10;# Apply support constraints&#13;&#10;for support in supports:&#13;&#10;    node_id = support['node']&#13;&#10;    dof_x, dof_y = get_dof(node_id)&#13;&#10;    &#13;&#10;    if support['ux'] == 1:  # Fixed in x-direction&#13;&#10;        K_global[dof_x, :] = 0&#13;&#10;        K_global[:, dof_x] = 0&#13;&#10;        K_global[dof_x, dof_x] = 1&#13;&#10;        F_global[dof_x] = 0&#13;&#10;        &#13;&#10;    if support['uy'] == 1:  # Fixed in y-direction&#13;&#10;        K_global[dof_y, :] = 0&#13;&#10;        K_global[:, dof_y] = 0&#13;&#10;        K_global[dof_y, dof_y] = 1&#13;&#10;        F_global[dof_y] = 0&#13;&#10;&#13;&#10;# Solve for displacements&#13;&#10;try:&#13;&#10;    displacements = np.linalg.solve(K_global, F_global)&#13;&#10;    print(f&quot;Solved for {len(displacements)//2} node displacements&quot;)&#13;&#10;except np.linalg.LinAlgError:&#13;&#10;    print(&quot;Error: Stiffness matrix is singular. Check support conditions.&quot;)&#13;&#10;    displacements = np.zeros(dof)&#13;&#10;&#13;&#10;# Calculate member forces&#13;&#10;member_forces = {}&#13;&#10;for member in members:&#13;&#10;    member_id = member['id']&#13;&#10;    start = member['i_node']&#13;&#10;    end = member['j_node']&#13;&#10;    x1, y1, _ = node_dict[start]&#13;&#10;    x2, y2, _ = node_dict[end]&#13;&#10;    length = ((x2 - x1)**2 + (y2 - y1)**2)**0.5&#13;&#10;    cos = (x2 - x1) / length&#13;&#10;    sin = (y2 - y1) / length&#13;&#10;&#13;&#10;    dof_start = get_dof(start)&#13;&#10;    dof_end = get_dof(end)&#13;&#10;    dof_indices = [*dof_start, *dof_end]&#13;&#10;&#13;&#10;    # Extract displacements for the member&#13;&#10;    u = displacements[dof_indices]&#13;&#10;&#13;&#10;    # Calculate axial force in the member&#13;&#10;    # Positive force = tension, Negative force = compression&#13;&#10;    force = (EA / length) * np.dot(np.array([-cos, -sin, cos, sin]), u)&#13;&#10;    member_forces[member_id] = force&#13;&#10;&#13;&#10;# Create figure&#13;&#10;fig, ax = plt.subplots(figsize=(14, 7))&#13;&#10;&#13;&#10;# Plot members with color based on tension/compression&#13;&#10;for member in members:&#13;&#10;    member_id = member['id']&#13;&#10;    i_node = member['i_node']&#13;&#10;    j_node = member['j_node']&#13;&#10;    force = member_forces[member_id]&#13;&#10;&#13;&#10;    # Find the coordinates for both nodes&#13;&#10;    x1, y1, _ = node_dict[i_node]&#13;&#10;    x2, y2, _ = node_dict[j_node]&#13;&#10;    x = [x1, x2]&#13;&#10;    y = [y1, y2]&#13;&#10;&#13;&#10;    # Color: red for tension, blue for compression&#13;&#10;    if force &gt; 0:&#13;&#10;        color = 'red'  # Tension&#13;&#10;        linestyle = '-'&#13;&#10;        linewidth = 2 + min(5, abs(force)/20)  # Scale width with force magnitude&#13;&#10;    else:&#13;&#10;        color = 'blue'  # Compression&#13;&#10;        linestyle = '-'&#13;&#10;        linewidth = 2 + min(5, abs(force)/20)  # Scale width with force magnitude&#13;&#10;&#13;&#10;    # Plot the member&#13;&#10;    ax.plot(x, y, color=color, linestyle=linestyle, linewidth=linewidth)&#13;&#10;    &#13;&#10;    # Add force label at midpoint&#13;&#10;    mid_x = (x1 + x2) / 2&#13;&#10;    mid_y = (y1 + y2) / 2&#13;&#10;    ax.text(mid_x, mid_y, f&quot;{abs(force):.1f}&quot;, &#13;&#10;            fontsize=8, ha='center', va='center', &#13;&#10;            bbox=dict(facecolor='white', alpha=0.7, pad=1))&#13;&#10;&#13;&#10;# Plot nodes&#13;&#10;for node_id, (x, y, _) in node_dict.items():&#13;&#10;    ax.plot(x, y, 'ko', markersize=6)&#13;&#10;    ax.text(x+0.5, y+0.5, f&quot;{node_id}&quot;, fontsize=9)&#13;&#10;&#13;&#10;# Plot supports&#13;&#10;for support in supports:&#13;&#10;    node_id = support['node']&#13;&#10;    x, y, _ = node_dict[node_id]&#13;&#10;&#13;&#10;    # Different markers for different support types&#13;&#10;    if support['ux'] == 1 and support['uy'] == 1:&#13;&#10;        # Pinned support - triangle&#13;&#10;        ax.plot(x, y-1, 'ks', markersize=10)&#13;&#10;    elif support['ux'] == 0 and support['uy'] == 1:&#13;&#10;        # Roller support - circle&#13;&#10;        ax.plot(x, y-1, 'ko', markersize=10)&#13;&#10;&#13;&#10;# Add legend&#13;&#10;red_line = plt.Line2D([0], [0], color='red', linewidth=3, label='Tension')&#13;&#10;blue_line = plt.Line2D([0], [0], color='blue', linewidth=3, label='Compression')&#13;&#10;ax.legend(handles=[red_line, blue_line], loc='upper right')&#13;&#10;&#13;&#10;# Set plot limits and labels&#13;&#10;max_x = max(node_dict[n][0] for n in node_dict)&#13;&#10;max_y = max(node_dict[n][1] for n in node_dict)&#13;&#10;ax.set_xlim(-5, max_x + 5)&#13;&#10;ax.set_ylim(-5, max_y + 5)&#13;&#10;ax.set_aspect('equal')&#13;&#10;ax.set_xlabel('Length (ft)')&#13;&#10;ax.set_ylabel('Height (ft)')&#13;&#10;ax.set_title('Pratt Truss Bridge Analysis - Red=Tension, Blue=Compression')&#13;&#10;ax.grid(True)&#13;&#10;&#13;&#10;# Print summary of results&#13;&#10;print(&quot;\nMember Forces Summary:&quot;)&#13;&#10;print(&quot;----------------------&quot;)&#13;&#10;print(&quot;Member | Force (kips) | Type&quot;)&#13;&#10;print(&quot;----------------------&quot;)&#13;&#10;for member in sorted(members, key=lambda m: m['id']):&#13;&#10;    member_id = member['id']&#13;&#10;    force = member_forces[member_id]&#13;&#10;    force_type = &quot;TENSION&quot; if force &gt; 0 else &quot;COMPRESSION&quot;&#13;&#10;    print(f&quot;{member_id:6} | {abs(force):11.2f} | {force_type}&quot;)&#13;&#10;&#13;&#10;plt.tight_layout()&#13;&#10;plt.show()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>