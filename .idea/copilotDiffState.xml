<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pyMAOS/loading/axial_loads.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/loading/axial_loads.py" />
              <option name="originalContent" value="import pint&#10;from typing import TYPE_CHECKING, Any&#10;from pyMAOS.loading.piecewisePolinomial import PiecewisePolynomial&#10;&#10;# Use TYPE_CHECKING to avoid runtime imports&#10;if TYPE_CHECKING:&#10;    from pyMAOS.frame2d import R2Frame&#10;&#10;&#10;class R2_Axial_Load:&#10;    def __init__(self, p: pint.Quantity, a: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        self.p = p&#10;        self.a = a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.A = member.section.Area&#10;&#10;        self.EA = self.E * self.A&#10;&#10;        self.kind = &quot;AXIAL_POINT&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Simple End Reactions&#10;        self.Rix = -1 * self.p&#10;        self.Rjx = 0&#10;&#10;        # Constants of Integration&#10;        p = self.p&#10;        a = self.a&#10;&#10;        self.c1 = 0&#10;        self.c2 = p * a&#10;&#10;        # Piecewise Functions&#10;        # Each piecewise function uses the following format:&#10;        # [coefficients_list, domain_bounds]&#10;        # where coefficients_list contains polynomial coefficients in ascending order [c0, c01, c02,...]&#10;        # representing c0 + c01*x + c02*x^2 + ...&#10;        # and domain_bounds are [start_x, end_x] for the applicable region&#10;        # [co....cn x^n] [xa, xb]&#10;        Ax = [&#10;            [[-1 * self.Rix], [0, self.a]],&#10;            [[-1 * self.Rix - self.p], [self.a, self.L]],&#10;        ]&#10;&#10;        Dx = [&#10;            [[self.c1, -1 * self.Rix], [0, self.a]],&#10;            [[self.c2, -1 * self.Rix - self.p], [self.a, self.L]],&#10;        ]&#10;&#10;        Dx[0][0] = [i / self.EA for i in Dx[0][0]]&#10;        Dx[1][0] = [i / self.EA for i in Dx[1][0]]&#10;        print(&quot;Dx=&quot;,Dx,sep=&quot;\n&quot;)&#10;        self.Wx = PiecewisePolynomial()  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        self.Ax = PiecewisePolynomial(Ax); print(&quot;Ax:&quot;, self.Ax, sep=&quot;\n&quot;)&#10;        self.Dx = PiecewisePolynomial(Dx); print(&quot;Dx:&quot;, self.Dx, sep=&quot;\n&quot;)&#10;        self.Vy = PiecewisePolynomial()&#10;        self.Mz = PiecewisePolynomial()&#10;        self.Sz = PiecewisePolynomial()&#10;        self.Dy = PiecewisePolynomial()&#10;&#10;    # def integration_constants(self):&#10;    #     p = self.p&#10;    #     a = self.a&#10;    #&#10;    #     self.c1 = 0&#10;    #     self.c2 = p * a&#10;&#10;    def FEF(self):&#10;        p = self.p&#10;        a = self.a&#10;        L = self.L&#10;&#10;        Rix = (p * (a - L)) / L&#10;        Rjx = (-1 * p * a) / L&#10;&#10;        # Print forces in both SI and display units&#10;        from pyMAOS.pymaos_units import convert_to_display_units&#10;        Rix_display = convert_to_display_units(Rix, 'force')&#10;        Rjx_display = convert_to_display_units(Rjx, 'force')&#10;        import pyMAOS.pymaos_units as units&#10;        # Then use units.DISPLAY_UNITS which will reflect the current value&#10;        print(f&quot;Axial reactions - SI: Rix={Rix:.3f} N, Rjx={Rjx:.3f} N&quot;)&#10;        print(f&quot;Axial reactions - Display: Rix={Rix_display:.3f} {units.DISPLAY_UNITS['force']}, &quot;&#10;              f&quot;Rjx={Rjx_display:.3f} {units.DISPLAY_UNITS['force']}&quot;)&#10;&#10;        return [Rix, 0, 0, Rjx, 0, 0]&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of an axial point load.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Axial Point Load ({self.loadcase}): &quot;&#10;                f&quot;p={self.p:.3f} at x={self.a:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of axial response with ASCII charts.&#10;&#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;        import sys&#10;        from pyMAOS import unit_manager&#10;&#10;        # Get current unit system directly from the manager&#10;        current_units = unit_manager.get_current_units()&#10;        system_name = unit_manager.get_system_name()&#10;&#10;        print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        print(f&quot;Axial reactions: Rix = {self.Rix:.3f}, Rjx = {self.Rjx:.3f}&quot;)&#10;&#10;        # Define regions for before and after the load point&#10;        regions = [(unit_manager.ureg.Quantity(0, unit_manager.INTERNAL_LENGTH_UNIT), self.a),&#10;                   (self.a, self.L)]&#10;        region_names = [&quot;Before Load [0 to a]&quot;, &quot;After Load [a to L]&quot;]&#10;&#10;        # Create sampling points&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                print(f&quot;Region {i+1} ({region_names[i]}): {points}&quot;)&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;&#10;        # Convert to numpy array&#10;        x_array = np.array(all_x, dtype=object)&#10;&#10;        # Calculate function values using vectorized evaluation if available&#10;        ax_values = self.Ax.evaluate_vectorized(x_array) if hasattr(self.Ax, 'evaluate_vectorized') else [self.Ax.evaluate(x) for x in all_x]&#10;        dx_values = self.Dx.evaluate_vectorized(x_array) if hasattr(self.Dx, 'evaluate_vectorized') else [self.Dx.evaluate(x) for x in all_x]&#10;&#10;        # Print ASCII charts&#10;        self._print_ascii_chart(&quot;Axial Force (Ax)&quot;, all_x, ax_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Axial Displacement (Dx)&quot;, all_x, dx_values, regions, chart_width, chart_height)&#10;&#10;        # Print table of values at key points&#10;        print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;        print(f&quot;{'Position':15} {'Axial Force':20} {'Axial Displacement':20}&quot;)&#10;        print(&quot;-&quot; * 60)&#10;        for x in [0, self.a, self.L]:&#10;            print(f&quot;{x:15.3f} {self.Ax.evaluate(x):20.3f} {self.Dx.evaluate(x):20.3e}&quot;)&#10;&#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Filter out NaN values before finding min/max&#10;        valid_indices = []&#10;        valid_y_values = []&#10;        for i, y in enumerate(y_values):&#10;            # Check if y is NaN (including Quantity objects with NaN magnitude)&#10;            is_nan = False&#10;            if hasattr(y, 'magnitude'):&#10;                is_nan = np.isnan(y.magnitude)&#10;            else:&#10;                is_nan = np.isnan(y) if isinstance(y, (int, float)) else False&#10;&#10;            if not is_nan:&#10;                valid_indices.append(i)&#10;                valid_y_values.append(y)&#10;&#10;        # If no valid values, skip plotting&#10;        if len(valid_y_values) == 0:&#10;            print(&quot;No valid data points to plot (all values are NaN)&quot;)&#10;            return&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(valid_y_values)&#10;        max_y = max(valid_y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;        range_y = max_y - min_y&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Skip NaN values&#10;            if hasattr(y, 'magnitude'):&#10;                if np.isnan(y.magnitude):&#10;                    continue&#10;            elif isinstance(y, (int, float)) and np.isnan(y):&#10;                continue&#10;&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart - avoid NaN issues&#10;            try:&#10;                y_normalized = (y - min_y) / range_y&#10;                y_pos = height - 1 - int(y_normalized * (height - 1))&#10;                y_pos = min(height - 1, max(0, y_pos))&#10;                chart[y_pos][x_pos] = '*'&#10;            except (ValueError, TypeError, ZeroDivisionError) as e:&#10;                print(f&quot;Warning: Could not plot point at x={x}, y={y}: {e}&quot;)&#10;                continue&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        from pyMAOS import unit_manager&#10;        print(f&quot;Region boundaries: [{unit_manager.ureg.Quantity(0, self.a.units)}, {self.a:.2f}, {self.L:.2f}]&quot;)&#10;&#10;class R2_Axial_Linear_Load:&#10;    def __init__(self, w1, w2, a, b, member, loadcase=&quot;D&quot;):&#10;        self.w1 = w1&#10;        self.w2 = w2&#10;        self.a = a&#10;        self.b = b&#10;        self.c = b - a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.A = member.section.Area&#10;&#10;        self.EA = self.E * self.A&#10;&#10;        self.kind = &quot;AXIAL_LINE&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Simple End Reactions&#10;        self.W = 0.5 * self.c * (self.w2 + self.w1)&#10;&#10;        self.Rix = -1 * self.W&#10;        self.Rjx = 0&#10;&#10;        # Constants of Integration&#10;        self.integration_constants()&#10;&#10;        # Piecewise Functions&#10;        # [co....cn x^n] [xa, xb]&#10;        Wx = [&#10;            [[0], [0, self.a]],&#10;            [&#10;                [&#10;                    ((-1 * self.a * self.w2) - (self.c * self.w1) - (self.a * self.w1))&#10;                    / self.c,&#10;                    (self.w2 - self.w1) / self.c,&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[0], [self.b, self.L]],&#10;        ]&#10;&#10;        Ax = [&#10;            [[-1 * self.Rix], [0, self.a]],&#10;            [&#10;                [&#10;                    self.c1,&#10;                    (self.a * self.w2 - self.b * self.w1) / (self.c),&#10;                    -1 * (self.w2 - self.w1) / (2 * self.c),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[-1 * self.Rix - self.W], [self.b, self.L]],&#10;        ]&#10;&#10;        Dx = [&#10;            [[self.c2, -1 * self.Rix], [0, self.a]],&#10;            [&#10;                [&#10;                    self.c3,&#10;                    self.c1,&#10;                    ((self.a * self.w2 - self.b * self.w1)) / (2 * self.c),&#10;                    -1 * ((self.w2 - self.w1)) / (6 * self.c),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c4, -1 * self.Rix - self.W], [self.b, self.L]],&#10;        ]&#10;&#10;        Dx[0][0] = [i / self.EA for i in Dx[0][0]]&#10;        Dx[1][0] = [i / self.EA for i in Dx[1][0]]&#10;        Dx[2][0] = [i / self.EA for i in Dx[2][0]]&#10;&#10;        self.Wx = PiecewisePolynomial(Wx)  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        self.Ax = PiecewisePolynomial(Ax)&#10;        self.Dx = PiecewisePolynomial(Dx)&#10;        self.Vy = PiecewisePolynomial()&#10;        self.Mz = PiecewisePolynomial()&#10;        self.Sz = PiecewisePolynomial()&#10;        self.Dy = PiecewisePolynomial()&#10;&#10;    def integration_constants(self):&#10;        w1 = self.w1&#10;        w2 = self.w2&#10;        a = self.a&#10;        b = self.b&#10;        Ri = self.Rix&#10;&#10;        self.c1 = -(&#10;            (a * a * w2 - 2 * a * b * w1 + a * a * w1 + 2 * Ri * b - 2 * Ri * a)&#10;            / (2 * (b - a))&#10;        )&#10;        self.c2 = 0&#10;        self.c3 = (a * a * (a * w2 - 3 * b * w1 + 2 * a * w1)) / (6 * (b - a))&#10;        self.c4 = (&#10;            (2 * b * b - a * b - a * a) * w2 + (b * b + a * b - 2 * a * a) * w1&#10;        ) / 6&#10;&#10;    def FEF(self):&#10;        w1 = self.w1&#10;        w2 = self.w2&#10;        a = self.a&#10;        b = self.b&#10;        L = self.L&#10;&#10;        Rix = (&#10;            (b - a)&#10;            * (2 * b * w2 + a * w2 - 3 * L * w2 + b * w1 + 2 * a * w1 - 3 * L * w1)&#10;        ) / (6 * L)&#10;        Rjx = -1 * (((b - a) * (2 * b * w2 + a * w2 + b * w1 + 2 * a * w1)) / (6 * L))&#10;&#10;        return [Rix, 0, 0, Rjx, 0, 0]&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of an axial linear load.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Axial Linear Load ({self.loadcase}): &quot;&#10;                f&quot;w1={self.w1:.3f}, w2={self.w2:.3f}, &quot;&#10;                f&quot;from x={self.a:.3f} to x={self.b:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of axial response with ASCII charts.&#10;&#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;        import sys&#10;        from pyMAOS import unit_manager&#10;&#10;        # Get current unit system directly from the manager&#10;        current_units = unit_manager.get_current_units()&#10;        system_name = unit_manager.get_system_name()&#10;&#10;        print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        print(f&quot;Axial reactions: Rix = {self.Rix:.3f}, Rjx = {self.Rjx:.3f}&quot;)&#10;&#10;        # Define regions for before and after the load point&#10;        regions = [(unit_manager.ureg.Quantity(0, unit_manager.INTERNAL_LENGTH_UNIT), self.a),&#10;                   (self.a, self.L)]&#10;        region_names = [&quot;Before Load [0 to a]&quot;, &quot;After Load [a to L]&quot;]&#10;&#10;        # Create sampling points&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                print(f&quot;Region {i+1} ({region_names[i]}): {points}&quot;)&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;&#10;        # Convert to numpy array&#10;        x_array = np.array(all_x, dtype=object)&#10;&#10;        # Calculate function values using vectorized evaluation if available&#10;        ax_values = self.Ax.evaluate_vectorized(x_array) if hasattr(self.Ax, 'evaluate_vectorized') else [self.Ax.evaluate(x) for x in all_x]&#10;        dx_values = self.Dx.evaluate_vectorized(x_array) if hasattr(self.Dx, 'evaluate_vectorized') else [self.Dx.evaluate(x) for x in all_x]&#10;&#10;        # Print ASCII charts&#10;        self._print_ascii_chart(&quot;Axial Force (Ax)&quot;, all_x, ax_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Axial Displacement (Dx)&quot;, all_x, dx_values, regions, chart_width, chart_height)&#10;&#10;        # Print table of values at key points&#10;        print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;        print(f&quot;{'Position':15} {'Axial Force':20} {'Axial Displacement':20}&quot;)&#10;        print(&quot;-&quot; * 60)&#10;        for x in [0, self.a, self.L]:&#10;            print(f&quot;{x:15.3f} {self.Ax.evaluate(x):20.3f} {self.Dx.evaluate(x):20.3e}&quot;)&#10;&#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Filter out NaN values before finding min/max&#10;        valid_indices = []&#10;        valid_y_values = []&#10;        for i, y in enumerate(y_values):&#10;            # Check if y is NaN (including Quantity objects with NaN magnitude)&#10;            is_nan = False&#10;            if hasattr(y, 'magnitude'):&#10;                is_nan = np.isnan(y.magnitude)&#10;            else:&#10;                is_nan = np.isnan(y) if isinstance(y, (int, float)) else False&#10;&#10;            if not is_nan:&#10;                valid_indices.append(i)&#10;                valid_y_values.append(y)&#10;&#10;        # If no valid values, skip plotting&#10;        if len(valid_y_values) == 0:&#10;            print(&quot;No valid data points to plot (all values are NaN)&quot;)&#10;            return&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(valid_y_values)&#10;        max_y = max(valid_y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;        range_y = max_y - min_y&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Skip NaN values&#10;            if hasattr(y, 'magnitude'):&#10;                if np.isnan(y.magnitude):&#10;                    continue&#10;            elif isinstance(y, (int, float)) and np.isnan(y):&#10;                continue&#10;&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart - avoid NaN issues&#10;            try:&#10;                y_normalized = (y - min_y) / range_y&#10;                y_pos = height - 1 - int(y_normalized * (height - 1))&#10;                y_pos = min(height - 1, max(0, y_pos))&#10;                chart[y_pos][x_pos] = '*'&#10;            except (ValueError, TypeError, ZeroDivisionError) as e:&#10;                print(f&quot;Warning: Could not plot point at x={x}, y={y}: {e}&quot;)&#10;                continue&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        from pyMAOS import unit_manager&#10;        print(f&quot;Region boundaries: [{unit_manager.ureg.Quantity(0, self.a.units)}, {self.a:.2f}, {self.L:.2f}]&quot;)" />
              <option name="updatedContent" value="import pint&#10;from typing import TYPE_CHECKING, Any&#10;from pyMAOS.loading.piecewisePolinomial import PiecewisePolynomial&#10;import numpy as np&#10;import pyMAOS&#10;from pyMAOS import unit_manager&#10;&#10;# Use TYPE_CHECKING to avoid runtime imports&#10;if TYPE_CHECKING:&#10;    from pyMAOS.frame2d import R2Frame&#10;&#10;&#10;class R2_Axial_Load:&#10;    def __init__(self, p: pint.Quantity, a: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        self.p = p&#10;        self.a = a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.A = member.section.Area&#10;&#10;        self.EA = self.E * self.A&#10;&#10;        self.kind = &quot;AXIAL_POINT&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Simple End Reactions&#10;        self.Rix = -1 * self.p&#10;        self.Rjx = 0&#10;&#10;        # Constants of Integration&#10;        p = self.p&#10;        a = self.a&#10;&#10;        self.c1 = 0&#10;        self.c2 = p * a&#10;&#10;        # Piecewise Functions using wrapped ndarrays&#10;        # Each piecewise function uses the following format:&#10;        # [coefficients_list, domain_bounds]&#10;        # where coefficients_list contains polynomial coefficients in ascending order [c0, c01, c02,...]&#10;        # representing c0 + c01*x + c02*x^2 + ...&#10;        # and domain_bounds are [start_x, end_x] for the applicable region&#10;        # [co....cn x^n] [xa, xb]&#10;        Ax = [&#10;            [[pyMAOS.unit_manager.ureg.Quantity(np.array([-1 * self.Rix.magnitude]), self.Rix.units)], &#10;             [pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT), self.a]],&#10;            [[pyMAOS.unit_manager.ureg.Quantity(np.array([-1 * self.Rix.magnitude - self.p.magnitude]), self.Rix.units)], &#10;             [self.a, self.L]],&#10;        ]&#10;&#10;        Dx = [&#10;            [[pyMAOS.unit_manager.ureg.Quantity(np.array([self.c1.magnitude]), self.c1.units), &#10;              pyMAOS.unit_manager.ureg.Quantity(np.array([-1 * self.Rix.magnitude]), self.Rix.units)], &#10;             [pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT), self.a]],&#10;            [[pyMAOS.unit_manager.ureg.Quantity(np.array([self.c2.magnitude]), self.c2.units), &#10;              pyMAOS.unit_manager.ureg.Quantity(np.array([-1 * self.Rix.magnitude - self.p.magnitude]), self.Rix.units)], &#10;             [self.a, self.L]],&#10;        ]&#10;&#10;        # Apply EA division using numpy operations&#10;        Dx[0][0] = pyMAOS.unit_manager.ureg.Quantity(&#10;            np.array([coef.magnitude for coef in Dx[0][0]]) / self.EA.magnitude,&#10;            f&quot;{Dx[0][0][0].units}/{self.EA.units}&quot;&#10;        )&#10;        Dx[1][0] = pyMAOS.unit_manager.ureg.Quantity(&#10;            np.array([coef.magnitude for coef in Dx[1][0]]) / self.EA.magnitude,&#10;            f&quot;{Dx[1][0][0].units}/{self.EA.units}&quot;&#10;        )&#10;        print(&quot;Dx=&quot;,Dx,sep=&quot;\n&quot;)&#10;        self.Wx = PiecewisePolynomial()  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        self.Ax = PiecewisePolynomial(Ax); print(&quot;Ax:&quot;, self.Ax, sep=&quot;\n&quot;)&#10;        self.Dx = PiecewisePolynomial(Dx); print(&quot;Dx:&quot;, self.Dx, sep=&quot;\n&quot;)&#10;        self.Vy = PiecewisePolynomial()&#10;        self.Mz = PiecewisePolynomial()&#10;        self.Sz = PiecewisePolynomial()&#10;        self.Dy = PiecewisePolynomial()&#10;&#10;    # def integration_constants(self):&#10;    #     p = self.p&#10;    #     a = self.a&#10;    #&#10;    #     self.c1 = 0&#10;    #     self.c2 = p * a&#10;&#10;    def FEF(self):&#10;        p = self.p&#10;        a = self.a&#10;        L = self.L&#10;&#10;        Rix = (p * (a - L)) / L&#10;        Rjx = (-1 * p * a) / L&#10;&#10;        # Print forces in both SI and display units&#10;        from pyMAOS.pymaos_units import convert_to_display_units&#10;        Rix_display = convert_to_display_units(Rix, 'force')&#10;        Rjx_display = convert_to_display_units(Rjx, 'force')&#10;        import pyMAOS.pymaos_units as units&#10;        # Then use units.DISPLAY_UNITS which will reflect the current value&#10;        print(f&quot;Axial reactions - SI: Rix={Rix:.3f} N, Rjx={Rjx:.3f} N&quot;)&#10;        print(f&quot;Axial reactions - Display: Rix={Rix_display:.3f} {units.DISPLAY_UNITS['force']}, &quot;&#10;              f&quot;Rjx={Rjx_display:.3f} {units.DISPLAY_UNITS['force']}&quot;)&#10;&#10;        # Return a properly wrapped ndarray with units&#10;        return pyMAOS.unit_manager.ureg.Quantity(&#10;            np.array([Rix.magnitude, 0, 0, Rjx.magnitude, 0, 0]),&#10;            pyMAOS.unit_manager.INTERNAL_FORCE_UNIT&#10;        )&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of an axial point load.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Axial Point Load ({self.loadcase}): &quot;&#10;                f&quot;p={self.p:.3f} at x={self.a:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of axial response with ASCII charts.&#10;&#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;        import sys&#10;        from pyMAOS import unit_manager&#10;&#10;        # Get current unit system directly from the manager&#10;        current_units = unit_manager.get_current_units()&#10;        system_name = unit_manager.get_system_name()&#10;&#10;        print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        print(f&quot;Axial reactions: Rix = {self.Rix:.3f}, Rjx = {self.Rjx:.3f}&quot;)&#10;&#10;        # Define regions for before and after the load point&#10;        regions = [(unit_manager.ureg.Quantity(0, unit_manager.INTERNAL_LENGTH_UNIT), self.a),&#10;                   (self.a, self.L)]&#10;        region_names = [&quot;Before Load [0 to a]&quot;, &quot;After Load [a to L]&quot;]&#10;&#10;        # Create sampling points&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                print(f&quot;Region {i+1} ({region_names[i]}): {points}&quot;)&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;&#10;        # Convert to numpy array&#10;        x_array = np.array(all_x, dtype=object)&#10;&#10;        # Calculate function values using vectorized evaluation if available&#10;        ax_values = self.Ax.evaluate_vectorized(x_array) if hasattr(self.Ax, 'evaluate_vectorized') else [self.Ax.evaluate(x) for x in all_x]&#10;        dx_values = self.Dx.evaluate_vectorized(x_array) if hasattr(self.Dx, 'evaluate_vectorized') else [self.Dx.evaluate(x) for x in all_x]&#10;&#10;        # Print ASCII charts&#10;        self._print_ascii_chart(&quot;Axial Force (Ax)&quot;, all_x, ax_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Axial Displacement (Dx)&quot;, all_x, dx_values, regions, chart_width, chart_height)&#10;&#10;        # Print table of values at key points&#10;        print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;        print(f&quot;{'Position':15} {'Axial Force':20} {'Axial Displacement':20}&quot;)&#10;        print(&quot;-&quot; * 60)&#10;        for x in [0, self.a, self.L]:&#10;            print(f&quot;{x:15.3f} {self.Ax.evaluate(x):20.3f} {self.Dx.evaluate(x):20.3e}&quot;)&#10;&#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Filter out NaN values before finding min/max&#10;        valid_indices = []&#10;        valid_y_values = []&#10;        for i, y in enumerate(y_values):&#10;            # Check if y is NaN (including Quantity objects with NaN magnitude)&#10;            is_nan = False&#10;            if hasattr(y, 'magnitude'):&#10;                is_nan = np.isnan(y.magnitude)&#10;            else:&#10;                is_nan = np.isnan(y) if isinstance(y, (int, float)) else False&#10;&#10;            if not is_nan:&#10;                valid_indices.append(i)&#10;                valid_y_values.append(y)&#10;&#10;        # If no valid values, skip plotting&#10;        if len(valid_y_values) == 0:&#10;            print(&quot;No valid data points to plot (all values are NaN)&quot;)&#10;            return&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(valid_y_values)&#10;        max_y = max(valid_y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;        range_y = max_y - min_y&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Skip NaN values&#10;            if hasattr(y, 'magnitude'):&#10;                if np.isnan(y.magnitude):&#10;                    continue&#10;            elif isinstance(y, (int, float)) and np.isnan(y):&#10;                continue&#10;&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart - avoid NaN issues&#10;            try:&#10;                y_normalized = (y - min_y) / range_y&#10;                y_pos = height - 1 - int(y_normalized * (height - 1))&#10;                y_pos = min(height - 1, max(0, y_pos))&#10;                chart[y_pos][x_pos] = '*'&#10;            except (ValueError, TypeError, ZeroDivisionError) as e:&#10;                print(f&quot;Warning: Could not plot point at x={x}, y={y}: {e}&quot;)&#10;                continue&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        from pyMAOS import unit_manager&#10;        print(f&quot;Region boundaries: [{unit_manager.ureg.Quantity(0, self.a.units)}, {self.a:.2f}, {self.L:.2f}]&quot;)&#10;&#10;class R2_Axial_Linear_Load:&#10;    def __init__(self, w1, w2, a, b, member, loadcase=&quot;D&quot;):&#10;        self.w1 = w1&#10;        self.w2 = w2&#10;        self.a = a&#10;        self.b = b&#10;        self.c = b - a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.A = member.section.Area&#10;&#10;        self.EA = self.E * self.A&#10;&#10;        self.kind = &quot;AXIAL_LINE&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Simple End Reactions&#10;        self.W = 0.5 * self.c * (self.w2 + self.w1)&#10;&#10;        self.Rix = -1 * self.W&#10;        self.Rjx = 0&#10;&#10;        # Constants of Integration&#10;        self.integration_constants()&#10;&#10;        # Piecewise Functions&#10;        # [co....cn x^n] [xa, xb]&#10;        Wx = [&#10;            [[0], [0, self.a]],&#10;            [&#10;                [&#10;                    ((-1 * self.a * self.w2) - (self.c * self.w1) - (self.a * self.w1))&#10;                    / self.c,&#10;                    (self.w2 - self.w1) / self.c,&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[0], [self.b, self.L]],&#10;        ]&#10;&#10;        Ax = [&#10;            [[-1 * self.Rix], [0, self.a]],&#10;            [&#10;                [&#10;                    self.c1,&#10;                    (self.a * self.w2 - self.b * self.w1) / (self.c),&#10;                    -1 * (self.w2 - self.w1) / (2 * self.c),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[-1 * self.Rix - self.W], [self.b, self.L]],&#10;        ]&#10;&#10;        Dx = [&#10;            [[self.c2, -1 * self.Rix], [0, self.a]],&#10;            [&#10;                [&#10;                    self.c3,&#10;                    self.c1,&#10;                    ((self.a * self.w2 - self.b * self.w1)) / (2 * self.c),&#10;                    -1 * ((self.w2 - self.w1)) / (6 * self.c),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c4, -1 * self.Rix - self.W], [self.b, self.L]],&#10;        ]&#10;&#10;        Dx[0][0] = [i / self.EA for i in Dx[0][0]]&#10;        Dx[1][0] = [i / self.EA for i in Dx[1][0]]&#10;        Dx[2][0] = [i / self.EA for i in Dx[2][0]]&#10;&#10;        self.Wx = PiecewisePolynomial(Wx)  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        self.Ax = PiecewisePolynomial(Ax)&#10;        self.Dx = PiecewisePolynomial(Dx)&#10;        self.Vy = PiecewisePolynomial()&#10;        self.Mz = PiecewisePolynomial()&#10;        self.Sz = PiecewisePolynomial()&#10;        self.Dy = PiecewisePolynomial()&#10;&#10;    def integration_constants(self):&#10;        w1 = self.w1&#10;        w2 = self.w2&#10;        a = self.a&#10;        b = self.b&#10;        Ri = self.Rix&#10;&#10;        self.c1 = -(&#10;            (a * a * w2 - 2 * a * b * w1 + a * a * w1 + 2 * Ri * b - 2 * Ri * a)&#10;            / (2 * (b - a))&#10;        )&#10;        self.c2 = 0&#10;        self.c3 = (a * a * (a * w2 - 3 * b * w1 + 2 * a * w1)) / (6 * (b - a))&#10;        self.c4 = (&#10;            (2 * b * b - a * b - a * a) * w2 + (b * b + a * b - 2 * a * a) * w1&#10;        ) / 6&#10;&#10;    def FEF(self):&#10;        w1 = self.w1&#10;        w2 = self.w2&#10;        a = self.a&#10;        b = self.b&#10;        L = self.L&#10;&#10;        Rix = (&#10;            (b - a)&#10;            * (2 * b * w2 + a * w2 - 3 * L * w2 + b * w1 + 2 * a * w1 - 3 * L * w1)&#10;        ) / (6 * L)&#10;        Rjx = -1 * (((b - a) * (2 * b * w2 + a * w2 + b * w1 + 2 * a * w1)) / (6 * L))&#10;&#10;        # Return a properly wrapped ndarray with units&#10;        return pyMAOS.unit_manager.ureg.Quantity(&#10;            np.array([Rix.magnitude, 0, 0, Rjx.magnitude, 0, 0]),&#10;            pyMAOS.unit_manager.INTERNAL_FORCE_UNIT&#10;        )&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of an axial linear load.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Axial Linear Load ({self.loadcase}): &quot;&#10;                f&quot;w1={self.w1:.3f}, w2={self.w2:.3f}, &quot;&#10;                f&quot;from x={self.a:.3f} to x={self.b:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of axial response with ASCII charts.&#10;&#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;        import sys&#10;        from pyMAOS import unit_manager&#10;&#10;        # Get current unit system directly from the manager&#10;        current_units = unit_manager.get_current_units()&#10;        system_name = unit_manager.get_system_name()&#10;&#10;        print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        print(f&quot;Axial reactions: Rix = {self.Rix:.3f}, Rjx = {self.Rjx:.3f}&quot;)&#10;&#10;        # Define regions for before and after the load point&#10;        regions = [(unit_manager.ureg.Quantity(0, unit_manager.INTERNAL_LENGTH_UNIT), self.a),&#10;                   (self.a, self.L)]&#10;        region_names = [&quot;Before Load [0 to a]&quot;, &quot;After Load [a to L]&quot;]&#10;&#10;        # Create sampling points&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                print(f&quot;Region {i+1} ({region_names[i]}): {points}&quot;)&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;&#10;        # Convert to numpy array&#10;        x_array = np.array(all_x, dtype=object)&#10;&#10;        # Calculate function values using vectorized evaluation if available&#10;        ax_values = self.Ax.evaluate_vectorized(x_array) if hasattr(self.Ax, 'evaluate_vectorized') else [self.Ax.evaluate(x) for x in all_x]&#10;        dx_values = self.Dx.evaluate_vectorized(x_array) if hasattr(self.Dx, 'evaluate_vectorized') else [self.Dx.evaluate(x) for x in all_x]&#10;&#10;        # Print ASCII charts&#10;        self._print_ascii_chart(&quot;Axial Force (Ax)&quot;, all_x, ax_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Axial Displacement (Dx)&quot;, all_x, dx_values, regions, chart_width, chart_height)&#10;&#10;        # Print table of values at key points&#10;        print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;        print(f&quot;{'Position':15} {'Axial Force':20} {'Axial Displacement':20}&quot;)&#10;        print(&quot;-&quot; * 60)&#10;        for x in [0, self.a, self.L]:&#10;            print(f&quot;{x:15.3f} {self.Ax.evaluate(x):20.3f} {self.Dx.evaluate(x):20.3e}&quot;)&#10;&#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Filter out NaN values before finding min/max&#10;        valid_indices = []&#10;        valid_y_values = []&#10;        for i, y in enumerate(y_values):&#10;            # Check if y is NaN (including Quantity objects with NaN magnitude)&#10;            is_nan = False&#10;            if hasattr(y, 'magnitude'):&#10;                is_nan = np.isnan(y.magnitude)&#10;            else:&#10;                is_nan = np.isnan(y) if isinstance(y, (int, float)) else False&#10;&#10;            if not is_nan:&#10;                valid_indices.append(i)&#10;                valid_y_values.append(y)&#10;&#10;        # If no valid values, skip plotting&#10;        if len(valid_y_values) == 0:&#10;            print(&quot;No valid data points to plot (all values are NaN)&quot;)&#10;            return&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(valid_y_values)&#10;        max_y = max(valid_y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;        range_y = max_y - min_y&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Skip NaN values&#10;            if hasattr(y, 'magnitude'):&#10;                if np.isnan(y.magnitude):&#10;                    continue&#10;            elif isinstance(y, (int, float)) and np.isnan(y):&#10;                continue&#10;&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart - avoid NaN issues&#10;            try:&#10;                y_normalized = (y - min_y) / range_y&#10;                y_pos = height - 1 - int(y_normalized * (height - 1))&#10;                y_pos = min(height - 1, max(0, y_pos))&#10;                chart[y_pos][x_pos] = '*'&#10;            except (ValueError, TypeError, ZeroDivisionError) as e:&#10;                print(f&quot;Warning: Could not plot point at x={x}, y={y}: {e}&quot;)&#10;                continue&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        from pyMAOS import unit_manager&#10;        print(f&quot;Region boundaries: [{unit_manager.ureg.Quantity(0, self.a.units)}, {self.a:.2f}, {self.L:.2f}]&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/loading/distributed_loads.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/loading/distributed_loads.py" />
              <option name="originalContent" value="import sys&#10;import pint&#10;from pint import Quantity&#10;from typing import TYPE_CHECKING, Any&#10;# from pyMAOS.display_utils import display_node_load_vector_in_units&#10;import numpy as np&#10;from pyMAOS.loading.piecewisePolinomial import PiecewisePolynomial&#10;from pyMAOS.loading.PiecewisePolynomial2 import PiecewisePolynomial2&#10;import pyMAOS&#10;from pyMAOS import unit_manager, INTERNAL_LENGTH_UNIT&#10;from pyMAOS import (# SI_UNITS, IMPERIAL_UNITS, METRIC_KN_UNITS,&#10;    INTERNAL_LENGTH_UNIT, INTERNAL_FORCE_UNIT,  INTERNAL_MOMENT_UNIT, INTERNAL_PRESSURE_UNIT, INTERNAL_DISTRIBUTED_LOAD_UNIT,&#10;    FORCE_DIMENSIONALITY, LENGTH_DIMENSIONALITY, MOMENT_DIMENSIONALITY, PRESSURE_DIMENSIONALITY, DISTRIBUTED_LOAD_DIMENSIONALITY,&#10;    unit_manager&#10;)&#10;&#10;from pprint import pprint&#10;&#10;# Use TYPE_CHECKING to avoid runtime imports&#10;if TYPE_CHECKING:&#10;    from pyMAOS.frame2d import R2Frame&#10;&#10;class LinearLoadXY:&#10;    def __init__(self, w1: pint.Quantity, w2: pint.Quantity, a: pint.Quantity, b: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        self.w1 = w1&#10;        self.w2 = w2&#10;        self.a = a&#10;        self.b = b&#10;        self.c = b - a&#10;        self.member_uid = member.uid&#10;        self.L = member.length&#10;&#10;        EI = member.material.E *  member.section.Ixx&#10;        EI = EI.to_reduced_units()&#10;        self.kind = &quot;LINE&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Constants of Integration&#10;        # self.integration_constants()&#10;        &quot;&quot;&quot;&#10;                Calculate the integration constants for beam deflection equations.&#10;&#10;                These constants (c01-c12) are determined by enforcing boundary conditions:&#10;                - Continuity of shear, moment, slope, and deflection at load discontinuities&#10;                - Zero displacement and rotation at member ends (for fixed-end conditions)&#10;                - Equilibrium of forces and moments&#10;                &quot;&quot;&quot;&#10;        # w1 = self.w1&#10;        # w2 = self.w2&#10;        # a = self.a&#10;        # b = self.b&#10;        L = self.L&#10;&#10;        #     These constants (c01-c12) are determined by enforcing boundary conditions:&#10;        #     - Continuity of shear, moment, slope, and deflection at load discontinuities&#10;        #     - Zero displacement and rotation at member ends (for fixed-end conditions)&#10;        #     - Equilibrium of forces and moments&#10;        #&#10;        #     The constants are used in the piecewise polynomial functions that define:&#10;        #     - Vy: Shear force distribution&#10;        #     - Mz: Bending moment distribution&#10;        #     - Sz: Slope (rotation) distribution&#10;        #     - Dy: Deflection distribution&#10;&#10;        # Constants for the shear force function (Vy)&#10;        self.c01 = (&#10;                          (((2 * b * b) + ((-a - 3 * L) * b) - (a * a) + (3 * L * a)) * w2)&#10;                          + (((b * b) + ((a - 3 * L) * b) - (2 * a * a) + (3 * L * a)) * w1)&#10;                  ) / (6 * L)&#10;        self.c02 = (&#10;                          (&#10;                                  (&#10;                                          (2 * b * b * b)&#10;                                          + ((-3 * a - 3 * L) * b * b)&#10;                                          + (6 * L * a * b)&#10;                                          + (a * a * a)&#10;                                  )&#10;                                  * w2&#10;                          )&#10;                          + (((b * b * b) - (3 * L * b * b) - (3 * a * a * b) + (2 * a * a * a)) * w1)&#10;                  ) / (6 * L * b - 6 * L * a)&#10;        self.c03 = (&#10;                          ((2 * b * b - a * b - a * a) * w2) + ((b * b + a * b - 2 * a * a) * w1)&#10;                  ) / (6 * L)&#10;&#10;        # Constants for the bending moment function (Mz)&#10;        # Use unit_manager.ureg instead of direct import&#10;        self.c04 = pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)  # Zero moment at x=0 for fixed-end condition&#10;        self.c05 = (&#10;                -1&#10;                * ((a * a * a * w2) + ((2 * a * a * a - 3 * a * a * b) * w1))&#10;                / (6 * b - 6 * a)&#10;        )&#10;        self.c06 = (&#10;                -1&#10;                * ((2 * b * b - a * b - a * a) * w2 + (b * b + a * b - 2 * a * a) * w1)&#10;                / 6&#10;        )&#10;&#10;        # Constants for the slope function (Sz)&#10;        self.c07 = (&#10;                          (&#10;                                  12 * b * b * b * b&#10;                                  + (-3 * a - 45 * L) * b * b * b&#10;                                  + (-3 * a * a + 15 * L * a + 40 * L * L) * b * b&#10;                                  + (-3 * a * a * a + 15 * L * a * a - 20 * L * L * a) * b&#10;                                  - 3 * a * a * a * a&#10;                                  + 15 * L * a * a * a&#10;                                  - 20 * L * L * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b&#10;                                  + (3 * a - 15 * L) * b * b * b&#10;                                  + (3 * a * a - 15 * L * a + 20 * L * L) * b * b&#10;                                  + (3 * a * a * a - 15 * L * a * a + 20 * L * L * a) * b&#10;                                  - 12 * a * a * a * a&#10;                                  + 45 * L * a * a * a&#10;                                  - 40 * L * L * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L)&#10;        self.c08 = (&#10;                          (&#10;                                  12 * b * b * b * b * b&#10;                                  + (-15 * a - 45 * L) * b * b * b * b&#10;                                  + (60 * L * a + 40 * L * L) * b * b * b&#10;                                  - 60 * L * L * a * b * b&#10;                                  + 3 * a * a * a * a * a&#10;                                  + 20 * L * L * a * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b * b&#10;                                  - 15 * L * b * b * b * b&#10;                                  + 20 * L * L * b * b * b&#10;                                  + (-15 * a * a * a * a - 60 * L * L * a * a) * b&#10;                                  + 12 * a * a * a * a * a&#10;                                  + 40 * L * L * a * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L * b - 360 * L * a)&#10;        self.c09 = (&#10;                          (&#10;                                  12 * b * b * b * b&#10;                                  - 3 * a * b * b * b&#10;                                  + (40 * L * L - 3 * a * a) * b * b&#10;                                  + (-3 * a * a * a - 20 * L * L * a) * b&#10;                                  - 3 * a * a * a * a&#10;                                  - 20 * L * L * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b&#10;                                  + 3 * a * b * b * b&#10;                                  + (3 * a * a + 20 * L * L) * b * b&#10;                                  + (3 * a * a * a + 20 * L * L * a) * b&#10;                                  - 12 * a * a * a * a&#10;                                  - 40 * L * L * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L)&#10;&#10;        # Constants for the deflection function (Dy)&#10;        self.c10 = pyMAOS.unit_manager.ureg.Quantity(0, f&quot;{pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}**3 * {pyMAOS.unit_manager.INTERNAL_FORCE_UNIT}&quot;)  # Zero deflection at x=0 for fixed-end condition&#10;        self.c11 = (&#10;                -1 /120&#10;                * (&#10;                        a * a * a * a * a * w2&#10;                        + (4 * a * a * a * a * a - 5 * a * a * a * a * b) * w1&#10;                )&#10;                / (b - a)&#10;        )&#10;        self.c12 = (&#10;                -1&#10;                * (&#10;                        (&#10;                                4 * b * b * b * b&#10;                                - a * b * b * b&#10;                                - a * a * b * b&#10;                                - a * a * a * b&#10;                                - a * a * a * a&#10;                        )&#10;                        * w2&#10;                        + (&#10;                                b * b * b * b&#10;                                + a * b * b * b&#10;                                + a * a * b * b&#10;                                + a * a * a * b&#10;                                - 4 * a * a * a * a&#10;                        )&#10;                        * w1&#10;                )&#10;                / 120&#10;        )&#10;&#10;        # Simple End Reactions&#10;        self.W = 0.5 * self.c * (self.w2 + self.w1)&#10;        self.cbar = ((self.w1 + (2 * self.w2)) / (3 * (self.w2 + self.w1))) * self.c&#10;&#10;        self.Rjy = -1 * self.W * (self.a + self.cbar) * (1 / self.L)&#10;        self.Riy = -1 * self.W - self.Rjy&#10;&#10;        # Piecewise Functions&#10;        # Each piecewise function represents a different structural response:&#10;        # - Wy: Distributed load function (input)&#10;        # - Vy: Shear force distribution (integral of Wy)&#10;        # - Mz: Bending moment distribution (integral of Vy)&#10;        # - Sz: Rotation/slope distribution (integral of Mz/EI)&#10;        # - Dy: Deflection distribution (integral of Sz)&#10;        #&#10;        # Each function is defined in three pieces:&#10;        # 1. Before loaded region [0 to a]&#10;        # 2. Within loaded region [a to b] &#10;        # 3. After loaded region [b to L]&#10;        #&#10;        # Format: [[coefficients], [domain_bounds]]&#10;        # where coefficients = [c, c, c...] representing c + cx + cx + ...&#10;        Wy = [&#10;            [[pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT)], [pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    ((-1 * self.a * self.w2) - (self.c * self.w1) - (self.a * self.w1))&#10;                    / self.c,&#10;                    (self.w2 - self.w1) / self.c,&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT)], [self.b, self.L]],&#10;        ]; print(&quot;Wy:\n&quot;, Wy)&#10;&#10;        Vy = [&#10;            [[self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c02,&#10;                    self.w1&#10;                    + ((self.a * self.w1) / self.c)&#10;                    - ((self.a * self.w2) / self.c),&#10;                    (self.w2 / (2 * self.c)) - (self.w1 / (2 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c03], [self.b, self.L]],&#10;        ]; print(&quot;Vy:\n&quot;, Vy)&#10;&#10;        Mz = [&#10;            [[self.c04, self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c05,&#10;                    self.c02,&#10;                    (self.w1 / 2)&#10;                    + ((self.a * self.w1) / (2 * self.c))&#10;                    - ((self.a * self.w2) / (2 * self.c)),&#10;                    (self.w2 / (6 * self.c)) - (self.w1 / (6 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c06, self.c03], [self.b, self.L]],&#10;        ]; print(&quot;Mz:\n&quot;, Mz)&#10;&#10;        Sz = [&#10;            [[self.c07, self.c04, 0.5 * self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c08,&#10;                    self.c05,&#10;                    0.5 * self.c02,&#10;                    (self.w1 / 6)&#10;                    + ((self.a * self.w1) / (6 * self.c))&#10;                    - ((self.a * self.w2) / (6 * self.c)),&#10;                    (self.w2 / (24 * self.c)) - (self.w1 / (24 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c09, self.c06, 0.5 * self.c03], [self.b, self.L]],&#10;        ]&#10;        Sz[0][0] = [i / EI for i in Sz[0][0]]&#10;        Sz[1][0] = [i / EI for i in Sz[1][0]]&#10;        Sz[2][0] = [i / EI for i in Sz[2][0]]&#10;&#10;        print(&quot;Sz:\n&quot;, Sz)&#10;&#10;        Dy = [&#10;            [[self.c10, self.c07, 0.5 * self.c04, self.c01 / 6], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c11,&#10;                    self.c08,&#10;                    0.5 * self.c05,&#10;                    self.c02 / 6,&#10;                    (self.w1 / 24)&#10;                    + ((self.a * self.w1) / (24 * self.c))&#10;                    - ((self.a * self.w2) / (24 * self.c)),&#10;                    (self.w2 / (120 * self.c)) - (self.w1 / (120 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [&#10;                [self.c12, self.c09, 0.5 * self.c06, self.c03 / 6],&#10;                [self.b, self.L],&#10;            ],&#10;        ]&#10;&#10;        Dy[0][0] = [i / EI for i in Dy[0][0]]&#10;        Dy[1][0] = [i / EI for i in Dy[1][0]]&#10;        Dy[2][0] = [i / EI for i in Dy[2][0]]&#10;        print(&quot;Dy:\n&quot;, Dy)&#10;        import inspect&#10;        print(f&quot;{inspect.getfile(inspect.currentframe())}:{inspect.currentframe().f_lineno}&quot;)&#10;        print(&quot;Dy:&quot;, Dy, sep=&quot;\n&quot;)&#10;        from display_utils import print_quantity_nested_list; print_quantity_nested_list(Dy,simplify_units=True)&#10;        # self.Wx = PiecewisePolynomial()  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial(Wy); print(&quot;Wy:&quot;, self.Wy, sep=&quot;\n&quot;) # Vertical Load Function&#10;&#10;        self.Ax = PiecewisePolynomial()&#10;        self.Dx = PiecewisePolynomial()&#10;        from pprint import pprint; pprint(Vy); self.Vy = PiecewisePolynomial(Vy); print(&quot;Vy:&quot;, self.Vy, sep=&quot;\n&quot;)&#10;        print(&quot;Mz=&quot;); pprint(Mz, width=240); self.Mz = PiecewisePolynomial(Mz); print(&quot;Mz:&quot;, self.Mz, sep=&quot;\n&quot;) # this is a moment&#10;        print(&quot;Sz=&quot;); pprint(Sz, width=240); self.Sz = PiecewisePolynomial(Sz); print(&quot;Sz:&quot;, self.Sz,sep=&quot;\n&quot;) # this is an angle&#10;        print(&quot;Dy=&quot;); pprint(Dy, width=240); self.Dy = PiecewisePolynomial(Dy); print(&quot;Dy:&quot;, self.Dy,sep=&quot;\n&quot;)&#10;&#10;        # After creating all polynomial objects&#10;        # fig = self.plot_all_functions()&#10;        # fig.show()  # If you want to display immediately&#10;&#10;&#10;        # Create PiecewisePolynomial2 objects for each function&#10;        self.Wy2 = PiecewisePolynomial2(Wy)&#10;        self.Vy2 = PiecewisePolynomial2(Vy)&#10;        self.Mz2 = PiecewisePolynomial2(Mz)&#10;        self.Sz2 = PiecewisePolynomial2(Sz)&#10;        self.Dy2 = PiecewisePolynomial2(Dy)&#10;        # Print the PiecewisePolynomial2 objects&#10;        print(&quot;Wy2:&quot;, self.Wy2)&#10;        print(&quot;Vy2:&quot;, self.Vy2)&#10;        print(&quot;Mz2:&quot;, self.Mz2)&#10;        print(&quot;Sz2:&quot;, self.Sz2)&#10;        print(&quot;Dy2:&quot;, self.Dy2)&#10;&#10;        # After creating PiecewisePolynomial2 objects&#10;        ppoly_fig = self.plot_all_ppoly_functions()&#10;        ppoly_fig.show()  # If you want to display immediately&#10;&#10;&#10;    def load_fef(self):&#10;        &quot;&quot;&quot;&#10;        Compute and return the fixed and forces&#10;        &quot;&quot;&quot;&#10;        L = self.L&#10;&#10;        c3 = self.c03&#10;        c6 = self.c06&#10;        c7 = self.c07&#10;        c9 = self.c09&#10;&#10;        # Calculate fixed end moments&#10;        Miz = -1 * (c3 * L * L + 2 * c6 * L + 2 * c9 + 4 * c7) / L&#10;        Mjz = -1 * (2 * c3 * L * L + 4 * c6 * L + 4 * c9 + 2 * c7) / L&#10;&#10;        # Calculate fixed end forces&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Dimension checking&#10;        # print(f&quot;DEBUG: Checking dimensions - Miz: {Miz.dimensionality}, Mjz: {Mjz.dimensionality}&quot;)&#10;        # print(f&quot;DEBUG: Checking dimensions - Riy: {Riy.dimensionality}, Rjy: {Rjy.dimensionality}&quot;)&#10;&#10;        # Verify moment dimensions&#10;        # try:&#10;        #     Miz.check(MOMENT_DIMENSIONALITY)&#10;        #     Mjz.check(MOMENT_DIMENSIONALITY)&#10;        #     # print(&quot;DEBUG: Moment dimension check passed&quot;)&#10;        # except pint.DimensionalityError as e:&#10;        #     print(f&quot;ERROR: Dimension error in moments: {e}&quot;)&#10;        #     # Create correctly dimensioned values as fallback&#10;        #     if not Miz.check(MOMENT_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Miz from {Miz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;        #         Miz = unit_manager.ureg.Quantity(Miz.magnitude, INTERNAL_MOMENT_UNIT)&#10;        #     if not Mjz.check(MOMENT_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Mjz from {Mjz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;        #         Mjz = unit_manager.ureg.Quantity(Mjz.magnitude, INTERNAL_MOMENT_UNIT)&#10;&#10;        # Verify force dimensions&#10;        # try:&#10;        #     Riy.check(FORCE_DIMENSIONALITY)&#10;        #     Rjy.check(FORCE_DIMENSIONALITY)&#10;        #     # print(&quot;DEBUG: Force dimension check passed&quot;)&#10;        # except pint.DimensionalityError as e:&#10;        #     print(f&quot;ERROR: Dimension error in forces: {e}&quot;)&#10;        #     # Create correctly dimensioned values as fallback&#10;        #     if not Riy.check(FORCE_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Riy from {Riy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;        #         Riy = unit_manager.ureg.Quantity(Riy.magnitude, INTERNAL_FORCE_UNIT)&#10;        #     if not Rjy.check(FORCE_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Rjy from {Rjy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;        #         Rjy = unit_manager.ureg.Quantity(Rjy.magnitude, INTERNAL_FORCE_UNIT)&#10;&#10;        # Print forces and moments in both SI and display units&#10;        #from pyMAOS.units_mod import convert_to_display_units&#10;        from pyMAOS.pymaos_units import FORCE_DISPLAY_UNIT, MOMENT_DISPLAY_UNIT&#10;        # Get current unit system directly from the manager&#10;        # current_units = unit_manager.get_current_units()&#10;        # system_name = unit_manager.get_system_name()&#10;        # Riy_display = Riy.to(FORCE_DISPLAY_UNIT)&#10;        # Rjy_display = Rjy.to(FORCE_DISPLAY_UNIT)&#10;        # Miz_display = Miz.to(MOMENT_DISPLAY_UNIT)&#10;        # Mjz_display = Mjz.to(MOMENT_DISPLAY_UNIT)&#10;        #&#10;        # print(f&quot;Vertical reactions - SI: Riy={Riy:.3f} N, Rjy={Rjy:.3f} N&quot;)&#10;        # print(f&quot;Vertical reactions - Display: Riy={Riy_display:.3f}, Rjy={Rjy_display:.3f}&quot;)&#10;        # print(f&quot;Moments - SI: Miz={Miz:.3f} N*m, Mjz={Mjz:.3f} N*m&quot;)&#10;        # print(f&quot;Moments - Display: Miz={Miz_display:.3f}, Mjz={Mjz_display:.3f}&quot;)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = 0 * pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;&#10;        ret_val = np.array([pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT), Riy, Miz, pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT), Rjy, Mjz], dtype=object)&#10;        print(f&quot;FEF distributed load results on member {self.member_uid} for Load Case {self.loadcase}:&quot;, ret_val, sep=&quot;\n&quot;)&#10;&#10;        # Final dimension check for return values&#10;        for i, (idx, expected_dim) in enumerate([(0, FORCE_DIMENSIONALITY), (1, FORCE_DIMENSIONALITY),&#10;                                               (2, MOMENT_DIMENSIONALITY), (3, FORCE_DIMENSIONALITY),&#10;                                               (4, FORCE_DIMENSIONALITY), (5, MOMENT_DIMENSIONALITY)]):&#10;            try:&#10;                ret_val[idx].check(expected_dim)&#10;            except pint.DimensionalityError as e:&#10;                print(f&quot;Dimensionality error in ret_val[{idx}]: {e}&quot;)&#10;                print(f&quot;  Actual: {ret_val[idx].dimensionality}, Expected: {expected_dim}&quot;)&#10;&#10;        return ret_val&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of a linear load.&#10;        &#10;        Returns:&#10;        -------&#10;        str&#10;            Description of the linear load including magnitude, position, and load case.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Linear Load ({self.loadcase}): &quot;&#10;                f&quot;w1={self.w1:.3f}, w2={self.w2:.3f}, &quot;&#10;                f&quot;from x={self.a:.3f} to x={self.b:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of beam response across all three regions with ASCII charts.&#10;&#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;&#10;        &#10;        import numpy as np&#10;&#10;        # Get current unit system directly from the manager&#10;        current_units = unit_manager.get_current_units()&#10;        system_name = unit_manager.get_system_name()&#10;        # print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        # print(f&quot;Total Load W = {self.W:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.W, 'force'):.3f} {current_units['force']})&quot;)&#10;        # print(f&quot;Load centroid from left: {self.a + self.cbar:.3f}&quot;)&#10;        # print(f&quot;Reactions: Riy = {self.Riy:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.Riy, 'force'):.3f} {current_units['force']}), Rjy = {self.Rjy:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.Rjy, 'force'):.3f} {current_units['force']})&quot;, end=&quot;\n&quot;)&#10;&#10;        zero_length=pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT)&#10;        regions = [(zero_length, self.a), (self.a, self.b), (self.b, self.L)]&#10;        region_names = [&quot;Before Load [0 to a]&quot;, &quot;Loaded Region [a to b]&quot;, &quot;After Load [b to L]&quot;]&#10;&#10;        # Create sampling points&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                # points=np.linspace(start, end, num_points+1).tolist()&#10;                print(f&quot;Region {i+1} ({region_names[i]}): {points}&quot;)&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;&#10;        # Convert to numpy array&#10;        x_array = np.array(all_x, dtype=object)&#10;&#10;        # Calculate function values using vectorized evaluation&#10;        wy_values = self.Wy.evaluate_vectorized(x_array)&#10;        vy_values = self.Vy.evaluate_vectorized(x_array)&#10;        mz_values = self.Mz.evaluate_vectorized(x_array)&#10;        sz_values = self.Sz.evaluate_vectorized(x_array)&#10;        dy_values = self.Dy.evaluate_vectorized(x_array)&#10;&#10;        # Print ASCII charts&#10;        self._print_ascii_chart(&quot;Distributed Load (Wy)&quot;, all_x, wy_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Shear Force (Vy)&quot;, all_x, vy_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Bending Moment (Mz)&quot;, all_x, mz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Rotation (Sz)&quot;, all_x, sz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Deflection (Dy)&quot;, all_x, dy_values, regions, chart_width, chart_height)&#10;&#10;        # Print table of values at region boundaries&#10;        print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;        print(f&quot;{'Position':15} {'Load':15} {'Shear':15} {'Moment':15} {'Rotation':15} {'Deflection':15}&quot;)&#10;        print(&quot;-&quot; * 90)&#10;        for x in [0, self.a, self.b, self.L]:&#10;            print(f&quot;{x:15.3f} {self.Wy.evaluate(x):15.3f} {self.Vy.evaluate(x):15.3f} {self.Mz.evaluate(x):15.3f} &quot;&#10;                  f&quot;{self.Sz.evaluate(x):15.3e} {self.Dy.evaluate(x):15.3e}&quot;)&#10;    &#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;        from pint import Quantity  # Import Quantity in the method scope&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Filter out NaN values before finding min/max&#10;        valid_indices = []&#10;        valid_y_values = []&#10;        for i, y in enumerate(y_values):&#10;            # Check if y is NaN (including Quantity objects with NaN magnitude)&#10;            is_nan = False&#10;            if hasattr(y, 'magnitude'):&#10;                is_nan = np.isnan(y.magnitude)&#10;            else:&#10;                is_nan = np.isnan(y) if isinstance(y, (int, float)) else False&#10;&#10;            if not is_nan:&#10;                valid_indices.append(i)&#10;                valid_y_values.append(y)&#10;&#10;        # If no valid values, skip plotting&#10;        if len(valid_y_values) == 0:&#10;            print(&quot;No valid data points to plot (all values are NaN)&quot;)&#10;            return&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(valid_y_values)&#10;        max_y = max(valid_y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;        range_y = max_y - min_y&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Skip NaN values&#10;            if hasattr(y, 'magnitude'):&#10;                if np.isnan(y.magnitude):&#10;                    continue&#10;            elif isinstance(y, (int, float)) and np.isnan(y):&#10;                continue&#10;&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart - avoid NaN issues&#10;            try:&#10;                y_normalized = (y - min_y) / range_y&#10;                y_pos = height - 1 - int(y_normalized * (height - 1))&#10;                y_pos = min(height - 1, max(0, y_pos))&#10;                chart[y_pos][x_pos] = '*'&#10;            except (ValueError, TypeError, ZeroDivisionError) as e:&#10;                print(f&quot;Warning: Could not plot point at x={x}, y={y}: {e}&quot;)&#10;                continue&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        print(f&quot;Region boundaries: [{unit_manager.ureg.Quantity(0, self.a.units)}, {self.a:.2f}, {self.b:.2f}, {self.L:.2f}]&quot;)&#10;&#10;    def plot_all_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all non-empty PiecewisePolynomial functions.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial objects with their names and colors&#10;        functions = []&#10;        if hasattr(self, 'Wy') and self.Wy.functions:&#10;            functions.append(('Wy', self.Wy, 'blue', 'Distributed Load'))&#10;        if hasattr(self, 'Vy') and self.Vy.functions:&#10;            functions.append(('Vy', self.Vy, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz') and self.Mz.functions:&#10;            functions.append(('Mz', self.Mz, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz') and self.Sz.functions:&#10;            functions.append(('Sz', self.Sz, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy') and self.Dy.functions:&#10;            functions.append(('Dy', self.Dy, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key points&#10;            for x in [self.a, self.b]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title&#10;        fig.suptitle(f&quot;Beam Analysis for {self.__str__()}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig&#10;&#10;    def plot_all_ppoly_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all PiecewisePolynomial2 functions.&#10;        Uses the efficient PPoly representation for better performance.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial2 objects&#10;        functions = []&#10;        if hasattr(self, 'Wy2') and self.Wy2.ppoly is not None:&#10;            functions.append(('Wy2', self.Wy2, 'blue', 'Distributed Load'))&#10;        if hasattr(self, 'Vy2') and self.Vy2.ppoly is not None:&#10;            functions.append(('Vy2', self.Vy2, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz2') and self.Mz2.ppoly is not None:&#10;            functions.append(('Mz2', self.Mz2, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz2') and self.Sz2.ppoly is not None:&#10;            functions.append(('Sz2', self.Sz2, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy2') and self.Dy2.ppoly is not None:&#10;            functions.append(('Dy2', self.Dy2, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No PiecewisePolynomial2 functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} PiecewisePolynomial2 functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key load boundaries&#10;            for x in [self.a, self.b]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title&#10;        fig.suptitle(f&quot;Beam Analysis (PPoly) for {self.__str__()}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig" />
              <option name="updatedContent" value="import sys&#10;import pint&#10;from pint import Quantity&#10;from typing import TYPE_CHECKING, Any&#10;# from pyMAOS.display_utils import display_node_load_vector_in_units&#10;import numpy as np&#10;from pyMAOS.loading.piecewisePolinomial import PiecewisePolynomial&#10;from pyMAOS.loading.PiecewisePolynomial2 import PiecewisePolynomial2&#10;import pyMAOS&#10;from pyMAOS import unit_manager, INTERNAL_LENGTH_UNIT&#10;from pyMAOS import (# SI_UNITS, IMPERIAL_UNITS, METRIC_KN_UNITS,&#10;    INTERNAL_LENGTH_UNIT, INTERNAL_FORCE_UNIT,  INTERNAL_MOMENT_UNIT, INTERNAL_PRESSURE_UNIT, INTERNAL_DISTRIBUTED_LOAD_UNIT,&#10;    FORCE_DIMENSIONALITY, LENGTH_DIMENSIONALITY, MOMENT_DIMENSIONALITY, PRESSURE_DIMENSIONALITY, DISTRIBUTED_LOAD_DIMENSIONALITY,&#10;    unit_manager&#10;)&#10;&#10;from pprint import pprint&#10;&#10;# Use TYPE_CHECKING to avoid runtime imports&#10;if TYPE_CHECKING:&#10;    from pyMAOS.frame2d import R2Frame&#10;&#10;class LinearLoadXY:&#10;    def __init__(self, w1: pint.Quantity, w2: pint.Quantity, a: pint.Quantity, b: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        self.w1 = w1&#10;        self.w2 = w2&#10;        self.a = a&#10;        self.b = b&#10;        self.c = b - a&#10;        self.member_uid = member.uid&#10;        self.L = member.length&#10;&#10;        EI = member.material.E *  member.section.Ixx&#10;        EI = EI.to_reduced_units()&#10;        self.kind = &quot;LINE&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Constants of Integration&#10;        # self.integration_constants()&#10;        &quot;&quot;&quot;&#10;                Calculate the integration constants for beam deflection equations.&#10;&#10;                These constants (c01-c12) are determined by enforcing boundary conditions:&#10;                - Continuity of shear, moment, slope, and deflection at load discontinuities&#10;                - Zero displacement and rotation at member ends (for fixed-end conditions)&#10;                - Equilibrium of forces and moments&#10;                &quot;&quot;&quot;&#10;        # w1 = self.w1&#10;        # w2 = self.w2&#10;        # a = self.a&#10;        # b = self.b&#10;        L = self.L&#10;&#10;        #     These constants (c01-c12) are determined by enforcing boundary conditions:&#10;        #     - Continuity of shear, moment, slope, and deflection at load discontinuities&#10;        #     - Zero displacement and rotation at member ends (for fixed-end conditions)&#10;        #     - Equilibrium of forces and moments&#10;        #&#10;        #     The constants are used in the piecewise polynomial functions that define:&#10;        #     - Vy: Shear force distribution&#10;        #     - Mz: Bending moment distribution&#10;        #     - Sz: Slope (rotation) distribution&#10;        #     - Dy: Deflection distribution&#10;&#10;        # Constants for the shear force function (Vy)&#10;        self.c01 = (&#10;                          (((2 * b * b) + ((-a - 3 * L) * b) - (a * a) + (3 * L * a)) * w2)&#10;                          + (((b * b) + ((a - 3 * L) * b) - (2 * a * a) + (3 * L * a)) * w1)&#10;                  ) / (6 * L)&#10;        self.c02 = (&#10;                          (&#10;                                  (&#10;                                          (2 * b * b * b)&#10;                                          + ((-3 * a - 3 * L) * b * b)&#10;                                          + (6 * L * a * b)&#10;                                          + (a * a * a)&#10;                                  )&#10;                                  * w2&#10;                          )&#10;                          + (((b * b * b) - (3 * L * b * b) - (3 * a * a * b) + (2 * a * a * a)) * w1)&#10;                  ) / (6 * L * b - 6 * L * a)&#10;        self.c03 = (&#10;                          ((2 * b * b - a * b - a * a) * w2) + ((b * b + a * b - 2 * a * a) * w1)&#10;                  ) / (6 * L)&#10;&#10;        # Constants for the bending moment function (Mz)&#10;        # Use unit_manager.ureg instead of direct import&#10;        self.c04 = pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)  # Zero moment at x=0 for fixed-end condition&#10;        self.c05 = (&#10;                -1&#10;                * ((a * a * a * w2) + ((2 * a * a * a - 3 * a * a * b) * w1))&#10;                / (6 * b - 6 * a)&#10;        )&#10;        self.c06 = (&#10;                -1&#10;                * ((2 * b * b - a * b - a * a) * w2 + (b * b + a * b - 2 * a * a) * w1)&#10;                / 6&#10;        )&#10;&#10;        # Constants for the slope function (Sz)&#10;        self.c07 = (&#10;                          (&#10;                                  12 * b * b * b * b&#10;                                  + (-3 * a - 45 * L) * b * b * b&#10;                                  + (-3 * a * a + 15 * L * a + 40 * L * L) * b * b&#10;                                  + (-3 * a * a * a + 15 * L * a * a - 20 * L * L * a) * b&#10;                                  - 3 * a * a * a * a&#10;                                  + 15 * L * a * a * a&#10;                                  - 20 * L * L * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b&#10;                                  + (3 * a - 15 * L) * b * b * b&#10;                                  + (3 * a * a - 15 * L * a + 20 * L * L) * b * b&#10;                                  + (3 * a * a * a - 15 * L * a * a + 20 * L * L * a) * b&#10;                                  - 12 * a * a * a * a&#10;                                  + 45 * L * a * a * a&#10;                                  - 40 * L * L * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L)&#10;        self.c08 = (&#10;                          (&#10;                                  12 * b * b * b * b * b&#10;                                  + (-15 * a - 45 * L) * b * b * b * b&#10;                                  + (60 * L * a + 40 * L * L) * b * b * b&#10;                                  - 60 * L * L * a * b * b&#10;                                  + 3 * a * a * a * a * a&#10;                                  + 20 * L * L * a * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b * b&#10;                                  - 15 * L * b * b * b * b&#10;                                  + 20 * L * L * b * b * b&#10;                                  + (-15 * a * a * a * a - 60 * L * L * a * a) * b&#10;                                  + 12 * a * a * a * a * a&#10;                                  + 40 * L * L * a * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L * b - 360 * L * a)&#10;        self.c09 = (&#10;                          (&#10;                                  12 * b * b * b * b&#10;                                  - 3 * a * b * b * b&#10;                                  + (40 * L * L - 3 * a * a) * b * b&#10;                                  + (-3 * a * a * a - 20 * L * L * a) * b&#10;                                  - 3 * a * a * a * a&#10;                                  - 20 * L * L * a * a&#10;                          )&#10;                          * w2&#10;                          + (&#10;                                  3 * b * b * b * b&#10;                                  + 3 * a * b * b * b&#10;                                  + (3 * a * a + 20 * L * L) * b * b&#10;                                  + (3 * a * a * a + 20 * L * L * a) * b&#10;                                  - 12 * a * a * a * a&#10;                                  - 40 * L * L * a * a&#10;                          )&#10;                          * w1&#10;                  ) / (360 * L)&#10;&#10;        # Constants for the deflection function (Dy)&#10;        self.c10 = pyMAOS.unit_manager.ureg.Quantity(0, f&quot;{pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}**3 * {pyMAOS.unit_manager.INTERNAL_FORCE_UNIT}&quot;)  # Zero deflection at x=0 for fixed-end condition&#10;        self.c11 = (&#10;                -1 /120&#10;                * (&#10;                        a * a * a * a * a * w2&#10;                        + (4 * a * a * a * a * a - 5 * a * a * a * a * b) * w1&#10;                )&#10;                / (b - a)&#10;        )&#10;        self.c12 = (&#10;                -1&#10;                * (&#10;                        (&#10;                                4 * b * b * b * b&#10;                                - a * b * b * b&#10;                                - a * a * b * b&#10;                                - a * a * a * b&#10;                                - a * a * a * a&#10;                        )&#10;                        * w2&#10;                        + (&#10;                                b * b * b * b&#10;                                + a * b * b * b&#10;                                + a * a * b * b&#10;                                + a * a * a * b&#10;                                - 4 * a * a * a * a&#10;                        )&#10;                        * w1&#10;                )&#10;                / 120&#10;        )&#10;&#10;        # Simple End Reactions&#10;        self.W = 0.5 * self.c * (self.w2 + self.w1)&#10;        self.cbar = ((self.w1 + (2 * self.w2)) / (3 * (self.w2 + self.w1))) * self.c&#10;&#10;        self.Rjy = -1 * self.W * (self.a + self.cbar) * (1 / self.L)&#10;        self.Riy = -1 * self.W - self.Rjy&#10;&#10;        # Piecewise Functions&#10;        # Each piecewise function represents a different structural response:&#10;        # - Wy: Distributed load function (input)&#10;        # - Vy: Shear force distribution (integral of Wy)&#10;        # - Mz: Bending moment distribution (integral of Vy)&#10;        # - Sz: Rotation/slope distribution (integral of Mz/EI)&#10;        # - Dy: Deflection distribution (integral of Sz)&#10;        #&#10;        # Each function is defined in three pieces:&#10;        # 1. Before loaded region [0 to a]&#10;        # 2. Within loaded region [a to b] &#10;        # 3. After loaded region [b to L]&#10;        #&#10;        # Format: [[coefficients], [domain_bounds]]&#10;        # where coefficients = [c, c, c...] representing c + cx + cx + ...&#10;        &#10;        # Use wrapped ndarrays for quantity arrays&#10;        zero_dist_load = pyMAOS.unit_manager.ureg.Quantity(np.array([0.0]), pyMAOS.unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT)&#10;        &#10;        Wy = [&#10;            [[zero_dist_load], [pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    pyMAOS.unit_manager.ureg.Quantity(&#10;                        ((-1 * self.a.magnitude * self.w2.magnitude) - (self.c.magnitude * self.w1.magnitude) - (self.a.magnitude * self.w1.magnitude))&#10;                        / self.c.magnitude,&#10;                        pyMAOS.unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT&#10;                    ),&#10;                    pyMAOS.unit_manager.ureg.Quantity(&#10;                        (self.w2.magnitude - self.w1.magnitude) / self.c.magnitude,&#10;                        f&quot;{pyMAOS.unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT}/{pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}&quot;&#10;                    )&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[zero_dist_load], [self.b, self.L]],&#10;        ]; print(&quot;Wy:\n&quot;, Wy)&#10;&#10;        Vy = [&#10;            [[self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c02,&#10;                    # Convert coefficients to use wrapped ndarrays with proper units&#10;                    pyMAOS.unit_manager.ureg.Quantity(&#10;                        np.array([&#10;                            self.w1.magnitude + ((self.a.magnitude * self.w1.magnitude) / self.c.magnitude)&#10;                            - ((self.a.magnitude * self.w2.magnitude) / self.c.magnitude)&#10;                        ]),&#10;                        self.w1.units&#10;                    ),&#10;                    pyMAOS.unit_manager.ureg.Quantity(&#10;                        np.array([(self.w2.magnitude / (2 * self.c.magnitude)) - (self.w1.magnitude / (2 * self.c.magnitude))]),&#10;                        f&quot;{self.w2.units}/{pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}&quot;&#10;                    )&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c03], [self.b, self.L]],&#10;        ]; print(&quot;Vy:\n&quot;, Vy)&#10;&#10;        Mz = [&#10;            [[self.c04, self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c05,&#10;                    self.c02,&#10;                    (self.w1 / 2)&#10;                    + ((self.a * self.w1) / (2 * self.c))&#10;                    - ((self.a * self.w2) / (2 * self.c)),&#10;                    (self.w2 / (6 * self.c)) - (self.w1 / (6 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c06, self.c03], [self.b, self.L]],&#10;        ]; print(&quot;Mz:\n&quot;, Mz)&#10;&#10;        Sz = [&#10;            [[self.c07, self.c04, 0.5 * self.c01], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c08,&#10;                    self.c05,&#10;                    0.5 * self.c02,&#10;                    (self.w1 / 6)&#10;                    + ((self.a * self.w1) / (6 * self.c))&#10;                    - ((self.a * self.w2) / (6 * self.c)),&#10;                    (self.w2 / (24 * self.c)) - (self.w1 / (24 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [[self.c09, self.c06, 0.5 * self.c03], [self.b, self.L]],&#10;        ]&#10;        Sz[0][0] = pyMAOS.unit_manager.ureg.Quantity(&#10;            np.array([coef.magnitude for coef in Sz[0][0]]) / EI.magnitude,&#10;            f&quot;{Sz[0][0][0].units}/{EI.units}&quot;&#10;        )&#10;        Sz[1][0] = pyMAOS.unit_manager.ureg.Quantity(&#10;            np.array([coef.magnitude for coef in Sz[1][0]]) / EI.magnitude,&#10;            f&quot;{Sz[1][0][0].units}/{EI.units}&quot;&#10;        )&#10;        Sz[2][0] = pyMAOS.unit_manager.ureg.Quantity(&#10;            np.array([coef.magnitude for coef in Sz[2][0]]) / EI.magnitude,&#10;            f&quot;{Sz[2][0][0].units}/{EI.units}&quot;&#10;        )&#10;&#10;        print(&quot;Sz:\n&quot;, Sz)&#10;&#10;        Dy = [&#10;            [[self.c10, self.c07, 0.5 * self.c04, self.c01 / 6], [unit_manager.ureg.Quantity(0, INTERNAL_LENGTH_UNIT), self.a]],&#10;            [&#10;                [&#10;                    self.c11,&#10;                    self.c08,&#10;                    0.5 * self.c05,&#10;                    self.c02 / 6,&#10;                    (self.w1 / 24)&#10;                    + ((self.a * self.w1) / (24 * self.c))&#10;                    - ((self.a * self.w2) / (24 * self.c)),&#10;                    (self.w2 / (120 * self.c)) - (self.w1 / (120 * self.c)),&#10;                ],&#10;                [self.a, self.b],&#10;            ],&#10;            [&#10;                [self.c12, self.c09, 0.5 * self.c06, self.c03 / 6],&#10;                [self.b, self.L],&#10;            ],&#10;        ]&#10;&#10;        Dy[0][0] = [i / EI for i in Dy[0][0]]&#10;        Dy[1][0] = [i / EI for i in Dy[1][0]]&#10;        Dy[2][0] = [i / EI for i in Dy[2][0]]&#10;        print(&quot;Dy:\n&quot;, Dy)&#10;        import inspect&#10;        print(f&quot;{inspect.getfile(inspect.currentframe())}:{inspect.currentframe().f_lineno}&quot;)&#10;        print(&quot;Dy:&quot;, Dy, sep=&quot;\n&quot;)&#10;        from display_utils import print_quantity_nested_list; print_quantity_nested_list(Dy,simplify_units=True)&#10;        # self.Wx = PiecewisePolynomial()  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial(Wy); print(&quot;Wy:&quot;, self.Wy, sep=&quot;\n&quot;) # Vertical Load Function&#10;&#10;        self.Ax = PiecewisePolynomial()&#10;        self.Dx = PiecewisePolynomial()&#10;        from pprint import pprint; pprint(Vy); self.Vy = PiecewisePolynomial(Vy); print(&quot;Vy:&quot;, self.Vy, sep=&quot;\n&quot;)&#10;        print(&quot;Mz=&quot;); pprint(Mz, width=240); self.Mz = PiecewisePolynomial(Mz); print(&quot;Mz:&quot;, self.Mz, sep=&quot;\n&quot;) # this is a moment&#10;        print(&quot;Sz=&quot;); pprint(Sz, width=240); self.Sz = PiecewisePolynomial(Sz); print(&quot;Sz:&quot;, self.Sz,sep=&quot;\n&quot;) # this is an angle&#10;        print(&quot;Dy=&quot;); pprint(Dy, width=240); self.Dy = PiecewisePolynomial(Dy); print(&quot;Dy:&quot;, self.Dy,sep=&quot;\n&quot;)&#10;&#10;        # After creating all polynomial objects&#10;        # fig = self.plot_all_functions()&#10;        # fig.show()  # If you want to display immediately&#10;&#10;&#10;        # Create PiecewisePolynomial2 objects for each function&#10;        self.Wy2 = PiecewisePolynomial2(Wy)&#10;        self.Vy2 = PiecewisePolynomial2(Vy)&#10;        self.Mz2 = PiecewisePolynomial2(Mz)&#10;        self.Sz2 = PiecewisePolynomial2(Sz)&#10;        self.Dy2 = PiecewisePolynomial2(Dy)&#10;        # Print the PiecewisePolynomial2 objects&#10;        print(&quot;Wy2:&quot;, self.Wy2)&#10;        print(&quot;Vy2:&quot;, self.Vy2)&#10;        print(&quot;Mz2:&quot;, self.Mz2)&#10;        print(&quot;Sz2:&quot;, self.Sz2)&#10;        print(&quot;Dy2:&quot;, self.Dy2)&#10;&#10;        # After creating PiecewisePolynomial2 objects&#10;        ppoly_fig = self.plot_all_ppoly_functions()&#10;        ppoly_fig.show()  # If you want to display immediately&#10;&#10;&#10;    def load_fef(self):&#10;        &quot;&quot;&quot;&#10;        Compute and return the fixed and forces&#10;        &quot;&quot;&quot;&#10;        L = self.L&#10;&#10;        c3 = self.c03&#10;        c6 = self.c06&#10;        c7 = self.c07&#10;        c9 = self.c09&#10;&#10;        # Calculate fixed end moments&#10;        Miz = -1 * (c3 * L * L + 2 * c6 * L + 2 * c9 + 4 * c7) / L&#10;        Mjz = -1 * (2 * c3 * L * L + 4 * c6 * L + 4 * c9 + 2 * c7) / L&#10;&#10;        # Calculate fixed end forces&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Dimension checking&#10;        # print(f&quot;DEBUG: Checking dimensions - Miz: {Miz.dimensionality}, Mjz: {Mjz.dimensionality}&quot;)&#10;        # print(f&quot;DEBUG: Checking dimensions - Riy: {Riy.dimensionality}, Rjy: {Rjy.dimensionality}&quot;)&#10;&#10;        # Verify moment dimensions&#10;        # try:&#10;        #     Miz.check(MOMENT_DIMENSIONALITY)&#10;        #     Mjz.check(MOMENT_DIMENSIONALITY)&#10;        #     # print(&quot;DEBUG: Moment dimension check passed&quot;)&#10;        # except pint.DimensionalityError as e:&#10;        #     print(f&quot;ERROR: Dimension error in moments: {e}&quot;)&#10;        #     # Create correctly dimensioned values as fallback&#10;        #     if not Miz.check(MOMENT_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Miz from {Miz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;        #         Miz = unit_manager.ureg.Quantity(Miz.magnitude, INTERNAL_MOMENT_UNIT)&#10;        #     if not Mjz.check(MOMENT_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Mjz from {Mjz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;        #         Mjz = unit_manager.ureg.Quantity(Mjz.magnitude, INTERNAL_MOMENT_UNIT)&#10;&#10;        # Verify force dimensions&#10;        # try:&#10;        #     Riy.check(FORCE_DIMENSIONALITY)&#10;        #     Rjy.check(FORCE_DIMENSIONALITY)&#10;        #     # print(&quot;DEBUG: Force dimension check passed&quot;)&#10;        # except pint.DimensionalityError as e:&#10;        #     print(f&quot;ERROR: Dimension error in forces: {e}&quot;)&#10;        #     # Create correctly dimensioned values as fallback&#10;        #     if not Riy.check(FORCE_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Riy from {Riy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;        #         Riy = unit_manager.ureg.Quantity(Riy.magnitude, INTERNAL_FORCE_UNIT)&#10;        #     if not Rjy.check(FORCE_DIMENSIONALITY):&#10;        #         print(f&quot;WARNING: Fixing dimensions of Rjy from {Rjy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;        #         Rjy = unit_manager.ureg.Quantity(Rjy.magnitude, INTERNAL_FORCE_UNIT)&#10;&#10;        # Print forces and moments in both SI and display units&#10;        #from pyMAOS.units_mod import convert_to_display_units&#10;        from pyMAOS.pymaos_units import FORCE_DISPLAY_UNIT, MOMENT_DISPLAY_UNIT&#10;        # Get current unit system directly from the manager&#10;        # current_units = unit_manager.get_current_units()&#10;        # system_name = unit_manager.get_system_name()&#10;        # Riy_display = Riy.to(FORCE_DISPLAY_UNIT)&#10;        # Rjy_display = Rjy.to(FORCE_DISPLAY_UNIT)&#10;        # Miz_display = Miz.to(MOMENT_DISPLAY_UNIT)&#10;        # Mjz_display = Mjz.to(MOMENT_DISPLAY_UNIT)&#10;        #&#10;        # print(f&quot;Vertical reactions - SI: Riy={Riy:.3f} N, Rjy={Rjy:.3f} N&quot;)&#10;        # print(f&quot;Vertical reactions - Display: Riy={Riy_display:.3f}, Rjy={Rjy_display:.3f}&quot;)&#10;        # print(f&quot;Moments - SI: Miz={Miz:.3f} N*m, Mjz={Mjz:.3f} N*m&quot;)&#10;        # print(f&quot;Moments - Display: Miz={Miz_display:.3f}, Mjz={Mjz_display:.3f}&quot;)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;&#10;        # Use numpy array with units for return value&#10;        ret_val = pyMAOS.unit_manager.ureg.Quantity(&#10;            np.array([0.0, Riy.magnitude, Miz.magnitude, 0.0, Rjy.magnitude, Mjz.magnitude]),&#10;            [pyMAOS.unit_manager.INTERNAL_FORCE_UNIT, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT, &#10;             pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT,&#10;             pyMAOS.unit_manager.INTERNAL_FORCE_UNIT, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT]&#10;        )&#10;        &#10;        # Print forces and moments in both SI and display units&#10;        #from pyMAOS.units_mod import convert_to_display_units&#10;        from pyMAOS.pymaos_units import FORCE_DISPLAY_UNIT, MOMENT_DISPLAY_UNIT&#10;        # Get current unit system directly from the manager&#10;        # current_units = unit_manager.get_current_units()&#10;        # system_name = unit_manager.get_system_name()&#10;        # Riy_display = Riy.to(FORCE_DISPLAY_UNIT)&#10;        # Rjy_display = Rjy.to(FORCE_DISPLAY_UNIT)&#10;        # Miz_display = Miz.to(MOMENT_DISPLAY_UNIT)&#10;        # Mjz_display = Mjz.to(MOMENT_DISPLAY_UNIT)&#10;        #&#10;        # print(f&quot;Vertical reactions - SI: Riy={Riy:.3f} N, Rjy={Rjy:.3f} N&quot;)&#10;        # print(f&quot;Vertical reactions - Display: Riy={Riy_display:.3f}, Rjy={Rjy_display:.3f}&quot;)&#10;        # print(f&quot;Moments - SI: Miz={Miz:.3f} N*m, Mjz={Mjz:.3f} N*m&quot;)&#10;        # print(f&quot;Moments - Display: Miz={Miz_display:.3f}, Mjz={Mjz_display:.3f}&quot;)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;&#10;        ret_val = np.array([pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT), Riy, Miz, pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS unit_manager.INTERNAL_FORCE_UNIT), Rjy, Mjz], dtype=object)&#10;        print(f&quot;FEF distributed load results on member {self.member_uid} for Load Case {self.loadcase}:&quot;, ret_val, sep=&quot;\n&quot;)&#10;&#10;        # Final dimension check for return values&#10;        for i, (idx, expected_dim) in enumerate([(0, FORCE_DIMENSIONALITY), (1, FORCE_DIMENSIONALITY),&#10;                                               (2, MOMENT_DIMENSIONALITY), (3, FORCE_DIMENSIONALITY),&#10;                                               (4, FORCE_DIMENSIONALITY), (5, MOMENT_DIMENSIONALITY)]):&#10;            try:&#10;                ret_val[idx].check(expected_dim)&#10;            except pint.DimensionalityError as e:&#10;                print(f&quot;Dimensionality error in ret_val[{idx}]: {e}&quot;)&#10;                print(f&quot;  Actual: {ret_val[idx].dimensionality}, Expected: {expected_dim}&quot;)&#10;&#10;        return ret_val&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of a linear load.&#10;        &#10;        Returns:&#10;        -------&#10;        str&#10;            Description of the linear load including magnitude, position, and load case.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Linear Load ({self.loadcase}): &quot;&#10;                f&quot;w1={self.w1:.3f}, w2={self.w2:.3f}, &quot;&#10;                f&quot;from x={self.a:.3f} to x={self.b:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of beam response across all three regions with ASCII charts.&#10;&#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;&#10;        &#10;        import numpy as np&#10;&#10;        # Get current unit system directly from the manager&#10;        current_units = unit_manager.get_current_units()&#10;        system_name = unit_manager.get_system_name()&#10;        # print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        # print(f&quot;Total Load W = {self.W:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.W, 'force'):.3f} {current_units['force']})&quot;)&#10;        # print(f&quot;Load centroid from left: {self.a + self.cbar:.3f}&quot;)&#10;        # print(f&quot;Reactions: Riy = {self.Riy:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.Riy, 'force'):.3f} {current_units['force']}), Rjy = {self.Rjy:.3f} {INTERNAL_FORCE_UNIT} ({convert_to_display_units(self.Rjy, 'force'):.3f} {current_units['force']})&quot;, end=&quot;\n&quot;)&#10;&#10;        zero_length=pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT)&#10;        regions = [(zero_length, self.a), (self.a, self.b), (self.b, self.L)]&#10;        region_names = [&quot;Before Load [0 to a]&quot;, &quot;Loaded Region [a to b]&quot;, &quot;After Load [b to L]&quot;]&#10;&#10;        # Create sampling points&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                # points=np.linspace(start, end, num_points+1).tolist()&#10;                print(f&quot;Region {i+1} ({region_names[i]}): {points}&quot;)&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;&#10;        # Convert to numpy array&#10;        x_array = np.array(all_x, dtype=object)&#10;&#10;        # Calculate function values using vectorized evaluation&#10;        wy_values = self.Wy.evaluate_vectorized(x_array)&#10;        vy_values = self.Vy.evaluate_vectorized(x_array)&#10;        mz_values = self.Mz.evaluate_vectorized(x_array)&#10;        sz_values = self.Sz.evaluate_vectorized(x_array)&#10;        dy_values = self.Dy.evaluate_vectorized(x_array)&#10;&#10;        # Print ASCII charts&#10;        self._print_ascii_chart(&quot;Distributed Load (Wy)&quot;, all_x, wy_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Shear Force (Vy)&quot;, all_x, vy_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Bending Moment (Mz)&quot;, all_x, mz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Rotation (Sz)&quot;, all_x, sz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Deflection (Dy)&quot;, all_x, dy_values, regions, chart_width, chart_height)&#10;&#10;        # Print table of values at region boundaries&#10;        print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;        print(f&quot;{'Position':15} {'Load':15} {'Shear':15} {'Moment':15} {'Rotation':15} {'Deflection':15}&quot;)&#10;        print(&quot;-&quot; * 90)&#10;        for x in [0, self.a, self.b, self.L]:&#10;            print(f&quot;{x:15.3f} {self.Wy.evaluate(x):15.3f} {self.Vy.evaluate(x):15.3f} {self.Mz.evaluate(x):15.3f} &quot;&#10;                  f&quot;{self.Sz.evaluate(x):15.3e} {self.Dy.evaluate(x):15.3e}&quot;)&#10;    &#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;        from pint import Quantity  # Import Quantity in the method scope&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Filter out NaN values before finding min/max&#10;        valid_indices = []&#10;        valid_y_values = []&#10;        for i, y in enumerate(y_values):&#10;            # Check if y is NaN (including Quantity objects with NaN magnitude)&#10;            is_nan = False&#10;            if hasattr(y, 'magnitude'):&#10;                is_nan = np.isnan(y.magnitude)&#10;            else:&#10;                is_nan = np.isnan(y) if isinstance(y, (int, float)) else False&#10;&#10;            if not is_nan:&#10;                valid_indices.append(i)&#10;                valid_y_values.append(y)&#10;&#10;        # If no valid values, skip plotting&#10;        if len(valid_y_values) == 0:&#10;            print(&quot;No valid data points to plot (all values are NaN)&quot;)&#10;            return&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(valid_y_values)&#10;        max_y = max(valid_y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;        range_y = max_y - min_y&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Skip NaN values&#10;            if hasattr(y, 'magnitude'):&#10;                if np.isnan(y.magnitude):&#10;                    continue&#10;            elif isinstance(y, (int, float)) and np.isnan(y):&#10;                continue&#10;&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart - avoid NaN issues&#10;            try:&#10;                y_normalized = (y - min_y) / range_y&#10;                y_pos = height - 1 - int(y_normalized * (height - 1))&#10;                y_pos = min(height - 1, max(0, y_pos))&#10;                chart[y_pos][x_pos] = '*'&#10;            except (ValueError, TypeError, ZeroDivisionError) as e:&#10;                print(f&quot;Warning: Could not plot point at x={x}, y={y}: {e}&quot;)&#10;                continue&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        print(f&quot;Region boundaries: [{unit_manager.ureg.Quantity(0, self.a.units)}, {self.a:.2f}, {self.b:.2f}, {self.L:.2f}]&quot;)&#10;&#10;    def plot_all_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all non-empty PiecewisePolynomial functions.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial objects with their names and colors&#10;        functions = []&#10;        if hasattr(self, 'Wy') and self.Wy.functions:&#10;            functions.append(('Wy', self.Wy, 'blue', 'Distributed Load'))&#10;        if hasattr(self, 'Vy') and self.Vy.functions:&#10;            functions.append(('Vy', self.Vy, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz') and self.Mz.functions:&#10;            functions.append(('Mz', self.Mz, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz') and self.Sz.functions:&#10;            functions.append(('Sz', self.Sz, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy') and self.Dy.functions:&#10;            functions.append(('Dy', self.Dy, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key points&#10;            for x in [self.a, self.b]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title&#10;        fig.suptitle(f&quot;Beam Analysis for {self.__str__()}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig&#10;&#10;    def plot_all_ppoly_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all PiecewisePolynomial2 functions.&#10;        Uses the efficient PPoly representation for better performance.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial2 objects&#10;        functions = []&#10;        if hasattr(self, 'Wy2') and self.Wy2.ppoly is not None:&#10;            functions.append(('Wy2', self.Wy2, 'blue', 'Distributed Load'))&#10;        if hasattr(self, 'Vy2') and self.Vy2.ppoly is not None:&#10;            functions.append(('Vy2', self.Vy2, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz2') and self.Mz2.ppoly is not None:&#10;            functions.append(('Mz2', self.Mz2, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz2') and self.Sz2.ppoly is not None:&#10;            functions.append(('Sz2', self.Sz2, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy2') and self.Dy2.ppoly is not None:&#10;            functions.append(('Dy2', self.Dy2, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No PiecewisePolynomial2 functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} PiecewisePolynomial2 functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key load boundaries&#10;            for x in [self.a, self.b]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title&#10;        fig.suptitle(f&quot;Beam Analysis (PPoly) for {self.__str__()}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/material.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/material.py" />
              <option name="originalContent" value="from xarray.coding.times import resolve_time_unit_from_attrs_dtype&#10;&#10;import pyMAOS&#10;&#10;from typing import Union&#10;import pint&#10;from pyMAOS import unit_manager&#10;&#10;class LinearElasticMaterial():&#10;    def __init__(self, uid: int,&#10;                 density: Union[float, str, Quantity] = 7861.092937697687,&#10;                 E: Union[float, str,Quantity] = 199947961501.8826,&#10;                 nu: float = 0.3):&#10;        super().__init__()&#10;        self.uid = uid  # Unique Material Identifier&#10;        self.nu = nu  # Poisson's ratio (dimensionless)&#10;&#10;        import pint&#10;        if isinstance(E, pint.Quantity):&#10;            # If it's a pint Quantity, convert to SI units&#10;            self.E=E.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            self.E = self._parse_value_with_units(E, 'pressure')&#10;            if isinstance(self.E, pint.Quantity):&#10;                self.E = self.E.to_reduced_units()&#10;&#10;&#10;        if isinstance(density, pint.Quantity):&#10;            self.density=density.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            density = unit_manager.ureg(density).to_reduced_units()&#10;        print(&#10;            f&quot;LinearElasticMaterial uid {self.uid} initialized with density={self.density:.4g}, E={self.E:.3g}, nu={self.nu}&quot;)&#10;&#10;    def __setstate__(self, state):&#10;&#10;&#10;        # Initialize the object properly&#10;        self.__init__(state.get('uid'),&#10;                      unit_manager.ureg(state.get('density', &quot;0.284 lb/in^3&quot;)).to_reduced_units(),&#10;                      unit_manager.ureg(state.get('E', &quot;29000.0 ksi&quot;)).to_reduced_units(),&#10;                      state.get('nu', 0.3))&#10;&#10;    def _parse_value_with_units(self, value: Union[float, str], unit_type: str) -&gt; float:&#10;        &quot;&quot;&quot;&#10;        Parse a value that may be a float or string with units.&#10;        &#10;        Parameters&#10;        ----------&#10;        value : float or str&#10;            Value, either as a number or string with units (e.g., &quot;29000ksi&quot;, &quot;0.000284klb/in^3&quot;)&#10;        unit_type : str&#10;            Type of unit ('pressure', 'density')&#10;            &#10;        Returns&#10;        -------&#10;        float&#10;            Value in SI units&#10;        &quot;&quot;&quot;&#10;        # If it's already a number, return it as-is (assume SI units)&#10;        if isinstance(value, (int, float)):&#10;            return float(value)&#10;&#10;        # If it's a string, try to parse units&#10;        if isinstance(value, str):&#10;            try:&#10;                # Import the parse function from units_mod&#10;                from pyMAOS.pymaos_units import parse_value_with_units&#10;                import pint&#10;&#10;                # Parse the value string&#10;                parsed_value = parse_value_with_units(value)&#10;&#10;                # If it has units, convert to SI units&#10;                if isinstance(parsed_value, pint.Quantity):&#10;&#10;                    # Convert based on unit type&#10;                    if unit_type == 'pressure':&#10;                        # Young's modulus - convert to Pascals&#10;                        si_value = parsed_value.to('Pa')#.magnitude&#10;                    elif unit_type == 'density':&#10;                        # Density - convert to kg/m^3&#10;                        si_value = parsed_value.to('kg/m^3')#.magnitude&#10;                    else:&#10;                        # Fallback - just use the magnitude&#10;                        si_value = None&#10;                    return float(si_value)&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not convert '{value}' to SI units for {unit_type}: {e}&quot;)&#10;                # Fall back to magnitude if conversion fails&#10;                return&#10;&#10;    # If we get here, something unexpected happened&#10;        raise ValueError(f&quot;Unsupported material value type: {type(value)}&quot;)&#10;&#10;    def stress(self, strain):&#10;        return self.E * strain&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the material properties&quot;&quot;&quot;&#10;&#10;        units = pyMAOS.unit_manager.get_current_units()&#10;        e_display = self.E.to(units['pressure'])&#10;        density_display = self.density.to(units['density'])&#10;        # pressure_unit = units.get('pressure', 'Pa')&#10;        # density_unit = units.get('density', 'kg/m^3')&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={density_display:.4f}, E={e_display}, nu={self.nu}) in {units.get('name', 'default')} units&quot;&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return developer representation of the material&quot;&quot;&quot;&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={self.density:.4f}, E={self.E:.2f}, nu={self.nu})&quot;&#10;&#10;def get_materials_from_yaml(materials_yml, logger=None):&#10;    &quot;&quot;&quot;&#10;    Loads materials from a YAML file and converts properties to internal units&#10;&#10;    Parameters&#10;    ----------&#10;    materials_yml : str&#10;        Path to the materials YAML file&#10;    logger : logging.Logger, optional&#10;        Logger for output messages&#10;&#10;    Returns&#10;    -------&#10;    dict&#10;        Dictionary of materials with uid as key&#10;    &quot;&quot;&quot;&#10;    materials_dict = {}&#10;&#10;    # Use print or logger.info based on what's available&#10;    def log(message):&#10;        if logger:&#10;            logger.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    # Get internal units directly from unit_manager (force refresh)&#10;    import pyMAOS&#10;&#10;    # Debug the unit manager state&#10;    log(f&quot;Unit manager system: {pyMAOS.unit_manager.system_name}&quot;)&#10;    log(f&quot;Unit manager base units: Force={pyMAOS.unit_manager.INTERNAL_FORCE_UNIT}, Length={pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}&quot;)&#10;&#10;    # Force update derived units before accessing them&#10;    # pyMAOS.unit_manager._update_derived_units()&#10;&#10;    # Now get the updated internal units&#10;    internal_pressure_unit = pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT&#10;    internal_density_unit = pyMAOS.unit_manager.INTERNAL_DENSITY_UNIT&#10;    system_name = pyMAOS.unit_manager.system_name&#10;&#10;    log(f&quot;Loading materials from: {materials_yml}&quot;)&#10;    log(f&quot;Using internal unit system: {system_name}&quot;)&#10;    log(f&quot;Internal pressure unit: {internal_pressure_unit}&quot;)&#10;    log(f&quot;Internal pressure unit expanded: {pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT_EXPANDED}&quot;)&#10;    log(f&quot;Internal density unit: {internal_density_unit}&quot;)&#10;&#10;    # Rest of the function...&#10;&#10;    with open(materials_yml, 'r') as file:&#10;        import yaml&#10;        materials_list = yaml.unsafe_load(file)&#10;&#10;    # Process each material and convert units to internal units&#10;    for material in materials_list:&#10;        # If the material is already a LinearElasticMaterial instance, update its units&#10;        if hasattr(material, 'E') and hasattr(material, 'density'):&#10;            # Convert E to internal pressure units if it's a Quantity&#10;            import pint&#10;            if isinstance(material.E, pint.Quantity):&#10;                material.E = material.E.to(internal_pressure_unit)&#10;&#10;            # Convert density to internal density units if it's a Quantity&#10;            if isinstance(material.density, pint.Quantity):&#10;                material.density = material.density.to(internal_density_unit)&#10;&#10;            log(f&quot;Material {material.uid}: E={material.E}, density={material.density}&quot;)&#10;&#10;        # Add material to dictionary&#10;        materials_dict[material.uid] = material&#10;&#10;    log(f&quot;Loaded {len(materials_dict)} materials&quot;)&#10;    return materials_dict" />
              <option name="updatedContent" value="from xarray.coding.times import resolve_time_unit_from_attrs_dtype&#10;&#10;import pyMAOS&#10;&#10;from typing import Union&#10;import pint&#10;from pyMAOS import unit_manager&#10;&#10;class LinearElasticMaterial():&#10;    def __init__(self, uid: int,&#10;                 density: Union[float, str, Quantity] = 7861.092937697687,&#10;                 E: Union[float, str,Quantity] = 199947961501.8826,&#10;                 nu: float = 0.3):&#10;        super().__init__()&#10;        self.uid = uid  # Unique Material Identifier&#10;        self.nu = nu  # Poisson's ratio (dimensionless)&#10;&#10;        import pint&#10;        if isinstance(E, pint.Quantity):&#10;            # If it's a pint Quantity, convert to SI units&#10;            self.E=E.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            self.E = self._parse_value_with_units(E, 'pressure')&#10;            if isinstance(self.E, pint.Quantity):&#10;                self.E = self.E.to_reduced_units()&#10;&#10;&#10;        if isinstance(density, pint.Quantity):&#10;            self.density=density.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            density = unit_manager.ureg(density).to_reduced_units()&#10;        print(&#10;            f&quot;LinearElasticMaterial uid {self.uid} initialized with density={self.density:.4g}, E={self.E:.3g}, nu={self.nu}&quot;)&#10;&#10;    def __setstate__(self, state):&#10;&#10;&#10;        # Initialize the object properly&#10;        self.__init__(state.get('uid'),&#10;                      unit_manager.ureg(state.get('density', &quot;0.284 lb/in^3&quot;)).to_reduced_units(),&#10;                      unit_manager.ureg(state.get('E', &quot;29000.0 ksi&quot;)).to_reduced_units(),&#10;                      state.get('nu', 0.3))&#10;&#10;    def _parse_value_with_units(self, value: Union[float, str], unit_type: str) -&gt; float:&#10;        &quot;&quot;&quot;&#10;        Parse a value that may be a float or string with units.&#10;        &#10;        Parameters&#10;        ----------&#10;        value : float or str&#10;            Value, either as a number or string with units (e.g., &quot;29000ksi&quot;, &quot;0.000284klb/in^3&quot;)&#10;        unit_type : str&#10;            Type of unit ('pressure', 'density')&#10;            &#10;        Returns&#10;        -------&#10;        float&#10;            Value in SI units&#10;        &quot;&quot;&quot;&#10;        # If it's already a number, return it as-is (assume SI units)&#10;        if isinstance(value, (int, float)):&#10;            return float(value)&#10;&#10;        # If it's a string, try to parse units&#10;        if isinstance(value, str):&#10;            try:&#10;                # Import the parse function from units_mod&#10;                from pyMAOS.pymaos_units import parse_value_with_units&#10;                import pint&#10;&#10;                # Parse the value string&#10;                parsed_value = parse_value_with_units(value)&#10;&#10;                # If it has units, convert to SI units&#10;                if isinstance(parsed_value, pint.Quantity):&#10;&#10;                    # Convert based on unit type&#10;                    if unit_type == 'pressure':&#10;                        # Young's modulus - convert to Pascals&#10;                        si_value = parsed_value.to('Pa')#.magnitude&#10;                    elif unit_type == 'density':&#10;                        # Density - convert to kg/m^3&#10;                        si_value = parsed_value.to('kg/m^3')#.magnitude&#10;                    else:&#10;                        # Fallback - just use the magnitude&#10;                        si_value = None&#10;                    return float(si_value)&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not convert '{value}' to SI units for {unit_type}: {e}&quot;)&#10;                # Fall back to magnitude if conversion fails&#10;                return&#10;&#10;    # If we get here, something unexpected happened&#10;        raise ValueError(f&quot;Unsupported material value type: {type(value)}&quot;)&#10;&#10;    def stress(self, strain):&#10;        return self.E * strain&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the material properties&quot;&quot;&quot;&#10;&#10;        units = pyMAOS.unit_manager.get_current_units()&#10;        e_display = self.E.to(units['pressure'])&#10;        density_display = self.density.to(units['density'])&#10;        # pressure_unit = units.get('pressure', 'Pa')&#10;        # density_unit = units.get('density', 'kg/m^3')&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={density_display:.4f}, E={e_display}, nu={self.nu}) in {units.get('name', 'default')} units&quot;&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return developer representation of the material&quot;&quot;&quot;&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={self.density:.4f}, E={self.E:.2f}, nu={self.nu})&quot;&#10;&#10;def get_materials_from_yaml(materials_yml, logger=None):&#10;    &quot;&quot;&quot;&#10;    Loads materials from a YAML file and converts properties to internal units&#10;&#10;    Parameters&#10;    ----------&#10;    materials_yml : str&#10;        Path to the materials YAML file&#10;    logger : logging.Logger, optional&#10;        Logger for output messages&#10;&#10;    Returns&#10;    -------&#10;    dict&#10;        Dictionary of materials with uid as key&#10;    &quot;&quot;&quot;&#10;    materials_dict = {}&#10;&#10;    # Use print or logger.info based on what's available&#10;    def log(message):&#10;        if logger:&#10;            logger.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    # Get internal units directly from unit_manager (force refresh)&#10;    import pyMAOS&#10;&#10;    # Debug the unit manager state&#10;    log(f&quot;Unit manager system: {pyMAOS.unit_manager.system_name}&quot;)&#10;    log(f&quot;Unit manager base units: Force={pyMAOS.unit_manager.INTERNAL_FORCE_UNIT}, Length={pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}&quot;)&#10;&#10;    # Force update derived units before accessing them&#10;    # pyMAOS.unit_manager._update_derived_units()&#10;&#10;    # Now get the updated internal units&#10;    internal_pressure_unit = pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT&#10;    internal_density_unit = pyMAOS.unit_manager.INTERNAL_DENSITY_UNIT&#10;    system_name = pyMAOS.unit_manager.system_name&#10;&#10;    log(f&quot;Loading materials from: {materials_yml}&quot;)&#10;    log(f&quot;Using internal unit system: {system_name}&quot;)&#10;    log(f&quot;Internal pressure unit: {internal_pressure_unit}&quot;)&#10;    log(f&quot;Internal pressure unit expanded: {pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT_EXPANDED}&quot;)&#10;    log(f&quot;Internal density unit: {internal_density_unit}&quot;)&#10;&#10;    # Rest of the function...&#10;&#10;    with open(materials_yml, 'r') as file:&#10;        import yaml&#10;        materials_list = yaml.unsafe_load(file)&#10;&#10;    # Process each material and convert units to internal units&#10;    for material in materials_list:&#10;        # If the material is already a LinearElasticMaterial instance, update its units&#10;        if hasattr(material, 'E') and hasattr(material, 'density'):&#10;            # Convert E to internal pressure units if it's a Quantity&#10;            import pint&#10;            if isinstance(material.E, pint.Quantity):&#10;                material.E = material.E.to(internal_pressure_unit)&#10;&#10;            # Convert density to internal density units if it's a Quantity&#10;            if isinstance(material.density, pint.Quantity):&#10;                material.density = material.density.to(internal_density_unit)&#10;&#10;            log(f&quot;Material {material.uid}: E={material.E}, density={material.density}&quot;)&#10;&#10;        # Add material to dictionary&#10;        materials_dict[material.uid] = material&#10;&#10;    log(f&quot;Loaded {len(materials_dict)} materials&quot;)&#10;    return materials_dict" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/node2d.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/node2d.py" />
              <option name="originalContent" value="# -*- coding: utf-8 -*-&#10;import math&#10;import numpy as np&#10;import pint&#10;from pint import Quantity&#10;import pyMAOS&#10;from pyMAOS.pymaos_units import parse_value_with_units&#10;&#10;&#10;class LoadsDict(dict):&#10;    &quot;&quot;&quot;Custom dictionary class that handles unit parsing for load values&quot;&quot;&quot;&#10;&#10;    def __init__(self, node):&#10;        super().__init__()&#10;        self.node = node  # Reference to the parent node for access to parsing methods&#10;&#10;    def __setitem__(self, key, value):&#10;        &quot;&quot;&quot;Override setitem to parse units when assigning individual load cases&quot;&quot;&quot;&#10;        if isinstance(value, (list, tuple)):&#10;            # Parse the load values with units&#10;            parsed_values = self.node._parse_load_values(value)&#10;            super().__setitem__(key, parsed_values)&#10;        else:&#10;            super().__setitem__(key, value)&#10;&#10;    def update(self, other_dict):&#10;        &quot;&quot;&quot;Override update to parse units for bulk updates&quot;&quot;&quot;&#10;        if isinstance(other_dict, dict):&#10;            for key, value in other_dict.items():&#10;                self[key] = value  # Use our custom __setitem__&#10;&#10;&#10;class R2Node:&#10;    def __init__(self, uid, x, y):&#10;        &quot;&quot;&quot;&#10;        Parameters&#10;        ----------&#10;        x : float, str, or pint.Quantity&#10;            x-axis coordinate of the node in R2.&#10;        y : float, str, or pint.Quantity&#10;            y-axis coordinate of the node in R2.&#10;        uid : int&#10;            unique node number.&#10;        &quot;&quot;&quot;&#10;        self.uid = uid&#10;        # Ux,Uy, and Rz = 3&#10;        # Number of possible Joint Displacements&#10;        self.NJD = 3&#10;&#10;        self.is_inode_of_elem_ids = []; self.is_jnode_of_elem_ids = []&#10;&#10;        self.is_inode_of_elems=[]; self.is_jnode_of_elems=[]&#10;&#10;        # Parse and store coordinates as pint.Quantity objects&#10;        self.x = self._parse_coordinate(x)&#10;        self.y = self._parse_coordinate(y)&#10;&#10;        # Restraints [Ux, Uy, Rz]&#10;        self.restraints_key = [&quot;Ux&quot;, &quot;Uy&quot;, &quot;Rz&quot;]&#10;        self.restraints = [0, 0, 0]&#10;&#10;        # Spring Restraint [kux, kuy, krz]&#10;        # Spring Stiffness should be 0 for a restrained direction&#10;        # Spring is still a DOF for the node&#10;        self._spring_stiffness = [0, 0, 0]&#10;&#10;        # Directionality of spring&#10;        # 0 = bidirectional resistance&#10;        # 1 = spring resists positive axis displacement&#10;        # -1 = spring resists negative axis displacement&#10;        self._spring_direction = [0, 0, 0]&#10;&#10;        # Spring Stiffness Multiplier&#10;        self._springUxmulti = {}&#10;        self._springUymulti = {}&#10;        self._springRzmulti = {}&#10;&#10;        # Enforced Displacement [Ux, Uy, Rz]&#10;        self._enforced_displacements = [0, 0, 0]&#10;&#10;        # Dict of Loads by case - use custom dictionary that handles unit parsing&#10;        self.loads = LoadsDict(self)&#10;&#10;        # Dict of Displacements by combo&#10;        self.displacements = {}&#10;&#10;        # Dict of Reactions by combo&#10;        self.reactions = {}&#10;&#10;        # Flags&#10;        self._isSpring = False&#10;        self._isNonLinear = False&#10;&#10;    def _parse_coordinate(self, coordinate):&#10;        # If already a Quantity, convert to internal length units&#10;        if isinstance(coordinate, pint.Quantity):&#10;            return coordinate.to(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;&#10;        # If it's a number, create a Quantity in internal length units&#10;        if isinstance(coordinate, (int, float)):&#10;            return coordinate * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;&#10;        # If it's a string, parse units&#10;        if isinstance(coordinate, str):&#10;            try:&#10;                parsed_value = parse_value_with_units(coordinate)&#10;&#10;                if isinstance(parsed_value, pint.Quantity):&#10;                    return parsed_value.to(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;                else:&#10;                    # No units specified, assume internal length units&#10;                    return float(parsed_value) * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not parse coordinate '{coordinate}': {e}&quot;)&#10;                try:&#10;                    return float(coordinate) * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;                except Exception:&#10;                    raise ValueError(f&quot;Could not parse coordinate value: {coordinate}&quot;)&#10;&#10;        raise ValueError(f&quot;Unsupported coordinate type: {type(coordinate)}&quot;)&#10;&#10;    def _parse_load_value(self, load_value):&#10;        # If already a Quantity, convert to appropriate internal units&#10;        if isinstance(load_value, pint.Quantity):&#10;            # Check dimensionality to convert to correct units&#10;            if load_value.dimensionality == pyMAOS.FORCE_DIMENSIONALITY:&#10;                return load_value.to(pyMAOS.INTERNAL_FORCE_UNIT)&#10;            elif load_value.dimensionality == pyMAOS.MOMENT_DIMENSIONALITY:&#10;                return load_value.to(pyMAOS.INTERNAL_MOMENT_UNIT)&#10;            return load_value&#10;&#10;        # If it's a number, assume internal force units&#10;        if isinstance(load_value, (int, float)):&#10;            return float(load_value) * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_FORCE_UNIT)&#10;&#10;        # If it's a string, parse units&#10;        if isinstance(load_value, str):&#10;            try:&#10;                parsed_value = parse_value_with_units(load_value)&#10;&#10;                if isinstance(parsed_value, pint.Quantity):&#10;                    # Convert to appropriate internal units based on dimensionality&#10;                    if parsed_value.dimensionality == pyMAOS.FORCE_DIMENSIONALITY:&#10;                        return parsed_value.to(pyMAOS.INTERNAL_FORCE_UNIT)&#10;                    elif parsed_value.dimensionality == pyMAOS.MOMENT_DIMENSIONALITY:&#10;                        return parsed_value.to(pyMAOS.INTERNAL_MOMENT_UNIT)&#10;                    return parsed_value&#10;                else:&#10;                    # No units specified, assume internal force units&#10;                    return float(parsed_value) * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_FORCE_UNIT)&#10;&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not parse load value '{load_value}': {e}&quot;)&#10;                try:&#10;                    return float(load_value) * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_FORCE_UNIT)&#10;                except Exception:&#10;                    raise ValueError(f&quot;Could not parse load value: {load_value}&quot;)&#10;&#10;        raise ValueError(f&quot;Unsupported load value type: {type(load_value)}&quot;)&#10;&#10;    def _parse_load_values(self, load_values):&#10;        &quot;&quot;&quot;&#10;        Parse a list of load values [fx, fy, mz].&#10;&#10;        Parameters&#10;        ----------&#10;        load_values : list&#10;            List of load values [fx, fy, mz]&#10;&#10;        Returns&#10;        -------&#10;        list&#10;            List of load values as pint.Quantity objects&#10;        &quot;&quot;&quot;&#10;        if not isinstance(load_values, (list, tuple)):&#10;            raise ValueError(&quot;Load values must be a list or tuple&quot;)&#10;&#10;        if len(load_values) != 3:&#10;            raise ValueError(&quot;Load values must contain exactly 3 elements [fx, fy, mz]&quot;)&#10;&#10;        parsed_loads = []&#10;        for i, load_value in enumerate(load_values):&#10;            parsed_loads.append(self._parse_load_value(load_value))&#10;&#10;        return parsed_loads&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return a readable string representation of the node with complete restraint information&quot;&quot;&quot;&#10;        restraint_symbols = {0: &quot;Free&quot;, 1: &quot;Fixed&quot;}&#10;&#10;        str_repr = f&quot;Node:{self.uid}\n&quot;&#10;        str_repr += f&quot;Coordinates: ({self.x}, {self.y})\n&quot;&#10;        str_repr += &quot;Restraints:\n&quot;&#10;        str_repr += &quot;-&quot; * 15 + &quot;\n&quot;&#10;&#10;        for i, r in enumerate(self.restraints):&#10;            str_repr += f&quot;{self.restraints_key[i]}: {restraint_symbols[r]}&quot;&#10;&#10;            # Add spring information if applicable&#10;            if self._isSpring and self._spring_stiffness[i] &gt; 0:&#10;                direction_info = &quot;&quot;&#10;                if self._spring_direction[i] == 1:&#10;                    direction_info = &quot; (+ direction only)&quot;&#10;                elif self._spring_direction[i] == -1:&#10;                    direction_info = &quot; (- direction only)&quot;&#10;&#10;                str_repr += f&quot; with Spring k={self._spring_stiffness[i]}{direction_info}&quot;&#10;&#10;            str_repr += &quot;\n&quot;&#10;&#10;        return str_repr&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return a string representation of the node for debugging&quot;&quot;&quot;&#10;        return f&quot;R2Node(uid={self.uid}, x={self.x}, y={self.y})&quot;&#10;&#10;    def x_displaced(self, combo, scale=1.0):&#10;        &quot;&quot;&quot;Return X coordinate with displacement applied&quot;&quot;&quot;&#10;        if combo.name in self.displacements:&#10;            # Get displacement in compatible form&#10;            raw_disp = self.displacements[combo.name][0]&#10;&#10;            # Convert the displacement to the same unit as self.x&#10;            disp_in_x_units = raw_disp.to(self.x.units) * scale&#10;&#10;            # Add using the same registry&#10;            return self.x + disp_in_x_units&#10;        return self.x&#10;&#10;    def y_displaced(self, combo, scale=1.0):&#10;        &quot;&quot;&quot;Return Y coordinate with displacement applied&quot;&quot;&quot;&#10;        if combo.name in self.displacements:&#10;            # Get displacement in compatible form&#10;            raw_disp = self.displacements[combo.name][1]&#10;&#10;            # Convert the displacement to the same unit as self.x&#10;            disp_in_y_units = raw_disp.to(self.y.units) * scale&#10;&#10;            # Add using the same registry&#10;            return self.y + disp_in_y_units&#10;        return self.y&#10;&#10;    def z_rotated(self, combo, scale=1.0):&#10;        &quot;&quot;&quot;Return Z rotation angle with displacement applied&quot;&quot;&quot;&#10;        if combo.name in self.displacements:&#10;            return self.displacements[combo.name][2] * scale&#10;        return 0&#10;&#10;    def distance(self, other):&#10;        &quot;&quot;&quot;&#10;        Calculate Euclidean distance between nodes.&#10;&#10;        Parameters&#10;        ----------&#10;        other : R2Node&#10;            Another node&#10;&#10;        Returns&#10;        -------&#10;        pint.Quantity&#10;            Euclidean distance in meters&#10;        &quot;&quot;&quot;&#10;        dx = self.x - other.x&#10;        dy = self.y - other.y&#10;&#10;        # Calculate distance preserving units&#10;        return (dx ** 2 + dy ** 2) ** 0.5&#10;&#10;    def restrainUx(self):&#10;        self.restraints[0] = 1&#10;&#10;    def restrainUy(self):&#10;        self.restraints[1] = 1&#10;&#10;    def restrainMz(self):&#10;        self.restraints[2] = 1&#10;&#10;    def restrainAll(self):&#10;        self.restraints = [1, 1, 1]&#10;&#10;    def restrainTranslation(self):&#10;        self.restraints = [1, 1, 0]&#10;&#10;    def releaseUx(self):&#10;        self.restraints[0] = 0&#10;&#10;    def releaseUy(self):&#10;        self.restraints[1] = 0&#10;&#10;    def releaseMz(self):&#10;        self.restraints[2] = 0&#10;&#10;    def releaseAll(self):&#10;        self.restraints = [0, 0, 0]&#10;&#10;    def applySpringUx(self, k=100, direction=0):&#10;        self.restraints[0] = 0&#10;        self._spring_stiffness[0] = k&#10;        self._spring_direction[0] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def applySpringUy(self, k=100, direction=0):&#10;        self.restraints[1] = 0&#10;        self._spring_stiffness[1] = k&#10;        self._spring_direction[1] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def applySpringRz(self, k=100, direction=0):&#10;        self.restraints[2] = 0&#10;        self._spring_stiffness[2] = k&#10;        self._spring_direction[2] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def add_nodal_load(self, fx, fy, mz, loadcase=&quot;D&quot;):&#10;        if loadcase not in self.loads:&#10;            zero_force = 0 * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_FORCE_UNIT)&#10;            zero_moment = 0 * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_MOMENT_UNIT)&#10;            self.loads[loadcase] = [zero_force, zero_force, zero_moment]&#10;&#10;        # Parse load values with units&#10;        fx_parsed = self._parse_load_value(fx)&#10;        fy_parsed = self._parse_load_value(fy)&#10;        mz_parsed = self._parse_load_value(mz)&#10;&#10;        # Add the load components to any existing loads&#10;        self.loads[loadcase][0] += fx_parsed&#10;        self.loads[loadcase][1] += fy_parsed&#10;        self.loads[loadcase][2] += mz_parsed&#10;&#10;    def display_loads(self):&#10;        &quot;&quot;&quot;Display all loads applied to the node.&quot;&quot;&quot;&#10;        if not self.loads:&#10;            print(f&quot;Node:{self.uid} - No loads applied&quot;)&#10;            return&#10;&#10;        print(f&quot;Node:{self.uid} - Applied Loads&quot;)&#10;        print(&quot;-&quot; * 50)&#10;&#10;        for loadcase, forces in self.loads.items():&#10;            print(f&quot;Load Case: {loadcase}&quot;)&#10;            print(f&quot;  Fx: {forces[0]}, Fy: {forces[1]}, Mz: {forces[2]}&quot;)&#10;&#10;    def compute_reactions(self, load_combination):&#10;        &quot;&quot;&quot;Calculate reactions for a given load combination&#10;&#10;        Computes support reactions by summing member end forces&#10;        at support nodes.&#10;&#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to calculate reactions&#10;&#10;        Returns&#10;        -------&#10;        numpy.ndarray&#10;            Vector of reaction forces/moments at support nodes&#10;        &quot;&quot;&quot;&#10;        # Initialize reactions array with object dtype to store quantities with units&#10;        reactions = np.zeros(self.NJD, dtype=object)&#10;&#10;        # Convert zeros to quantities with appropriate units&#10;        import pyMAOS&#10;        for i in range(self.NJD):&#10;            # Use alternating force and moment units based on DOF index&#10;            unit = pyMAOS.unit_manager.get_current_units().get('force' if i % 3 != 2 else 'moment', 'N')&#10;            reactions[i] = pyMAOS.unit_manager.get_zero_quantity(unit)&#10;&#10;        print(f&quot;Computing reactions for load combination: {load_combination.name}&quot;)&#10;&#10;        # For each member, add its contribution to the reactions&#10;        from pyMAOS.quantity_utils import add_arrays_with_units&#10;        # First iterate through members where this node is the i-node&#10;        for member in self.is_inode_of_elems:&#10;            member_FG = member.set_end_forces_global(load_combination)&#10;            # Use slice for i-node forces (first part of force vector)&#10;            reactions = add_arrays_with_units(reactions, member_FG[0:self.NJD])&#10;            print(f&quot;After adding i-node member {member.uid}, reactions = {reactions}&quot;)&#10;&#10;        # Then iterate through members where this node is the j-node&#10;        for member in self.is_jnode_of_elems:&#10;            member_FG = member.set_end_forces_global(load_combination)&#10;            # Use slice for j-node forces (second part of force vector)&#10;            reactions = add_arrays_with_units(reactions, member_FG[self.NJD:(2*self.NJD)])&#10;            print(f&quot;After adding j-node member {member.uid}, reactions = {reactions}&quot;)&#10;&#10;        self.reactions = reactions&#10;        print(f&quot;Node {self.uid} reactions: Rx={reactions[0]:.4E}, Ry={reactions[1]:.4E}, Mz={reactions[2]:.4E}&quot;)&#10;&#10;        return reactions&#10;&#10;# --- Read nodes ---&#10;def get_nodes_from_csv(csv_file):&#10;    import csv&#10;    nodes_dict = {}&#10;    with open(csv_file, newline=&quot;&quot;) as csvfile:&#10;        reader = csv.DictReader(csvfile, skipinitialspace=True)&#10;        for row in reader:&#10;            uid = int(row[&quot;uid&quot;])&#10;            x = float(row[&quot;X&quot;])&#10;            y = float(row[&quot;Y&quot;])&#10;            rx = int(row[&quot;rx&quot;])&#10;            ry = int(row[&quot;ry&quot;])&#10;            rz = int(row[&quot;rz&quot;])&#10;            node = R2Node(uid, x, y)&#10;            node.restraints = [rx, ry, rz]&#10;            nodes_dict[uid] = node&#10;    return nodes_dict" />
              <option name="updatedContent" value="# -*- coding: utf-8 -*-&#10;import math&#10;import numpy as np&#10;import pint&#10;from pint import Quantity&#10;import pyMAOS&#10;from pyMAOS.pymaos_units import parse_value_with_units&#10;&#10;&#10;class LoadsDict(dict):&#10;    &quot;&quot;&quot;Custom dictionary class that handles unit parsing for load values&quot;&quot;&quot;&#10;&#10;    def __init__(self, node):&#10;        super().__init__()&#10;        self.node = node  # Reference to the parent node for access to parsing methods&#10;&#10;    def __setitem__(self, key, value):&#10;        &quot;&quot;&quot;Override setitem to parse units when assigning individual load cases&quot;&quot;&quot;&#10;        if isinstance(value, (list, tuple)):&#10;            # Parse the load values with units&#10;            parsed_values = self.node._parse_load_values(value)&#10;            super().__setitem__(key, parsed_values)&#10;        else:&#10;            super().__setitem__(key, value)&#10;&#10;    def update(self, other_dict):&#10;        &quot;&quot;&quot;Override update to parse units for bulk updates&quot;&quot;&quot;&#10;        if isinstance(other_dict, dict):&#10;            for key, value in other_dict.items():&#10;                self[key] = value  # Use our custom __setitem__&#10;&#10;&#10;class R2Node:&#10;    def __init__(self, uid, x, y):&#10;        &quot;&quot;&quot;&#10;        Parameters&#10;        ----------&#10;        x : float, str, or pint.Quantity&#10;            x-axis coordinate of the node in R2.&#10;        y : float, str, or pint.Quantity&#10;            y-axis coordinate of the node in R2.&#10;        uid : int&#10;            unique node number.&#10;        &quot;&quot;&quot;&#10;        self.uid = uid&#10;        # Ux,Uy, and Rz = 3&#10;        # Number of possible Joint Displacements&#10;        self.NJD = 3&#10;&#10;        self.is_inode_of_elem_ids = []; self.is_jnode_of_elem_ids = []&#10;&#10;        self.is_inode_of_elems=[]; self.is_jnode_of_elems=[]&#10;&#10;        # Parse and store coordinates as pint.Quantity objects&#10;        self.x = self._parse_coordinate(x)&#10;        self.y = self._parse_coordinate(y)&#10;&#10;        # Restraints [Ux, Uy, Rz]&#10;        self.restraints_key = [&quot;Ux&quot;, &quot;Uy&quot;, &quot;Rz&quot;]&#10;        self.restraints = [0, 0, 0]&#10;&#10;        # Spring Restraint [kux, kuy, krz]&#10;        # Spring Stiffness should be 0 for a restrained direction&#10;        # Spring is still a DOF for the node&#10;        self._spring_stiffness = [0, 0, 0]&#10;&#10;        # Directionality of spring&#10;        # 0 = bidirectional resistance&#10;        # 1 = spring resists positive axis displacement&#10;        # -1 = spring resists negative axis displacement&#10;        self._spring_direction = [0, 0, 0]&#10;&#10;        # Spring Stiffness Multiplier&#10;        self._springUxmulti = {}&#10;        self._springUymulti = {}&#10;        self._springRzmulti = {}&#10;&#10;        # Enforced Displacement [Ux, Uy, Rz]&#10;        self._enforced_displacements = [0, 0, 0]&#10;&#10;        # Dict of Loads by case - use custom dictionary that handles unit parsing&#10;        self.loads = LoadsDict(self)&#10;&#10;        # Dict of Displacements by combo&#10;        self.displacements = {}&#10;&#10;        # Dict of Reactions by combo&#10;        self.reactions = {}&#10;&#10;        # Flags&#10;        self._isSpring = False&#10;        self._isNonLinear = False&#10;&#10;    def _parse_coordinate(self, coordinate):&#10;        # If already a Quantity, convert to internal length units&#10;        if isinstance(coordinate, pint.Quantity):&#10;            return coordinate.to(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;&#10;        # If it's a number, create a Quantity in internal length units&#10;        if isinstance(coordinate, (int, float)):&#10;            return coordinate * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;&#10;        # If it's a string, parse units&#10;        if isinstance(coordinate, str):&#10;            try:&#10;                parsed_value = parse_value_with_units(coordinate)&#10;&#10;                if isinstance(parsed_value, pint.Quantity):&#10;                    return parsed_value.to(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;                else:&#10;                    # No units specified, assume internal length units&#10;                    return float(parsed_value) * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not parse coordinate '{coordinate}': {e}&quot;)&#10;                try:&#10;                    return float(coordinate) * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;                except Exception:&#10;                    raise ValueError(f&quot;Could not parse coordinate value: {coordinate}&quot;)&#10;&#10;        raise ValueError(f&quot;Unsupported coordinate type: {type(coordinate)}&quot;)&#10;&#10;    def _parse_load_value(self, load_value):&#10;        # If already a Quantity, convert to appropriate internal units&#10;        if isinstance(load_value, pint.Quantity):&#10;            # Check dimensionality to convert to correct units&#10;            if load_value.dimensionality == pyMAOS.FORCE_DIMENSIONALITY:&#10;                return load_value.to(pyMAOS.INTERNAL_FORCE_UNIT)&#10;            elif load_value.dimensionality == pyMAOS.MOMENT_DIMENSIONALITY:&#10;                return load_value.to(pyMAOS.INTERNAL_MOMENT_UNIT)&#10;            return load_value&#10;&#10;        # If it's a number, assume internal force units&#10;        if isinstance(load_value, (int, float)):&#10;            return float(load_value) * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_FORCE_UNIT)&#10;&#10;        # If it's a string, parse units&#10;        if isinstance(load_value, str):&#10;            try:&#10;                parsed_value = parse_value_with_units(load_value)&#10;&#10;                if isinstance(parsed_value, pint.Quantity):&#10;                    # Convert to appropriate internal units based on dimensionality&#10;                    if parsed_value.dimensionality == pyMAOS.FORCE_DIMENSIONALITY:&#10;                        return parsed_value.to(pyMAOS.INTERNAL_FORCE_UNIT)&#10;                    elif parsed_value.dimensionality == pyMAOS.MOMENT_DIMENSIONALITY:&#10;                        return parsed_value.to(pyMAOS.INTERNAL_MOMENT_UNIT)&#10;                    return parsed_value&#10;                else:&#10;                    # No units specified, assume internal force units&#10;                    return float(parsed_value) * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_FORCE_UNIT)&#10;&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not parse load value '{load_value}': {e}&quot;)&#10;                try:&#10;                    return float(load_value) * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_FORCE_UNIT)&#10;                except Exception:&#10;                    raise ValueError(f&quot;Could not parse load value: {load_value}&quot;)&#10;&#10;        raise ValueError(f&quot;Unsupported load value type: {type(load_value)}&quot;)&#10;&#10;    def _parse_load_values(self, load_values):&#10;        &quot;&quot;&quot;&#10;        Parse a list of load values [fx, fy, mz].&#10;&#10;        Parameters&#10;        ----------&#10;        load_values : list&#10;            List of load values [fx, fy, mz]&#10;&#10;        Returns&#10;        -------&#10;        list&#10;            List of load values as pint.Quantity objects&#10;        &quot;&quot;&quot;&#10;        if not isinstance(load_values, (list, tuple)):&#10;            raise ValueError(&quot;Load values must be a list or tuple&quot;)&#10;&#10;        if len(load_values) != 3:&#10;            raise ValueError(&quot;Load values must contain exactly 3 elements [fx, fy, mz]&quot;)&#10;&#10;        parsed_loads = []&#10;        for i, load_value in enumerate(load_values):&#10;            parsed_loads.append(self._parse_load_value(load_value))&#10;&#10;        return parsed_loads&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return a readable string representation of the node with complete restraint information&quot;&quot;&quot;&#10;        restraint_symbols = {0: &quot;Free&quot;, 1: &quot;Fixed&quot;}&#10;&#10;        str_repr = f&quot;Node:{self.uid}\n&quot;&#10;        str_repr += f&quot;Coordinates: ({self.x}, {self.y})\n&quot;&#10;        str_repr += &quot;Restraints:\n&quot;&#10;        str_repr += &quot;-&quot; * 15 + &quot;\n&quot;&#10;&#10;        for i, r in enumerate(self.restraints):&#10;            str_repr += f&quot;{self.restraints_key[i]}: {restraint_symbols[r]}&quot;&#10;&#10;            # Add spring information if applicable&#10;            if self._isSpring and self._spring_stiffness[i] &gt; 0:&#10;                direction_info = &quot;&quot;&#10;                if self._spring_direction[i] == 1:&#10;                    direction_info = &quot; (+ direction only)&quot;&#10;                elif self._spring_direction[i] == -1:&#10;                    direction_info = &quot; (- direction only)&quot;&#10;&#10;                str_repr += f&quot; with Spring k={self._spring_stiffness[i]}{direction_info}&quot;&#10;&#10;            str_repr += &quot;\n&quot;&#10;&#10;        return str_repr&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return a string representation of the node for debugging&quot;&quot;&quot;&#10;        return f&quot;R2Node(uid={self.uid}, x={self.x}, y={self.y})&quot;&#10;&#10;    def x_displaced(self, combo, scale=1.0):&#10;        &quot;&quot;&quot;Return X coordinate with displacement applied&quot;&quot;&quot;&#10;        if combo.name in self.displacements:&#10;            # Get displacement in compatible form&#10;            raw_disp = self.displacements[combo.name][0]&#10;            &#10;            # Handle case where displacement is stored as a plain number&#10;            if not hasattr(raw_disp, 'to'):&#10;                # Convert to a quantity with appropriate units&#10;                raw_disp = raw_disp * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;            &#10;            # Convert the displacement to the same unit as self.x&#10;            disp_in_x_units = raw_disp.to(self.x.units) * scale&#10;            &#10;            # Add using the same registry&#10;            return self.x + disp_in_x_units&#10;        return self.x&#10;&#10;    def y_displaced(self, combo, scale=1.0):&#10;        &quot;&quot;&quot;Return Y coordinate with displacement applied&quot;&quot;&quot;&#10;        if combo.name in self.displacements:&#10;            # Get displacement in compatible form&#10;            raw_disp = self.displacements[combo.name][1]&#10;            &#10;            # Handle case where displacement is stored as a plain number&#10;            if not hasattr(raw_disp, 'to'):&#10;                # Convert to a quantity with appropriate units&#10;                raw_disp = raw_disp * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_LENGTH_UNIT)&#10;            &#10;            # Convert the displacement to the same unit as self.y&#10;            disp_in_y_units = raw_disp.to(self.y.units) * scale&#10;            &#10;            # Add using the same registry&#10;            return self.y + disp_in_y_units&#10;        return self.y&#10;&#10;    def z_rotated(self, combo, scale=1.0):&#10;        &quot;&quot;&quot;Return Z rotation angle with displacement applied&quot;&quot;&quot;&#10;        if combo.name in self.displacements:&#10;            raw_rot = self.displacements[combo.name][2]&#10;            # Handle case where rotation is stored as a plain number&#10;            if not hasattr(raw_rot, 'magnitude'):&#10;                # Convert to a quantity with appropriate units&#10;                return raw_rot * scale * pyMAOS.unit_manager.ureg('rad')&#10;            return raw_rot * scale&#10;        return 0 * pyMAOS.unit_manager.ureg('rad')&#10;&#10;    def distance(self, other):&#10;        &quot;&quot;&quot;&#10;        Calculate Euclidean distance between nodes.&#10;&#10;        Parameters&#10;        ----------&#10;        other : R2Node&#10;            Another node&#10;&#10;        Returns&#10;        -------&#10;        pint.Quantity&#10;            Euclidean distance in meters&#10;        &quot;&quot;&quot;&#10;        dx = self.x - other.x&#10;        dy = self.y - other.y&#10;&#10;        # Calculate distance preserving units&#10;        return (dx ** 2 + dy ** 2) ** 0.5&#10;&#10;    def restrainUx(self):&#10;        self.restraints[0] = 1&#10;&#10;    def restrainUy(self):&#10;        self.restraints[1] = 1&#10;&#10;    def restrainMz(self):&#10;        self.restraints[2] = 1&#10;&#10;    def restrainAll(self):&#10;        self.restraints = [1, 1, 1]&#10;&#10;    def restrainTranslation(self):&#10;        self.restraints = [1, 1, 0]&#10;&#10;    def releaseUx(self):&#10;        self.restraints[0] = 0&#10;&#10;    def releaseUy(self):&#10;        self.restraints[1] = 0&#10;&#10;    def releaseMz(self):&#10;        self.restraints[2] = 0&#10;&#10;    def releaseAll(self):&#10;        self.restraints = [0, 0, 0]&#10;&#10;    def applySpringUx(self, k=100, direction=0):&#10;        self.restraints[0] = 0&#10;        self._spring_stiffness[0] = k&#10;        self._spring_direction[0] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def applySpringUy(self, k=100, direction=0):&#10;        self.restraints[1] = 0&#10;        self._spring_stiffness[1] = k&#10;        self._spring_direction[1] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def applySpringRz(self, k=100, direction=0):&#10;        self.restraints[2] = 0&#10;        self._spring_stiffness[2] = k&#10;        self._spring_direction[2] = direction&#10;        self._isSpring = True&#10;        if direction != 0:&#10;            self._isNonLinear = True&#10;&#10;    def add_nodal_load(self, fx, fy, mz, loadcase=&quot;D&quot;):&#10;        if loadcase not in self.loads:&#10;            zero_force = 0 * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_FORCE_UNIT)&#10;            zero_moment = 0 * pyMAOS.unit_manager.ureg(pyMAOS.INTERNAL_MOMENT_UNIT)&#10;            self.loads[loadcase] = [zero_force, zero_force, zero_moment]&#10;&#10;        # Parse load values with units&#10;        fx_parsed = self._parse_load_value(fx)&#10;        fy_parsed = self._parse_load_value(fy)&#10;        mz_parsed = self._parse_load_value(mz)&#10;&#10;        # Add the load components to any existing loads&#10;        self.loads[loadcase][0] += fx_parsed&#10;        self.loads[loadcase][1] += fy_parsed&#10;        self.loads[loadcase][2] += mz_parsed&#10;&#10;    def display_loads(self):&#10;        &quot;&quot;&quot;Display all loads applied to the node.&quot;&quot;&quot;&#10;        if not self.loads:&#10;            print(f&quot;Node:{self.uid} - No loads applied&quot;)&#10;            return&#10;&#10;        print(f&quot;Node:{self.uid} - Applied Loads&quot;)&#10;        print(&quot;-&quot; * 50)&#10;&#10;        for loadcase, forces in self.loads.items():&#10;            print(f&quot;Load Case: {loadcase}&quot;)&#10;            print(f&quot;  Fx: {forces[0]}, Fy: {forces[1]}, Mz: {forces[2]}&quot;)&#10;&#10;    def compute_reactions(self, load_combination):&#10;        &quot;&quot;&quot;Calculate reactions for a given load combination&#10;&#10;        Computes support reactions by summing member end forces&#10;        at support nodes.&#10;&#10;        Parameters&#10;        ----------&#10;        load_combination : LoadCombo&#10;            The load combination for which to calculate reactions&#10;&#10;        Returns&#10;        -------&#10;        numpy.ndarray&#10;            Vector of reaction forces/moments at support nodes&#10;        &quot;&quot;&quot;&#10;        # Initialize reactions array with object dtype to store quantities with units&#10;        reactions = np.zeros(self.NJD, dtype=object)&#10;&#10;        # Convert zeros to quantities with appropriate units&#10;        import pyMAOS&#10;        for i in range(self.NJD):&#10;            # Use alternating force and moment units based on DOF index&#10;            unit = pyMAOS.unit_manager.get_current_units().get('force' if i % 3 != 2 else 'moment', 'N')&#10;            reactions[i] = pyMAOS.unit_manager.get_zero_quantity(unit)&#10;&#10;        print(f&quot;Computing reactions for load combination: {load_combination.name}&quot;)&#10;&#10;        # For each member, add its contribution to the reactions&#10;        from pyMAOS.quantity_utils import add_arrays_with_units&#10;        # First iterate through members where this node is the i-node&#10;        for member in self.is_inode_of_elems:&#10;            member_FG = member.set_end_forces_global(load_combination)&#10;            # Use slice for i-node forces (first part of force vector)&#10;            reactions = add_arrays_with_units(reactions, member_FG[0:self.NJD])&#10;            print(f&quot;After adding i-node member {member.uid}, reactions = {reactions}&quot;)&#10;&#10;        # Then iterate through members where this node is the j-node&#10;        for member in self.is_jnode_of_elems:&#10;            member_FG = member.set_end_forces_global(load_combination)&#10;            # Use slice for j-node forces (second part of force vector)&#10;            reactions = add_arrays_with_units(reactions, member_FG[self.NJD:(2*self.NJD)])&#10;            print(f&quot;After adding j-node member {member.uid}, reactions = {reactions}&quot;)&#10;&#10;        self.reactions = reactions&#10;        print(f&quot;Node {self.uid} reactions: Rx={reactions[0]:.4E}, Ry={reactions[1]:.4E}, Mz={reactions[2]:.4E}&quot;)&#10;&#10;        return reactions&#10;&#10;# --- Read nodes ---&#10;def get_nodes_from_csv(csv_file):&#10;    import csv&#10;    nodes_dict = {}&#10;    with open(csv_file, newline=&quot;&quot;) as csvfile:&#10;        reader = csv.DictReader(csvfile, skipinitialspace=True)&#10;        for row in reader:&#10;            uid = int(row[&quot;uid&quot;])&#10;            x = float(row[&quot;X&quot;])&#10;            y = float(row[&quot;Y&quot;])&#10;            rx = int(row[&quot;rx&quot;])&#10;            ry = int(row[&quot;ry&quot;])&#10;            rz = int(row[&quot;rz&quot;])&#10;            node = R2Node(uid, x, y)&#10;            node.restraints = [rx, ry, rz]&#10;            nodes_dict[uid] = node&#10;    return nodes_dict" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/plotting/structure2d_vista.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/plotting/structure2d_vista.py" />
              <option name="originalContent" value="import pyvista as pv&#10;import numpy as np&#10;&#10;def plot_structure_pv(structure, loadcombo=None, scale=1.0, scaling_file=None):&#10;    &quot;&quot;&quot;&#10;    Plot the structure using PyVista/VTK with scaling from config file.&#10;&#10;    Parameters&#10;    ----------&#10;    structure : R2Structure&#10;        Structure object containing nodes and members&#10;    loadcombo : LoadCombo, optional&#10;        Load combination for plotting deformed shape&#10;    scale : float, optional&#10;        Scale factor for deformations (default=1.0)&#10;    scaling_file : str, optional&#10;        Path to the scaling.json file&#10;    &quot;&quot;&quot;&#10;    import vtk&#10;    import pyvista as pv&#10;    import numpy as np&#10;    import os&#10;    from pyMAOS.plotting.scaling import get_scaling_from_config&#10;&#10;    # Find scaling.json in input directory or current directory&#10;    if scaling_file is None and os.path.exists('scaling.json'):&#10;        scaling_file = 'scaling.json'&#10;&#10;    # Get scaling parameters from config file or use defaults&#10;    if scaling_file and os.path.exists(scaling_file):&#10;        print(f&quot;Loading scaling parameters from {scaling_file}&quot;)&#10;        scaling_params = get_scaling_from_config(scaling_file)&#10;        rotation_scale = scaling_params.get(&quot;rotation&quot;, 5000)&#10;        displacement_scale = scaling_params.get(&quot;displacement&quot;, 100) * scale&#10;        print(f&quot;Using rotation_scale={rotation_scale}, displacement_scale={displacement_scale}&quot;)&#10;    else:&#10;        print(&quot;No scaling.json found, using default values&quot;)&#10;        rotation_scale = 5000&#10;        displacement_scale = 100 * scale&#10;&#10;    # Debug info&#10;    print(f&quot;Number of nodes: {len(structure.nodes)}&quot;)&#10;    print(f&quot;Number of members: {len(structure.members)}&quot;)&#10;&#10;    # Find node 1 and calculate offset to place it at x=0&#10;    x_offset = 0&#10;    for node in structure.nodes:&#10;        if node.uid == 1:&#10;            x_offset = node.x.magnitude&#10;            print(f&quot;Found node 1 at x={x_offset}, will offset all nodes to place it at x=0&quot;)&#10;            break&#10;&#10;    # Create points and cells&#10;    points = vtk.vtkPoints()&#10;    cells = vtk.vtkCellArray()&#10;&#10;    # Add points for nodes with offset applied&#10;    node_indices = {}  # Map node UIDs to their index in the points array&#10;    for i, node in enumerate(structure.nodes):&#10;        # Extract magnitude values from the Quantity objects and apply offset&#10;        x = node.x.magnitude - x_offset&#10;        y = node.y.magnitude&#10;        print(f&quot;Node {node.uid}: Original ({node.x.magnitude}, {node.y.magnitude}), Adjusted ({x}, {y})&quot;)&#10;        points.InsertNextPoint(x, y, 0)&#10;        node_indices[node.uid] = i&#10;&#10;    # Add lines for members&#10;    for member in structure.members:&#10;        print(f&quot;Member: node {member.inode.uid} to {member.jnode.uid}&quot;)&#10;        line = vtk.vtkLine()&#10;        # Get indices based on node UIDs&#10;        i_index = node_indices[member.inode.uid]&#10;        j_index = node_indices[member.jnode.uid]&#10;        line.GetPointIds().SetId(0, i_index)&#10;        line.GetPointIds().SetId(1, j_index)&#10;        cells.InsertNextCell(line)&#10;&#10;    # Create a polydata to store points and lines&#10;    polydata = vtk.vtkPolyData()&#10;    polydata.SetPoints(points)&#10;    polydata.SetLines(cells)&#10;&#10;    # Convert to PyVista mesh for easier handling&#10;    mesh = pv.PolyData(polydata)&#10;    print(mesh)&#10;    # Create PyVista plotter&#10;    plotter = pv.Plotter()&#10;&#10;    # Add structure to plot&#10;    plotter.add_mesh(mesh, color='black', line_width=3)&#10;&#10;    # Add node markers&#10;    node_size = 0.05  # Adjust as needed&#10;    for node in structure.nodes:&#10;        adjusted_x = node.x.magnitude - x_offset&#10;        plotter.add_mesh(pv.Sphere(radius=node_size, center=(adjusted_x, node.y.magnitude, 0)),&#10;                         color='blue')&#10;&#10;    # Create node labels (carefully ensuring non-empty strings)&#10;    if structure.nodes:&#10;        node_points = []&#10;        node_labels = []&#10;        for node in structure.nodes:&#10;            adjusted_x = node.x.magnitude - x_offset&#10;            node_label = f&quot;N{node.uid}&quot;&#10;            # Only add points with valid labels&#10;            if node_label:  # Check that label is not empty&#10;                node_points.append([adjusted_x, node.y.magnitude, 0])&#10;                node_labels.append(node_label)&#10;&#10;        # Add labels to plot if we have valid points and labels&#10;        if node_points and node_labels:&#10;            plotter.add_point_labels(&#10;                node_points, node_labels,&#10;                font_size=10,&#10;                point_color='blue',&#10;                text_color='black',&#10;                always_visible=True&#10;            )&#10;&#10;        # Plot deformed shape if loadcombo is provided&#10;        if loadcombo is not None:&#10;            # Create points and cells for deformed shape&#10;            deformed_points = vtk.vtkPoints()&#10;            deformed_cells = vtk.vtkCellArray()&#10;&#10;            # Add deformed points - using the node's x_displaced and y_displaced methods&#10;            # similar to how it's done in the matplotlib implementation&#10;            for i, node in enumerate(structure.nodes):&#10;                try:&#10;                    # Use the node's built-in displacement methods which properly handle all transformations&#10;                    if hasattr(node, 'x_displaced') and hasattr(node, 'y_displaced'):&#10;                        # These methods already apply the proper transformations&#10;                        x_def = node.x_displaced(loadcombo, displacement_scale).magnitude - x_offset&#10;                        y_def = node.y_displaced(loadcombo, displacement_scale).magnitude&#10;                    else:&#10;                        # Fallback to direct calculation if methods not available&#10;                        dx = node.get_displacement(loadcombo, 'DX').magnitude * displacement_scale if hasattr(node, 'get_displacement') else 0&#10;                        dy = node.get_displacement(loadcombo, 'DY').magnitude * displacement_scale if hasattr(node, 'get_displacement') else 0&#10;                        x_def = (node.x.magnitude - x_offset) + dx&#10;                        y_def = node.y.magnitude + dy&#10;&#10;                    print(f&quot;Node {node.uid} Deformed: ({x_def}, {y_def})&quot;)&#10;                    deformed_points.InsertNextPoint(x_def, y_def, 0)&#10;                except Exception as e:&#10;                    print(f&quot;Error computing deformed position for node {node.uid}: {e}&quot;)&#10;                    # Use undeformed position as fallback&#10;                    x_def = node.x.magnitude - x_offset&#10;                    y_def = node.y.magnitude&#10;                    deformed_points.InsertNextPoint(x_def, y_def, 0)&#10;&#10;            # Add lines for deformed members&#10;            for member in structure.members:&#10;                i_index = node_indices[member.inode.uid]&#10;                j_index = node_indices[member.jnode.uid]&#10;&#10;                # First create basic line between deformed nodes&#10;                line = vtk.vtkLine()&#10;                line.GetPointIds().SetId(0, i_index)&#10;                line.GetPointIds().SetId(1, j_index)&#10;                deformed_cells.InsertNextCell(line)&#10;&#10;                # For frame elements, generate a more accurate deformation curve&#10;                if member.type != &quot;TRUSS&quot; and hasattr(member, 'dglobal_span'):&#10;                    try:&#10;                        # Get deformed shape (global displacements) using the member's method&#10;                        dglobal = member.dglobal_span(loadcombo, displacement_scale)&#10;&#10;                        # Create a polyline for this member's deformation curve&#10;                        polyline = vtk.vtkPolyLine()&#10;                        num_points = len(dglobal)&#10;                        polyline.GetPointIds().SetNumberOfIds(num_points)&#10;&#10;                        # Add all points of the deformation curve&#10;                        for i, point in enumerate(dglobal):&#10;                            # Convert to global coordinates with offset&#10;                            x_global = point[0] + member.inode.x.magnitude - x_offset&#10;                            y_global = point[1] + member.inode.y.magnitude&#10;&#10;                            # Add point to deformed shape&#10;                            point_id = deformed_points.InsertNextPoint(x_global, y_global, 0)&#10;                            polyline.GetPointIds().SetId(i, point_id)&#10;&#10;                        deformed_cells.InsertNextCell(polyline)&#10;                    except Exception as e:&#10;                        print(f&quot;Error plotting deformed shape for member {member.uid}: {e}&quot;)&#10;&#10;            # Create polydata for deformed shape&#10;            deformed_polydata = vtk.vtkPolyData()&#10;            deformed_polydata.SetPoints(deformed_points)&#10;            deformed_polydata.SetLines(deformed_cells)&#10;&#10;            # Convert to PyVista mesh&#10;            deformed_mesh = pv.PolyData(deformed_polydata)&#10;&#10;            # Add deformed shape to plot&#10;            plotter.add_mesh(deformed_mesh, color='red', line_width=2, style='wireframe')&#10;&#10;        # Set up camera and view&#10;        plotter.camera_position = 'xy'  # Top-down view&#10;        plotter.enable_parallel_projection()&#10;&#10;        # Set background color&#10;        plotter.background_color = 'white'&#10;&#10;        # Add a title&#10;        plotter.add_title(f&quot;Structure Plot - {'Deformed' if loadcombo else 'Undeformed'}&quot;)&#10;&#10;        # Show plot&#10;        plotter.show()" />
              <option name="updatedContent" value="import pyvista as pv&#10;import numpy as np&#10;from pyMAOS.quantity_utils import convert_registry&#10;&#10;def plot_structure_pv(structure, loadcombo=None, scale=1.0, scaling_file=None):&#10;    &quot;&quot;&quot;&#10;    Plot the structure using PyVista/VTK with scaling from config file.&#10;&#10;    Parameters&#10;    ----------&#10;    structure : R2Structure&#10;        Structure object containing nodes and members&#10;    loadcombo : LoadCombo, optional&#10;        Load combination for plotting deformed shape&#10;    scale : float, optional&#10;        Scale factor for deformations (default=1.0)&#10;    scaling_file : str, optional&#10;        Path to the scaling.json file&#10;    &quot;&quot;&quot;&#10;    import vtk&#10;    import pyvista as pv&#10;    import numpy as np&#10;    import os&#10;    import pyMAOS&#10;    from pyMAOS.plotting.scaling import get_scaling_from_config&#10;    from pyMAOS.quantity_utils import convert_registry&#10;&#10;    # Ensure we're using the global registry for all quantities in this function&#10;    ureg = pyMAOS.unit_manager.ureg&#10;    &#10;    # Find scaling.json in input directory or current directory&#10;    if scaling_file is None and os.path.exists('scaling.json'):&#10;        scaling_file = 'scaling.json'&#10;&#10;    # Get scaling parameters from config file or use defaults&#10;    if scaling_file and os.path.exists(scaling_file):&#10;        print(f&quot;Loading scaling parameters from {scaling_file}&quot;)&#10;        scaling_params = get_scaling_from_config(scaling_file)&#10;        rotation_scale = scaling_params.get(&quot;rotation&quot;, 5000)&#10;        displacement_scale = scaling_params.get(&quot;displacement&quot;, 100) * scale&#10;        print(f&quot;Using rotation_scale={rotation_scale}, displacement_scale={displacement_scale}&quot;)&#10;    else:&#10;        print(&quot;No scaling.json found, using default values&quot;)&#10;        rotation_scale = 5000&#10;        displacement_scale = 100 * scale&#10;&#10;    # Debug info&#10;    print(f&quot;Number of nodes: {len(structure.nodes)}&quot;)&#10;    print(f&quot;Number of members: {len(structure.members)}&quot;)&#10;    &#10;    # Check for registry consistency&#10;    registry_mismatch = False&#10;    for node in structure.nodes:&#10;        if hasattr(node.x, '_REGISTRY') and node.x._REGISTRY is not ureg:&#10;            registry_mismatch = True&#10;            print(f&quot;WARNING: Node {node.uid} uses registry {id(node.x._REGISTRY)} instead of global registry {id(ureg)}&quot;)&#10;            break&#10;    &#10;    if registry_mismatch:&#10;        print(&quot;Converting all quantities to global registry...&quot;)&#10;        from pyMAOS.quantity_utils import convert_all_quantities&#10;        structure = convert_all_quantities(structure, ureg)&#10;&#10;    # Find node 1 and calculate offset to place it at x=0&#10;    x_offset = 0&#10;    for node in structure.nodes:&#10;        if node.uid == 1:&#10;            # Ensure this quantity uses the global registry&#10;            x = convert_registry(node.x, ureg)&#10;            x_offset = x.magnitude&#10;            print(f&quot;Found node 1 at x={x_offset}, will offset all nodes to place it at x=0&quot;)&#10;            break&#10;&#10;    # Create points and cells&#10;    points = vtk.vtkPoints()&#10;    cells = vtk.vtkCellArray()&#10;&#10;    # Add points for nodes with offset applied&#10;    node_indices = {}  # Map node UIDs to their index in the points array&#10;    for i, node in enumerate(structure.nodes):&#10;        # Extract magnitude values from the Quantity objects and apply offset&#10;        x = convert_registry(node.x, ureg).magnitude - x_offset&#10;        y = convert_registry(node.y, ureg).magnitude&#10;        print(f&quot;Node {node.uid}: Original ({node.x.magnitude}, {node.y.magnitude}), Adjusted ({x}, {y})&quot;)&#10;        points.InsertNextPoint(x, y, 0)&#10;        node_indices[node.uid] = i&#10;&#10;    # Add lines for members&#10;    for member in structure.members:&#10;        print(f&quot;Member: node {member.inode.uid} to {member.jnode.uid}&quot;)&#10;        line = vtk.vtkLine()&#10;        # Get indices based on node UIDs&#10;        i_index = node_indices[member.inode.uid]&#10;        j_index = node_indices[member.jnode.uid]&#10;        line.GetPointIds().SetId(0, i_index)&#10;        line.GetPointIds().SetId(1, j_index)&#10;        cells.InsertNextCell(line)&#10;&#10;    # Create a polydata to store points and lines&#10;    polydata = vtk.vtkPolyData()&#10;    polydata.SetPoints(points)&#10;    polydata.SetLines(cells)&#10;&#10;    # Convert to PyVista mesh for easier handling&#10;    mesh = pv.PolyData(polydata)&#10;    print(mesh)&#10;    # Create PyVista plotter&#10;    plotter = pv.Plotter()&#10;&#10;    # Add structure to plot&#10;    plotter.add_mesh(mesh, color='black', line_width=3)&#10;&#10;    # Add node markers&#10;    node_size = 0.05  # Adjust as needed&#10;    for node in structure.nodes:&#10;        adjusted_x = node.x.magnitude - x_offset&#10;        plotter.add_mesh(pv.Sphere(radius=node_size, center=(adjusted_x, node.y.magnitude, 0)),&#10;                         color='blue')&#10;&#10;    # Create node labels (carefully ensuring non-empty strings)&#10;    if structure.nodes:&#10;        node_points = []&#10;        node_labels = []&#10;        for node in structure.nodes:&#10;            adjusted_x = node.x.magnitude - x_offset&#10;            node_label = f&quot;N{node.uid}&quot;&#10;            # Only add points with valid labels&#10;            if node_label:  # Check that label is not empty&#10;                node_points.append([adjusted_x, node.y.magnitude, 0])&#10;                node_labels.append(node_label)&#10;&#10;        # Add labels to plot if we have valid points and labels&#10;        if node_points and node_labels:&#10;            plotter.add_point_labels(&#10;                node_points, node_labels,&#10;                font_size=10,&#10;                point_color='blue',&#10;                text_color='black',&#10;                always_visible=True&#10;            )&#10;&#10;        # Plot deformed shape if loadcombo is provided&#10;        if loadcombo is not None:&#10;            # Create points and cells for deformed shape&#10;            deformed_points = vtk.vtkPoints()&#10;            deformed_cells = vtk.vtkCellArray()&#10;&#10;            # Add deformed points - using the node's x_displaced and y_displaced methods&#10;            # similar to how it's done in the matplotlib implementation&#10;            for i, node in enumerate(structure.nodes):&#10;                try:&#10;                    # Use the node's built-in displacement methods which properly handle all transformations&#10;                    if hasattr(node, 'x_displaced') and hasattr(node, 'y_displaced'):&#10;                        # Ensure these quantities use the global registry&#10;                        x_def = convert_registry(node.x_displaced(loadcombo, displacement_scale), ureg).magnitude - x_offset&#10;                        y_def = convert_registry(node.y_displaced(loadcombo, displacement_scale), ureg).magnitude&#10;                    else:&#10;                        # Fallback to direct calculation if methods not available&#10;                        dx = convert_registry(node.get_displacement(loadcombo, 'DX'), ureg).magnitude * displacement_scale if hasattr(node, 'get_displacement') else 0&#10;                        dy = convert_registry(node.get_displacement(loadcombo, 'DY'), ureg).magnitude * displacement_scale if hasattr(node, 'get_displacement') else 0&#10;                        x_def = (convert_registry(node.x, ureg).magnitude - x_offset) + dx&#10;                        y_def = convert_registry(node.y, ureg).magnitude + dy&#10;            &#10;                    print(f&quot;Node {node.uid} Deformed: ({x_def}, {y_def})&quot;)&#10;                    deformed_points.InsertNextPoint(x_def, y_def, 0)&#10;                except Exception as e:&#10;                    print(f&quot;Error computing deformed position for node {node.uid}: {e}&quot;)&#10;                    # Use undeformed position as fallback&#10;                    x_def = convert_registry(node.x, ureg).magnitude - x_offset&#10;                    y_def = convert_registry(node.y, ureg).magnitude&#10;                    deformed_points.InsertNextPoint(x_def, y_def, 0)&#10;&#10;            # Add lines for deformed members&#10;            for member in structure.members:&#10;                i_index = node_indices[member.inode.uid]&#10;                j_index = node_indices[member.jnode.uid]&#10;&#10;                # First create basic line between deformed nodes&#10;                line = vtk.vtkLine()&#10;                line.GetPointIds().SetId(0, i_index)&#10;                line.GetPointIds().SetId(1, j_index)&#10;                deformed_cells.InsertNextCell(line)&#10;&#10;                # For frame elements, generate a more accurate deformation curve&#10;                if member.type != &quot;TRUSS&quot; and hasattr(member, 'dglobal_span'):&#10;                    try:&#10;                        # Get deformed shape (global displacements) using the member's method&#10;                        dglobal = member.dglobal_span(loadcombo, displacement_scale)&#10;&#10;                        # Create a polyline for this member's deformation curve&#10;                        polyline = vtk.vtkPolyLine()&#10;                        num_points = len(dglobal)&#10;                        polyline.GetPointIds().SetNumberOfIds(num_points)&#10;&#10;                        # Add all points of the deformation curve&#10;                        for i, point in enumerate(dglobal):&#10;                            # Convert to global coordinates with offset&#10;                            x_global = point[0] + member.inode.x.magnitude - x_offset&#10;                            y_global = point[1] + member.inode.y.magnitude&#10;&#10;                            # Add point to deformed shape&#10;                            point_id = deformed_points.InsertNextPoint(x_global, y_global, 0)&#10;                            polyline.GetPointIds().SetId(i, point_id)&#10;&#10;                        deformed_cells.InsertNextCell(polyline)&#10;                    except Exception as e:&#10;                        print(f&quot;Error plotting deformed shape for member {member.uid}: {e}&quot;)&#10;&#10;            # Create polydata for deformed shape&#10;            deformed_polydata = vtk.vtkPolyData()&#10;            deformed_polydata.SetPoints(deformed_points)&#10;            deformed_polydata.SetLines(deformed_cells)&#10;&#10;            # Convert to PyVista mesh&#10;            deformed_mesh = pv.PolyData(deformed_polydata)&#10;&#10;            # Add deformed shape to plot&#10;            plotter.add_mesh(deformed_mesh, color='red', line_width=2, style='wireframe')&#10;&#10;        # Set up camera and view&#10;        plotter.camera_position = 'xy'  # Top-down view&#10;        plotter.enable_parallel_projection()&#10;&#10;        # Set background color&#10;        plotter.background_color = 'white'&#10;&#10;        # Add a title&#10;        plotter.add_title(f&quot;Structure Plot - {'Deformed' if loadcombo else 'Undeformed'}&quot;)&#10;&#10;        # Show plot&#10;        plotter.show()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/quantity_utils.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/quantity_utils.py" />
              <option name="originalContent" value="# -*- coding: utf-8 -*-&#10;import numpy as np&#10;import pint&#10;import pyMAOS&#10;&#10;# Replace any direct ureg usage with unit_manager.ureg&#10;Q_ = pyMAOS.unit_manager.ureg.Quantity&#10;&#10;def convert_to_unit(array_with_units, target_unit):&#10;    &quot;&quot;&quot;Convert all quantities in the array to a common unit.&#10;&#10;    Parameters&#10;    ----------&#10;    array_with_units : array of pint.Quantity&#10;        Array containing quantities to convert&#10;    target_unit : str or pint.Unit&#10;        Target unit to convert all quantities to&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array with all values converted to the target unit&#10;    &quot;&quot;&quot;&#10;    if isinstance(array_with_units, np.ndarray):&#10;        # Convert to object array to handle mixed types&#10;        result = np.empty_like(array_with_units, dtype=object)&#10;&#10;        # Process each element&#10;        for idx in np.ndindex(array_with_units.shape):&#10;            value = array_with_units[idx]&#10;            if isinstance(value, pint.Quantity):&#10;                try:&#10;                    # Try to convert to target unit&#10;                    result[idx] = value.to(target_unit).magnitude&#10;                except pint.DimensionalityError:&#10;                    # If conversion not possible, keep original value&#10;                    result[idx] = value&#10;            else:&#10;                result[idx] = value&#10;&#10;        return result&#10;    else:&#10;        raise TypeError(&quot;Input must be a numpy array containing pint.Quantity objects&quot;)&#10;&#10;# def convert_array_to_float64(input_array):&#10;#     &quot;&quot;&quot;&#10;#     Convert an array with mixed types or Quantity objects to a uniform float64 array.&#10;#&#10;#     Parameters&#10;#     ----------&#10;#     input_array : array-like&#10;#         Array that may contain Quantity objects or other numeric types&#10;#&#10;#     Returns&#10;#     -------&#10;#     numpy.ndarray&#10;#         Converted array with dtype=float64&#10;#     &quot;&quot;&quot;&#10;#     import numpy as np&#10;#&#10;#     # Convert to numpy array if not already&#10;#     array = np.asarray(input_array)&#10;#&#10;#     # If already float64 array, return directly&#10;#     if array.dtype == np.float64:&#10;#         return array&#10;#&#10;#     # Create output array&#10;#     result = np.empty(array.shape, dtype=np.float64)&#10;#&#10;#     # Process each element&#10;#     for idx in np.ndindex(array.shape):&#10;#         val = array[idx]&#10;#&#10;#         # Handle Quantity objects&#10;#         if hasattr(val, 'magnitude'):&#10;#             result[idx] = float(val.magnitude)&#10;#         else:&#10;#             # Handle other types&#10;#             try:&#10;#                 result[idx] = float(val)&#10;#             except (TypeError, ValueError):&#10;#                 print(f&quot;DEBUG: Cannot convert value at {idx}: {val}&quot;)&#10;#                 result[idx] = 0.0&#10;#&#10;#     # print(f&quot;DEBUG: Converted array to float64: {result}&quot;)&#10;#     return result&#10;&#10;def numpy_array_of_quantity_to_numpy_array_of_float64(quantity_array):&#10;    &quot;&quot;&quot;&#10;    Convert an array of mixed types or Quantity objects to a uniform float64 array.&#10;&#10;    Parameters&#10;    ----------&#10;    quantity_array : array-like&#10;        Array containing Pint Quantity objects or other numeric types&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array with the same shape as input but with magnitudes as float64 values&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # Convert to numpy array if not already&#10;    array = np.asarray(quantity_array)&#10;&#10;    # Fast path if already float64 array&#10;    if array.dtype == np.float64:&#10;        return array&#10;&#10;    # Fast path for arrays that are already numeric&#10;    if np.issubdtype(array.dtype, np.number):&#10;        print(f&quot;DEBUG: Array already has numeric dtype {array.dtype}, converting to float64&quot;)&#10;        return array.astype(np.float64)&#10;&#10;    # For single Quantity objects&#10;    if hasattr(array, 'magnitude'):&#10;        print(f&quot;DEBUG: Converting single Quantity with magnitude&quot;)&#10;        return np.float64(array.magnitude)&#10;&#10;    # Create output array&#10;    result = np.zeros(array.shape, dtype=np.float64)&#10;&#10;    # Use flat iteration for better performance&#10;    for i, val in enumerate(array.flat):&#10;        try:&#10;            # Handle Quantity objects&#10;            if hasattr(val, 'magnitude'):&#10;                result.flat[i] = float(val.magnitude)&#10;            else:&#10;                # Handle other types&#10;                result.flat[i] = float(val)&#10;        except (TypeError, ValueError):&#10;            idx = np.unravel_index(i, array.shape)&#10;            print(f&quot;DEBUG: Cannot convert value at {idx}: {val}&quot;)&#10;            result.flat[i] = 0.0&#10;&#10;    print(f&quot;DEBUG: Converted array with shape {array.shape} to float64&quot;)&#10;    return result&#10;&#10;def extract_units_from_quantities(quantity_array):&#10;    &quot;&quot;&quot;&#10;    Extract unit information from an array of Pint Quantity objects.&#10;&#10;    Parameters&#10;    ----------&#10;    quantity_array : numpy.ndarray&#10;        Array containing Pint Quantity objects&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array of the same shape containing only the unit information&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # Create an empty array with object dtype to store unit objects&#10;    units_array = np.empty_like(quantity_array, dtype=object)&#10;&#10;    # Iterate through all elements&#10;    for idx in np.ndindex(quantity_array.shape):&#10;        # Get the quantity at this position&#10;        quantity = quantity_array[idx]&#10;&#10;        # Extract just the unit information if it's a Quantity&#10;        if hasattr(quantity, 'units'):&#10;            units_array[idx] = quantity.units&#10;            print(f&quot;DEBUG: Found unit {quantity.units} at position {idx}&quot;)&#10;        else:&#10;            units_array[idx] = None&#10;            print(f&quot;DEBUG: No unit at position {idx}&quot;)&#10;&#10;    return units_array&#10;&#10;def increment_with_units(self, addend):&#10;    &quot;&quot;&quot;&#10;    Increment a value with another value while ensuring consistent units.&#10;&#10;    If self is not a Quantity, it's promoted to a Quantity with internal units.&#10;    If addend is a Quantity, it's converted to internal units before adding.&#10;&#10;    Parameters&#10;    ----------&#10;    addend : pint.Quantity or scalar&#10;        The value to add&#10;&#10;    Returns&#10;    -------&#10;    pint.Quantity&#10;        A new Quantity with internal units, incremented by addend&#10;    &quot;&quot;&quot;&#10;    import pint&#10;&#10;    print(f&quot;DEBUG: Incrementing {self} with {addend}&quot;)&#10;&#10;    # If addend is not a Quantity, just do regular addition&#10;    if not isinstance(addend, pint.Quantity):&#10;        result = self + addend&#10;        print(f&quot;DEBUG: Added non-Quantity addend, result = {result}&quot;)&#10;        return result&#10;&#10;    # Determine the internal unit type based on addend's dimensionality&#10;    unit_type = None&#10;    if addend.check('[length]'):&#10;        unit_type = 'length'&#10;    elif addend.check('[force]'):&#10;        unit_type = 'force'&#10;    elif addend.check('[length] * [force]'):&#10;        unit_type = 'moment'&#10;    elif addend.check('[force] / [length]'):&#10;        unit_type = 'distributed_load'&#10;    elif addend.check('[force] / [length]^2'):&#10;        unit_type = 'pressure'&#10;&#10;    # Get the appropriate internal unit&#10;    if unit_type:&#10;        internal_unit = pyMAOS.unit_manager.get_internal_unit(unit_type)&#10;        print(f&quot;DEBUG: Using internal unit {internal_unit} for {unit_type}&quot;)&#10;    else:&#10;        # If we can't determine the unit type, use addend's units as fallback&#10;        internal_unit = addend.units&#10;        print(f&quot;DEBUG: Could not determine unit type, using addend units {internal_unit}&quot;)&#10;&#10;    # If self is not a Quantity, promote it to a Quantity with internal units&#10;    if not isinstance(self, pint.Quantity):&#10;        self = pyMAOS.unit_manager.ureg.Quantity(self, internal_unit)&#10;        print(f&quot;DEBUG: Promoted self to Quantity with internal units: {self}&quot;)&#10;&#10;    try:&#10;        # Convert addend to internal units before adding&#10;        converted_addend = addend.to(internal_unit)&#10;        print(f&quot;DEBUG: Converted addend from {addend} to {converted_addend}&quot;)&#10;&#10;        # Create result with the proper internal units&#10;        result = type(self)(self.magnitude + converted_addend.magnitude, internal_unit)&#10;        print(f&quot;DEBUG: Result after increment: {result}&quot;)&#10;&#10;        return result&#10;    except pint.DimensionalityError as e:&#10;        print(f&quot;DEBUG: Dimensionality error - {self.dimensionality}  {addend.dimensionality}&quot;)&#10;        raise e&#10;&#10;def add_arrays_with_units(array1, array2):&#10;    &quot;&quot;&quot;&#10;    Add two arrays element-wise while ensuring consistent units for each element.&#10;&#10;    For each element pair:&#10;    - Checks that dimensions agree, or one is a pure number and the other a Quantity&#10;    - Sums the magnitudes elementwise&#10;    - Converts the result to a Quantity in the internal unit system&#10;&#10;    Parameters&#10;    ----------&#10;    array1 : array-like&#10;        First array, may contain Quantity objects&#10;    array2 : array-like&#10;        Second array, may contain Quantity objects&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Result array with proper internal units for each element&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;    from pyMAOS.quantity_utils import increment_with_units&#10;&#10;    # Convert inputs to numpy arrays if they're not already&#10;    array1 = np.asarray(array1)&#10;    array2 = np.asarray(array2)&#10;&#10;    # Check that shapes are compatible&#10;    if array1.shape != array2.shape:&#10;        raise ValueError(f&quot;Arrays must have the same shape, got {array1.shape} and {array2.shape}&quot;)&#10;&#10;    # Create output array with the same shape&#10;    result = np.empty_like(array1, dtype=object)&#10;&#10;    # Process each element using the existing increment_with_units function&#10;    for idx in np.ndindex(array1.shape):&#10;        result[idx] = increment_with_units(array1[idx], array2[idx])&#10;        print(f&quot;DEBUG: Element-wise addition at {idx}: {array1[idx]} + {array2[idx]} = {result[idx]}&quot;)&#10;&#10;    return result&#10;&#10;def print_units_matrix(array):&#10;    &quot;&quot;&quot;&#10;    Print a matrix with its values and units.&#10;&#10;    This function displays the content of a numpy array containing Pint Quantity objects,&#10;    showing both the magnitude values and their corresponding units.&#10;&#10;    For elements without units, only their values are shown.&#10;&#10;    Parameters&#10;    ----------&#10;    array : numpy.ndarray&#10;        The array to print, potentially containing Pint Quantity objects&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # First, print the shape information&#10;    print(f&quot;Matrix shape: {array.shape}&quot;)&#10;&#10;    # Helper function for formatting a single value&#10;    def format_value(val):&#10;        if val is None:&#10;            return &quot;None&quot;&#10;        elif hasattr(val, 'units'):&#10;            # Format magnitude with appropriate precision&#10;            if abs(val.magnitude) &lt; 1e-10:&#10;                return f&quot;0 {val.units}&quot;&#10;            else:&#10;                return f&quot;{val.magnitude:.4g} {val.units}&quot;&#10;        else:&#10;            # Format plain numbers with appropriate precision&#10;            if isinstance(val, (int, float)) and abs(val) &lt; 1e-10:&#10;                return &quot;0&quot;&#10;            return str(val)&#10;&#10;    # Helper function for recursive printing of subarrays&#10;    def print_array(arr, indent=&quot;&quot;):&#10;        if arr.ndim == 1:&#10;            elements = [format_value(val) for val in arr]&#10;            print(indent + &quot;[&quot; + &quot;, &quot;.join(elements) + &quot;]&quot;)&#10;        elif arr.ndim == 2:&#10;            print(indent + &quot;[&quot;)&#10;            for row in arr:&#10;                print_array(row, indent + &quot;  &quot;)&#10;            print(indent + &quot;]&quot;)&#10;        else:&#10;            print(indent + f&quot;Array with {arr.ndim} dimensions:&quot;)&#10;            for i, subarray in enumerate(arr):&#10;                print(indent + f&quot;Dimension {i}:&quot;)&#10;                print_array(subarray, indent + &quot;  &quot;)&#10;&#10;    # Collect unit information for reporting&#10;    if array.size &gt; 0:&#10;        unique_units = set()&#10;        has_units = False&#10;&#10;        # Check for units in the array&#10;        for idx in np.ndindex(array.shape):&#10;            val = array[idx]&#10;            if hasattr(val, 'units'):&#10;                has_units = True&#10;                unique_units.add(str(val.units))&#10;&#10;        if has_units:&#10;            print(f&quot;DEBUG: Units found in matrix: {', '.join(sorted(unique_units))}&quot;)&#10;        else:&#10;            print(&quot;DEBUG: No units found in matrix&quot;)&#10;&#10;    # For empty arrays&#10;    if array.size == 0:&#10;        print(&quot;[]&quot;)&#10;        return&#10;&#10;    # For scalar arrays&#10;    if array.ndim == 0:&#10;        val = array.item()&#10;        print(format_value(val))&#10;        return&#10;&#10;    # Print the array&#10;    print_array(array)&#10;&#10;def convert_registry(quantity, target_registry=None):&#10;    &quot;&quot;&quot;&#10;    Convert a quantity to use a different registry.&#10;&#10;    Parameters&#10;    ----------&#10;    quantity : pint.Quantity&#10;        The quantity to convert&#10;    target_registry : pint.UnitRegistry, optional&#10;        The target registry. If None, uses the global registry from unit_manager.&#10;&#10;    Returns&#10;    -------&#10;    pint.Quantity&#10;        A new quantity using the target registry with the same value and unit&#10;    &quot;&quot;&quot;&#10;    import pyMAOS&#10;&#10;    # Default to global registry&#10;    if target_registry is None:&#10;        target_registry = pyMAOS.unit_manager.ureg&#10;&#10;    # If already using target registry, return the original&#10;    if hasattr(quantity, '_REGISTRY') and quantity._REGISTRY is target_registry:&#10;        return quantity&#10;&#10;    # Handle non-quantity objects&#10;    if not hasattr(quantity, 'magnitude') or not hasattr(quantity, 'units'):&#10;        return quantity&#10;&#10;    # Create new quantity with target registry&#10;    try:&#10;        return target_registry.Quantity(quantity.magnitude, str(quantity.units))&#10;    except Exception as e:&#10;        print(f&quot;Error converting quantity {quantity} to target registry: {e}&quot;)&#10;        return quantity&#10;&#10;def convert_all_quantities(obj, target_registry=None, processed_objects=None):&#10;    &quot;&quot;&quot;&#10;    Recursively convert all quantities in a complex object to use the target registry.&#10;&#10;    Parameters&#10;    ----------&#10;    obj : object&#10;        The object containing quantities to convert&#10;    target_registry : pint.UnitRegistry, optional&#10;        The target registry. If None, uses the global registry from unit_manager.&#10;    processed_objects : dict, optional&#10;        Dictionary to track already processed objects to avoid circular references&#10;&#10;    Returns&#10;    -------&#10;    object&#10;        A copy of the object with all quantities using the target registry&#10;    &quot;&quot;&quot;&#10;    import pyMAOS&#10;    import numpy as np&#10;&#10;    # Initialize processed_objects if it's the first call&#10;    if processed_objects is None:&#10;        processed_objects = {}&#10;&#10;    # If we've already processed this object, return the converted version&#10;    obj_id = id(obj)&#10;    if obj_id in processed_objects:&#10;        return processed_objects[obj_id]&#10;&#10;    # Default to global registry&#10;    if target_registry is None:&#10;        target_registry = pyMAOS.unit_manager.ureg&#10;&#10;    # Handle quantities directly&#10;    if hasattr(obj, '_REGISTRY') and hasattr(obj, 'magnitude'):&#10;        result = convert_registry(obj, target_registry)&#10;        processed_objects[obj_id] = result&#10;        return result&#10;&#10;    # Handle numpy arrays&#10;    if isinstance(obj, np.ndarray):&#10;        # For arrays of quantities&#10;        if obj.dtype == object:&#10;            result = np.empty_like(obj)&#10;            for i, value in enumerate(obj.flat):&#10;                result.flat[i] = convert_all_quantities(value, target_registry, processed_objects)&#10;            processed_objects[obj_id] = result&#10;            return result&#10;        processed_objects[obj_id] = obj&#10;        return obj&#10;&#10;    # Handle lists&#10;    if isinstance(obj, list):&#10;        result = [convert_all_quantities(item, target_registry, processed_objects) for item in obj]&#10;        processed_objects[obj_id] = result&#10;        return result&#10;&#10;    # Handle dictionaries&#10;    if isinstance(obj, dict):&#10;        result = {key: convert_all_quantities(value, target_registry, processed_objects) for key, value in obj.items()}&#10;        processed_objects[obj_id] = result&#10;        return result&#10;&#10;    # Handle objects with __dict__ attribute (most custom classes)&#10;    if hasattr(obj, '__dict__'):&#10;        # Create a shallow copy to avoid modifying original&#10;        import copy&#10;        new_obj = copy.copy(obj)&#10;&#10;        # Mark this object as processed BEFORE recursing to prevent infinite loops&#10;        processed_objects[obj_id] = new_obj&#10;&#10;        # Convert all attributes&#10;        for attr_name, attr_value in obj.__dict__.items():&#10;            setattr(new_obj, attr_name, convert_all_quantities(attr_value, target_registry, processed_objects))&#10;&#10;        return new_obj&#10;&#10;    # Return other objects unchanged&#10;    processed_objects[obj_id] = obj&#10;    return obj&#10;" />
              <option name="updatedContent" value="# -*- coding: utf-8 -*-&#10;import numpy as np&#10;import pint&#10;import pyMAOS&#10;&#10;# Replace any direct ureg usage with unit_manager.ureg&#10;Q_ = pyMAOS.unit_manager.ureg.Quantity&#10;&#10;def convert_to_unit(array_with_units, target_unit):&#10;    &quot;&quot;&quot;Convert all quantities in the array to a common unit.&#10;&#10;    Parameters&#10;    ----------&#10;    array_with_units : array of pint.Quantity&#10;        Array containing quantities to convert&#10;    target_unit : str or pint.Unit&#10;        Target unit to convert all quantities to&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array with all values converted to the target unit&#10;    &quot;&quot;&quot;&#10;    if isinstance(array_with_units, np.ndarray):&#10;        # Convert to object array to handle mixed types&#10;        result = np.empty_like(array_with_units, dtype=object)&#10;&#10;        # Process each element&#10;        for idx in np.ndindex(array_with_units.shape):&#10;            value = array_with_units[idx]&#10;            if isinstance(value, pint.Quantity):&#10;                try:&#10;                    # Try to convert to target unit&#10;                    result[idx] = value.to(target_unit).magnitude&#10;                except pint.DimensionalityError:&#10;                    # If conversion not possible, keep original value&#10;                    result[idx] = value&#10;            else:&#10;                result[idx] = value&#10;&#10;        return result&#10;    else:&#10;        raise TypeError(&quot;Input must be a numpy array containing pint.Quantity objects&quot;)&#10;&#10;# def convert_array_to_float64(input_array):&#10;#     &quot;&quot;&quot;&#10;#     Convert an array with mixed types or Quantity objects to a uniform float64 array.&#10;#&#10;#     Parameters&#10;#     ----------&#10;#     input_array : array-like&#10;#         Array that may contain Quantity objects or other numeric types&#10;#&#10;#     Returns&#10;#     -------&#10;#     numpy.ndarray&#10;#         Converted array with dtype=float64&#10;#     &quot;&quot;&quot;&#10;#     import numpy as np&#10;#&#10;#     # Convert to numpy array if not already&#10;#     array = np.asarray(input_array)&#10;#&#10;#     # If already float64 array, return directly&#10;#     if array.dtype == np.float64:&#10;#         return array&#10;#&#10;#     # Create output array&#10;#     result = np.empty(array.shape, dtype=np.float64)&#10;#&#10;#     # Process each element&#10;#     for idx in np.ndindex(array.shape):&#10;#         val = array[idx]&#10;#&#10;#         # Handle Quantity objects&#10;#         if hasattr(val, 'magnitude'):&#10;#             result[idx] = float(val.magnitude)&#10;#         else:&#10;#             # Handle other types&#10;#             try:&#10;#                 result[idx] = float(val)&#10;#             except (TypeError, ValueError):&#10;#                 print(f&quot;DEBUG: Cannot convert value at {idx}: {val}&quot;)&#10;#                 result[idx] = 0.0&#10;#&#10;#     # print(f&quot;DEBUG: Converted array to float64: {result}&quot;)&#10;#     return result&#10;&#10;def numpy_array_of_quantity_to_numpy_array_of_float64(quantity_array):&#10;    &quot;&quot;&quot;&#10;    Convert an array of mixed types or Quantity objects to a uniform float64 array.&#10;&#10;    Parameters&#10;    ----------&#10;    quantity_array : array-like&#10;        Array containing Pint Quantity objects or other numeric types&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array with the same shape as input but with magnitudes as float64 values&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # Convert to numpy array if not already&#10;    array = np.asarray(quantity_array)&#10;&#10;    # Fast path if already float64 array&#10;    if array.dtype == np.float64:&#10;        return array&#10;&#10;    # Fast path for arrays that are already numeric&#10;    if np.issubdtype(array.dtype, np.number):&#10;        print(f&quot;DEBUG: Array already has numeric dtype {array.dtype}, converting to float64&quot;)&#10;        return array.astype(np.float64)&#10;&#10;    # For single Quantity objects&#10;    if hasattr(array, 'magnitude'):&#10;        print(f&quot;DEBUG: Converting single Quantity with magnitude&quot;)&#10;        return np.float64(array.magnitude)&#10;&#10;    # Create output array&#10;    result = np.zeros(array.shape, dtype=np.float64)&#10;&#10;    # Use flat iteration for better performance&#10;    for i, val in enumerate(array.flat):&#10;        try:&#10;            # Handle Quantity objects&#10;            if hasattr(val, 'magnitude'):&#10;                result.flat[i] = float(val.magnitude)&#10;            else:&#10;                # Handle other types&#10;                result.flat[i] = float(val)&#10;        except (TypeError, ValueError):&#10;            idx = np.unravel_index(i, array.shape)&#10;            print(f&quot;DEBUG: Cannot convert value at {idx}: {val}&quot;)&#10;            result.flat[i] = 0.0&#10;&#10;    print(f&quot;DEBUG: Converted array with shape {array.shape} to float64&quot;)&#10;    return result&#10;&#10;def extract_units_from_quantities(quantity_array):&#10;    &quot;&quot;&quot;&#10;    Extract unit information from an array of Pint Quantity objects.&#10;&#10;    Parameters&#10;    ----------&#10;    quantity_array : numpy.ndarray&#10;        Array containing Pint Quantity objects&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Array of the same shape containing only the unit information&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # Create an empty array with object dtype to store unit objects&#10;    units_array = np.empty_like(quantity_array, dtype=object)&#10;&#10;    # Iterate through all elements&#10;    for idx in np.ndindex(quantity_array.shape):&#10;        # Get the quantity at this position&#10;        quantity = quantity_array[idx]&#10;&#10;        # Extract just the unit information if it's a Quantity&#10;        if hasattr(quantity, 'units'):&#10;            units_array[idx] = quantity.units&#10;            print(f&quot;DEBUG: Found unit {quantity.units} at position {idx}&quot;)&#10;        else:&#10;            units_array[idx] = None&#10;            print(f&quot;DEBUG: No unit at position {idx}&quot;)&#10;&#10;    return units_array&#10;&#10;def increment_with_units(self, addend):&#10;    &quot;&quot;&quot;&#10;    Increment a value with another value while ensuring consistent units.&#10;&#10;    If self is not a Quantity, it's promoted to a Quantity with internal units.&#10;    If addend is a Quantity, it's converted to internal units before adding.&#10;&#10;    Parameters&#10;    ----------&#10;    addend : pint.Quantity or scalar&#10;        The value to add&#10;&#10;    Returns&#10;    -------&#10;    pint.Quantity&#10;        A new Quantity with internal units, incremented by addend&#10;    &quot;&quot;&quot;&#10;    import pint&#10;&#10;    print(f&quot;DEBUG: Incrementing {self} with {addend}&quot;)&#10;&#10;    # If addend is not a Quantity, just do regular addition&#10;    if not isinstance(addend, pint.Quantity):&#10;        result = self + addend&#10;        print(f&quot;DEBUG: Added non-Quantity addend, result = {result}&quot;)&#10;        return result&#10;&#10;    # Determine the internal unit type based on addend's dimensionality&#10;    unit_type = None&#10;    if addend.check('[length]'):&#10;        unit_type = 'length'&#10;    elif addend.check('[force]'):&#10;        unit_type = 'force'&#10;    elif addend.check('[length] * [force]'):&#10;        unit_type = 'moment'&#10;    elif addend.check('[force] / [length]'):&#10;        unit_type = 'distributed_load'&#10;    elif addend.check('[force] / [length]^2'):&#10;        unit_type = 'pressure'&#10;&#10;    # Get the appropriate internal unit&#10;    if unit_type:&#10;        internal_unit = pyMAOS.unit_manager.get_internal_unit(unit_type)&#10;        print(f&quot;DEBUG: Using internal unit {internal_unit} for {unit_type}&quot;)&#10;    else:&#10;        # If we can't determine the unit type, use addend's units as fallback&#10;        internal_unit = addend.units&#10;        print(f&quot;DEBUG: Could not determine unit type, using addend units {internal_unit}&quot;)&#10;&#10;    # If self is not a Quantity, promote it to a Quantity with internal units&#10;    if not isinstance(self, pint.Quantity):&#10;        self = pyMAOS.unit_manager.ureg.Quantity(self, internal_unit)&#10;        print(f&quot;DEBUG: Promoted self to Quantity with internal units: {self}&quot;)&#10;&#10;    try:&#10;        # Convert addend to internal units before adding&#10;        converted_addend = addend.to(internal_unit)&#10;        print(f&quot;DEBUG: Converted addend from {addend} to {converted_addend}&quot;)&#10;&#10;        # Create result with the proper internal units&#10;        result = type(self)(self.magnitude + converted_addend.magnitude, internal_unit)&#10;        print(f&quot;DEBUG: Result after increment: {result}&quot;)&#10;&#10;        return result&#10;    except pint.DimensionalityError as e:&#10;        print(f&quot;DEBUG: Dimensionality error - {self.dimensionality}  {addend.dimensionality}&quot;)&#10;        raise e&#10;&#10;def add_arrays_with_units(array1, array2):&#10;    &quot;&quot;&quot;&#10;    Add two arrays element-wise while ensuring consistent units for each element.&#10;&#10;    For each element pair:&#10;    - Checks that dimensions agree, or one is a pure number and the other a Quantity&#10;    - Sums the magnitudes elementwise&#10;    - Converts the result to a Quantity in the internal unit system&#10;&#10;    Parameters&#10;    ----------&#10;    array1 : array-like&#10;        First array, may contain Quantity objects&#10;    array2 : array-like&#10;        Second array, may contain Quantity objects&#10;&#10;    Returns&#10;    -------&#10;    numpy.ndarray&#10;        Result array with proper internal units for each element&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;    from pyMAOS.quantity_utils import increment_with_units&#10;&#10;    # Convert inputs to numpy arrays if they're not already&#10;    array1 = np.asarray(array1)&#10;    array2 = np.asarray(array2)&#10;&#10;    # Check that shapes are compatible&#10;    if array1.shape != array2.shape:&#10;        raise ValueError(f&quot;Arrays must have the same shape, got {array1.shape} and {array2.shape}&quot;)&#10;&#10;    # Create output array with the same shape&#10;    result = np.empty_like(array1, dtype=object)&#10;&#10;    # Process each element using the existing increment_with_units function&#10;    for idx in np.ndindex(array1.shape):&#10;        result[idx] = increment_with_units(array1[idx], array2[idx])&#10;        print(f&quot;DEBUG: Element-wise addition at {idx}: {array1[idx]} + {array2[idx]} = {result[idx]}&quot;)&#10;&#10;    return result&#10;&#10;def print_units_matrix(array):&#10;    &quot;&quot;&quot;&#10;    Print a matrix with its values and units.&#10;&#10;    This function displays the content of a numpy array containing Pint Quantity objects,&#10;    showing both the magnitude values and their corresponding units.&#10;&#10;    For elements without units, only their values are shown.&#10;&#10;    Parameters&#10;    ----------&#10;    array : numpy.ndarray&#10;        The array to print, potentially containing Pint Quantity objects&#10;    &quot;&quot;&quot;&#10;    import numpy as np&#10;&#10;    # First, print the shape information&#10;    print(f&quot;Matrix shape: {array.shape}&quot;)&#10;&#10;    # Helper function for formatting a single value&#10;    def format_value(val):&#10;        if val is None:&#10;            return &quot;None&quot;&#10;        elif hasattr(val, 'units'):&#10;            # Format magnitude with appropriate precision&#10;            if abs(val.magnitude) &lt; 1e-10:&#10;                return f&quot;0 {val.units}&quot;&#10;            else:&#10;                return f&quot;{val.magnitude:.4g} {val.units}&quot;&#10;        else:&#10;            # Format plain numbers with appropriate precision&#10;            if isinstance(val, (int, float)) and abs(val) &lt; 1e-10:&#10;                return &quot;0&quot;&#10;            return str(val)&#10;&#10;    # Helper function for recursive printing of subarrays&#10;    def print_array(arr, indent=&quot;&quot;):&#10;        if arr.ndim == 1:&#10;            elements = [format_value(val) for val in arr]&#10;            print(indent + &quot;[&quot; + &quot;, &quot;.join(elements) + &quot;]&quot;)&#10;        elif arr.ndim == 2:&#10;            print(indent + &quot;[&quot;)&#10;            for row in arr:&#10;                print_array(row, indent + &quot;  &quot;)&#10;            print(indent + &quot;]&quot;)&#10;        else:&#10;            print(indent + f&quot;Array with {arr.ndim} dimensions:&quot;)&#10;            for i, subarray in enumerate(arr):&#10;                print(indent + f&quot;Dimension {i}:&quot;)&#10;                print_array(subarray, indent + &quot;  &quot;)&#10;&#10;    # Collect unit information for reporting&#10;    if array.size &gt; 0:&#10;        unique_units = set()&#10;        has_units = False&#10;&#10;        # Check for units in the array&#10;        for idx in np.ndindex(array.shape):&#10;            val = array[idx]&#10;            if hasattr(val, 'units'):&#10;                has_units = True&#10;                unique_units.add(str(val.units))&#10;&#10;        if has_units:&#10;            print(f&quot;DEBUG: Units found in matrix: {', '.join(sorted(unique_units))}&quot;)&#10;        else:&#10;            print(&quot;DEBUG: No units found in matrix&quot;)&#10;&#10;    # For empty arrays&#10;    if array.size == 0:&#10;        print(&quot;[]&quot;)&#10;        return&#10;&#10;    # For scalar arrays&#10;    if array.ndim == 0:&#10;        val = array.item()&#10;        print(format_value(val))&#10;        return&#10;&#10;    # Print the array&#10;    print_array(array)&#10;&#10;def convert_registry(quantity, target_registry=None):&#10;    &quot;&quot;&quot;&#10;    Convert a quantity to use a different registry.&#10;&#10;    Parameters&#10;    ----------&#10;    quantity : pint.Quantity&#10;        The quantity to convert&#10;    target_registry : pint.UnitRegistry, optional&#10;        The target registry. If None, uses the global registry from unit_manager.&#10;&#10;    Returns&#10;    -------&#10;    pint.Quantity&#10;        A new quantity using the target registry with the same value and unit&#10;    &quot;&quot;&quot;&#10;    import pyMAOS&#10;&#10;    # Default to global registry&#10;    if target_registry is None:&#10;        target_registry = pyMAOS.unit_manager.ureg&#10;&#10;    # If already using target registry, return the original&#10;    if hasattr(quantity, '_REGISTRY') and quantity._REGISTRY is target_registry:&#10;        return quantity&#10;&#10;    # Handle non-quantity objects&#10;    if not hasattr(quantity, 'magnitude') or not hasattr(quantity, 'units'):&#10;        return quantity&#10;&#10;    # Create new quantity with target registry&#10;    try:&#10;        return target_registry.Quantity(quantity.magnitude, str(quantity.units))&#10;    except Exception as e:&#10;        print(f&quot;Error converting quantity {quantity} to target registry: {e}&quot;)&#10;        return quantity&#10;&#10;def convert_all_quantities(obj, target_registry=None, processed_objects=None):&#10;    &quot;&quot;&quot;&#10;    Recursively convert all quantities in a complex object to use the target registry.&#10;&#10;    Parameters&#10;    ----------&#10;    obj : object&#10;        The object containing quantities to convert&#10;    target_registry : pint.UnitRegistry, optional&#10;        The target registry. If None, uses the global registry from unit_manager.&#10;    processed_objects : dict, optional&#10;        Dictionary to track already processed objects to avoid circular references&#10;&#10;    Returns&#10;    -------&#10;    object&#10;        A copy of the object with all quantities using the target registry&#10;    &quot;&quot;&quot;&#10;    import pyMAOS&#10;    import numpy as np&#10;&#10;    # Initialize processed_objects if it's the first call&#10;    if processed_objects is None:&#10;        processed_objects = {}&#10;&#10;    # If we've already processed this object, return the converted version&#10;    obj_id = id(obj)&#10;    if obj_id in processed_objects:&#10;        return processed_objects[obj_id]&#10;&#10;    # Default to global registry&#10;    if target_registry is None:&#10;        target_registry = pyMAOS.unit_manager.ureg&#10;&#10;    # Handle quantities directly&#10;    if hasattr(obj, '_REGISTRY') and hasattr(obj, 'magnitude'):&#10;        result = convert_registry(obj, target_registry)&#10;        processed_objects[obj_id] = result&#10;        return result&#10;&#10;    # Handle numpy arrays&#10;    if isinstance(obj, np.ndarray):&#10;        # For arrays of quantities&#10;        if obj.dtype == object:&#10;            result = np.empty_like(obj)&#10;            for i, value in enumerate(obj.flat):&#10;                result.flat[i] = convert_all_quantities(value, target_registry, processed_objects)&#10;            processed_objects[obj_id] = result&#10;            return result&#10;        processed_objects[obj_id] = obj&#10;        return obj&#10;&#10;    # Handle lists&#10;    if isinstance(obj, list):&#10;        result = [convert_all_quantities(item, target_registry, processed_objects) for item in obj]&#10;        processed_objects[obj_id] = result&#10;        return result&#10;&#10;    # Handle dictionaries&#10;    if isinstance(obj, dict):&#10;        result = {key: convert_all_quantities(value, target_registry, processed_objects) for key, value in obj.items()}&#10;        processed_objects[obj_id] = result&#10;        return result&#10;&#10;    # Handle objects with __dict__ attribute (most custom classes)&#10;    if hasattr(obj, '__dict__'):&#10;        # Create a shallow copy to avoid modifying original&#10;        import copy&#10;        new_obj = copy.copy(obj)&#10;&#10;        # Mark this object as processed BEFORE recursing to prevent infinite loops&#10;        processed_objects[obj_id] = new_obj&#10;&#10;        # Convert all attributes, skipping properties that have no setter&#10;        for attr_name, attr_value in obj.__dict__.items():&#10;            try:&#10;                # Check if this attribute is a property with no setter&#10;                cls = obj.__class__&#10;                if hasattr(cls, attr_name) and isinstance(getattr(cls, attr_name), property):&#10;                    prop = getattr(cls, attr_name)&#10;                    if prop.fset is None:&#10;                        # Skip read-only properties&#10;                        continue&#10;                &#10;                # Set the attribute with its converted value&#10;                setattr(new_obj, attr_name, convert_all_quantities(attr_value, target_registry, processed_objects))&#10;            except AttributeError as e:&#10;                # This happens when trying to set read-only properties&#10;                print(f&quot;Warning: Could not set attribute '{attr_name}' on {obj.__class__.__name__}: {e}&quot;)&#10;                continue&#10;&#10;        return new_obj&#10;&#10;    # Return other objects unchanged&#10;    processed_objects[obj_id] = obj&#10;    return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/structure2d.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/structure2d.py" />
              <option name="originalContent" value="import os&#10;import sys&#10;&#10;import numpy as np&#10;import pyMAOS&#10;from pyMAOS import unit_manager&#10;from pyMAOS.pymaos_units import array_convert_to_unit_system&#10;&#10;np.set_printoptions(precision=4, suppress=False, floatmode='maxprec_equal', linewidth=999)&#10;&#10;import operator&#10;&#10;&#10;# # Add custom formatters with explicit type signatures&#10;def format_with_dots(x) -&gt; str:&#10;    return '.'.center(12) if abs(x) &lt; 1e-10 else f&quot;{x:12.4g}&quot;&#10;&#10;&#10;def format_double(x) -&gt; str:&#10;    return '.'.center(13) if abs(x) &lt; 1e-10 else f&quot;{x:13.8g}&quot;  # More precision for doubles&#10;&#10;&#10;# Now use these type-annotated functions in the formatter dictionary&#10;np.set_printoptions(precision=4,&#10;                    suppress=False,&#10;                    formatter={&#10;                        'float': format_with_dots,  # For float32 and generic floats&#10;                        'float_kind': format_with_dots,  # For all floating point types&#10;                        'float64': format_double  # Specifically for float64 (double precision)&#10;                    },  # type: ignore&#10;                    linewidth=120  # Wider output to prevent unnecessary wrapping&#10;                    )&#10;&#10;&#10;# Parameters you can adjust:&#10;# *&#9;precision: Number of decimal places (4 is a good default)&#10;# *&#9;suppress: When True, very small values near zero are displayed as 0&#10;# *&#9;floatmode: Controls the display format&#10;# *&#9;'maxprec_equal': Best option for automatic switching between formats&#10;# *&#9;'fixed': Always use fixed-point notation&#10;# *&#9;'scientific': Always use scientific notation&#10;# *&#9;'unique': Use minimum digits to distinguish values&#10;&#10;class R2Structure:&#10;    def __init__(self, nodes, members, units=None):&#10;        self.nodes = nodes&#10;        self.members = members&#10;        self.units = units or pyMAOS.unit_manager.get_current_units()  # Use unit manager as fallback&#10;&#10;        # Validate node UIDs are unique&#10;        self._validate_node_uids()&#10;&#10;        # Validate member UIDs are unique&#10;        self._validate_member_uids()&#10;&#10;        self.create_uid_maps()  # Replace create_uid_map() with the new method&#10;&#10;        # Validate that all member nodes exist in the node list&#10;        for member in members:&#10;            if member.inode.uid not in self.uid_to_index:&#10;                raise ValueError(&#10;                    f&quot;Member {member.uid} references node {member.inode.uid} which doesn't exist in the structure&quot;)&#10;            if member.jnode.uid not in self.uid_to_index:&#10;                raise ValueError(&#10;                    f&quot;Member {member.uid} references node {member.jnode.uid} which doesn't exist in the structure&quot;)&#10;&#10;        # Rest of initialization remains the same...&#10;        self.members = members&#10;&#10;        # Structure Type&#10;        # 2D Structure&#10;&#10;&#10;        # Number of Joints&#10;        self.NJ = len(self.nodes)&#10;&#10;        # Number of Members&#10;        self.NM = len(self.members)&#10;&#10;        # Number of Restraints&#10;        self.NR = sum([sum(node.restraints) for node in self.nodes])&#10;&#10;        # Degrees of Freedom&#10;        self.DIM=sum([node.NJD for node in self.nodes])&#10;        self.NDOF = self.DIM - self.NR&#10;&#10;        # Data Stores&#10;        self._springNodes = None&#10;        self._nonlinearNodes = None&#10;        self._D = {}  # Structure Displacement Vector Dictionary&#10;        self.U=[]&#10;        # Flags&#10;        self._unstable = False&#10;        self._Kgenerated = False&#10;        self._ERRORS = []&#10;&#10;        # Register members with the structure for unit access&#10;        for member in self.members:&#10;            if hasattr(member, 'set_structure'):&#10;                member.set_structure(self)&#10;&#10;    def set_node_uids(self):&#10;        i = 1&#10;&#10;        for node in self.nodes:&#10;            node.uid = i&#10;            i += 1&#10;&#10;    def set_member_uids(self):&#10;        i = 1&#10;&#10;        for member in self.members:&#10;            member.uid = i&#10;            i += 1&#10;&#10;    def _validate_node_uids(self):&#10;        &quot;&quot;&quot;&#10;        Validate that all node UIDs in the structure are unique.&#10;        Raises ValueError if duplicate UIDs are found.&#10;        &quot;&quot;&quot;&#10;        uids = [node.uid for node in self.nodes]&#10;        duplicates = set([uid for uid in uids if uids.count(uid) &gt; 1])&#10;&#10;        if duplicates:&#10;            duplicate_str = &quot;, &quot;.join(str(uid) for uid in duplicates)&#10;            raise ValueError(f&quot;Duplicate node UIDs found: {duplicate_str}&quot;)&#10;&#10;    def _validate_member_uids(self):&#10;        &quot;&quot;&quot;&#10;        Validate that all member UIDs in the structure are unique.&#10;        Raises ValueError if duplicate UIDs are found.&#10;        &quot;&quot;&quot;&#10;        uids = [member.uid for member in self.members]&#10;        duplicates = set([uid for uid in uids if uids.count(uid) &gt; 1])&#10;&#10;        if duplicates:&#10;            duplicate_str = &quot;, &quot;.join(str(uid) for uid in duplicates)&#10;            raise ValueError(f&quot;Duplicate member UIDs found: {duplicate_str}&quot;)&#10;&#10;    def spring_nodes(self):&#10;        # loop through nodes and create a list of the nodes with springs&#10;        # assigned to a DOF.&#10;        springNodes = []&#10;        nonlinearNodes = []&#10;        for node in self.nodes:&#10;            if node._isSpring is True:&#10;                springNodes.append(node)&#10;&#10;            if node._isNonLinear is True:&#10;                nonlinearNodes.append(node)&#10;&#10;        if springNodes:&#10;            self._springNodes = springNodes&#10;&#10;        if nonlinearNodes:&#10;            self._nonlinearNodes = nonlinearNodes&#10;&#10;    def create_uid_map(self):&#10;        &quot;&quot;&quot;Create a mapping from UIDs to positions&quot;&quot;&quot;&#10;        self.uid_to_index = {node.uid: i for i, node in enumerate(self.nodes)}&#10;&#10;    def create_uid_maps(self):&#10;        &quot;&quot;&quot;Create mappings between UIDs and positions (in both directions)&quot;&quot;&quot;&#10;        # Map from UID to position index&#10;        self.uid_to_index = {node.uid: i for i, node in enumerate(self.nodes)}&#10;&#10;        # Map from position index to UID&#10;        self.index_to_uid = {i: node.uid for i, node in enumerate(self.nodes)}&#10;&#10;    def set_freedom_map(self):&#10;        # Freedom Map&#10;        self.FM = np.zeros(self.DIM, dtype=np.int32)  # Ensure FM is initialized as an integer array&#10;&#10;        # Loop through the nodes mapping free and restrained joint displacements to&#10;        # the Freedom Map (FM). This will facilitate generating the global stiffness&#10;        # matrix in partitioned form.&#10;&#10;        j = 0  # starting index for the first free displacement&#10;        k = self.NDOF  # starting index for the first restraint&#10;&#10;        for node_index, node in enumerate(self.nodes):&#10;            for r, restraint in enumerate(node.restraints):&#10;                fmindex = node_index * node.NJD + r&#10;&#10;                if restraint == 0:&#10;                    self.FM[fmindex] = j&#10;                    j += 1&#10;                else:&#10;                    self.FM[fmindex] = k&#10;                    k += 1&#10;&#10;        return self.FM.astype(np.int32)&#10;&#10;    def get_freedom_map(self):&#10;        return self.FM.astype(np.int32)  # Ensure FM is returned as an integer array&#10;&#10;    def Kstructure(self, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Build the structure stiffness matrix organized into paritioned form&#10;        using the freedom map to reposition nodal DOFs&#10;&#10;        Returns&#10;        -------&#10;        KSTRUCT: Numpy Matrix&#10;            Structure Stiffness Matrix.&#10;&#10;        &quot;&quot;&quot;&#10;        verbose = kwargs.get('verbose', False)&#10;        output_dir = kwargs.get('output_dir', '.')&#10;        if not os.path.exists(output_dir):&#10;            os.makedirs(output_dir)&#10;&#10;        # Structure Stiffness Matrix&#10;        KSTRUCT = np.zeros([self.DIM, self.DIM], dtype=object)&#10;        print(&quot;KSTRUCT shape:&quot;, KSTRUCT.shape, flush=True)&#10;&#10;        for member in self.members:&#10;            # Freedom map for i and j nodes&#10;            inode=member.inode&#10;            imap = [int(self.FM[(self.uid_to_index[inode.uid]) * inode.NJD + r]) for r in range(inode.NJD)]&#10;            jnode=member.jnode&#10;            imap.extend([int(self.FM[(self.uid_to_index[jnode.uid]) * jnode.NJD + r]) for r in range(jnode.NJD)])&#10;            print(f&quot;Freedom Map Indices for Member {member.uid}:\n{imap}&quot;, flush=True)&#10;&#10;            # Member global stiffness matrix&#10;            kmglobal = member.kglobal()&#10;            print(f&quot;Member {member.uid}:\tkmglobal (Internal Units)\n{kmglobal}\n&quot;, flush=True)&#10;&#10;            # Check if the member is a truss&#10;            if member.type == &quot;TRUSS&quot;:&#10;                # For truss elements, verify that all bending/shear terms are zero&#10;                bending_terms = [&#10;                    kmglobal[2, 2],  # i-node bending terms&#10;                    kmglobal[5, 5]  # j-node bending terms&#10;                ]&#10;&#10;                # Check if any of these terms are non-zero&#10;                if not all(abs(term) &lt; 1e-10 for term in bending_terms):&#10;                    non_zero_terms = [f&quot;[{i}]={val}&quot; for i, val in enumerate(bending_terms) if abs(val) &gt; 1e-10]&#10;                    error_msg = (f&quot;Error: Member {member.uid} is a TRUSS but has non-zero bending terms: &quot;&#10;                                 f&quot;{', '.join(non_zero_terms)}. Truss elements must have zero bending stiffness.&quot;)&#10;                    print(error_msg)&#10;                    raise ValueError(error_msg)&#10;&#10;            # Save each member's global stiffness matrix to a separate CSV file&#10;            filename = os.path.join(output_dir, f'member_{member.uid}_global_stiffness_SI.csv')&#10;            np.savetxt(filename, kmglobal, delimiter=',', fmt='%g')&#10;            print(f&quot;Saved member {member.uid} global stiffness matrix to {filename}&quot;, flush=True)&#10;&#10;            self.NJD=3 # temporary fix&#10;            for i in range(self.NJD):&#10;                for j in range(self.NJD):&#10;                    # print(f&quot;i: {i}, j: {j}, imap[i]: {imap[i]}, imap[j]: {imap[j]}&quot;, flush=True)&#10;                    # Get current values at the target positions&#10;                    pos_ii = (imap[i], imap[j])&#10;                    pos_ji = (imap[i + self.NJD], imap[j])&#10;                    pos_ij = (imap[i], imap[j + self.NJD])&#10;                    pos_jj = (imap[i + self.NJD], imap[j + self.NJD])&#10;&#10;                    # Get source values to add&#10;                    val_ii = kmglobal[i, j]&#10;                    val_ji = kmglobal[i + self.NJD, j]&#10;                    val_ij = kmglobal[i, j + self.NJD]&#10;                    val_jj = kmglobal[i + self.NJD, j + self.NJD]&#10;&#10;                    from pyMAOS.quantity_utils import increment_with_units&#10;                    # Use increment_with_units to add values with unit checking&#10;                    print(f&quot;DEBUG: Adding to KSTRUCT at {pos_ii}: {val_ii}&quot;)&#10;                    KSTRUCT[pos_ii] = increment_with_units(KSTRUCT[pos_ii], val_ii)&#10;&#10;                    print(f&quot;DEBUG: Adding to KSTRUCT at {pos_ji}: {val_ji}&quot;)&#10;                    KSTRUCT[pos_ji] = increment_with_units(KSTRUCT[pos_ji], val_ji)&#10;&#10;                    print(f&quot;DEBUG: Adding to KSTRUCT at {pos_ij}: {val_ij}&quot;)&#10;                    KSTRUCT[pos_ij] = increment_with_units(KSTRUCT[pos_ij], val_ij)&#10;&#10;                    print(f&quot;DEBUG: Adding to KSTRUCT at {pos_jj}: {val_jj}&quot;)&#10;                    KSTRUCT[pos_jj] = increment_with_units(KSTRUCT[pos_jj], val_jj)&#10;&#10;&#10;        # Loop through Spring Nodes and add the spring stiffness&#10;        if self._springNodes:&#10;            for node in self._springNodes:&#10;                node_index = self.uid_to_index[node.uid]&#10;                uxposition = int(FM[(node_index) * self.NJD + 0])&#10;                uyposition = int(FM[(node_index) * self.NJD + 1])&#10;                rzposition = int(FM[(node_index) * self.NJD + 2])&#10;                kux = node._spring_stiffness[0]&#10;                kuy = node._spring_stiffness[1]&#10;                krz = node._spring_stiffness[2]&#10;&#10;                # KSTRUCT[uxposition, uxposition] += kux&#10;                # KSTRUCT[uyposition, uyposition] += kuy&#10;                # KSTRUCT[rzposition, rzposition] += krz&#10;&#10;                KSTRUCT.incremental_add_with_units((uxposition, uxposition), kux)&#10;                KSTRUCT.incremental_add_with_units((uyposition, uyposition), kuy)&#10;                KSTRUCT.incremental_add_with_units((rzposition, rzposition), krz)&#10;        self._Kgenerated = True&#10;&#10;        if verbose:&#10;            np.set_printoptions(precision=4,&#10;                                suppress=False,&#10;                                formatter={&#10;                                    'float': format_with_dots,  # For float32 and generic floats&#10;                                    'float_kind': format_with_dots,  # For all floating point types&#10;                                    'float64': format_double  # Specifically for float64 (double precision)&#10;                                },  # type: ignore&#10;                                linewidth=120  # Wider output to prevent unnecessary wrapping&#10;                                )&#10;            print(&quot;KSTRUCT:&quot;, KSTRUCT, sep=&quot;\n&quot;);&#10;            print(KSTRUCT.shape);&#10;            from pyMAOS.quantity_utils import print_units_matrix&#10;            print_units_matrix(KSTRUCT)&#10;&#10;            KSTRUCT_csv = os.path.join(output_dir, 'KSTRUCT.csv')&#10;            np.savetxt(KSTRUCT_csv, KSTRUCT, delimiter=',', fmt='%lg')&#10;            print(f&quot;Saved KSTRUCT to {KSTRUCT_csv}&quot;)&#10;&#10;        return KSTRUCT&#10;&#10;&#10;    def nodal_force_vector(self, FM, load_combination):&#10;        &quot;&quot;&quot;&#10;        Build the structure nodal force vector mapped to the same partitions&#10;        as KSTRUCT using the freedom map (FM).&#10;&#10;        Returns&#10;        -------&#10;        FG : ndarray&#10;            Structure Nodal Force Vector with proper units.&#10;        &quot;&quot;&quot;&#10;        # from pyMAOS.units_mod import INTERNAL_FORCE_UNIT, INTERNAL_MOMENT_UNIT&#10;        # zero_force=unit_manager.get_zero_quantity(INTERNAL_FORCE_UNIT)&#10;        # zero_moment= unit_manager.get_zero_quantity(INTERNAL_MOMENT_UNIT)&#10;&#10;        FG = np.zeros(self.NJD * self.NJ, dtype=object)&#10;&#10;        print(f&quot;DEBUG: Initialized FG as QuantityArray, shape={FG.shape}&quot;)&#10;&#10;        # Apply loads from each node&#10;        for node_index, node in enumerate(self.nodes):&#10;            for load_case, load in node.loads.items():&#10;                # Display load information for debugging&#10;                from pyMAOS.display_utils import display_node_load_vector_in_units&#10;                display_node_load_vector_in_units(&#10;                    load_vector=load,&#10;                    node_uid=node.uid,&#10;                    force_unit=self.units.get('force', 'N'),&#10;                    length_unit=self.units.get('length', 'm'),&#10;                    load_combo_name=load_combination.name&#10;                )&#10;&#10;                load_factor = load_combination.factors.get(load_case, 0)&#10;&#10;                # Use list comprehension for pint quantities&#10;                factored_load = [load_factor * f for f in load]&#10;                print(f&quot;DEBUG: Node {node.uid}, load_case={load_case}, factor={load_factor}, factored_load={factored_load}&quot;)&#10;&#10;                for i, f in enumerate(factored_load):&#10;                    fm_index = node_index * self.NJD + i&#10;                    mapped_index = int(self.FM[fm_index])  # Ensure integer index&#10;&#10;                    # Add load component using QuantityArray's add_with_units method&#10;                    FG.incremental_add_with_units((mapped_index,), f)&#10;                    print(f&quot;DEBUG: Added {f} at position {mapped_index}&quot;)&#10;&#10;        print(&quot;Nodal Force Vector:&quot;, sep=&quot;\n&quot;)&#10;        from pyMAOS.pymaos_units import array_convert_to_unit_system&#10;        _ = array_convert_to_unit_system(FG, &quot;imperial&quot;)&#10;&#10;        return FG&#10;&#10;&#10;&#10;    def assemble_fixed_end_force(self, load_combination):&#10;        # Initialize array with object dtype to store Quantity objects&#10;        structure_fef = np.zeros(self.NJD * self.NJ, dtype='object')&#10;&#10;        print(f&quot;DEBUG: Initial PF dtype = {structure_fef.dtype}&quot;)&#10;&#10;        for member in self.members:&#10;            if member.type != &quot;TRUSS&quot;:&#10;                # Get fixed end forces in global coordinates&#10;                elem_fef_global = member.FEFglobal(load_combination)&#10;                # print(&quot;DEBUG: Ff type:&quot;, type(Ff), &quot;shape:&quot;, np.shape(Ff))&#10;                from pyMAOS.pymaos_units import array_convert_to_unit_system;&#10;                # print(f&quot;Member {member.uid} fixed end forces before conversion: {Ff.view(QuantityArray)}&quot;)&#10;                _ = array_convert_to_unit_system(elem_fef_global, &quot;imperial&quot;)&#10;&#10;                i_index = self.uid_to_index[member.inode.uid]&#10;                j_index = self.uid_to_index[member.jnode.uid]&#10;&#10;                # Debug info about the returned forces&#10;                # print(f&quot;DEBUG: Member {member.uid} forces type: {type(Ff)} shape: {np.shape(Ff)}&quot;)&#10;                # print(f&quot;DEBUG: First element type: {type(Ff[0])}&quot;)&#10;&#10;                # Add the forces directly - with object dtype, this should work with Quantity objects&#10;                imap = self.FM[i_index * self.NJD:(i_index + 1) * self.NJD]&#10;                print(f&quot;DEBUG: imap for i_index {i_index}: {imap}&quot;)&#10;                from pyMAOS.quantity_utils import increment_with_units&#10;                # structure_fef[imap] += Ff[0:self.NJD]&#10;                print(elem_fef_global[0:self.NJD])&#10;                structure_fef[imap]= increment_with_units(structure_fef[imap], elem_fef_global[0:self.NJD])&#10;                # target_indices = self.FM[j_index * self.NJD:(j_index + 1) * self.NJD]&#10;                # source_values = Ff[self.NJD:2 * self.NJD]&#10;                #&#10;                # # Loop through each index and use increment_with_units&#10;                # for i, idx in enumerate(target_indices):&#10;                #     structure_fef[idx] = increment_with_units(structure_fef[idx], source_values[i])&#10;&#10;                # Check units consistency after addition&#10;                # sample_idx = FM[i_index * self.NJD]&#10;                # print(f&quot;DEBUG: structure_fef[{sample_idx}] type after addition: {type(structure_fef[sample_idx])}&quot;)&#10;&#10;        from pyMAOS.quantity_utils import print_units_matrix&#10;&#10;        print(f&quot;Member {member.uid} Fixed End Force Vector PF:&quot;)&#10;        print_units_matrix(structure_fef)&#10;&#10;        # At the end, you can extract magnitudes if needed for further calculations&#10;        # PF_magnitudes = np.array([f.magnitude if hasattr(f, 'magnitude') else f for f in structure_fef])&#10;        # print(f&quot;DEBUG: Final PF_magnitudes dtype = {PF_magnitudes.dtype}&quot;)&#10;        self.structure_fef = structure_fef&#10;        print(&quot;Structure Fixed End Force Vector structure_fef:&quot;, structure_fef, sep=&quot;\n&quot;)&#10;        print(&quot;Put back in order by code numers:&quot;, structure_fef[self.FM], sep=&quot;\n&quot;)&#10;        return structure_fef&#10;&#10;&#10;    def solve_linear_static(self, load_combination, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Perform a linear static solution of the model using the Kff&#10;        and FGf paritions&#10;&#10;        Returns&#10;        -------&#10;        TYPE&#10;            DESCRIPTION.&#10;&#10;        &quot;&quot;&quot;&#10;        # Extract arguments from kwargs&#10;        verbose = kwargs.get('verbose', False)&#10;        # if verbose:&#10;        #     print(&quot;--- Running in Verbose Mode ---&quot;)&#10;        structure_state_bin = kwargs.get(&quot;structure_state_bin&quot;, None)&#10;&#10;        # Generate Freedom Map&#10;        self.FM = self.set_freedom_map(); print(&quot;Freedom Map:&quot;, self.FM, sep=&quot;\n&quot;)&#10;&#10;        # Generate Full Structure Stiffness Matrix&#10;        self.KSTRUCT = self.Kstructure(**kwargs)&#10;&#10;        self._verify_stable(self.FM, self.KSTRUCT)&#10;&#10;        if self._unstable:&#10;            raise ValueError(&quot;Structure is unstable&quot;);&#10;            sys.exit(1)&#10;&#10;        # Build Nodal Force Vector&#10;        self.FG = self.nodal_force_vector(self.FM, load_combination)&#10;        # print(&quot;Nodal Force Vector FG:\n&quot;, self.FG); print(self.FG.shape)&#10;        from pyMAOS.pymaos_units import array_convert_to_unit_system; print(&quot;Structure nodal global forces&quot;)&#10;        _ = array_convert_to_unit_system(self.FG, &quot;imperial&quot;)&#10;        # Build Member Fixed-end-Force vector&#10;        self.structure_fef = self.assemble_fixed_end_force(load_combination)&#10;        # print(&quot;Structure Fixed End Force Vector:\n&quot;, structure_fef); print(structure_fef.shape)&#10;&#10;        from pymaos_units import array_convert_to_unit_system; print(&quot;Structure Fixed-end Forces&quot;)&#10;        _ = array_convert_to_unit_system(self.structure_fef, &quot;imperial&quot;)&#10;&#10;        self.Kff = self.KSTRUCT[0: self.NDOF, 0: self.NDOF]; print(&quot;Kff Partition:&quot;, self.Kff, sep=&quot;\n&quot;);&#10;        print(self.Kff.shape)  # display_stiffness_matrix_in_units(self.Kff)&#10;        # Slice out the FGf partition from the global nodal force vector&#10;        self.FGf = self.FG[0: self.NDOF];  print(&quot;FGf Partition:&quot;, self.FGf, sep=&quot;\n&quot;);&#10;        print(self.FGf.shape);  _ = array_convert_to_unit_system(self.FGf, &quot;imperial&quot;)&#10;        self.PFf = self.structure_fef[0: self.NDOF]&#10;        print(&quot;PFf Partition:&quot;, self.PFf, sep=&quot;\n&quot;);&#10;        print(self.PFf.shape)&#10;        from pyMAOS.quantity_utils import numpy_array_of_quantity_to_numpy_array_of_float64&#10;        # Extract magnitudes for calculation&#10;        Kff_magnitudes = numpy_array_of_quantity_to_numpy_array_of_float64(self.Kff)&#10;        print(&quot;Kff_magnitudes:&quot;, Kff_magnitudes, sep=&quot;\n&quot;)&#10;        # FGf_magnitudes = np.array([f.magnitude if hasattr(f, 'magnitude') else float(f) for f in self.FGf],&#10;        #                           dtype=np.float64)&#10;        # print(&quot;FGf_magnitudes:&quot;, FGf_magnitudes, sep=&quot;\n&quot;)&#10;        # PFf_magnitudes = np.array([p.magnitude if hasattr(p, 'magnitude') else float(p) for p in self.PFf],&#10;        #                           dtype=np.float64);&#10;        # print(PFf_magnitudes)&#10;        # print(f&quot;DEBUG: Kff_magnitudes shape: {Kff_magnitudes.shape}&quot;)&#10;        # print(f&quot;DEBUG: FGf_magnitudes shape: {FGf_magnitudes.shape}&quot;)&#10;        # print(f&quot;DEBUG: PFf_magnitudes shape: {PFf_magnitudes.shape}&quot;)&#10;        # Check if the Kff partition is singular&#10;        if np.linalg.cond(Kff_magnitudes) &gt; 1.0 / np.finfo(np.float64).eps:&#10;            print(&quot;WARNING: Kff partition is singular or nearly singular. The system may not have a unique solution.&quot;)&#10;            self._unstable = True&#10;            return None&#10;        # If we have units, we need to handle them carefully&#10;        # Use scipy.linalg.solve to solve the linear system&#10;        # This will return the displacement vector U in the same units as the right-hand side&#10;        # If the right-hand side is a Pint Quantity, we need to extract the magnitudes&#10;        # and reattach the units to the result.&#10;        # If the right-hand side is a numpy array, we can use it directly.&#10;        # Check if we're working with Pint Quantity objects&#10;        import scipy.linalg as sla&#10;&#10;        if hasattr(self.FGf[0], 'magnitude') or hasattr(self.PFf[0], 'magnitude') or True:&#10;&#10;            # Store units from the right-hand side for later&#10;            # Extract original units from the right-hand side&#10;            rhs = self.FGf - self.PFf; print(rhs)&#10;            _ = array_convert_to_unit_system(rhs, &quot;imperial&quot;)&#10;&#10;&#10;&#10;            # Convert to numpy array of Quantity objects&#10;            from pyMAOS.quantity_utils import numpy_array_of_quantity_to_numpy_array_of_float64&#10;            rhs_quantities = numpy_array_of_quantity_to_numpy_array_of_float64(rhs)&#10;            print(f&quot;DEBUG: Converted to array of Quantities with shape {rhs_quantities.shape}&quot;)&#10;&#10;            # Solve using scipy.linalg&#10;            U_magnitudes = sla.solve(Kff_magnitudes, rhs_quantities)&#10;            from pyMAOS.quantity_utils import extract_units_from_quantities&#10;            rhs_units = extract_units_from_quantities(rhs)&#10;            print(f&quot;DEBUG: Right-hand side units: {rhs_units}&quot;)&#10;            # Example usage of the units array&#10;            # for idx, unit in np.ndenumerate(rhs_units):&#10;            #     if unit is not None:&#10;            #         print(f&quot;Element at {idx} has unit: {unit}&quot;)&#10;            # Define and immediately apply the lambda function for each unit&#10;            conjugate_units_container_list = [(lambda u: unit_manager.ureg.UnitsContainer(&#10;                {'[length]': 2, '[mass]': 1, '[time]': -2}) / u.dimensionality)(u)&#10;                               for u in rhs_units]&#10;            # Create quantities with value 1.0 and the container units&#10;            quantities = [unit_manager.ureg.Quantity(1.0, container) for container in conjugate_units_container_list]&#10;            print(f&quot;DEBUG: Created {len(quantities)} quantities from containers&quot;)&#10;&#10;            # Convert to imperial system&#10;            imperial_quantities = array_convert_to_unit_system(quantities, &quot;imperial&quot;)&#10;            print(f&quot;DEBUG: Converted to imperial: {imperial_quantities}&quot;)&#10;&#10;            # Extract just the units&#10;            imperial_units = [q.units for q in imperial_quantities]&#10;            print(f&quot;DEBUG: Extracted units: {imperial_units}&quot;)&#10;&#10;            print(f&quot;DEBUG: Converted {rhs_units} to conjugate unit(s): {conjugate_units_container_list}&quot;)&#10;&#10;            # Reattach conjugate units to displacement results&#10;            self.U = np.array([pyMAOS.unit_manager.ureg.Quantity(mag, conj_unit)&#10;                               for mag, conj_unit in zip(U_magnitudes, conjugate_units_container_list)], dtype=object)&#10;&#10;            print(f&quot;DEBUG: Reattached conjugate units to displacement vector: {self.U}&quot;)&#10;&#10;        else:&#10;            # No units involved, use scipy.linalg directly&#10;            print(&quot;DEBUG: Using scipy.linalg directly (no units)&quot;)&#10;            self.U = sla.solve(self.Kff, self.FGf - self.PFf)&#10;        print(self.U)&#10;        return self.U&#10;&#10;    def set_node_displacements(self, load_combination=None):&#10;        # Later, to restart from saved state:&#10;        # if self.load_structure_state(&quot;structure_state.bin&quot;):&#10;        #     print(&quot;Successfully restored structure state - ready to continue analysis&quot;)&#10;        # else:&#10;        #     print(&quot;Failed to load state - need to recalculate&quot;)&#10;&#10;        print(&quot;Structure displacement U:&quot;, self.U, sep=&quot;\n&quot;)#; print(self.U.shape)&#10;&#10;        # Full Displacement Vector&#10;        # Result is still mapped to DOF via FM&#10;        # Create USTRUCT as an object array to hold Quantity objects&#10;        # Create USTRUCT as self.U padded with zeros up to self.NJD * self.NJ elements&#10;        USTRUCT = np.zeros(self.DIM, dtype=object)&#10;&#10;        # Copy values from self.U to the beginning of padded_array&#10;        USTRUCT[:len(self.U)] = self.U&#10;&#10;        # Debug information&#10;        print( f&quot;DEBUG: Created USTRUCT by padding self.U ({len(self.U)} elements) to full size ({self.DIM} elements)&quot;)&#10;&#10;        print(&quot;USTRUCT&quot;)&#10;        _ = array_convert_to_unit_system(USTRUCT, &quot;imperial&quot;)&#10;        # store displacement results to the current case to the nodes&#10;        for node in self.nodes:&#10;            node_index = self.uid_to_index[node.uid]&#10;            keys = self.FM[node_index * node.NJD: (node_index + 1) * self.NJD]&#10;            node_displacements = USTRUCT[keys]&#10;&#10;            print(f&quot;node {node.uid}    Ux: {node_displacements[0]:.4E} -- Uy: {node_displacements[1]:.4E} -- Rz: {node_displacements[2]:.4E}&quot;)&#10;            # print(f&quot;DEBUG: Node {node.uid} displacements with units: {node_displacements}&quot;);&#10;&#10;            node.displacements[load_combination.name] = node_displacements&#10;&#10;        return&#10;&#10;&#10;    def compute_reactions(self, load_combination):&#10;        &quot;&quot;&quot;Calculate nodal reactions for the given load combination&quot;&quot;&quot;&#10;        for node in self.nodes:&#10;            node_index = self.uid_to_index[node.uid]&#10;            # Initialize reactions vector [rx, ry, mz]&#10;            # reactions = np.zeros(self.NJD)&#10;            #&#10;            # # Add contributions from nodal loads (with negative sign)&#10;            # for load_case, load in node.loads.items():&#10;            #     load_factor = load_combination.factors.get(load_case, 0)&#10;            #     reactions -= np.array(load) * load_factor&#10;            #&#10;            # # Add contributions from member end forces&#10;            # for member in self.members:&#10;            #     member_FG = member.set_end_forces_global(load_combination)&#10;            #     print(f&quot;Member {member.uid} Fixed End Forces:\n{member_FG}&quot;)&#10;            #     # Add forces from i-node if this node is the i-node&#10;            #     if member.inode == node:&#10;            #         # Debug shapes when encountering errors&#10;            #         reactions += member_FG[0:self.NJD]  # Use reshape(-1) to ensure correct shape&#10;            #&#10;            #     # Add forces from j-node if this node is the j-node&#10;            #     if member.jnode == node:&#10;            #         reactions += member_FG[self.NJD:(2 * self.NJD)]&#10;            #&#10;            # # Override with spring reactions if applicable&#10;            # u = node.displacements.get(load_combination.name, np.zeros(self.NJD))&#10;            # for i in range(self.NJD):&#10;            #     if node._spring_stiffness[i] &gt; 0:&#10;            #         reactions[i] = -1 * u[i] * node._spring_stiffness[i]&#10;            #&#10;            # # Store reactions and print summary&#10;            # node.reactions[load_combination.name] = reactions.tolist()&#10;            node.compute_reactions(load_combination)&#10;&#10;&#10;    def _verify_stable(self, FM, KSTRUCT):&#10;        &quot;&quot;&quot;&#10;        Check the diagonal terms of the stiffness matrix against support&#10;        conditions. If diagonal term is 0 and the node is unsupported for&#10;        that DOF then the Kmatrix is singular and unstable.&#10;&#10;        Returns&#10;        -------&#10;        If unstable returns a dictionary of unstable nodes&#10;        and degree of freedom marked unstable.&#10;&#10;        &quot;&quot;&quot;&#10;&#10;        unstablenodes = []&#10;&#10;        for node_index, node in enumerate(self.nodes):&#10;            # Check each DOF of node:&#10;            for i, dof in enumerate(node.restraints):&#10;                fmindex = node_index * self.NJD + i&#10;                val = FM[fmindex]&#10;&#10;                # value the diagonal position in the stiffness matrix&#10;                kval = KSTRUCT[int(val), int(val)]&#10;&#10;                if kval == 0 and dof != 1:&#10;                    self._unstable = True&#10;                    unstablenodes.append(&#10;                        f&quot;Node {node.uid} : Unstable for {node.restraints_key[i]}&quot;&#10;                    )&#10;        # add unstable messages to ERROR list&#10;        self._ERRORS.extend(unstablenodes)&#10;&#10;        return unstablenodes&#10;&#10;&#10;    def plot_loadcombos_vtk(self, loadcombos=None, scaling=None):&#10;        &quot;&quot;&quot;Visualizes the structure with results from multiple load combinations using VTK.&quot;&quot;&quot;&#10;        try:&#10;            # Import the plotting function from R2Structure_extras&#10;            from pyMAOS.structure2d_extras import plot_loadcombos_vtk, check_vtk_available&#10;&#10;            # Check if VTK is available&#10;            if not check_vtk_available():&#10;                print(&quot;Warning: VTK library is not installed. Please install VTK for visualization.&quot;)&#10;                return&#10;&#10;            # Call the imported function with self as first argument&#10;            plot_loadcombos_vtk(self, loadcombos, scaling)&#10;        except ImportError as e:&#10;            print(f&quot;Warning: Visualization module not found: {e}&quot;)&#10;            print(&quot;Make sure structure2d_extras.py is in the pyMAOS package directory.&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error during visualization: {e}&quot;)&#10;&#10;&#10;    def get_summary(self):&#10;        &quot;&quot;&quot;&#10;        Returns a string representation of the structure using the display units&#10;        specified in the input file.&#10;        &quot;&quot;&quot;&#10;        # Access the global unit variables (defined elsewhere in the program)&#10;        # import sys&#10;        # from inspect import currentframe, getouterframes&#10;        # module = sys.modules[__name__]&#10;&#10;        # Attempt to get unit info from module scope&#10;        # Use units from self.units dictionary with appropriate defaults&#10;        force_unit = self.units.get('force', 'N')&#10;        length_unit = self.units.get('length', 'm')&#10;        pressure_unit = self.units.get('pressure', 'Pa')&#10;        moment_unit = self.units.get('moment', f&quot;{force_unit}*{length_unit}&quot;)&#10;        distributed_load_unit = self.units.get('distributed_load', f&quot;{force_unit}/{length_unit}&quot;)&#10;&#10;        # Create a ureg for conversions if not already available&#10;        try:&#10;            from pyMAOS.pymaos_units import ureg&#10;            Q_ = ureg.Quantity&#10;        except:&#10;            # Fall back if pint is not available&#10;            print(&quot;Warning: pint library not available, using SI units for display&quot;)&#10;            Q_ = lambda x, unit: x&#10;&#10;        # Build the output string&#10;        result = []&#10;        result.append(&quot;=&quot; * 80)&#10;        result.append(f&quot;STRUCTURAL MODEL SUMMARY&quot;)&#10;        result.append(f&quot;Display units: Force={force_unit}, Length={length_unit}, Pressure={pressure_unit}&quot;)&#10;        result.append(&quot;-&quot; * 80)&#10;&#10;        # Basic structure info&#10;        result.append(f&quot;Number of nodes: {self.NJ}&quot;)&#10;        result.append(f&quot;Number of members: {self.NM}&quot;)&#10;        result.append(f&quot;Degrees of freedom: {self.NDOF}&quot;)&#10;        result.append(f&quot;Number of restraints: {self.NR}&quot;)&#10;&#10;        # Node information&#10;        result.append(&quot;\nNODE INFORMATION:&quot;)&#10;        result.append(f&quot;{'Node ID':8} {'X (' + length_unit + ')':15} {'Y (' + length_unit + ')':15} {'Restraints':15}&quot;)&#10;        result.append(&quot;-&quot; * 80)&#10;&#10;        for node in sorted(self.nodes, key=operator.attrgetter('uid')):&#10;            # Convert coordinates to display units&#10;            x_display = Q_(node.x, 'm').to(length_unit).magnitude if hasattr(Q_, 'to') else node.x&#10;            y_display = Q_(node.y, 'm').to(length_unit).magnitude if hasattr(Q_, 'to') else node.y&#10;&#10;            # Format restraints&#10;            restraint_str = &quot;&quot;.join([&#10;                &quot;Rx&quot; if node.restraints[0] else &quot;--&quot;,&#10;                &quot; Ry&quot; if node.restraints[1] else &quot; --&quot;,&#10;                &quot; Rz&quot; if node.restraints[2] else &quot; --&quot;&#10;            ])&#10;&#10;            result.append(f&quot;{node.uid:&lt;8} {x_display:&lt;15.4g} {y_display:&lt;15.4g} {restraint_str:&lt;15}&quot;)&#10;&#10;        # Member information&#10;        result.append(&quot;\nMEMBER INFORMATION:&quot;)&#10;        result.append(f&quot;{'Member ID':10} {'Type':8} {'i-node':8} {'j-node':8} {'Length (' + length_unit + ')':15}&quot;)&#10;        result.append(&quot;-&quot; * 80)&#10;&#10;        for member in sorted(self.members, key=lambda m: m.uid):  # type: ignore&#10;            # Convert length to display units&#10;            length_display = Q_(member.length, 'm').to(length_unit).magnitude if hasattr(Q_, 'to') else member.length&#10;&#10;            result.append(&#10;                f&quot;{member.uid:&lt;10} {member.type:&lt;8} {member.inode.uid:&lt;8} {member.jnode.uid:&lt;8} {length_display:&lt;15.4g}&quot;)&#10;&#10;        # Material properties&#10;        materials_seen = set()&#10;        result.append(&quot;\nMATERIAL PROPERTIES:&quot;)&#10;        result.append(f&quot;{'Material':10} {'E (' + pressure_unit + ')':15}&quot;)&#10;        result.append(&quot;-&quot; * 80)&#10;&#10;        for member in self.members:&#10;            if member.material not in materials_seen:&#10;                # Convert elastic modulus to display units&#10;                E_display = Q_(member.material.E, 'Pa').to(pressure_unit).magnitude if hasattr(Q_,&#10;                                                                                               'to') else member.material.E&#10;&#10;                result.append(f&quot;{member.material.uid:&lt;10} {E_display:&lt;15.4g}&quot;)&#10;                materials_seen.add(member.material)&#10;&#10;        # Section properties&#10;        sections_seen = set()&#10;        result.append(&quot;\nSECTION PROPERTIES:&quot;)&#10;        result.append(f&quot;{'Section':10} {'Area (' + length_unit + '^2)':18} {'Ixx (' + length_unit + '^4)':18}&quot;)&#10;        result.append(&quot;-&quot; * 80)&#10;&#10;        for member in self.members:&#10;            if member.section not in sections_seen:&#10;                # Convert section properties to display units&#10;                area_display = Q_(member.section.Area, 'm^2').to(length_unit + '^2').magnitude if hasattr(Q_,&#10;                                                                                                          'to') else member.section.Area&#10;                ixx_display = Q_(member.section.Ixx, 'm^4').to(length_unit + '^4').magnitude if hasattr(Q_,&#10;                                                                                                        'to') else member.section.Ixx&#10;&#10;                result.append(f&quot;{member.section.uid:&lt;10} {area_display:&lt;18.4g} {ixx_display:&lt;18.4g}&quot;)&#10;                sections_seen.add(member.section)&#10;&#10;        # Load information&#10;        has_node_loads = any(node.loads for node in self.nodes)&#10;        if has_node_loads:&#10;            result.append(&quot;\nNODAL LOADS:&quot;)&#10;            result.append(&#10;                f&quot;{'Node ID':8} {'Load Case':10} {'Fx (' + force_unit + ')':15} {'Fy (' + force_unit + ')':15} {'Mz (' + moment_unit + ')':15}&quot;)&#10;            result.append(&quot;-&quot; * 80)&#10;&#10;            for node in sorted(self.nodes, key=lambda n: n.uid):  # type: ignore&#10;                if node.loads:&#10;                    for case, load in node.loads.items():&#10;                        # Convert forces and moments to display units&#10;                        fx_display = Q_(load[0], 'N').to(force_unit).magnitude if hasattr(Q_, 'to') else load[0]&#10;                        fy_display = Q_(load[1], 'N').to(force_unit).magnitude if hasattr(Q_, 'to') else load[1]&#10;                        mz_display = Q_(load[2], 'N*m').to(moment_unit).magnitude if hasattr(Q_, 'to') else load[2]&#10;&#10;                        result.append(&#10;                            f&quot;{node.uid:&lt;8} {case:&lt;10} {fx_display:&lt;15.4g} {fy_display:&lt;15.4g} {mz_display:&lt;15.4g}&quot;)&#10;&#10;        # Displacements and reactions if calculated&#10;        has_displacements = any(hasattr(node, 'displacements') and node.displacements for node in self.nodes)&#10;        if has_displacements:&#10;            result.append(&quot;\nNODAL DISPLACEMENTS (most recent load combination):&quot;)&#10;            result.append(f&quot;{'Node ID':8} {'Ux (' + length_unit + ')':15} {'Uy (' + length_unit + ')':15} {'Rz (rad)':15}&quot;)&#10;            result.append(&quot;-&quot; * 80)&#10;&#10;            for node in sorted(self.nodes, key=lambda n: n.uid):  # type: ignore&#10;                if hasattr(node, 'displacements') and node.displacements:&#10;                    # Get the most recent load combination&#10;                    latest_combo = list(node.displacements.keys())[-1]&#10;                    disp = node.displacements[latest_combo]&#10;&#10;                    # Convert displacements to display units&#10;                    ux_display = Q_(disp[0], 'm').to(length_unit).magnitude&#10;                    uy_display = Q_(disp[1], 'm').to(length_unit).magnitude&#10;                    rz_display = Q_(disp[2], 'rad').to('rad').magnitude  # Radians are dimensionless in terms of conversion&#10;&#10;                    result.append(f&quot;{node.uid:&lt;8} {ux_display:&lt;15.6g} {uy_display:&lt;15.6g} {rz_display:&lt;15.6g}&quot;)&#10;&#10;        # Errors if any&#10;        if self._ERRORS:&#10;            result.append(&quot;\nERRORS:&quot;)&#10;            result.append(&quot;-&quot; * 80)&#10;            for error in self._ERRORS:&#10;                result.append(error)&#10;&#10;        # THIS IS THE KEY FIX - Return the joined result&#10;        return &quot;\n&quot;.join(result)&#10;&#10;&#10;    def export_results_to_excel(self, output_file, loadcombos=None, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Export structural analysis results to Excel format with multiple sheets including visualization&#10;&#10;        Parameters&#10;        ----------&#10;        output_file : str or Path&#10;            Path for the output Excel file&#10;        loadcombos : list of LoadCombo objects, optional&#10;            List of load combinations to include in the export (if None, uses all analyzed load combinations)&#10;        **kwargs : dict&#10;            Additional options:&#10;            - include_visualization : bool, default True&#10;                Whether to include structure visualization sheet&#10;            - unit_system : str, default None&#10;                The unit system to use (&quot;imperial&quot;, &quot;si&quot;, &quot;metric_kn&quot;)&#10;                If None, uses the current unit system from the model&#10;            - scaling : dict, optional&#10;                Scaling factors for visualization&#10;        &quot;&quot;&quot;&#10;        # Check for required packages&#10;        try:&#10;            import pandas as pd&#10;            import matplotlib.pyplot as plt&#10;            import numpy as np&#10;            import io&#10;            from pathlib import Path&#10;            from pint import UnitRegistry&#10;        except ImportError as e:&#10;            raise ImportError(f&quot;Required package not available for Excel export: {e}&quot;)&#10;&#10;        # Create unit registry for conversions&#10;        &#10;        Q_ = unit_manager.ureg.Quantity&#10;&#10;        # Process unit system&#10;        unit_system = kwargs.get('unit_system')&#10;        if unit_system:&#10;            # Import unit systems&#10;            from pyMAOS.pymaos_units import SI_UNITS, IMPERIAL_DISPLAY_UNITS, METRIC_KN_UNITS&#10;&#10;            # Use the specified unit system for display&#10;            if unit_system == &quot;imperial&quot;:&#10;                display_units = IMPERIAL_DISPLAY_UNITS&#10;                system_name = &quot;Imperial&quot;&#10;            elif unit_system == &quot;si&quot;:&#10;                display_units = SI_UNITS&#10;                system_name = &quot;SI&quot;&#10;            elif unit_system == &quot;metric_kn&quot;:&#10;                display_units = METRIC_KN_UNITS&#10;                system_name = &quot;Metric kN&quot;&#10;            else:&#10;                display_units = self.units&#10;                system_name = &quot;Current&quot;&#10;        else:&#10;            display_units = self.units&#10;            system_name = &quot;Current&quot;&#10;&#10;        print(f&quot;Using {system_name} units for Excel export&quot;)&#10;&#10;        # Utility function for unit conversion&#10;        def convert_value(value, from_unit, to_unit):&#10;            &quot;&quot;&quot;Convert a value from one unit to another&quot;&quot;&quot;&#10;            try:&#10;                # Handle special case for dimensionless units like radians&#10;                if to_unit in ['rad', 'radian', 'radians']:&#10;                    return value&#10;&#10;                # Convert using pint&#10;                return Q_(value, from_unit).to(to_unit).magnitude&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not convert {value} from {from_unit} to {to_unit}: {e}&quot;)&#10;                return value&#10;&#10;        # Resolve output file path&#10;        output_file = Path(output_file)&#10;&#10;        # Get list of all load combinations that have been analyzed&#10;        if loadcombos is None:&#10;            # Find all unique load combos that have results&#10;            all_combos = set()&#10;            for node in self.nodes:&#10;                if hasattr(node, 'displacements'):&#10;                    all_combos.update(node.displacements.keys())&#10;            from pyMAOS.loadcombos import LoadCombo&#10;            loadcombos = [LoadCombo(name, {name: 1.0}, [name], False, &quot;CUSTOM&quot;) for name in all_combos]&#10;&#10;        if not loadcombos:&#10;            raise ValueError(&quot;No load combinations specified and no analysis results found.&quot;)&#10;&#10;        # Extract options&#10;        include_visualization = kwargs.get('include_visualization', True)&#10;&#10;        print(f&quot;Exporting analysis results to {output_file}...&quot;)&#10;&#10;        # Create Excel writer&#10;        with pd.ExcelWriter(output_file, engine='xlsxwriter') as writer:&#10;            workbook = writer.book&#10;&#10;            # Create formats&#10;            try:&#10;                header_format = workbook.add_format({&#10;                    'bold': True,&#10;                    'text_wrap': True,&#10;                    'valign': 'top',&#10;                    'fg_color': '#D7E4BC',&#10;                    'border': 1&#10;                })&#10;            except AttributeError:&#10;                header_format = None&#10;&#10;            # 1. Summary sheet&#10;            summary_data = {&#10;                'Parameter': ['Number of Nodes', 'Number of Members', 'Degrees of Freedom',&#10;                              'Number of Restraints', 'Analysis Type'],&#10;                'Value': [self.NJ, self.NM, self.NDOF, self.NR, 'Linear Static']&#10;            }&#10;            # Add load combinations to summary&#10;            for i, combo in enumerate(loadcombos):&#10;                summary_data['Parameter'].append(f&quot;Load Combination {i + 1}&quot;)&#10;                summary_data['Value'].append(combo.name)&#10;&#10;            summary_df = pd.DataFrame(summary_data)&#10;            summary_df.to_excel(writer, sheet_name='Summary', index=False)&#10;&#10;            # 2. Structure visualization (if requested)&#10;            if include_visualization:&#10;                try:&#10;                    from structure2d_matplotlib import plot_structure_matplotlib&#10;&#10;                    # Use the existing plot function&#10;                    fig, ax = plot_structure_matplotlib(self.nodes, self.members)&#10;&#10;                    # Add visualization to Excel&#10;                    worksheet = workbook.add_worksheet('Structure Visualization')&#10;&#10;                    # Save the figure to a BytesIO object&#10;                    imgdata = io.BytesIO()&#10;                    fig.savefig(imgdata, format='png', dpi=150, bbox_inches='tight')&#10;                    imgdata.seek(0)&#10;&#10;                    # Insert the image into the worksheet&#10;                    worksheet.insert_image('A1', 'structure.png',&#10;                                           {'image_data': imgdata, 'x_scale': 0.8, 'y_scale': 0.8})&#10;&#10;                    # Close the matplotlib figure to free memory&#10;                    plt.close(fig)&#10;&#10;                except (ImportError, AttributeError) as e:&#10;                    print(f&quot;Warning: Could not create structure visualization: {e}&quot;)&#10;&#10;            # 3. Units sheet&#10;            units_data = []&#10;            for dimension, unit in display_units.items():&#10;                units_data.append({'Dimension': dimension, 'Unit': unit})&#10;            units_df = pd.DataFrame(units_data)&#10;            units_df.to_excel(writer, sheet_name='Units', index=False)&#10;&#10;            # Process each load combination&#10;            for combo in loadcombos:&#10;                combo_name = combo.name&#10;                sheet_name = f&quot;Results_{combo_name}&quot;[:31]  # Excel sheet name limit is 31 chars&#10;&#10;                # 4. Node information sheet for this load combination&#10;                nodes_data = []&#10;                for node in sorted(self.nodes, key=lambda n: n.uid):&#10;                    # Convert coordinates to display units&#10;                    x_display = convert_value(node.x, 'm', display_units['length'])&#10;                    y_display = convert_value(node.y, 'm', display_units['length'])&#10;&#10;                    node_info = {&#10;                        'Node ID': node.uid,&#10;                        f'X ({display_units[&quot;length&quot;]})': x_display,&#10;                        f'Y ({display_units[&quot;length&quot;]})': y_display,&#10;                        'Restrained X': node.restraints[0],&#10;                        'Restrained Y': node.restraints[1],&#10;                        'Restrained Z': node.restraints[2],&#10;                    }&#10;&#10;                    # Add displacements if available&#10;                    if hasattr(node, 'displacements') and combo_name in node.displacements:&#10;                        disp = node.displacements[combo_name]&#10;                        # Convert to display units&#10;                        disp_x = convert_value(disp[0], 'm', display_units['length'])&#10;                        disp_y = convert_value(disp[1], 'm', display_units['length'])&#10;                        rot_z = disp[2]  # Radians are dimensionless&#10;&#10;                        node_info.update({&#10;                            f'Displacement X ({display_units[&quot;length&quot;]})': disp_x,&#10;                            f'Displacement Y ({display_units[&quot;length&quot;]})': disp_y,&#10;                            'Rotation Z (rad)': rot_z,&#10;                        })&#10;                    else:&#10;                        node_info.update({&#10;                            f'Displacement X ({display_units[&quot;length&quot;]})': 0.0,&#10;                            f'Displacement Y ({display_units[&quot;length&quot;]})': 0.0,&#10;                            'Rotation Z (rad)': 0.0,&#10;                        })&#10;&#10;                    # Add reactions if available&#10;                    if hasattr(node, 'reactions') and combo_name in node.reactions:&#10;                        reaction = node.reactions[combo_name]&#10;                        # Convert to display units&#10;                        rx = convert_value(reaction[0], 'N', display_units['force'])&#10;                        ry = convert_value(reaction[1], 'N', display_units['force'])&#10;                        mz = convert_value(reaction[2], 'N*m', display_units['moment'])&#10;&#10;                        node_info.update({&#10;                            f'Reaction X ({display_units[&quot;force&quot;]})': rx,&#10;                            f'Reaction Y ({display_units[&quot;force&quot;]})': ry,&#10;                            f'Moment Z ({display_units[&quot;moment&quot;]})': mz,&#10;                        })&#10;                    else:&#10;                        node_info.update({&#10;                            f'Reaction X ({display_units[&quot;force&quot;]})': 0.0,&#10;                            f'Reaction Y ({display_units[&quot;force&quot;]})': 0.0,&#10;                            f'Moment Z ({display_units[&quot;moment&quot;]})': 0.0,&#10;                        })&#10;&#10;                    nodes_data.append(node_info)&#10;&#10;                nodes_df = pd.DataFrame(nodes_data)&#10;                nodes_df.to_excel(writer, sheet_name=sheet_name, index=False)&#10;&#10;                # 5. Member forces sheet for this load combination&#10;                forces_data = []&#10;                for member in sorted(self.members, key=lambda m: m.uid):&#10;                    # Calculate member forces for this load combination&#10;                    if hasattr(member, 'end_forces_global') and combo_name in member.end_forces_global:&#10;                        global_forces = member.end_forces_global[combo_name]&#10;                        # Ensure global_forces is 1D&#10;                        global_forces = np.asarray(global_forces).flatten()&#10;                    else:&#10;                        # Calculate forces if not already available&#10;                        try:&#10;                            global_forces = member.set_end_forces_global(combo)&#10;                            # Ensure global_forces is 1D&#10;                            global_forces = np.asarray(global_forces).flatten()&#10;                        except:&#10;                            global_forces = np.zeros(6)&#10;&#10;                    if hasattr(member, 'end_forces_local') and combo_name in member.end_forces_local:&#10;                        # Always flatten local_forces to ensure consistent 1D access&#10;                        local_forces = np.asarray(member.end_forces_local[combo_name]).flatten()&#10;                    else:&#10;                        try:&#10;                            member.Flocal(combo)&#10;                            # Always flatten the result to get a 1D array&#10;                            local_forces = np.asarray(member.end_forces_local[combo_name]).flatten()&#10;                        except:&#10;                            local_forces = np.zeros(6)&#10;&#10;                    # Convert forces to display units&#10;                    global_forces_display = [&#10;                        convert_value(global_forces[0], 'N', display_units['force']),&#10;                        convert_value(global_forces[1], 'N', display_units['force']),&#10;                        convert_value(global_forces[2], 'N*m', display_units['moment']),&#10;                        convert_value(global_forces[3], 'N', display_units['force']),&#10;                        convert_value(global_forces[4], 'N', display_units['force']),&#10;                        convert_value(global_forces[5], 'N*m', display_units['moment'])&#10;                    ]&#10;&#10;                    local_forces_display = [&#10;                        convert_value(local_forces[0], 'N', display_units['force']),&#10;                        convert_value(local_forces[1], 'N', display_units['force']),&#10;                        convert_value(local_forces[2], 'N*m', display_units['moment']),&#10;                        convert_value(local_forces[3], 'N', display_units['force']),&#10;                        convert_value(local_forces[4], 'N', display_units['force']),&#10;                        convert_value(local_forces[5], 'N*m', display_units['moment'])&#10;                    ]&#10;&#10;                    # i-node global forces&#10;                    forces_data.append({&#10;                        'Member ID': member.uid,&#10;                        'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;                        f'Fx ({display_units[&quot;force&quot;]})': global_forces_display[0],&#10;                        f'Fy ({display_units[&quot;force&quot;]})': global_forces_display[1],&#10;                        f'Mz ({display_units[&quot;moment&quot;]})': global_forces_display[2],&#10;                        'System': 'Global'&#10;                    })&#10;&#10;                    # j-node global forces&#10;                    forces_data.append({&#10;                        'Member ID': member.uid,&#10;                        'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;                        f'Fx ({display_units[&quot;force&quot;]})': global_forces_display[3],&#10;                        f'Fy ({display_units[&quot;force&quot;]})': global_forces_display[4],&#10;                        f'Mz ({display_units[&quot;moment&quot;]})': global_forces_display[5],&#10;                        'System': 'Global'&#10;                    })&#10;&#10;                    # i-node local forces&#10;                    forces_data.append({&#10;                        'Member ID': member.uid,&#10;                        'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;                        f'Fx ({display_units[&quot;force&quot;]})': local_forces_display[0],&#10;                        f'Fy ({display_units[&quot;force&quot;]})': local_forces_display[1],&#10;                        f'Mz ({display_units[&quot;moment&quot;]})': local_forces_display[2],&#10;                        'System': 'Local'&#10;                    })&#10;&#10;                    # j-node local forces&#10;                    forces_data.append({&#10;                        'Member ID': member.uid,&#10;                        'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;                        f'Fx ({display_units[&quot;force&quot;]})': local_forces_display[3],&#10;                        f'Fy ({display_units[&quot;force&quot;]})': local_forces_display[4],&#10;                        f'Mz ({display_units[&quot;moment&quot;]})': local_forces_display[5],&#10;                        'System': 'Local'&#10;                    })&#10;&#10;                # Write member forces to a separate sheet for this load combo&#10;                forces_df = pd.DataFrame(forces_data)&#10;                sheet_name = f&quot;Forces_{combo_name}&quot;[:31]  # Excel sheet name limit is 31 chars&#10;                forces_df.to_excel(writer, sheet_name=sheet_name, index=False)&#10;&#10;            # Add a member properties sheet (common to all load combos)&#10;            members_data = []&#10;            for member in sorted(self.members, key=lambda m: m.uid):&#10;                # Convert member properties to display units&#10;                length_display = convert_value(member.length, 'm', display_units['length'])&#10;                e_display = convert_value(member.material.E, 'Pa', display_units['pressure'])&#10;                area_display = convert_value(member.section.Area, 'm^2', f&quot;{display_units['length']}^2&quot;)&#10;                ixx_display = convert_value(member.section.Ixx, 'm^4', f&quot;{display_units['length']}^4&quot;)&#10;&#10;                member_info = {&#10;                    'Member ID': member.uid,&#10;                    'Type': member.type,&#10;                    'i-node': member.inode.uid,&#10;                    'j-node': member.jnode.uid,&#10;                    f'Length ({display_units[&quot;length&quot;]})': length_display,&#10;                    'Material ID': member.material.uid,&#10;                    f'E ({display_units[&quot;pressure&quot;]})': e_display,&#10;                    'Section ID': member.section.uid,&#10;                    f'Area ({display_units[&quot;length&quot;]})': area_display,&#10;                    f'Ixx ({display_units[&quot;length&quot;]})': ixx_display,&#10;                }&#10;&#10;                # Add hinge information if it's a frame&#10;                if hasattr(member, 'hinges'):&#10;                    hinge_info = []&#10;                    if member.hinges[0]:&#10;                        hinge_info.append('i-node')&#10;                    if member.hinges[1]:&#10;                        hinge_info.append('j-node')&#10;                    member_info['Hinges'] = ', '.join(hinge_info) if hinge_info else 'None'&#10;&#10;                members_data.append(member_info)&#10;&#10;            members_df = pd.DataFrame(members_data)&#10;            members_df.to_excel(writer, sheet_name='Member Properties', index=False)&#10;&#10;        print(f&quot;Successfully exported results to {output_file}&quot;)&#10;        return str(output_file)&#10;&#10;    def verify_structure_state(self, state_data):&#10;        &quot;&quot;&quot;&#10;        Verify that the loaded structure state is complete and consistent.&#10;        Checks if KU = F-P equation is satisfied.&#10;&#10;        Parameters&#10;        ----------&#10;        state_data : dict&#10;            Dictionary containing the loaded structure state&#10;&#10;        Returns&#10;        -------&#10;        bool&#10;            True if verification passes, False otherwise&#10;        &quot;&quot;&quot;&#10;        print(&quot;Verifying structure state completeness and consistency...&quot;)&#10;&#10;        # 1. Check if all essential components are present&#10;        # essential_keys = ['nodes', 'members', 'U', 'KSTRUCT', 'FG', 'structure_fef']&#10;        # missing_keys = [key for key in essential_keys if key not in state_data]&#10;        # if missing_keys:&#10;        #     print(f&quot;ERROR: Missing essential data: {missing_keys}&quot;)&#10;        #     return False&#10;&#10;        # 2. Check stiffness equation KU = F-P for free DOFs&#10;        if all(hasattr(self, attr) for attr in ['Kff', 'U', 'FGf', 'PFf']):&#10;            try:&#10;                # Convert quantities to numerical values for calculation&#10;                from pyMAOS.quantity_utils import numpy_array_of_quantity_to_numpy_array_of_float64&#10;                import numpy as np&#10;&#10;                # Extract magnitudes for calculation&#10;                Kff_mag = numpy_array_of_quantity_to_numpy_array_of_float64(self.Kff)&#10;                U_mag = numpy_array_of_quantity_to_numpy_array_of_float64(self.U)&#10;                FGf_mag = numpy_array_of_quantity_to_numpy_array_of_float64(self.FGf)&#10;                PFf_mag = numpy_array_of_quantity_to_numpy_array_of_float64(self.PFf)&#10;&#10;                # Calculate left and right sides of equation&#10;                KU = np.matmul(Kff_mag, U_mag)&#10;                F_minus_P = FGf_mag - PFf_mag&#10;&#10;                # Calculate residual and relative error&#10;                residual = KU - F_minus_P&#10;                error_norm = np.linalg.norm(residual)&#10;                rel_error = error_norm / np.linalg.norm(F_minus_P) if np.linalg.norm(F_minus_P) &gt; 1e-10 else error_norm&#10;&#10;                print(f&quot;Stiffness equation verification:&quot;)&#10;                print(f&quot;  Norm of KU:   {np.linalg.norm(KU):.6e}&quot;)&#10;                print(f&quot;  Norm of F-P:   {np.linalg.norm(F_minus_P):.6e}&quot;)&#10;                print(f&quot;  Residual norm: {error_norm:.6e}&quot;)&#10;                print(f&quot;  Relative error: {rel_error:.6e}&quot;)&#10;&#10;                # Check if error is acceptably small (adjust tolerance as needed)&#10;                if rel_error &gt; 1e-6:&#10;                    print(&quot;WARNING: Relative error in stiffness equation exceeds tolerance&quot;)&#10;                    return False&#10;&#10;                print(&quot; Stiffness equation verified successfully&quot;)&#10;&#10;            except Exception as e:&#10;                print(f&quot;ERROR during verification: {e}&quot;)&#10;                import traceback&#10;                traceback.print_exc()&#10;                return False&#10;        else:&#10;            print(&quot;WARNING: Cannot verify stiffness equation - missing required data&quot;)&#10;&#10;        # 3. Check node equilibrium by verifying reactions match applied loads + member forces&#10;        # (This would require gathering all member end forces for each node)&#10;&#10;        print(&quot;Structure state verification completed&quot;)&#10;        return True&#10;&#10;    def save_structure_state(self, filename):&#10;        &quot;&quot;&quot;&#10;        Save the entire structure object to a binary file in one operation.&#10;&#10;        Parameters&#10;        ----------&#10;        filename : str&#10;            Path to the binary output file&#10;&#10;        Returns&#10;        -------&#10;        bool&#10;            True if saving was successful, False otherwise&#10;        &quot;&quot;&quot;&#10;        import pickle&#10;        import zlib&#10;&#10;        print(f&quot;Saving complete structure state to {filename}...&quot;)&#10;&#10;        try:&#10;            # Pickle the entire object&#10;            pickled_data = pickle.dumps(self)&#10;&#10;            # Compress the pickled data&#10;            compressed_data = zlib.compress(pickled_data)&#10;&#10;            # Write compressed data to file&#10;            with open(filename, 'wb') as file:&#10;                file.write(compressed_data)&#10;&#10;            print(f&quot;Structure state saved successfully ({len(compressed_data):,} bytes compressed, {len(pickled_data):,} bytes uncompressed)&quot;)&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error saving structure state: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            return False&#10;&#10;&#10;&#10;def load_structure_state(filename):&#10;    &quot;&quot;&quot;&#10;    Load structure state from a binary file.&#10;&#10;    Parameters&#10;    ----------&#10;    filename : str&#10;        Path to binary file containing structure state&#10;&#10;    Returns&#10;    -------&#10;    R2Structure&#10;        Structure object with all quantities using the global registry&#10;    &quot;&quot;&quot;&#10;    import pickle&#10;    import pyMAOS&#10;    import zlib&#10;    import io&#10;    from pyMAOS.quantity_utils import convert_all_quantities&#10;&#10;    # Debug info&#10;    print(f&quot;Loading structure state from: {filename}&quot;)&#10;    print(f&quot;Using global unit registry with id: {id(pyMAOS.unit_manager.ureg)}&quot;)&#10;    &#10;    # Custom unpickler that converts quantities to the global registry during load&#10;    class QuantityUnpickler(pickle.Unpickler):&#10;        def find_class(self, module, name):&#10;            # Get the standard class&#10;            cls = super().find_class(module, name)&#10;            &#10;            # If it's a Quantity class, return our conversion wrapper&#10;            if module == 'pint.quantity' and name == 'Quantity':&#10;                # Create a wrapper that converts registry on unpickling&#10;                def quantity_factory(*args, **kwargs):&#10;                    # Standard creation&#10;                    obj = cls(*args, **kwargs)&#10;                    &#10;                    # If it's using a different registry, convert it&#10;                    if obj._REGISTRY is not pyMAOS.unit_manager.ureg:&#10;                        print(f&quot;Converting quantity {obj} from registry {id(obj._REGISTRY)} to global registry&quot;)&#10;                        obj = pyMAOS.unit_manager.ureg.Quantity(obj.magnitude, str(obj.units))&#10;                    &#10;                    return obj&#10;                &#10;                return quantity_factory&#10;            return cls&#10;&#10;    # Load structure from file&#10;    try:&#10;        with open(filename, 'rb') as f:&#10;            # Read compressed data&#10;            compressed_data = f.read()&#10;            &#10;            # Decompress data&#10;            try:&#10;                pickled_data = zlib.decompress(compressed_data)&#10;                # Use custom unpickler that converts quantities during load&#10;                unpickler = QuantityUnpickler(io.BytesIO(pickled_data))&#10;                structure = unpickler.load()&#10;                print(f&quot;Successfully loaded compressed binary file ({len(compressed_data):,} bytes compressed)&quot;)&#10;            except zlib.error:&#10;                # If decompression fails, try direct unpickling (for backward compatibility)&#10;                print(&quot;File appears to be uncompressed, trying direct unpickling...&quot;)&#10;                f.seek(0)  # Reset file pointer to beginning&#10;                # Use custom unpickler for uncompressed data too&#10;                unpickler = QuantityUnpickler(f)&#10;                structure = unpickler.load()&#10;                print(&quot;Successfully loaded uncompressed pickle file&quot;)&#10;&#10;        # Add registry ID to structure for future reference&#10;        structure.registry_id = id(pyMAOS.unit_manager.ureg)&#10;        &#10;        # Double-check for any quantities that weren't converted during unpickling&#10;        # This is a safety measure in case some quantities were stored in a way &#10;        # that bypassed our custom unpickler&#10;        structure = convert_all_quantities(structure, pyMAOS.unit_manager.ureg)&#10;&#10;        return structure&#10;    &#10;    except Exception as e:&#10;        print(f&quot;Error loading structure state from {filename}: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;        raise ValueError(f&quot;Failed to load structure state: {e}&quot;)&#10;&#10;def save_structure_state(self, filename):&#10;    &quot;&quot;&quot;&#10;    Save structure state to a binary file.&#10;&#10;    Parameters&#10;    ----------&#10;    filename : str&#10;        Path to binary file where structure state will be saved&#10;    &quot;&quot;&quot;&#10;    import pickle&#10;    import pyMAOS&#10;&#10;    # Store the registry ID for future reference&#10;    self.registry_id = id(pyMAOS.unit_manager.ureg)&#10;&#10;    try:&#10;        with open(filename, 'wb') as f:&#10;            pickle.dump(self, f)&#10;        print(f&quot;Structure state saved to {filename}&quot;)&#10;        print(f&quot;Registry ID stored: {self.registry_id}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error saving structure state to {filename}: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;" />
              <option name="updatedContent" value="import os&#10;import sys&#10;&#10;import numpy as np&#10;import pyMAOS&#10;from pyMAOS import unit_manager&#10;from pyMAOS.pymaos_units import array_convert_to_unit_system&#10;&#10;np.set_printoptions(precision=4, suppress=False, floatmode='maxprec_equal', linewidth=999)&#10;&#10;import operator&#10;&#10;&#10;# # Add custom formatters with explicit type signatures&#10;def format_with_dots(x) -&gt; str:&#10;    return '.'.center(12) if abs(x) &lt; 1e-10 else f&quot;{x:12.4g}&quot;&#10;&#10;&#10;def format_double(x) -&gt; str:&#10;    return '.'.center(13) if abs(x) &lt; 1e-10 else f&quot;{x:13.8g}&quot;  # More precision for doubles&#10;&#10;&#10;# Now use these type-annotated functions in the formatter dictionary&#10;np.set_printoptions(precision=4,&#10;                    suppress=False,&#10;                    formatter={&#10;                        'float': format_with_dots,  # For float32 and generic floats&#10;                        'float_kind': format_with_dots,  # For all floating point types&#10;                        'float64': format_double  # Specifically for float64 (double precision)&#10;                    },  # type: ignore&#10;                    linewidth=120  # Wider output to prevent unnecessary wrapping&#10;                    )&#10;&#10;&#10;# Parameters you can adjust:&#10;# *&#9;precision: Number of decimal places (4 is a good default)&#10;# *&#9;suppress: When True, very small values near zero are displayed as 0&#10;# *&#9;floatmode: Controls the display format&#10;# *&#9;'maxprec_equal': Best option for automatic switching between formats&#10;# *&#9;'fixed': Always use fixed-point notation&#10;# *&#9;'scientific': Always use scientific notation&#10;# *&#9;'unique': Use minimum digits to distinguish values&#10;&#10;class R2Structure:&#10;    def __init__(self, nodes, members, units=None):&#10;        self.nodes = nodes&#10;        self.members = members&#10;        self.units = units or pyMAOS.unit_manager.get_current_units()  # Use unit manager as fallback&#10;&#10;        # Validate node UIDs are unique&#10;        self._validate_node_uids()&#10;&#10;        # Validate member UIDs are unique&#10;        self._validate_member_uids()&#10;&#10;        self.create_uid_maps()  # Replace create_uid_map() with the new method&#10;&#10;        # Validate that all member nodes exist in the node list&#10;        for member in members:&#10;            if member.inode.uid not in self.uid_to_index:&#10;                raise ValueError(&#10;                    f&quot;Member {member.uid} references node {member.inode.uid} which doesn't exist in the structure&quot;)&#10;            if member.jnode.uid not in self.uid_to_index:&#10;                raise ValueError(&#10;                    f&quot;Member {member.uid} references node {member.jnode.uid} which doesn't exist in the structure&quot;)&#10;&#10;        # Rest of initialization remains the same...&#10;        self.members = members&#10;&#10;        # Structure Type&#10;        # 2D Structure&#10;&#10;&#10;        # Number of Joints&#10;        self.NJ = len(self.nodes)&#10;&#10;        # Number of Members&#10;        self.NM = len(self.members)&#10;&#10;        # Number of Restraints&#10;        self.NR = sum([sum(node.restraints) for node in self.nodes])&#10;&#10;        # Degrees of Freedom&#10;        self.DIM=sum([node.NJD for node in self.nodes])&#10;        self.NDOF = self.DIM - self.NR&#10;&#10;        # Data Stores&#10;        self._springNodes = None&#10;        self._nonlinearNodes = None&#10;        self._D = {}  # Structure Displacement Vector Dictionary&#10;        self.U=[]&#10;        # Flags&#10;        self._unstable = False&#10;        self._Kgenerated = False&#10;        self._ERRORS = []&#10;&#10;        # Register members with the structure for unit access&#10;        for member in self.members:&#10;            if hasattr(member, 'set_structure'):&#10;                member.set_structure(self)&#10;&#10;    def set_node_uids(self):&#10;        i = 1&#10;&#10;        for node in self.nodes:&#10;            node.uid = i&#10;            i += 1&#10;&#10;    def set_member_uids(self):&#10;        i = 1&#10;&#10;        for member in self.members:&#10;            member.uid = i&#10;            i += 1&#10;&#10;    def _validate_node_uids(self):&#10;        &quot;&quot;&quot;&#10;        Validate that all node UIDs in the structure are unique.&#10;        Raises ValueError if duplicate UIDs are found.&#10;        &quot;&quot;&quot;&#10;        uids = [node.uid for node in self.nodes]&#10;        duplicates = set([uid for uid in uids if uids.count(uid) &gt; 1])&#10;&#10;        if duplicates:&#10;            duplicate_str = &quot;, &quot;.join(str(uid) for uid in duplicates)&#10;            raise ValueError(f&quot;Duplicate node UIDs found: {duplicate_str}&quot;)&#10;&#10;    def _validate_member_uids(self):&#10;        &quot;&quot;&quot;&#10;        Validate that all member UIDs in the structure are unique.&#10;        Raises ValueError if duplicate UIDs are found.&#10;        &quot;&quot;&quot;&#10;        uids = [member.uid for member in self.members]&#10;        duplicates = set([uid for uid in uids if uids.count(uid) &gt; 1])&#10;&#10;        if duplicates:&#10;            duplicate_str = &quot;, &quot;.join(str(uid) for uid in duplicates)&#10;            raise ValueError(f&quot;Duplicate member UIDs found: {duplicate_str}&quot;)&#10;&#10;    def spring_nodes(self):&#10;        # loop through nodes and create a list of the nodes with springs&#10;        # assigned to a DOF.&#10;        springNodes = []&#10;        nonlinearNodes = []&#10;        for node in self.nodes:&#10;            if node._isSpring is True:&#10;                springNodes.append(node)&#10;&#10;            if node._isNonLinear is True:&#10;                nonlinearNodes.append(node)&#10;&#10;        if springNodes:&#10;            self._springNodes = springNodes&#10;&#10;        if nonlinearNodes:&#10;            self._nonlinearNodes = nonlinearNodes&#10;&#10;    def create_uid_map(self):&#10;        &quot;&quot;&quot;Create a mapping from UIDs to positions&quot;&quot;&quot;&#10;        self.uid_to_index = {node.uid: i for i, node in enumerate(self.nodes)}&#10;&#10;    def create_uid_maps(self):&#10;        &quot;&quot;&quot;Create mappings between UIDs and positions (in both directions)&quot;&quot;&quot;&#10;        # Map from UID to position index&#10;        self.uid_to_index = {node.uid: i for i, node in enumerate(self.nodes)}&#10;&#10;        # Map from position index to UID&#10;        self.index_to_uid = {i: node.uid for i, node in enumerate(self.nodes)}&#10;&#10;    def set_freedom_map(self):&#10;        # Freedom Map&#10;        self.FM = np.zeros(self.DIM, dtype=np.int32)  # Ensure FM is initialized as an integer array&#10;&#10;        # Loop through the nodes mapping free and restrained joint displacements to&#10;        # the Freedom Map (FM). This will facilitate generating the global stiffness&#10;        # matrix in partitioned form.&#10;&#10;        j = 0  # starting index for the first free displacement&#10;        k = self.NDOF  # starting index for the first restraint&#10;&#10;        for node_index, node in enumerate(self.nodes):&#10;            for r, restraint in enumerate(node.restraints):&#10;                fmindex = node_index * node.NJD + r&#10;&#10;                if restraint == 0:&#10;                    self.FM[fmindex] = j&#10;                    j += 1&#10;                else:&#10;                    self.FM[fmindex] = k&#10;                    k += 1&#10;&#10;        return self.FM.astype(np.int32)&#10;&#10;    def get_freedom_map(self):&#10;        return self.FM.astype(np.int32)  # Ensure FM is returned as an integer array&#10;&#10;    def Kstructure(self, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Build the structure stiffness matrix organized into paritioned form&#10;        using the freedom map to reposition nodal DOFs&#10;&#10;        Returns&#10;        -------&#10;        KSTRUCT: Numpy Matrix&#10;            Structure Stiffness Matrix.&#10;&#10;        &quot;&quot;&quot;&#10;        verbose = kwargs.get('verbose', False)&#10;        output_dir = kwargs.get('output_dir', '.')&#10;        if not os.path.exists(output_dir):&#10;            os.makedirs(output_dir)&#10;&#10;        # Structure Stiffness Matrix&#10;        KSTRUCT = np.zeros([self.DIM, self.DIM], dtype=object)&#10;        print(&quot;KSTRUCT shape:&quot;, KSTRUCT.shape, flush=True)&#10;&#10;        for member in self.members:&#10;            # Freedom map for i and j nodes&#10;            inode=member.inode&#10;            imap = [int(self.FM[(self.uid_to_index[inode.uid]) * inode.NJD + r]) for r in range(inode.NJD)]&#10;            jnode=member.jnode&#10;            imap.extend([int(self.FM[(self.uid_to_index[jnode.uid]) * jnode.NJD + r]) for r in range(jnode.NJD)])&#10;            print(f&quot;Freedom Map Indices for Member {member.uid}:\n{imap}&quot;, flush=True)&#10;&#10;            # Member global stiffness matrix&#10;            kmglobal = member.kglobal()&#10;            print(f&quot;Member {member.uid}:\tkmglobal (Internal Units)\n{kmglobal}\n&quot;, flush=True)&#10;&#10;            # Check if the member is a truss&#10;            if member.type == &quot;TRUSS&quot;:&#10;                # For truss elements, verify that all bending/shear terms are zero&#10;                bending_terms = [&#10;                    kmglobal[2, 2],  # i-node bending terms&#10;                    kmglobal[5, 5]  # j-node bending terms&#10;                ]&#10;&#10;                # Check if any of these terms are non-zero&#10;                if not all(abs(term) &lt; 1e-10 for term in bending_terms):&#10;                    non_zero_terms = [f&quot;[{i}]={val}&quot; for i, val in enumerate(bending_terms) if abs(val) &gt; 1e-10]&#10;                    error_msg = (f&quot;Error: Member {member.uid} is a TRUSS but has non-zero bending terms: &quot;&#10;                                 f&quot;{', '.join(non_zero_terms)}. Truss elements must have zero bending stiffness.&quot;)&#10;                    print(error_msg)&#10;                    raise ValueError(error_msg)&#10;&#10;            # Save each member's global stiffness matrix to a separate CSV file&#10;            filename = os.path.join(output_dir, f'member_{member.uid}_global_stiffness_SI.csv')&#10;            np.savetxt(filename, kmglobal, delimiter=',', fmt='%g')&#10;            print(f&quot;Saved member {member.uid} global stiffness matrix to {filename}&quot;, flush=True)&#10;&#10;            self.NJD=3 # temporary fix&#10;            for i in range(self.NJD):&#10;                for j in range(self.NJD):&#10;                    # print(f&quot;i: {i}, j: {j}, imap[i]: {imap[i]}, imap[j]: {imap[j]}&quot;, flush=True)&#10;                    # Get current values at the target positions&#10;                    pos_ii = (imap[i], imap[j])&#10;                    pos_ji = (imap[i + self.NJD], imap[j])&#10;                    pos_ij = (imap[i], imap[j + self.NJD])&#10;                    pos_jj = (imap[i + self.NJD], imap[j + self.NJD])&#10;&#10;                    # Get source values to add&#10;                    val_ii = kmglobal[i, j]&#10;                    val_ji = kmglobal[i + self.NJD, j]&#10;                    val_ij = kmglobal[i, j + self.NJD]&#10;                    val_jj = kmglobal[i + self.NJD, j + self.NJD]&#10;&#10;                    from pyMAOS.quantity_utils import increment_with_units&#10;                    # Use increment_with_units to add values with unit checking&#10;                    print(f&quot;DEBUG: Adding to KSTRUCT at {pos_ii}: {val_ii}&quot;)&#10;                    KSTRUCT[pos_ii] = increment_with_units(KSTRUCT[pos_ii], val_ii)&#10;&#10;                    print(f&quot;DEBUG: Adding to KSTRUCT at {pos_ji}: {val_ji}&quot;)&#10;                    KSTRUCT[pos_ji] = increment_with_units(KSTRUCT[pos_ji], val_ji)&#10;&#10;                    print(f&quot;DEBUG: Adding to KSTRUCT at {pos_ij}: {val_ij}&quot;)&#10;                    KSTRUCT[pos_ij] = increment_with_units(KSTRUCT[pos_ij], val_ij)&#10;&#10;                    print(f&quot;DEBUG: Adding to KSTRUCT at {pos_jj}: {val_jj}&quot;)&#10;                    KSTRUCT[pos_jj] = increment_with_units(KSTRUCT[pos_jj], val_jj)&#10;&#10;&#10;        # Loop through Spring Nodes and add the spring stiffness&#10;        if self._springNodes:&#10;            for node in self._springNodes:&#10;                node_index = self.uid_to_index[node.uid]&#10;                uxposition = int(FM[(node_index) * self.NJD + 0])&#10;                uyposition = int(FM[(node_index) * self.NJD + 1])&#10;                rzposition = int(FM[(node_index) * self.NJD + 2])&#10;                kux = node._spring_stiffness[0]&#10;                kuy = node._spring_stiffness[1]&#10;                krz = node._spring_stiffness[2]&#10;&#10;                # KSTRUCT[uxposition, uxposition] += kux&#10;                # KSTRUCT[uyposition, uyposition] += kuy&#10;                # KSTRUCT[rzposition, rzposition] += krz&#10;&#10;                KSTRUCT.incremental_add_with_units((uxposition, uxposition), kux)&#10;                KSTRUCT.incremental_add_with_units((uyposition, uyposition), kuy)&#10;                KSTRUCT.incremental_add_with_units((rzposition, rzposition), krz)&#10;        self._Kgenerated = True&#10;&#10;        if verbose:&#10;            np.set_printoptions(precision=4,&#10;                                suppress=False,&#10;                                formatter={&#10;                                    'float': format_with_dots,  # For float32 and generic floats&#10;                                    'float_kind': format_with_dots,  # For all floating point types&#10;                                    'float64': format_double  # Specifically for float64 (double precision)&#10;                                },  # type: ignore&#10;                                linewidth=120  # Wider output to prevent unnecessary wrapping&#10;                                )&#10;            print(&quot;KSTRUCT:&quot;, KSTRUCT, sep=&quot;\n&quot;);&#10;            print(KSTRUCT.shape);&#10;            from pyMAOS.quantity_utils import print_units_matrix&#10;            print_units_matrix(KSTRUCT)&#10;&#10;            KSTRUCT_csv = os.path.join(output_dir, 'KSTRUCT.csv')&#10;            np.savetxt(KSTRUCT_csv, KSTRUCT, delimiter=',', fmt='%lg')&#10;            print(f&quot;Saved KSTRUCT to {KSTRUCT_csv}&quot;)&#10;&#10;        return KSTRUCT&#10;&#10;&#10;    def nodal_force_vector(self, FM, load_combination):&#10;        &quot;&quot;&quot;&#10;        Build the structure nodal force vector mapped to the same partitions&#10;        as KSTRUCT using the freedom map (FM).&#10;&#10;        Returns&#10;        -------&#10;        FG : ndarray&#10;            Structure Nodal Force Vector with proper units.&#10;        &quot;&quot;&quot;&#10;        # from pyMAOS.units_mod import INTERNAL_FORCE_UNIT, INTERNAL_MOMENT_UNIT&#10;        # zero_force=unit_manager.get_zero_quantity(INTERNAL_FORCE_UNIT)&#10;        # zero_moment= unit_manager.get_zero_quantity(INTERNAL_MOMENT_UNIT)&#10;&#10;        FG = np.zeros(self.NJD * self.NJ, dtype=object)&#10;&#10;        print(f&quot;DEBUG: Initialized FG as QuantityArray, shape={FG.shape}&quot;)&#10;&#10;        # Apply loads from each node&#10;        for node_index, node in enumerate(self.nodes):&#10;            for load_case, load in node.loads.items():&#10;                # Display load information for debugging&#10;                from pyMAOS.display_utils import display_node_load_vector_in_units&#10;                display_node_load_vector_in_units(&#10;                    load_vector=load,&#10;                    node_uid=node.uid,&#10;                    force_unit=self.units.get('force', 'N'),&#10;                    length_unit=self.units.get('length', 'm'),&#10;                    load_combo_name=load_combination.name&#10;                )&#10;&#10;                load_factor = load_combination.factors.get(load_case, 0)&#10;&#10;                # Use list comprehension for pint quantities&#10;                factored_load = [load_factor * f for f in load]&#10;                print(f&quot;DEBUG: Node {node.uid}, load_case={load_case}, factor={load_factor}, factored_load={factored_load}&quot;)&#10;&#10;                for i, f in enumerate(factored_load):&#10;                    fm_index = node_index * self.NJD + i&#10;                    mapped_index = int(self.FM[fm_index])  # Ensure integer index&#10;&#10;                    # Add load component using QuantityArray's add_with_units method&#10;                    FG.incremental_add_with_units((mapped_index,), f)&#10;                    print(f&quot;DEBUG: Added {f} at position {mapped_index}&quot;)&#10;&#10;        print(&quot;Nodal Force Vector:&quot;, sep=&quot;\n&quot;)&#10;        from pyMAOS.pymaos_units import array_convert_to_unit_system&#10;        _ = array_convert_to_unit_system(FG, &quot;imperial&quot;)&#10;&#10;        return FG&#10;&#10;&#10;&#10;    def assemble_fixed_end_force(self, load_combination):&#10;        # Initialize array with object dtype to store Quantity objects&#10;        structure_fef = np.zeros(self.NJD * self.NJ, dtype='object')&#10;&#10;        print(f&quot;DEBUG: Initial PF dtype = {structure_fef.dtype}&quot;)&#10;&#10;        for member in self.members:&#10;            if member.type != &quot;TRUSS&quot;:&#10;                # Get fixed end forces in global coordinates&#10;                elem_fef_global = member.FEFglobal(load_combination)&#10;                # print(&quot;DEBUG: Ff type:&quot;, type(Ff), &quot;shape:&quot;, np.shape(Ff))&#10;                from pyMAOS.pymaos_units import array_convert_to_unit_system;&#10;                # print(f&quot;Member {member.uid} fixed end forces before conversion: {Ff.view(QuantityArray)}&quot;)&#10;                _ = array_convert_to_unit_system(elem_fef_global, &quot;imperial&quot;)&#10;&#10;                i_index = self.uid_to_index[member.inode.uid]&#10;                j_index = self.uid_to_index[member.jnode.uid]&#10;&#10;                # Debug info about the returned forces&#10;                # print(f&quot;DEBUG: Member {member.uid} forces type: {type(Ff)} shape: {np.shape(Ff)}&quot;)&#10;                # print(f&quot;DEBUG: First element type: {type(Ff[0])}&quot;)&#10;&#10;                # Add the forces directly - with object dtype, this should work with Quantity objects&#10;                imap = self.FM[i_index * self.NJD:(i_index + 1) * self.NJD]&#10;                print(f&quot;DEBUG: imap for i_index {i_index}: {imap}&quot;)&#10;                from pyMAOS.quantity_utils import increment_with_units&#10;                # structure_fef[imap] += Ff[0:self.NJD]&#10;                print(elem_fef_global[0:self.NJD])&#10;                structure_fef[imap]= increment_with_units(structure_fef[imap], elem_fef_global[0:self.NJD])&#10;                # target_indices = self.FM[j_index * self.NJD:(j_index + 1) * self.NJD]&#10;                # source_values = Ff[self.NJD:2 * self.NJD]&#10;                #&#10;                # # Loop through each index and use increment_with_units&#10;                # for i, idx in enumerate(target_indices):&#10;                #     structure_fef[idx] = increment_with_units(structure_fef[idx], source_values[i])&#10;&#10;                # Check units consistency after addition&#10;                # sample_idx = FM[i_index * self.NJD]&#10;                # print(f&quot;DEBUG: structure_fef[{sample_idx}] type after addition: {type(structure_fef[sample_idx])}&quot;)&#10;&#10;        from pyMAOS.quantity_utils import print_units_matrix&#10;&#10;        print(f&quot;Member {member.uid} Fixed End Force Vector PF:&quot;)&#10;        print_units_matrix(structure_fef)&#10;&#10;        # At the end, you can extract magnitudes if needed for further calculations&#10;        # PF_magnitudes = np.array([f.magnitude if hasattr(f, 'magnitude') else f for f in structure_fef])&#10;        # print(f&quot;DEBUG: Final PF_magnitudes dtype = {PF_magnitudes.dtype}&quot;)&#10;        self.structure_fef = structure_fef&#10;        print(&quot;Structure Fixed End Force Vector structure_fef:&quot;, structure_fef, sep=&quot;\n&quot;)&#10;        print(&quot;Put back in order by code numers:&quot;, structure_fef[self.FM], sep=&quot;\n&quot;)&#10;        return structure_fef&#10;&#10;&#10;    def solve_linear_static(self, load_combination, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Perform a linear static solution of the model using the Kff&#10;        and FGf paritions&#10;&#10;        Returns&#10;        -------&#10;        TYPE&#10;            DESCRIPTION.&#10;&#10;        &quot;&quot;&quot;&#10;        # Extract arguments from kwargs&#10;        verbose = kwargs.get('verbose', False)&#10;        # if verbose:&#10;        #     print(&quot;--- Running in Verbose Mode ---&quot;)&#10;        structure_state_bin = kwargs.get(&quot;structure_state_bin&quot;, None)&#10;&#10;        # Generate Freedom Map&#10;        self.FM = self.set_freedom_map(); print(&quot;Freedom Map:&quot;, self.FM, sep=&quot;\n&quot;)&#10;&#10;        # Generate Full Structure Stiffness Matrix&#10;        self.KSTRUCT = self.Kstructure(**kwargs)&#10;&#10;        self._verify_stable(self.FM, self.KSTRUCT)&#10;&#10;        if self._unstable:&#10;            raise ValueError(&quot;Structure is unstable&quot;);&#10;            sys.exit(1)&#10;&#10;        # Build Nodal Force Vector&#10;        self.FG = self.nodal_force_vector(self.FM, load_combination)&#10;        # print(&quot;Nodal Force Vector FG:\n&quot;, self.FG); print(self.FG.shape)&#10;        from pyMAOS.pymaos_units import array_convert_to_unit_system; print(&quot;Structure nodal global forces&quot;)&#10;        _ = array_convert_to_unit_system(self.FG, &quot;imperial&quot;)&#10;        # Build Member Fixed-end-Force vector&#10;        self.structure_fef = self.assemble_fixed_end_force(load_combination)&#10;        # print(&quot;Structure Fixed End Force Vector:\n&quot;, structure_fef); print(structure_fef.shape)&#10;&#10;        from pymaos_units import array_convert_to_unit_system; print(&quot;Structure Fixed-end Forces&quot;)&#10;        _ = array_convert_to_unit_system(self.structure_fef, &quot;imperial&quot;)&#10;&#10;        self.Kff = self.KSTRUCT[0: self.NDOF, 0: self.NDOF]; print(&quot;Kff Partition:&quot;, self.Kff, sep=&quot;\n&quot;);&#10;        print(self.Kff.shape)  # display_stiffness_matrix_in_units(self.Kff)&#10;        # Slice out the FGf partition from the global nodal force vector&#10;        self.FGf = self.FG[0: self.NDOF];  print(&quot;FGf Partition:&quot;, self.FGf, sep=&quot;\n&quot;);&#10;        print(self.FGf.shape);  _ = array_convert_to_unit_system(self.FGf, &quot;imperial&quot;)&#10;        self.PFf = self.structure_fef[0: self.NDOF]&#10;        print(&quot;PFf Partition:&quot;, self.PFf, sep=&quot;\n&quot;);&#10;        print(self.PFf.shape)&#10;        from pyMAOS.quantity_utils import numpy_array_of_quantity_to_numpy_array_of_float64&#10;        # Extract magnitudes for calculation&#10;        Kff_magnitudes = numpy_array_of_quantity_to_numpy_array_of_float64(self.Kff)&#10;        print(&quot;Kff_magnitudes:&quot;, Kff_magnitudes, sep=&quot;\n&quot;)&#10;        # FGf_magnitudes = np.array([f.magnitude if hasattr(f, 'magnitude') else float(f) for f in self.FGf],&#10;        #                           dtype=np.float64)&#10;        # print(&quot;FGf_magnitudes:&quot;, FGf_magnitudes, sep=&quot;\n&quot;)&#10;        # PFf_magnitudes = np.array([p.magnitude if hasattr(p, 'magnitude') else float(p) for p in self.PFf],&#10;        #                           dtype=np.float64);&#10;        # print(PFf_magnitudes)&#10;        # print(f&quot;DEBUG: Kff_magnitudes shape: {Kff_magnitudes.shape}&quot;)&#10;        # print(f&quot;DEBUG: FGf_magnitudes shape: {FGf_magnitudes.shape}&quot;)&#10;        # print(f&quot;DEBUG: PFf_magnitudes shape: {PFf_magnitudes.shape}&quot;)&#10;        # Check if the Kff partition is singular&#10;        if np.linalg.cond(Kff_magnitudes) &gt; 1.0 / np.finfo(np.float64).eps:&#10;            print(&quot;WARNING: Kff partition is singular or nearly singular. The system may not have a unique solution.&quot;)&#10;            self._unstable = True&#10;            return None&#10;        # If we have units, we need to handle them carefully&#10;        # Use scipy.linalg.solve to solve the linear system&#10;        # This will return the displacement vector U in the same units as the right-hand side&#10;        # If the right-hand side is a Pint Quantity, we need to extract the magnitudes&#10;        # and reattach the units to the result.&#10;        # If the right-hand side is a numpy array, we can use it directly.&#10;        # Check if we're working with Pint Quantity objects&#10;        import scipy.linalg as sla&#10;&#10;        if hasattr(self.FGf[0], 'magnitude') or hasattr(self.PFf[0], 'magnitude') or True:&#10;&#10;            # Store units from the right-hand side for later&#10;            # Extract original units from the right-hand side&#10;            rhs = self.FGf - self.PFf; print(rhs)&#10;            _ = array_convert_to_unit_system(rhs, &quot;imperial&quot;)&#10;&#10;&#10;&#10;            # Convert to numpy array of Quantity objects&#10;            from pyMAOS.quantity_utils import numpy_array_of_quantity_to_numpy_array_of_float64&#10;            rhs_quantities = numpy_array_of_quantity_to_numpy_array_of_float64(rhs)&#10;            print(f&quot;DEBUG: Converted to array of Quantities with shape {rhs_quantities.shape}&quot;)&#10;&#10;            # Solve using scipy.linalg&#10;            U_magnitudes = sla.solve(Kff_magnitudes, rhs_quantities)&#10;            from pyMAOS.quantity_utils import extract_units_from_quantities&#10;            rhs_units = extract_units_from_quantities(rhs)&#10;            print(f&quot;DEBUG: Right-hand side units: {rhs_units}&quot;)&#10;            # Example usage of the units array&#10;            # for idx, unit in np.ndenumerate(rhs_units):&#10;            #     if unit is not None:&#10;            #         print(f&quot;Element at {idx} has unit: {unit}&quot;)&#10;            # Define and immediately apply the lambda function for each unit&#10;            conjugate_units_container_list = [(lambda u: unit_manager.ureg.UnitsContainer(&#10;                {'[length]': 2, '[mass]': 1, '[time]': -2}) / u.dimensionality)(u)&#10;                               for u in rhs_units]&#10;            # Create quantities with value 1.0 and the container units&#10;            quantities = [unit_manager.ureg.Quantity(1.0, container) for container in conjugate_units_container_list]&#10;            print(f&quot;DEBUG: Created {len(quantities)} quantities from containers&quot;)&#10;&#10;            # Convert to imperial system&#10;            imperial_quantities = array_convert_to_unit_system(quantities, &quot;imperial&quot;)&#10;            print(f&quot;DEBUG: Converted to imperial: {imperial_quantities}&quot;)&#10;&#10;            # Extract just the units&#10;            imperial_units = [q.units for q in imperial_quantities]&#10;            print(f&quot;DEBUG: Extracted units: {imperial_units}&quot;)&#10;&#10;            print(f&quot;DEBUG: Converted {rhs_units} to conjugate unit(s): {conjugate_units_container_list}&quot;)&#10;&#10;            # Reattach conjugate units to displacement results&#10;            self.U = np.array([pyMAOS.unit_manager.ureg.Quantity(mag, conj_unit)&#10;                               for mag, conj_unit in zip(U_magnitudes, conjugate_units_container_list)], dtype=object)&#10;&#10;            print(f&quot;DEBUG: Reattached conjugate units to displacement vector: {self.U}&quot;)&#10;&#10;        else:&#10;            # No units involved, use scipy.linalg directly&#10;            print(&quot;DEBUG: Using scipy.linalg directly (no units)&quot;)&#10;            self.U = sla.solve(self.Kff, self.FGf - self.PFf)&#10;        print(self.U)&#10;        return self.U&#10;&#10;    def set_node_displacements(self, load_combination=None):&#10;        # Later, to restart from saved state:&#10;        # if self.load_structure_state(&quot;structure_state.bin&quot;):&#10;        #     print(&quot;Successfully restored structure state - ready to continue analysis&quot;)&#10;        # else:&#10;        #     print(&quot;Failed to load state - need to recalculate&quot;)&#10;&#10;        print(&quot;Structure displacement U:&quot;, self.U, sep=&quot;\n&quot;)#; print(self.U.shape)&#10;&#10;        # Full Displacement Vector&#10;        # Result is still mapped to DOF via FM&#10;        # Create USTRUCT as an object array to hold Quantity objects&#10;        # Create USTRUCT as self.U padded with zeros up to self.NJD * self.NJ elements&#10;        USTRUCT = np.zeros(self.DIM, dtype=object)&#10;&#10;        # Copy values from self.U to the beginning of padded_array&#10;        USTRUCT[:len(self.U)] = self.U&#10;&#10;        # Debug information&#10;        print( f&quot;DEBUG: Created USTRUCT by padding self.U ({len(self.U)} elements) to full size ({self.DIM} elements)&quot;)&#10;&#10;        print(&quot;USTRUCT&quot;)&#10;        _ = array_convert_to_unit_system(USTRUCT, &quot;imperial&quot;)&#10;        # store displacement results to the current case to the nodes&#10;        for node in self.nodes:&#10;            node_index = self.uid_to_index[node.uid]&#10;            keys = self.FM[node_index * node.NJD: (node_index + 1) * self.NJD]&#10;            node_displacements = USTRUCT[keys]&#10;&#10;            print(f&quot;node {node.uid}    Ux: {node_displacements[0]:.4E} -- Uy: {node_displacements[1]:.4E} -- Rz: {node_displacements[2]:.4E}&quot;)&#10;            # print(f&quot;DEBUG: Node {node.uid} displacements with units: {node_displacements}&quot;);&#10;&#10;            node.displacements[load_combination.name] = node_displacements&#10;&#10;        return&#10;&#10;&#10;    def compute_reactions(self, load_combination):&#10;        &quot;&quot;&quot;Calculate nodal reactions for the given load combination&quot;&quot;&quot;&#10;        for node in self.nodes:&#10;            node_index = self.uid_to_index[node.uid]&#10;            # Initialize reactions vector [rx, ry, mz]&#10;            # reactions = np.zeros(self.NJD)&#10;            #&#10;            # # Add contributions from nodal loads (with negative sign)&#10;            # for load_case, load in node.loads.items():&#10;            #     load_factor = load_combination.factors.get(load_case, 0)&#10;            #     reactions -= np.array(load) * load_factor&#10;            #&#10;            # # Add contributions from member end forces&#10;            # for member in self.members:&#10;            #     member_FG = member.set_end_forces_global(load_combination)&#10;            #     print(f&quot;Member {member.uid} Fixed End Forces:\n{member_FG}&quot;)&#10;            #     # Add forces from i-node if this node is the i-node&#10;            #     if member.inode == node:&#10;            #         # Debug shapes when encountering errors&#10;            #         reactions += member_FG[0:self.NJD]  # Use reshape(-1) to ensure correct shape&#10;            #&#10;            #     # Add forces from j-node if this node is the j-node&#10;            #     if member.jnode == node:&#10;            #         reactions += member_FG[self.NJD:(2 * self.NJD)]&#10;            #&#10;            # # Override with spring reactions if applicable&#10;            # u = node.displacements.get(load_combination.name, np.zeros(self.NJD))&#10;            # for i in range(self.NJD):&#10;            #     if node._spring_stiffness[i] &gt; 0:&#10;            #         reactions[i] = -1 * u[i] * node._spring_stiffness[i]&#10;            #&#10;            # # Store reactions and print summary&#10;            # node.reactions[load_combination.name] = reactions.tolist()&#10;            node.compute_reactions(load_combination)&#10;&#10;&#10;    def _verify_stable(self, FM, KSTRUCT):&#10;        &quot;&quot;&quot;&#10;        Check the diagonal terms of the stiffness matrix against support&#10;        conditions. If diagonal term is 0 and the node is unsupported for&#10;        that DOF then the Kmatrix is singular and unstable.&#10;&#10;        Returns&#10;        -------&#10;        If unstable returns a dictionary of unstable nodes&#10;        and degree of freedom marked unstable.&#10;&#10;        &quot;&quot;&quot;&#10;&#10;        unstablenodes = []&#10;&#10;        for node_index, node in enumerate(self.nodes):&#10;            # Check each DOF of node:&#10;            for i, dof in enumerate(node.restraints):&#10;                fmindex = node_index * self.NJD + i&#10;                val = FM[fmindex]&#10;&#10;                # value the diagonal position in the stiffness matrix&#10;                kval = KSTRUCT[int(val), int(val)]&#10;&#10;                if kval == 0 and dof != 1:&#10;                    self._unstable = True&#10;                    unstablenodes.append(&#10;                        f&quot;Node {node.uid} : Unstable for {node.restraints_key[i]}&quot;&#10;                    )&#10;        # add unstable messages to ERROR list&#10;        self._ERRORS.extend(unstablenodes)&#10;&#10;        return unstablenodes&#10;&#10;&#10;    def plot_loadcombos_vtk(self, loadcombos=None, scaling=None):&#10;        &quot;&quot;&quot;Visualizes the structure with results from multiple load combinations using VTK.&quot;&quot;&quot;&#10;        try:&#10;            # Import the plotting function from R2Structure_extras&#10;            from pyMAOS.structure2d_extras import plot_loadcombos_vtk, check_vtk_available&#10;&#10;            # Check if VTK is available&#10;            if not check_vtk_available():&#10;                print(&quot;Warning: VTK library is not installed. Please install VTK for visualization.&quot;)&#10;                return&#10;&#10;            # Call the imported function with self as first argument&#10;            plot_loadcombos_vtk(self, loadcombos, scaling)&#10;        except ImportError as e:&#10;            print(f&quot;Warning: Visualization module not found: {e}&quot;)&#10;            print(&quot;Make sure structure2d_extras.py is in the pyMAOS package directory.&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error during visualization: {e}&quot;)&#10;&#10;&#10;    def get_summary(self):&#10;        &quot;&quot;&quot;&#10;        Returns a string representation of the structure using the display units&#10;        specified in the input file.&#10;        &quot;&quot;&quot;&#10;        # Access the global unit variables (defined elsewhere in the program)&#10;        # import sys&#10;        # from inspect import currentframe, getouterframes&#10;        # module = sys.modules[__name__]&#10;&#10;        # Attempt to get unit info from module scope&#10;        # Use units from self.units dictionary with appropriate defaults&#10;        force_unit = self.units.get('force', 'N')&#10;        length_unit = self.units.get('length', 'm')&#10;        pressure_unit = self.units.get('pressure', 'Pa')&#10;        moment_unit = self.units.get('moment', f&quot;{force_unit}*{length_unit}&quot;)&#10;        distributed_load_unit = self.units.get('distributed_load', f&quot;{force_unit}/{length_unit}&quot;)&#10;&#10;        # Create a ureg for conversions if not already available&#10;        try:&#10;            from pyMAOS.pymaos_units import ureg&#10;            Q_ = ureg.Quantity&#10;        except:&#10;            # Fall back if pint is not available&#10;            print(&quot;Warning: pint library not available, using SI units for display&quot;)&#10;            Q_ = lambda x, unit: x&#10;&#10;        # Build the output string&#10;        result = []&#10;        result.append(&quot;=&quot; * 80)&#10;        result.append(f&quot;STRUCTURAL MODEL SUMMARY&quot;)&#10;        result.append(f&quot;Display units: Force={force_unit}, Length={length_unit}, Pressure={pressure_unit}&quot;)&#10;        result.append(&quot;-&quot; * 80)&#10;&#10;        # Basic structure info&#10;        result.append(f&quot;Number of nodes: {self.NJ}&quot;)&#10;        result.append(f&quot;Number of members: {self.NM}&quot;)&#10;        result.append(f&quot;Degrees of freedom: {self.NDOF}&quot;)&#10;        result.append(f&quot;Number of restraints: {self.NR}&quot;)&#10;&#10;        # Node information&#10;        result.append(&quot;\nNODE INFORMATION:&quot;)&#10;        result.append(f&quot;{'Node ID':8} {'X (' + length_unit + ')':15} {'Y (' + length_unit + ')':15} {'Restraints':15}&quot;)&#10;        result.append(&quot;-&quot; * 80)&#10;&#10;        for node in sorted(self.nodes, key=operator.attrgetter('uid')):&#10;            # Convert coordinates to display units&#10;            x_display = Q_(node.x, 'm').to(length_unit).magnitude if hasattr(Q_, 'to') else node.x&#10;            y_display = Q_(node.y, 'm').to(length_unit).magnitude if hasattr(Q_, 'to') else node.y&#10;&#10;            # Format restraints&#10;            restraint_str = &quot;&quot;.join([&#10;                &quot;Rx&quot; if node.restraints[0] else &quot;--&quot;,&#10;                &quot; Ry&quot; if node.restraints[1] else &quot; --&quot;,&#10;                &quot; Rz&quot; if node.restraints[2] else &quot; --&quot;&#10;            ])&#10;&#10;            result.append(f&quot;{node.uid:&lt;8} {x_display:&lt;15.4g} {y_display:&lt;15.4g} {restraint_str:&lt;15}&quot;)&#10;&#10;        # Member information&#10;        result.append(&quot;\nMEMBER INFORMATION:&quot;)&#10;        result.append(f&quot;{'Member ID':10} {'Type':8} {'i-node':8} {'j-node':8} {'Length (' + length_unit + ')':15}&quot;)&#10;        result.append(&quot;-&quot; * 80)&#10;&#10;        for member in sorted(self.members, key=lambda m: m.uid):  # type: ignore&#10;            # Convert length to display units&#10;            length_display = Q_(member.length, 'm').to(length_unit).magnitude if hasattr(Q_, 'to') else member.length&#10;&#10;            result.append(&#10;                f&quot;{member.uid:&lt;10} {member.type:&lt;8} {member.inode.uid:&lt;8} {member.jnode.uid:&lt;8} {length_display:&lt;15.4g}&quot;)&#10;&#10;        # Material properties&#10;        materials_seen = set()&#10;        result.append(&quot;\nMATERIAL PROPERTIES:&quot;)&#10;        result.append(f&quot;{'Material':10} {'E (' + pressure_unit + ')':15}&quot;)&#10;        result.append(&quot;-&quot; * 80)&#10;&#10;        for member in self.members:&#10;            if member.material not in materials_seen:&#10;                # Convert elastic modulus to display units&#10;                E_display = Q_(member.material.E, 'Pa').to(pressure_unit).magnitude if hasattr(Q_,&#10;                                                                                               'to') else member.material.E&#10;&#10;                result.append(f&quot;{member.material.uid:&lt;10} {E_display:&lt;15.4g}&quot;)&#10;                materials_seen.add(member.material)&#10;&#10;        # Section properties&#10;        sections_seen = set()&#10;        result.append(&quot;\nSECTION PROPERTIES:&quot;)&#10;        result.append(f&quot;{'Section':10} {'Area (' + length_unit + '^2)':18} {'Ixx (' + length_unit + '^4)':18}&quot;)&#10;        result.append(&quot;-&quot; * 80)&#10;&#10;        for member in self.members:&#10;            if member.section not in sections_seen:&#10;                # Convert section properties to display units&#10;                area_display = Q_(member.section.Area, 'm^2').to(length_unit + '^2').magnitude if hasattr(Q_,&#10;                                                                                                          'to') else member.section.Area&#10;                ixx_display = Q_(member.section.Ixx, 'm^4').to(length_unit + '^4').magnitude if hasattr(Q_,&#10;                                                                                                        'to') else member.section.Ixx&#10;&#10;                result.append(f&quot;{member.section.uid:&lt;10} {area_display:&lt;18.4g} {ixx_display:&lt;18.4g}&quot;)&#10;                sections_seen.add(member.section)&#10;&#10;        # Load information&#10;        has_node_loads = any(node.loads for node in self.nodes)&#10;        if has_node_loads:&#10;            result.append(&quot;\nNODAL LOADS:&quot;)&#10;            result.append(&#10;                f&quot;{'Node ID':8} {'Load Case':10} {'Fx (' + force_unit + ')':15} {'Fy (' + force_unit + ')':15} {'Mz (' + moment_unit + ')':15}&quot;)&#10;            result.append(&quot;-&quot; * 80)&#10;&#10;            for node in sorted(self.nodes, key=lambda n: n.uid):  # type: ignore&#10;                if node.loads:&#10;                    for case, load in node.loads.items():&#10;                        # Convert forces and moments to display units&#10;                        fx_display = Q_(load[0], 'N').to(force_unit).magnitude if hasattr(Q_, 'to') else load[0]&#10;                        fy_display = Q_(load[1], 'N').to(force_unit).magnitude if hasattr(Q_, 'to') else load[1]&#10;                        mz_display = Q_(load[2], 'N*m').to(moment_unit).magnitude if hasattr(Q_, 'to') else load[2]&#10;&#10;                        result.append(&#10;                            f&quot;{node.uid:&lt;8} {case:&lt;10} {fx_display:&lt;15.4g} {fy_display:&lt;15.4g} {mz_display:&lt;15.4g}&quot;)&#10;&#10;        # Displacements and reactions if calculated&#10;        has_displacements = any(hasattr(node, 'displacements') and node.displacements for node in self.nodes)&#10;        if has_displacements:&#10;            result.append(&quot;\nNODAL DISPLACEMENTS (most recent load combination):&quot;)&#10;            result.append(f&quot;{'Node ID':8} {'Ux (' + length_unit + ')':15} {'Uy (' + length_unit + ')':15} {'Rz (rad)':15}&quot;)&#10;            result.append(&quot;-&quot; * 80)&#10;&#10;            for node in sorted(self.nodes, key=lambda n: n.uid):  # type: ignore&#10;                if hasattr(node, 'displacements') and node.displacements:&#10;                    # Get the most recent load combination&#10;                    latest_combo = list(node.displacements.keys())[-1]&#10;                    disp = node.displacements[latest_combo]&#10;&#10;                    # Convert displacements to display units&#10;                    ux_display = Q_(disp[0], 'm').to(length_unit).magnitude&#10;                    uy_display = Q_(disp[1], 'm').to(length_unit).magnitude&#10;                    rz_display = Q_(disp[2], 'rad').to('rad').magnitude  # Radians are dimensionless in terms of conversion&#10;&#10;                    result.append(f&quot;{node.uid:&lt;8} {ux_display:&lt;15.6g} {uy_display:&lt;15.6g} {rz_display:&lt;15.6g}&quot;)&#10;&#10;        # Errors if any&#10;        if self._ERRORS:&#10;            result.append(&quot;\nERRORS:&quot;)&#10;            result.append(&quot;-&quot; * 80)&#10;            for error in self._ERRORS:&#10;                result.append(error)&#10;&#10;        # THIS IS THE KEY FIX - Return the joined result&#10;        return &quot;\n&quot;.join(result)&#10;&#10;&#10;    def export_results_to_excel(self, output_file, loadcombos=None, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Export structural analysis results to Excel format with multiple sheets including visualization&#10;&#10;        Parameters&#10;        ----------&#10;        output_file : str or Path&#10;            Path for the output Excel file&#10;        loadcombos : list of LoadCombo objects, optional&#10;            List of load combinations to include in the export (if None, uses all analyzed load combinations)&#10;        **kwargs : dict&#10;            Additional options:&#10;            - include_visualization : bool, default True&#10;                Whether to include structure visualization sheet&#10;            - unit_system : str, default None&#10;                The unit system to use (&quot;imperial&quot;, &quot;si&quot;, &quot;metric_kn&quot;)&#10;                If None, uses the current unit system from the model&#10;            - scaling : dict, optional&#10;                Scaling factors for visualization&#10;        &quot;&quot;&quot;&#10;        # Check for required packages&#10;        try:&#10;            import pandas as pd&#10;            import matplotlib.pyplot as plt&#10;            import numpy as np&#10;            import io&#10;            from pathlib import Path&#10;            from pint import UnitRegistry&#10;        except ImportError as e:&#10;            raise ImportError(f&quot;Required package not available for Excel export: {e}&quot;)&#10;&#10;        # Create unit registry for conversions&#10;        &#10;        Q_ = unit_manager.ureg.Quantity&#10;&#10;        # Process unit system&#10;        unit_system = kwargs.get('unit_system')&#10;        if unit_system:&#10;            # Import unit systems&#10;            from pyMAOS.pymaos_units import SI_UNITS, IMPERIAL_DISPLAY_UNITS, METRIC_KN_UNITS&#10;&#10;            # Use the specified unit system for display&#10;            if unit_system == &quot;imperial&quot;:&#10;                display_units = IMPERIAL_DISPLAY_UNITS&#10;                system_name = &quot;Imperial&quot;&#10;            elif unit_system == &quot;si&quot;:&#10;                display_units = SI_UNITS&#10;                system_name = &quot;SI&quot;&#10;            elif unit_system == &quot;metric_kn&quot;:&#10;                display_units = METRIC_KN_UNITS&#10;                system_name = &quot;Metric kN&quot;&#10;            else:&#10;                display_units = self.units&#10;                system_name = &quot;Current&quot;&#10;        else:&#10;            display_units = self.units&#10;            system_name = &quot;Current&quot;&#10;&#10;        print(f&quot;Using {system_name} units for Excel export&quot;)&#10;&#10;        # Utility function for unit conversion&#10;        def convert_value(value, from_unit, to_unit):&#10;            &quot;&quot;&quot;Convert a value from one unit to another&quot;&quot;&quot;&#10;            try:&#10;                # Handle special case for dimensionless units like radians&#10;                if to_unit in ['rad', 'radian', 'radians']:&#10;                    return value&#10;&#10;                # Convert using pint&#10;                return Q_(value, from_unit).to(to_unit).magnitude&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not convert {value} from {from_unit} to {to_unit}: {e}&quot;)&#10;                return value&#10;&#10;        # Resolve output file path&#10;        output_file = Path(output_file)&#10;&#10;        # Get list of all load combinations that have been analyzed&#10;        if loadcombos is None:&#10;            # Find all unique load combos that have results&#10;            all_combos = set()&#10;            for node in self.nodes:&#10;                if hasattr(node, 'displacements'):&#10;                    all_combos.update(node.displacements.keys())&#10;            from pyMAOS.loadcombos import LoadCombo&#10;            loadcombos = [LoadCombo(name, {name: 1.0}, [name], False, &quot;CUSTOM&quot;) for name in all_combos]&#10;&#10;        if not loadcombos:&#10;            raise ValueError(&quot;No load combinations specified and no analysis results found.&quot;)&#10;&#10;        # Extract options&#10;        include_visualization = kwargs.get('include_visualization', True)&#10;&#10;        print(f&quot;Exporting analysis results to {output_file}...&quot;)&#10;&#10;        # Create Excel writer&#10;        with pd.ExcelWriter(output_file, engine='xlsxwriter') as writer:&#10;            workbook = writer.book&#10;&#10;            # Create formats&#10;            try:&#10;                header_format = workbook.add_format({&#10;                    'bold': True,&#10;                    'text_wrap': True,&#10;                    'valign': 'top',&#10;                    'fg_color': '#D7E4BC',&#10;                    'border': 1&#10;                })&#10;            except AttributeError:&#10;                header_format = None&#10;&#10;            # 1. Summary sheet&#10;            summary_data = {&#10;                'Parameter': ['Number of Nodes', 'Number of Members', 'Degrees of Freedom',&#10;                              'Number of Restraints', 'Analysis Type'],&#10;                'Value': [self.NJ, self.NM, self.NDOF, self.NR, 'Linear Static']&#10;            }&#10;            # Add load combinations to summary&#10;            for i, combo in enumerate(loadcombos):&#10;                summary_data['Parameter'].append(f&quot;Load Combination {i + 1}&quot;)&#10;                summary_data['Value'].append(combo.name)&#10;&#10;            summary_df = pd.DataFrame(summary_data)&#10;            summary_df.to_excel(writer, sheet_name='Summary', index=False)&#10;&#10;            # 2. Structure visualization (if requested)&#10;            if include_visualization:&#10;                try:&#10;                    from structure2d_matplotlib import plot_structure_matplotlib&#10;&#10;                    # Use the existing plot function&#10;                    fig, ax = plot_structure_matplotlib(self.nodes, self.members)&#10;&#10;                    # Add visualization to Excel&#10;                    worksheet = workbook.add_worksheet('Structure Visualization')&#10;&#10;                    # Save the figure to a BytesIO object&#10;                    imgdata = io.BytesIO()&#10;                    fig.savefig(imgdata, format='png', dpi=150, bbox_inches='tight')&#10;                    imgdata.seek(0)&#10;&#10;                    # Insert the image into the worksheet&#10;                    worksheet.insert_image('A1', 'structure.png',&#10;                                           {'image_data': imgdata, 'x_scale': 0.8, 'y_scale': 0.8})&#10;&#10;                    # Close the matplotlib figure to free memory&#10;                    plt.close(fig)&#10;&#10;                except (ImportError, AttributeError) as e:&#10;                    print(f&quot;Warning: Could not create structure visualization: {e}&quot;)&#10;&#10;            # 3. Units sheet&#10;            units_data = []&#10;            for dimension, unit in display_units.items():&#10;                units_data.append({'Dimension': dimension, 'Unit': unit})&#10;            units_df = pd.DataFrame(units_data)&#10;            units_df.to_excel(writer, sheet_name='Units', index=False)&#10;&#10;            # Process each load combination&#10;            for combo in loadcombos:&#10;                combo_name = combo.name&#10;                sheet_name = f&quot;Results_{combo_name}&quot;[:31]  # Excel sheet name limit is 31 chars&#10;&#10;                # 4. Node information sheet for this load combination&#10;                nodes_data = []&#10;                for node in sorted(self.nodes, key=lambda n: n.uid):&#10;                    # Convert coordinates to display units&#10;                    x_display = convert_value(node.x, 'm', display_units['length'])&#10;                    y_display = convert_value(node.y, 'm', display_units['length'])&#10;&#10;                    node_info = {&#10;                        'Node ID': node.uid,&#10;                        f'X ({display_units[&quot;length&quot;]})': x_display,&#10;                        f'Y ({display_units[&quot;length&quot;]})': y_display,&#10;                        'Restrained X': node.restraints[0],&#10;                        'Restrained Y': node.restraints[1],&#10;                        'Restrained Z': node.restraints[2],&#10;                    }&#10;&#10;                    # Add displacements if available&#10;                    if hasattr(node, 'displacements') and combo_name in node.displacements:&#10;                        disp = node.displacements[combo_name]&#10;                        # Convert to display units&#10;                        disp_x = convert_value(disp[0], 'm', display_units['length'])&#10;                        disp_y = convert_value(disp[1], 'm', display_units['length'])&#10;                        rot_z = disp[2]  # Radians are dimensionless&#10;&#10;                        node_info.update({&#10;                            f'Displacement X ({display_units[&quot;length&quot;]})': disp_x,&#10;                            f'Displacement Y ({display_units[&quot;length&quot;]})': disp_y,&#10;                            'Rotation Z (rad)': rot_z,&#10;                        })&#10;                    else:&#10;                        node_info.update({&#10;                            f'Displacement X ({display_units[&quot;length&quot;]})': 0.0,&#10;                            f'Displacement Y ({display_units[&quot;length&quot;]})': 0.0,&#10;                            'Rotation Z (rad)': 0.0,&#10;                        })&#10;&#10;                    # Add reactions if available&#10;                    if hasattr(node, 'reactions') and combo_name in node.reactions:&#10;                        reaction = node.reactions[combo_name]&#10;                        # Convert to display units&#10;                        rx = convert_value(reaction[0], 'N', display_units['force'])&#10;                        ry = convert_value(reaction[1], 'N', display_units['force'])&#10;                        mz = convert_value(reaction[2], 'N*m', display_units['moment'])&#10;&#10;                        node_info.update({&#10;                            f'Reaction X ({display_units[&quot;force&quot;]})': rx,&#10;                            f'Reaction Y ({display_units[&quot;force&quot;]})': ry,&#10;                            f'Moment Z ({display_units[&quot;moment&quot;]})': mz,&#10;                        })&#10;                    else:&#10;                        node_info.update({&#10;                            f'Reaction X ({display_units[&quot;force&quot;]})': 0.0,&#10;                            f'Reaction Y ({display_units[&quot;force&quot;]})': 0.0,&#10;                            f'Moment Z ({display_units[&quot;moment&quot;]})': 0.0,&#10;                        })&#10;&#10;                    nodes_data.append(node_info)&#10;&#10;                nodes_df = pd.DataFrame(nodes_data)&#10;                nodes_df.to_excel(writer, sheet_name=sheet_name, index=False)&#10;&#10;                # 5. Member forces sheet for this load combination&#10;                forces_data = []&#10;                for member in sorted(self.members, key=lambda m: m.uid):&#10;                    # Calculate member forces for this load combination&#10;                    if hasattr(member, 'end_forces_global') and combo_name in member.end_forces_global:&#10;                        global_forces = member.end_forces_global[combo_name]&#10;                        # Ensure global_forces is 1D&#10;                        global_forces = np.asarray(global_forces).flatten()&#10;                    else:&#10;                        # Calculate forces if not already available&#10;                        try:&#10;                            global_forces = member.set_end_forces_global(combo)&#10;                            # Ensure global_forces is 1D&#10;                            global_forces = np.asarray(global_forces).flatten()&#10;                        except:&#10;                            global_forces = np.zeros(6)&#10;&#10;                    if hasattr(member, 'end_forces_local') and combo_name in member.end_forces_local:&#10;                        # Always flatten local_forces to ensure consistent 1D access&#10;                        local_forces = np.asarray(member.end_forces_local[combo_name]).flatten()&#10;                    else:&#10;                        try:&#10;                            member.Flocal(combo)&#10;                            # Always flatten the result to get a 1D array&#10;                            local_forces = np.asarray(member.end_forces_local[combo_name]).flatten()&#10;                        except:&#10;                            local_forces = np.zeros(6)&#10;&#10;                    # Convert forces to display units&#10;                    global_forces_display = [&#10;                        convert_value(global_forces[0], 'N', display_units['force']),&#10;                        convert_value(global_forces[1], 'N', display_units['force']),&#10;                        convert_value(global_forces[2], 'N*m', display_units['moment']),&#10;                        convert_value(global_forces[3], 'N', display_units['force']),&#10;                        convert_value(global_forces[4], 'N', display_units['force']),&#10;                        convert_value(global_forces[5], 'N*m', display_units['moment'])&#10;                    ]&#10;&#10;                    local_forces_display = [&#10;                        convert_value(local_forces[0], 'N', display_units['force']),&#10;                        convert_value(local_forces[1], 'N', display_units['force']),&#10;                        convert_value(local_forces[2], 'N*m', display_units['moment']),&#10;                        convert_value(local_forces[3], 'N', display_units['force']),&#10;                        convert_value(local_forces[4], 'N', display_units['force']),&#10;                        convert_value(local_forces[5], 'N*m', display_units['moment'])&#10;                    ]&#10;&#10;                    # i-node global forces&#10;                    forces_data.append({&#10;                        'Member ID': member.uid,&#10;                        'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;                        f'Fx ({display_units[&quot;force&quot;]})': global_forces_display[0],&#10;                        f'Fy ({display_units[&quot;force&quot;]})': global_forces_display[1],&#10;                        f'Mz ({display_units[&quot;moment&quot;]})': global_forces_display[2],&#10;                        'System': 'Global'&#10;                    })&#10;&#10;                    # j-node global forces&#10;                    forces_data.append({&#10;                        'Member ID': member.uid,&#10;                        'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;                        f'Fx ({display_units[&quot;force&quot;]})': global_forces_display[3],&#10;                        f'Fy ({display_units[&quot;force&quot;]})': global_forces_display[4],&#10;                        f'Mz ({display_units[&quot;moment&quot;]})': global_forces_display[5],&#10;                        'System': 'Global'&#10;                    })&#10;&#10;                    # i-node local forces&#10;                    forces_data.append({&#10;                        'Member ID': member.uid,&#10;                        'Node': f&quot;{member.inode.uid} (i)&quot;,&#10;                        f'Fx ({display_units[&quot;force&quot;]})': local_forces_display[0],&#10;                        f'Fy ({display_units[&quot;force&quot;]})': local_forces_display[1],&#10;                        f'Mz ({display_units[&quot;moment&quot;]})': local_forces_display[2],&#10;                        'System': 'Local'&#10;                    })&#10;&#10;                    # j-node local forces&#10;                    forces_data.append({&#10;                        'Member ID': member.uid,&#10;                        'Node': f&quot;{member.jnode.uid} (j)&quot;,&#10;                        f'Fx ({display_units[&quot;force&quot;]})': local_forces_display[3],&#10;                        f'Fy ({display_units[&quot;force&quot;]})': local_forces_display[4],&#10;                        f'Mz ({display_units[&quot;moment&quot;]})': local_forces_display[5],&#10;                        'System': 'Local'&#10;                    })&#10;&#10;                # Write member forces to a separate sheet for this load combo&#10;                forces_df = pd.DataFrame(forces_data)&#10;                sheet_name = f&quot;Forces_{combo_name}&quot;[:31]  # Excel sheet name limit is 31 chars&#10;                forces_df.to_excel(writer, sheet_name=sheet_name, index=False)&#10;&#10;            # Add a member properties sheet (common to all load combos)&#10;            members_data = []&#10;            for member in sorted(self.members, key=lambda m: m.uid):&#10;                # Convert member properties to display units&#10;                length_display = convert_value(member.length, 'm', display_units['length'])&#10;                e_display = convert_value(member.material.E, 'Pa', display_units['pressure'])&#10;                area_display = convert_value(member.section.Area, 'm^2', f&quot;{display_units['length']}^2&quot;)&#10;                ixx_display = convert_value(member.section.Ixx, 'm^4', f&quot;{display_units['length']}^4&quot;)&#10;&#10;                member_info = {&#10;                    'Member ID': member.uid,&#10;                    'Type': member.type,&#10;                    'i-node': member.inode.uid,&#10;                    'j-node': member.jnode.uid,&#10;                    f'Length ({display_units[&quot;length&quot;]})': length_display,&#10;                    'Material ID': member.material.uid,&#10;                    f'E ({display_units[&quot;pressure&quot;]})': e_display,&#10;                    'Section ID': member.section.uid,&#10;                    f'Area ({display_units[&quot;length&quot;]})': area_display,&#10;                    f'Ixx ({display_units[&quot;length&quot;]})': ixx_display,&#10;                }&#10;&#10;                # Add hinge information if it's a frame&#10;                if hasattr(member, 'hinges'):&#10;                    hinge_info = []&#10;                    if member.hinges[0]:&#10;                        hinge_info.append('i-node')&#10;                    if member.hinges[1]:&#10;                        hinge_info.append('j-node')&#10;                    member_info['Hinges'] = ', '.join(hinge_info) if hinge_info else 'None'&#10;&#10;                members_data.append(member_info)&#10;&#10;            members_df = pd.DataFrame(members_data)&#10;            members_df.to_excel(writer, sheet_name='Member Properties', index=False)&#10;&#10;        print(f&quot;Successfully exported results to {output_file}&quot;)&#10;        return str(output_file)&#10;&#10;    def verify_structure_state(self, state_data):&#10;        &quot;&quot;&quot;&#10;        Verify that the loaded structure state is complete and consistent.&#10;        Checks if KU = F-P equation is satisfied.&#10;&#10;        Parameters&#10;        ----------&#10;        state_data : dict&#10;            Dictionary containing the loaded structure state&#10;&#10;        Returns&#10;        -------&#10;        bool&#10;            True if verification passes, False otherwise&#10;        &quot;&quot;&quot;&#10;        print(&quot;Verifying structure state completeness and consistency...&quot;)&#10;&#10;        # 1. Check if all essential components are present&#10;        # essential_keys = ['nodes', 'members', 'U', 'KSTRUCT', 'FG', 'structure_fef']&#10;        # missing_keys = [key for key in essential_keys if key not in state_data]&#10;        # if missing_keys:&#10;        #     print(f&quot;ERROR: Missing essential data: {missing_keys}&quot;)&#10;        #     return False&#10;&#10;        # 2. Check stiffness equation KU = F-P for free DOFs&#10;        if all(hasattr(self, attr) for attr in ['Kff', 'U', 'FGf', 'PFf']):&#10;            try:&#10;                # Convert quantities to numerical values for calculation&#10;                from pyMAOS.quantity_utils import numpy_array_of_quantity_to_numpy_array_of_float64&#10;                import numpy as np&#10;&#10;                # Extract magnitudes for calculation&#10;                Kff_mag = numpy_array_of_quantity_to_numpy_array_of_float64(self.Kff)&#10;                U_mag = numpy_array_of_quantity_to_numpy_array_of_float64(self.U)&#10;                FGf_mag = numpy_array_of_quantity_to_numpy_array_of_float64(self.FGf)&#10;                PFf_mag = numpy_array_of_quantity_to_numpy_array_of_float64(self.PFf)&#10;&#10;                # Calculate left and right sides of equation&#10;                KU = np.matmul(Kff_mag, U_mag)&#10;                F_minus_P = FGf_mag - PFf_mag&#10;&#10;                # Calculate residual and relative error&#10;                residual = KU - F_minus_P&#10;                error_norm = np.linalg.norm(residual)&#10;                rel_error = error_norm / np.linalg.norm(F_minus_P) if np.linalg.norm(F_minus_P) &gt; 1e-10 else error_norm&#10;&#10;                print(f&quot;Stiffness equation verification:&quot;)&#10;                print(f&quot;  Norm of KU:   {np.linalg.norm(KU):.6e}&quot;)&#10;                print(f&quot;  Norm of F-P:   {np.linalg.norm(F_minus_P):.6e}&quot;)&#10;                print(f&quot;  Residual norm: {error_norm:.6e}&quot;)&#10;                print(f&quot;  Relative error: {rel_error:.6e}&quot;)&#10;&#10;                # Check if error is acceptably small (adjust tolerance as needed)&#10;                if rel_error &gt; 1e-6:&#10;                    print(&quot;WARNING: Relative error in stiffness equation exceeds tolerance&quot;)&#10;                    return False&#10;&#10;                print(&quot; Stiffness equation verified successfully&quot;)&#10;&#10;            except Exception as e:&#10;                print(f&quot;ERROR during verification: {e}&quot;)&#10;                import traceback&#10;                traceback.print_exc()&#10;                return False&#10;        else:&#10;            print(&quot;WARNING: Cannot verify stiffness equation - missing required data&quot;)&#10;&#10;        # 3. Check node equilibrium by verifying reactions match applied loads + member forces&#10;        # (This would require gathering all member end forces for each node)&#10;&#10;        print(&quot;Structure state verification completed&quot;)&#10;        return True&#10;&#10;    def save_structure_state(self, filename):&#10;        &quot;&quot;&quot;&#10;        Save the entire structure object to a binary file in one operation.&#10;&#10;        Parameters&#10;        ----------&#10;        filename : str&#10;            Path to the binary output file&#10;&#10;        Returns&#10;        -------&#10;        bool&#10;            True if saving was successful, False otherwise&#10;        &quot;&quot;&quot;&#10;        import pickle&#10;        import zlib&#10;&#10;        print(f&quot;Saving complete structure state to {filename}...&quot;)&#10;&#10;        try:&#10;            # Pickle the entire object&#10;            pickled_data = pickle.dumps(self)&#10;&#10;            # Compress the pickled data&#10;            compressed_data = zlib.compress(pickled_data)&#10;&#10;            # Write compressed data to file&#10;            with open(filename, 'wb') as file:&#10;                file.write(compressed_data)&#10;&#10;            print(f&quot;Structure state saved successfully ({len(compressed_data):,} bytes compressed, {len(pickled_data):,} bytes uncompressed)&quot;)&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error saving structure state: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            return False&#10;&#10;&#10;&#10;def load_structure_state(filename):&#10;    &quot;&quot;&quot;&#10;    Load structure state from a binary file.&#10;&#10;    Parameters&#10;    ----------&#10;    filename : str&#10;        Path to binary file containing structure state&#10;&#10;    Returns&#10;    -------&#10;    R2Structure&#10;        Structure object with all quantities using the global registry&#10;    &quot;&quot;&quot;&#10;    import pickle&#10;    import pyMAOS&#10;    import zlib&#10;    import io&#10;    from pyMAOS.quantity_utils import convert_all_quantities&#10;&#10;    # Debug info&#10;    print(f&quot;Loading structure state from: {filename}&quot;)&#10;    print(f&quot;Using global unit registry with id: {id(pyMAOS.unit_manager.ureg)}&quot;)&#10;    &#10;    # Custom unpickler that converts quantities to the global registry during load&#10;    class QuantityUnpickler(pickle.Unpickler):&#10;        def find_class(self, module, name):&#10;            # Get the standard class&#10;            cls = super().find_class(module, name)&#10;            &#10;            # If it's a Quantity class, return our conversion wrapper&#10;            if module == 'pint.quantity' and name == 'Quantity':&#10;                # Create a wrapper that converts registry on unpickling&#10;                def quantity_factory(*args, **kwargs):&#10;                    # Standard creation&#10;                    obj = cls(*args, **kwargs)&#10;                    &#10;                    # If it's using a different registry, convert it&#10;                    if obj._REGISTRY is not pyMAOS.unit_manager.ureg:&#10;                        print(f&quot;Converting quantity {obj} from registry {id(obj._REGISTRY)} to global registry&quot;)&#10;                        obj = pyMAOS.unit_manager.ureg.Quantity(obj.magnitude, str(obj.units))&#10;                    &#10;                    return obj&#10;                &#10;                return quantity_factory&#10;            return cls&#10;&#10;    # Load structure from file&#10;    try:&#10;        with open(filename, 'rb') as f:&#10;            # Read compressed data&#10;            compressed_data = f.read()&#10;            &#10;            # Decompress data&#10;            try:&#10;                pickled_data = zlib.decompress(compressed_data)&#10;                # Use custom unpickler that converts quantities during load&#10;                unpickler = QuantityUnpickler(io.BytesIO(pickled_data))&#10;                structure = unpickler.load()&#10;                print(f&quot;Successfully loaded compressed binary file ({len(compressed_data):,} bytes compressed)&quot;)&#10;            except zlib.error:&#10;                # If decompression fails, try direct unpickling (for backward compatibility)&#10;                print(&quot;File appears to be uncompressed, trying direct unpickling...&quot;)&#10;                f.seek(0)  # Reset file pointer to beginning&#10;                # Use custom unpickler for uncompressed data too&#10;                unpickler = QuantityUnpickler(f)&#10;                structure = unpickler.load()&#10;                print(&quot;Successfully loaded uncompressed pickle file&quot;)&#10;&#10;        # Add registry ID to structure for future reference&#10;        structure.registry_id = id(pyMAOS.unit_manager.ureg)&#10;        &#10;        # Double-check for any quantities that weren't converted during unpickling&#10;        # This is a safety measure in case some quantities were stored in a way &#10;        # that bypassed our custom unpickler&#10;        structure = convert_all_quantities(structure, pyMAOS.unit_manager.ureg)&#10;&#10;        return structure&#10;    &#10;    except Exception as e:&#10;        print(f&quot;Error loading structure state from {filename}: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;        raise ValueError(f&quot;Failed to load structure state: {e}&quot;)&#10;&#10;def save_structure_state(self, filename):&#10;    &quot;&quot;&quot;&#10;    Save structure state to a binary file.&#10;&#10;    Parameters&#10;    ----------&#10;    filename : str&#10;        Path to binary file where structure state will be saved&#10;    &quot;&quot;&quot;&#10;    import pickle&#10;    import pyMAOS&#10;&#10;    # Store the registry ID for future reference&#10;    self.registry_id = id(pyMAOS.unit_manager.ureg)&#10;&#10;    try:&#10;        with open(filename, 'wb') as f:&#10;            pickle.dump(self, f)&#10;        print(f&quot;Structure state saved to {filename}&quot;)&#10;        print(f&quot;Registry ID stored: {self.registry_id}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error saving structure state to {filename}: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/structure2d_to_html.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/structure2d_to_html.py" />
              <option name="originalContent" value="def generate_html_report(self, loadcombos=None, output_html=&quot;results.html&quot;):&#10;    &quot;&quot;&quot;&#10;    Generate an interactive HTML report for structural analysis results using Plotly.&#10;&#10;    Parameters&#10;    ----------&#10;    loadcombos : list, optional&#10;        List of load combinations to include in the report&#10;    output_html : str, optional&#10;        Path to save the HTML report&#10;&#10;    Returns&#10;    -------&#10;    str&#10;        Path to the created HTML file&#10;    &quot;&quot;&quot;&#10;    import plotly.graph_objects as go&#10;    from plotly.subplots import make_subplots&#10;    import numpy as np&#10;    import os&#10;&#10;    print(f&quot;Generating interactive HTML report: {output_html}&quot;)&#10;&#10;    # Use all load combos if none specified&#10;    if loadcombos is None:&#10;        # Determine available load combos from node displacements&#10;        if self.nodes and hasattr(self.nodes[0], 'displacements') and self.nodes[0].displacements:&#10;            available_combos = list(self.nodes[0].displacements.keys())&#10;            loadcombos = available_combos&#10;        else:&#10;            print(&quot;Warning: No load combinations found in results.&quot;)&#10;            return None&#10;&#10;    # Extract values safely (handling Pint quantities)&#10;    def extract_value(val):&#10;        try:&#10;            if hasattr(val, 'magnitude'):  # Check if it's a Pint quantity&#10;                return float(val.magnitude)&#10;            return float(val)&#10;        except Exception as e:&#10;            print(f&quot;Error extracting value: {e}&quot;)&#10;            return 0.0&#10;&#10;    # Create figure with subplots&#10;    fig = make_subplots(&#10;        rows=2, cols=2,&#10;        specs=[[{&quot;type&quot;: &quot;scatter&quot;}, {&quot;type&quot;: &quot;scatter&quot;}],&#10;               [{&quot;type&quot;: &quot;scatter&quot;}, {&quot;type&quot;: &quot;table&quot;}]],&#10;        subplot_titles=(&quot;Structure Geometry&quot;, &quot;Deformed Shape&quot;,&#10;                        &quot;Bending Moment Diagram&quot;, &quot;Results Summary&quot;)&#10;    )&#10;&#10;    # Plot 1: Structure Geometry&#10;    print(&quot;Creating structure geometry plot...&quot;)&#10;    # Add members&#10;    for member in self.members:&#10;        fig.add_trace(&#10;            go.Scatter(&#10;                x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                mode='lines',&#10;                line=dict(color='blue', width=3),&#10;                name=f&quot;Member {member.uid}&quot;&#10;            ),&#10;            row=1, col=1&#10;        )&#10;&#10;    # Add nodes with hover text showing restraints&#10;    for node in self.nodes:&#10;        hover_text = (f&quot;Node {node.uid}&lt;br&gt;&quot;&#10;                     f&quot;Restraints: {node.restraints}&lt;br&gt;&quot;&#10;                     f&quot;X: {extract_value(node.x):.4f}&lt;br&gt;&quot;&#10;                     f&quot;Y: {extract_value(node.y):.4f}&quot;)&#10;&#10;        # Use different markers for restrained nodes&#10;        marker_symbol = 'circle'&#10;        marker_color = 'blue'&#10;        if sum(node.restraints) &gt; 0:&#10;            marker_symbol = 'square'&#10;            marker_color = 'red'&#10;&#10;        fig.add_trace(&#10;            go.Scatter(&#10;                x=[extract_value(node.x)],&#10;                y=[extract_value(node.y)],&#10;                mode='markers',&#10;                marker=dict(size=10, symbol=marker_symbol, color=marker_color),&#10;                name=f&quot;Node {node.uid}&quot;,&#10;                text=hover_text,&#10;                hoverinfo='text'&#10;            ),&#10;            row=1, col=1&#10;        )&#10;&#10;    # Plot 2: Deformed Shape for each load combo&#10;    print(&quot;Creating deformed shape plot...&quot;)&#10;    for combo in loadcombos:&#10;        # Get max displacement for scaling&#10;        max_disp = 0.0&#10;        for node in self.nodes:&#10;            if hasattr(node, 'displacements') and combo in node.displacements:&#10;                ux = extract_value(node.displacements[combo][0])&#10;                uy = extract_value(node.displacements[combo][1])&#10;                disp_magnitude = np.sqrt(ux**2 + uy**2)&#10;                max_disp = max(max_disp, disp_magnitude)&#10;&#10;        # Apply scaling factor for better visualization&#10;        scale_factor = 20.0  # Adjust for visibility&#10;        if max_disp &gt; 0:&#10;            scale_factor = min(&#10;                0.2 * max([extract_value(m.length) for m in self.members]) / max_disp,&#10;                scale_factor&#10;            )&#10;&#10;        print(f&quot;Load combo: {combo}, Max displacement: {max_disp:.6f}, Scale factor: {scale_factor}&quot;)&#10;&#10;        # Plot deformed shape&#10;        for member in self.members:&#10;            i_node = member.inode&#10;            j_node = member.jnode&#10;&#10;            # Get original coordinates&#10;            x1, y1 = extract_value(i_node.x), extract_value(i_node.y)&#10;            x2, y2 = extract_value(j_node.x), extract_value(j_node.y)&#10;&#10;            # Get displacements if available&#10;            ux1, uy1, ux2, uy2 = 0, 0, 0, 0&#10;&#10;            if hasattr(i_node, 'displacements') and combo in i_node.displacements:&#10;                ux1 = extract_value(i_node.displacements[combo][0])&#10;                uy1 = extract_value(i_node.displacements[combo][1])&#10;&#10;            if hasattr(j_node, 'displacements') and combo in j_node.displacements:&#10;                ux2 = extract_value(j_node.displacements[combo][0])&#10;                uy2 = extract_value(j_node.displacements[combo][1])&#10;&#10;            # Calculate deformed coordinates&#10;            x1_def = x1 + ux1 * scale_factor&#10;            y1_def = y1 + uy1 * scale_factor&#10;            x2_def = x2 + ux2 * scale_factor&#10;            y2_def = y2 + uy2 * scale_factor&#10;&#10;            # Add deformed member&#10;            fig.add_trace(&#10;                go.Scatter(&#10;                    x=[x1_def, x2_def],&#10;                    y=[y1_def, y2_def],&#10;                    mode='lines',&#10;                    line=dict(color='red', width=2, dash='dash'),&#10;                    name=f&quot;Deformed Member {member.uid} ({combo})&quot;&#10;                ),&#10;                row=1, col=2&#10;            )&#10;&#10;    # Plot 3: Bending Moment Diagram&#10;    print(&quot;Creating bending moment diagram...&quot;)&#10;    for combo in loadcombos[:1]:  # Just use the first combo for this example&#10;        for member in self.members:&#10;            if not hasattr(member, 'Mz') or combo not in member.Mz:&#10;                continue&#10;&#10;            length = extract_value(member.length)&#10;            num_points = 21&#10;&#10;            # Create x positions along member&#10;            x_local = np.linspace(0, length, num_points)&#10;&#10;            # Get moment values at each position&#10;            moment_values = []&#10;            for x in x_local:&#10;                try:&#10;                    m = extract_value(member.Mz[combo].evaluate(x))&#10;                    moment_values.append(m)&#10;                except Exception as e:&#10;                    print(f&quot;Error evaluating moment at x={x}: {e}&quot;)&#10;                    moment_values.append(0)&#10;&#10;            # Scale for better visualization&#10;            max_moment = max(abs(np.array(moment_values)))&#10;            if max_moment &gt; 0:&#10;                moment_scale = 0.2 * length / max_moment&#10;            else:&#10;                moment_scale = 1.0&#10;&#10;            # Get the global coordinates&#10;            cos_theta = (extract_value(member.jnode.x) - extract_value(member.inode.x)) / length&#10;            sin_theta = (extract_value(member.jnode.y) - extract_value(member.inode.y)) / length&#10;&#10;            x_global = []&#10;            y_global = []&#10;            for i, x in enumerate(x_local):&#10;                # Position along the member in global coordinates&#10;                x_pos = extract_value(member.inode.x) + x * cos_theta&#10;                y_pos = extract_value(member.inode.y) + x * sin_theta&#10;&#10;                # Add moment value perpendicular to the member&#10;                m = moment_values[i] * moment_scale&#10;                x_pos -= m * sin_theta&#10;                y_pos += m * cos_theta&#10;&#10;                x_global.append(x_pos)&#10;                y_global.append(y_pos)&#10;&#10;            # Plot the moment diagram&#10;            fig.add_trace(&#10;                go.Scatter(&#10;                    x=x_global,&#10;                    y=y_global,&#10;                    mode='lines',&#10;                    line=dict(color='green', width=2),&#10;                    name=f&quot;Moment {member.uid} ({combo})&quot;&#10;                ),&#10;                row=2, col=1&#10;            )&#10;&#10;    # Plot 4: Results Table&#10;    print(&quot;Creating results table...&quot;)&#10;    table_headers = [&quot;Node&quot;, &quot;Ux (m)&quot;, &quot;Uy (m)&quot;, &quot;Rz (rad)&quot;]&#10;    table_data = []&#10;&#10;    for node in self.nodes:&#10;        for combo in loadcombos[:1]:  # Just use first combo for table&#10;            if hasattr(node, 'displacements') and combo in node.displacements:&#10;                ux = extract_value(node.displacements[combo][0])&#10;                uy = extract_value(node.displacements[combo][1])&#10;                rz = extract_value(node.displacements[combo][2])&#10;                table_data.append([str(node.uid), f&quot;{ux:.6e}&quot;, f&quot;{uy:.6e}&quot;, f&quot;{rz:.6e}&quot;])&#10;&#10;    fig.add_trace(&#10;        go.Table(&#10;            header=dict(values=table_headers),&#10;            cells=dict(values=list(zip(*table_data))),&#10;        ),&#10;        row=2, col=2&#10;    )&#10;&#10;    # Update layout&#10;    fig.update_layout(&#10;        title_text=&quot;Interactive Structural Analysis Results&quot;,&#10;        height=800,&#10;        showlegend=False&#10;    )&#10;&#10;    # Ensure consistent aspect ratio and axis ranges&#10;    fig.update_yaxes(&#10;        scaleanchor=&quot;x&quot;,&#10;        scaleratio=1,&#10;        row=1, col=1&#10;    )&#10;&#10;    fig.update_yaxes(&#10;        scaleanchor=&quot;x&quot;,&#10;        scaleratio=1,&#10;        row=1, col=2&#10;    )&#10;&#10;    # Write the HTML file&#10;    print(f&quot;Writing HTML report to: {output_html}&quot;)&#10;    try:&#10;        fig.write_html(output_html)&#10;        print(f&quot;Successfully created HTML report at: {output_html}&quot;)&#10;        return output_html&#10;    except Exception as e:&#10;        print(f&quot;Error writing HTML file: {e}&quot;)&#10;        return None" />
              <option name="updatedContent" value="def generate_html_report(self, loadcombos=None, output_html=&quot;results.html&quot;):&#10;    &quot;&quot;&quot;&#10;    Generate a comprehensive interactive HTML report for structural analysis results using Plotly.&#10;&#10;    Parameters&#10;    ----------&#10;    loadcombos : list, optional&#10;        List of load combinations to include in the report&#10;    output_html : str, optional&#10;        Path to save the HTML report&#10;&#10;    Returns&#10;    -------&#10;    str&#10;        Path to the created HTML file&#10;    &quot;&quot;&quot;&#10;    import plotly.graph_objects as go&#10;    from plotly.subplots import make_subplots&#10;    import numpy as np&#10;    import os&#10;    import plotly.io as pio&#10;    import pandas as pd&#10;    from plotly.colors import qualitative&#10;&#10;    print(f&quot;Generating comprehensive interactive HTML report: {output_html}&quot;)&#10;&#10;    # Use all load combos if none specified&#10;    if loadcombos is None:&#10;        # Determine available load combos from node displacements&#10;        if self.nodes and hasattr(self.nodes[0], 'displacements') and self.nodes[0].displacements:&#10;            available_combos = list(self.nodes[0].displacements.keys())&#10;            loadcombos = available_combos&#10;        else:&#10;            print(&quot;Warning: No load combinations found in results.&quot;)&#10;            return None&#10;&#10;    # Extract values safely (handling Pint quantities)&#10;    def extract_value(val):&#10;        try:&#10;            if hasattr(val, 'magnitude'):  # Check if it's a Pint quantity&#10;                return float(val.magnitude)&#10;            return float(val)&#10;        except Exception as e:&#10;            print(f&quot;Error extracting value: {e}&quot;)&#10;            return 0.0&#10;    &#10;    def extract_unit(val):&#10;        &quot;&quot;&quot;Extract unit string from a quantity&quot;&quot;&quot;&#10;        try:&#10;            if hasattr(val, 'units'):&#10;                return str(val.units)&#10;            return &quot;&quot;&#10;        except Exception:&#10;            return &quot;&quot;&#10;    &#10;    # Get display units from the first few quantities we encounter&#10;    display_units = {}&#10;    &#10;    # Try to determine units from first node coordinates&#10;    if self.nodes:&#10;        if hasattr(self.nodes[0].x, 'units'):&#10;            display_units['length'] = str(self.nodes[0].x.units)&#10;        &#10;    # Try to determine force units from first member reaction&#10;    if self.members and hasattr(self.members[0], 'end_forces_local'):&#10;        for combo_name, forces in self.members[0].end_forces_local.items():&#10;            if forces is not None and len(forces) &gt; 0:&#10;                if hasattr(forces[0], 'units'):&#10;                    display_units['force'] = str(forces[0].units)&#10;                    break&#10;    &#10;    # Set default units if not found&#10;    if 'length' not in display_units:&#10;        display_units['length'] = 'm'&#10;    if 'force' not in display_units:&#10;        display_units['force'] = 'N'&#10;    if 'moment' not in display_units:&#10;        display_units['moment'] = f&quot;{display_units['force']}{display_units['length']}&quot;&#10;        &#10;    print(f&quot;Using display units: {display_units}&quot;)&#10;    &#10;    # Create HTML with multiple tabs using Plotly's Dash components but rendered as static HTML&#10;    # First, create a list to hold all figures&#10;    figures = []&#10;    &#10;    # 1. Create summary information table&#10;    summary_fig = go.Figure(data=[go.Table(&#10;        header=dict(&#10;            values=['Parameter', 'Value'],&#10;            fill_color='lightblue',&#10;            align='left',&#10;            font=dict(size=14)&#10;        ),&#10;        cells=dict(&#10;            values=[&#10;                ['Number of Nodes', 'Number of Members', 'Degrees of Freedom', &#10;                 'Number of Restraints', 'Analysis Type', 'Load Combinations'],&#10;                [len(self.nodes), len(self.members), self.NDOF, &#10;                 sum(sum(node.restraints) for node in self.nodes), 'Linear Static',&#10;                 ', '.join(combo for combo in loadcombos)]&#10;            ],&#10;            fill_color='lavender',&#10;            align='left',&#10;            font=dict(size=12)&#10;        )&#10;    )])&#10;    &#10;    summary_fig.update_layout(&#10;        title_text=&quot;Analysis Summary&quot;,&#10;        height=300,&#10;        margin=dict(l=0, r=0, b=0, t=30),&#10;    )&#10;    &#10;    figures.append(summary_fig)&#10;    &#10;    # 2. Create structure visualization with loads&#10;    structure_fig = go.Figure()&#10;    &#10;    # Add members&#10;    for member in self.members:&#10;        structure_fig.add_trace(&#10;            go.Scatter(&#10;                x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                mode='lines',&#10;                line=dict(color='blue', width=3),&#10;                name=f&quot;Member {member.uid}&quot;&#10;            )&#10;        )&#10;    &#10;    # Add nodes with hover text showing restraints&#10;    for node in self.nodes:&#10;        hover_text = (f&quot;Node {node.uid}&lt;br&gt;&quot;&#10;                     f&quot;Restraints: {node.restraints}&lt;br&gt;&quot;&#10;                     f&quot;X: {extract_value(node.x)} {display_units['length']}&lt;br&gt;&quot;&#10;                     f&quot;Y: {extract_value(node.y)} {display_units['length']}&quot;)&#10;&#10;        # Use different markers for restrained nodes&#10;        marker_symbol = 'circle'&#10;        marker_color = 'blue'&#10;        if sum(node.restraints) &gt; 0:&#10;            marker_symbol = 'square'&#10;            marker_color = 'red'&#10;&#10;        structure_fig.add_trace(&#10;            go.Scatter(&#10;                x=[extract_value(node.x)],&#10;                y=[extract_value(node.y)],&#10;                mode='markers',&#10;                marker=dict(size=10, symbol=marker_symbol, color=marker_color),&#10;                name=f&quot;Node {node.uid}&quot;,&#10;                text=hover_text,&#10;                hoverinfo='text'&#10;            )&#10;        )&#10;        &#10;        # Add nodal loads (if any)&#10;        for combo in loadcombos:&#10;            if hasattr(node, 'loads') and combo in node.loads:&#10;                load = node.loads[combo]&#10;                fx = extract_value(load[0])&#10;                fy = extract_value(load[1])&#10;                mz = extract_value(load[2])&#10;                &#10;                # Only show loads that are not zero&#10;                load_magnitude = np.sqrt(fx*fx + fy*fy)&#10;                if load_magnitude &gt; 0:&#10;                    # Scale arrow for visibility&#10;                    scale = min(5.0, max(0.5, 20.0 / load_magnitude)) if load_magnitude &gt; 0 else 1.0&#10;                    &#10;                    # Add arrow for force&#10;                    arrow_x = extract_value(node.x)&#10;                    arrow_y = extract_value(node.y)&#10;                    arrow_dx = -fx * scale  # Negative because loads are in opposite direction&#10;                    arrow_dy = -fy * scale&#10;                    &#10;                    structure_fig.add_trace(&#10;                        go.Scatter(&#10;                            x=[arrow_x, arrow_x + arrow_dx],&#10;                            y=[arrow_y, arrow_y + arrow_dy],&#10;                            mode='lines+markers',&#10;                            line=dict(color='red', width=2),&#10;                            marker=dict(size=[0, 8], symbol='arrow', angle=np.degrees(np.arctan2(arrow_dy, arrow_dx))),&#10;                            name=f&quot;Load {combo} at Node {node.uid}&quot;,&#10;                            text=f&quot;Fx={fx:.2f} {display_units['force']}&lt;br&gt;Fy={fy:.2f} {display_units['force']}&quot;,&#10;                            hoverinfo='text'&#10;                        )&#10;                    )&#10;                &#10;                # Add curved arrow for moment (if not zero)&#10;                if abs(mz) &gt; 1e-8:&#10;                    # Create a small circle to represent moment&#10;                    theta = np.linspace(0, 2*np.pi, 20)&#10;                    radius = 0.05 * max([extract_value(m.length) for m in self.members if hasattr(m, 'length')])&#10;                    &#10;                    # Direction depends on sign of moment&#10;                    if mz &gt; 0:  # Counter-clockwise&#10;                        structure_fig.add_trace(&#10;                            go.Scatter(&#10;                                x=extract_value(node.x) + radius * np.cos(theta),&#10;                                y=extract_value(node.y) + radius * np.sin(theta),&#10;                                mode='lines',&#10;                                line=dict(color='red', width=2),&#10;                                name=f&quot;Moment {combo} at Node {node.uid}&quot;,&#10;                                text=f&quot;Mz={mz:.2f} {display_units['moment']}&quot;,&#10;                                hoverinfo='text'&#10;                            )&#10;                        )&#10;                        # Add arrowhead&#10;                        structure_fig.add_trace(&#10;                            go.Scatter(&#10;                                x=[extract_value(node.x) + radius, extract_value(node.x) + radius*0.8, &#10;                                   extract_value(node.x) + radius*0.8],&#10;                                y=[extract_value(node.y), extract_value(node.y) + radius*0.1, &#10;                                   extract_value(node.y) - radius*0.1],&#10;                                mode='lines',&#10;                                line=dict(color='red', width=2),&#10;                                showlegend=False&#10;                            )&#10;                        )&#10;                    else:  # Clockwise&#10;                        structure_fig.add_trace(&#10;                            go.Scatter(&#10;                                x=extract_value(node.x) + radius * np.cos(theta),&#10;                                y=extract_value(node.y) + radius * np.sin(theta),&#10;                                mode='lines',&#10;                                line=dict(color='red', width=2),&#10;                                name=f&quot;Moment {combo} at Node {node.uid}&quot;,&#10;                                text=f&quot;Mz={mz:.2f} {display_units['moment']}&quot;,&#10;                                hoverinfo='text'&#10;                            )&#10;                        )&#10;                        # Add arrowhead&#10;                        structure_fig.add_trace(&#10;                            go.Scatter(&#10;                                x=[extract_value(node.x) - radius, extract_value(node.x) - radius*0.8, &#10;                                   extract_value(node.x) - radius*0.8],&#10;                                y=[extract_value(node.y), extract_value(node.y) + radius*0.1, &#10;                                   extract_value(node.y) - radius*0.1],&#10;                                mode='lines',&#10;                                line=dict(color='red', width=2),&#10;                                showlegend=False&#10;                            )&#10;                        )&#10;    &#10;    # Add distributed loads on members&#10;    for member in self.members:&#10;        if hasattr(member, 'loads'):&#10;            for load in member.loads:&#10;                # Handle different types of loads&#10;                if hasattr(load, 'kind') and load.kind == 'DISTRIBUTED':&#10;                    # Draw distributed load&#10;                    length = extract_value(member.length)&#10;                    num_arrows = 5  # Number of arrows to represent distributed load&#10;                    &#10;                    # Get local coordinates&#10;                    cos_theta = (extract_value(member.jnode.x) - extract_value(member.inode.x)) / length&#10;                    sin_theta = (extract_value(member.jnode.y) - extract_value(member.inode.y)) / length&#10;                    &#10;                    # For each arrow position&#10;                    for i in range(num_arrows):&#10;                        x_local = length * (i + 0.5) / num_arrows&#10;                        &#10;                        # Get load magnitude at this position (assuming w1 and w2 attributes for linear load)&#10;                        if hasattr(load, 'w1') and hasattr(load, 'w2'):&#10;                            w1 = extract_value(load.w1)&#10;                            w2 = extract_value(load.w2)&#10;                            w_x = w1 + (w2 - w1) * x_local / length&#10;                        else:&#10;                            w_x = extract_value(load.p) if hasattr(load, 'p') else 1.0&#10;                        &#10;                        # Position along member&#10;                        x_pos = extract_value(member.inode.x) + x_local * cos_theta&#10;                        y_pos = extract_value(member.inode.y) + x_local * sin_theta&#10;                        &#10;                        # Arrow direction (perpendicular to member)&#10;                        scale = 0.1 * length  # Scale for visibility&#10;                        &#10;                        structure_fig.add_trace(&#10;                            go.Scatter(&#10;                                x=[x_pos, x_pos - w_x * scale * sin_theta],&#10;                                y=[y_pos, y_pos + w_x * scale * cos_theta],&#10;                                mode='lines+markers',&#10;                                line=dict(color='purple', width=2),&#10;                                marker=dict(size=[0, 8], symbol='arrow'),&#10;                                name=f&quot;Distributed Load on Member {member.uid}&quot;,&#10;                                showlegend=(i == 0)&#10;                            )&#10;                        )&#10;    &#10;    structure_fig.update_layout(&#10;        title_text=&quot;Structure Geometry and Loads&quot;,&#10;        xaxis=dict(&#10;            title=f&quot;X ({display_units['length']})&quot;,&#10;            constrain=&quot;domain&quot;,&#10;            scaleanchor=&quot;y&quot;,&#10;            scaleratio=1,&#10;        ),&#10;        yaxis=dict(&#10;            title=f&quot;Y ({display_units['length']})&quot;&#10;        ),&#10;        legend=dict(&#10;            yanchor=&quot;top&quot;,&#10;            y=0.99,&#10;            xanchor=&quot;left&quot;,&#10;            x=0.01,&#10;            bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;&#10;        ),&#10;        height=700,&#10;        margin=dict(l=0, r=0, b=0, t=50),&#10;    )&#10;    &#10;    figures.append(structure_fig)&#10;    &#10;    # 3. Create deformed shape for all load combinations&#10;    for combo_idx, combo in enumerate(loadcombos):&#10;        deformed_fig = go.Figure()&#10;        &#10;        # Add original structure (undeformed)&#10;        for member in self.members:&#10;            deformed_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                    y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                    mode='lines',&#10;                    line=dict(color='blue', width=2, dash='dot'),&#10;                    name=&quot;Undeformed Shape&quot;&#10;                )&#10;            )&#10;        &#10;        # Get max displacement for scaling&#10;        max_disp = 0.0&#10;        for node in self.nodes:&#10;            if hasattr(node, 'displacements') and combo in node.displacements:&#10;                ux = extract_value(node.displacements[combo][0])&#10;                uy = extract_value(node.displacements[combo][1])&#10;                disp_magnitude = np.sqrt(ux**2 + uy**2)&#10;                max_disp = max(max_disp, disp_magnitude)&#10;        &#10;        # Apply scaling factor for better visualization&#10;        scale_factor = 20.0  # Default&#10;        if max_disp &gt; 0:&#10;            avg_member_length = np.mean([extract_value(m.length) for m in self.members])&#10;            scale_factor = 0.2 * avg_member_length / max_disp&#10;            scale_factor = min(scale_factor, 50.0)  # Limit scaling&#10;        &#10;        print(f&quot;Load combo: {combo}, Max displacement: {max_disp:.6f}, Scale factor: {scale_factor}&quot;)&#10;        &#10;        # Draw deformed shape&#10;        for member_idx, member in enumerate(self.members):&#10;            i_node = member.inode&#10;            j_node = member.jnode&#10;            &#10;            # Get original coordinates&#10;            x1, y1 = extract_value(i_node.x), extract_value(i_node.y)&#10;            x2, y2 = extract_value(j_node.x), extract_value(j_node.y)&#10;            &#10;            # Get displacements if available&#10;            ux1, uy1, ux2, uy2 = 0, 0, 0, 0&#10;            &#10;            if hasattr(i_node, 'displacements') and combo in i_node.displacements:&#10;                ux1 = extract_value(i_node.displacements[combo][0])&#10;                uy1 = extract_value(i_node.displacements[combo][1])&#10;            &#10;            if hasattr(j_node, 'displacements') and combo in j_node.displacements:&#10;                ux2 = extract_value(j_node.displacements[combo][0])&#10;                uy2 = extract_value(j_node.displacements[combo][1])&#10;            &#10;            # For more accurate representation, use the member displacement function if available&#10;            if hasattr(member, 'displacement_functions') and combo in member.displacement_functions:&#10;                try:&#10;                    disp_function = member.displacement_functions[combo]&#10;                    &#10;                    # Generate multiple points along member&#10;                    num_points = 20&#10;                    x_local = np.linspace(0, extract_value(member.length), num_points)&#10;                    &#10;                    # Calculate displacement at each point&#10;                    x_global = []&#10;                    y_global = []&#10;                    &#10;                    for x in x_local:&#10;                        # Get member local coordinates&#10;                        cos_theta = (x2 - x1) / extract_value(member.length)&#10;                        sin_theta = (y2 - y1) / extract_value(member.length)&#10;                        &#10;                        # Position along undeformed member&#10;                        x_pos = x1 + x * cos_theta&#10;                        y_pos = y1 + x * sin_theta&#10;                        &#10;                        # Add displacement&#10;                        try:&#10;                            ux = extract_value(disp_function['ux'](x)) if 'ux' in disp_function else 0&#10;                            uy = extract_value(disp_function['uy'](x)) if 'uy' in disp_function else 0&#10;                        except Exception as e:&#10;                            print(f&quot;Error evaluating displacement at x={x}: {e}&quot;)&#10;                            ux, uy = 0, 0&#10;                        &#10;                        x_pos += ux * scale_factor&#10;                        y_pos += uy * scale_factor&#10;                        &#10;                        x_global.append(x_pos)&#10;                        y_global.append(y_pos)&#10;                    &#10;                    # Draw the deformed member as a smooth curve&#10;                    deformed_fig.add_trace(&#10;                        go.Scatter(&#10;                            x=x_global,&#10;                            y=y_global,&#10;                            mode='lines',&#10;                            line=dict(color='red', width=3),&#10;                            name=f&quot;Deformed Member {member.uid}&quot;&#10;                        )&#10;                    )&#10;                &#10;                except Exception as e:&#10;                    print(f&quot;Error generating displacement curve for member {member.uid}: {e}&quot;)&#10;                    # Fall back to linear deformation&#10;                    x1_def = x1 + ux1 * scale_factor&#10;                    y1_def = y1 + uy1 * scale_factor&#10;                    x2_def = x2 + ux2 * scale_factor&#10;                    y2_def = y2 + uy2 * scale_factor&#10;                    &#10;                    deformed_fig.add_trace(&#10;                        go.Scatter(&#10;                            x=[x1_def, x2_def],&#10;                            y=[y1_def, y2_def],&#10;                            mode='lines',&#10;                            line=dict(color='red', width=3),&#10;                            name=f&quot;Deformed Member {member.uid}&quot;&#10;                        )&#10;                    )&#10;            else:&#10;                # Simple linear deformation&#10;                x1_def = x1 + ux1 * scale_factor&#10;                y1_def = y1 + uy1 * scale_factor&#10;                x2_def = x2 + ux2 * scale_factor&#10;                y2_def = y2 + uy2 * scale_factor&#10;                &#10;                deformed_fig.add_trace(&#10;                    go.Scatter(&#10;                        x=[x1_def, x2_def],&#10;                        y=[y1_def, y2_def],&#10;                        mode='lines',&#10;                        line=dict(color='red', width=3),&#10;                        name=f&quot;Deformed Member {member.uid}&quot;&#10;                    )&#10;                )&#10;        &#10;        # Add deformed node positions with displacement text&#10;        for node in self.nodes:&#10;            if hasattr(node, 'displacements') and combo in node.displacements:&#10;                ux = extract_value(node.displacements[combo][0])&#10;                uy = extract_value(node.displacements[combo][1])&#10;                rz = extract_value(node.displacements[combo][2])&#10;                &#10;                # Calculate deformed position&#10;                x_def = extract_value(node.x) + ux * scale_factor&#10;                y_def = extract_value(node.y) + uy * scale_factor&#10;                &#10;                hover_text = (f&quot;Node {node.uid}&lt;br&gt;&quot;&#10;                             f&quot;Ux: {ux:.4e} {display_units['length']}&lt;br&gt;&quot;&#10;                             f&quot;Uy: {uy:.4e} {display_units['length']}&lt;br&gt;&quot;&#10;                             f&quot;Rz: {rz:.4e} rad&quot;)&#10;                &#10;                deformed_fig.add_trace(&#10;                    go.Scatter(&#10;                        x=[x_def],&#10;                        y=[y_def],&#10;                        mode='markers',&#10;                        marker=dict(size=8, color='red'),&#10;                        name=f&quot;Deformed Node {node.uid}&quot;,&#10;                        text=hover_text,&#10;                        hoverinfo='text'&#10;                    )&#10;                )&#10;        &#10;        deformed_fig.update_layout(&#10;            title_text=f&quot;Deformed Shape - {combo} (Scale: {scale_factor:.1f}X)&quot;,&#10;            xaxis=dict(&#10;                title=f&quot;X ({display_units['length']})&quot;,&#10;                constrain=&quot;domain&quot;,&#10;                scaleanchor=&quot;y&quot;,&#10;                scaleratio=1,&#10;            ),&#10;            yaxis=dict(&#10;                title=f&quot;Y ({display_units['length']})&quot;&#10;            ),&#10;            legend=dict(&#10;                yanchor=&quot;top&quot;,&#10;                y=0.99,&#10;                xanchor=&quot;left&quot;,&#10;                x=0.01,&#10;                bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;&#10;            ),&#10;            height=600,&#10;            margin=dict(l=0, r=0, b=0, t=50),&#10;        )&#10;        &#10;        figures.append(deformed_fig)&#10;    &#10;    # 4. Create internal force diagrams (moment, shear, axial)&#10;    for combo_idx, combo in enumerate(loadcombos):&#10;        # a. Bending Moment Diagram&#10;        moment_fig = go.Figure()&#10;        &#10;        # Add reference structure&#10;        for member in self.members:&#10;            moment_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                    y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                    mode='lines',&#10;                    line=dict(color='gray', width=1, dash='dot'),&#10;                    name=&quot;Structure&quot;&#10;                )&#10;            )&#10;        &#10;        # Plot moment diagram for each member&#10;        for member_idx, member in enumerate(self.members):&#10;            if not hasattr(member, 'Mz') or combo not in member.Mz:&#10;                continue&#10;            &#10;            length = extract_value(member.length)&#10;            num_points = 31&#10;            &#10;            # Create x positions along member&#10;            x_local = np.linspace(0, length, num_points)&#10;            &#10;            # Get moment values at each position&#10;            moment_values = []&#10;            for x in x_local:&#10;                try:&#10;                    m = extract_value(member.Mz[combo].evaluate(x))&#10;                    moment_values.append(m)&#10;                except Exception as e:&#10;                    print(f&quot;Error evaluating moment at x={x}: {e}&quot;)&#10;                    moment_values.append(0)&#10;            &#10;            # Scale for better visualization&#10;            max_moment = max(abs(np.array(moment_values))) if moment_values else 0&#10;            if max_moment &gt; 0:&#10;                moment_scale = 0.15 * length / max_moment&#10;            else:&#10;                moment_scale = 1.0&#10;            &#10;            # Get the global coordinates&#10;            cos_theta = (extract_value(member.jnode.x) - extract_value(member.inode.x)) / length&#10;            sin_theta = (extract_value(member.jnode.y) - extract_value(member.inode.y)) / length&#10;            &#10;            x_global = []&#10;            y_global = []&#10;            hover_texts = []&#10;            &#10;            for i, x in enumerate(x_local):&#10;                # Position along the member in global coordinates&#10;                x_pos = extract_value(member.inode.x) + x * cos_theta&#10;                y_pos = extract_value(member.inode.y) + x * sin_theta&#10;                &#10;                # Add moment value perpendicular to the member&#10;                m = moment_values[i] * moment_scale&#10;                x_pos -= m * sin_theta&#10;                y_pos += m * cos_theta&#10;                &#10;                x_global.append(x_pos)&#10;                y_global.append(y_pos)&#10;                hover_texts.append(f&quot;x: {x:.2f} {display_units['length']}&lt;br&gt;Mz: {moment_values[i]:.2f} {display_units['moment']}&quot;)&#10;            &#10;            # Plot the moment diagram&#10;            moment_fig.add_trace(&#10;                go.Scatter(&#10;                    x=x_global,&#10;                    y=y_global,&#10;                    mode='lines',&#10;                    line=dict(color=qualitative.Plotly[member_idx % len(qualitative.Plotly)], width=2),&#10;                    name=f&quot;Member {member.uid}&quot;,&#10;                    text=hover_texts,&#10;                    hoverinfo='text'&#10;                )&#10;            )&#10;            &#10;            # Add value labels at ends&#10;            moment_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[x_global[0], x_global[-1]],&#10;                    y=[y_global[0], y_global[-1]],&#10;                    mode='markers+text',&#10;                    marker=dict(size=5, color=qualitative.Plotly[member_idx % len(qualitative.Plotly)]),&#10;                    text=[f&quot;{moment_values[0]:.2f}&quot;, f&quot;{moment_values[-1]:.2f}&quot;],&#10;                    textposition=[&quot;bottom center&quot;, &quot;bottom center&quot;],&#10;                    showlegend=False&#10;                )&#10;            )&#10;        &#10;        moment_fig.update_layout(&#10;            title_text=f&quot;Bending Moment Diagram - {combo}&quot;,&#10;            xaxis=dict(&#10;                title=f&quot;X ({display_units['length']})&quot;,&#10;                constrain=&quot;domain&quot;,&#10;                scaleanchor=&quot;y&quot;,&#10;                scaleratio=1,&#10;            ),&#10;            yaxis=dict(&#10;                title=f&quot;Y ({display_units['length']})&quot;&#10;            ),&#10;            legend=dict(&#10;                yanchor=&quot;top&quot;,&#10;                y=0.99,&#10;                xanchor=&quot;left&quot;,&#10;                x=0.01,&#10;                bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;&#10;            ),&#10;            height=600,&#10;            margin=dict(l=0, r=0, b=0, t=50),&#10;        )&#10;        &#10;        figures.append(moment_fig)&#10;        &#10;        # b. Shear Force Diagram&#10;        shear_fig = go.Figure()&#10;        &#10;        # Add reference structure&#10;        for member in self.members:&#10;            shear_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                    y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                    mode='lines',&#10;                    line=dict(color='gray', width=1, dash='dot'),&#10;                    name=&quot;Structure&quot;&#10;                )&#10;            )&#10;        &#10;        # Plot shear diagram for each member&#10;        for member_idx, member in enumerate(self.members):&#10;            if not hasattr(member, 'Vy') or combo not in member.Vy:&#10;                continue&#10;            &#10;            length = extract_value(member.length)&#10;            num_points = 31&#10;            &#10;            # Create x positions along member&#10;            x_local = np.linspace(0, length, num_points)&#10;            &#10;            # Get shear values at each position&#10;            shear_values = []&#10;            for x in x_local:&#10;                try:&#10;                    v = extract_value(member.Vy[combo].evaluate(x))&#10;                    shear_values.append(v)&#10;                except Exception as e:&#10;                    print(f&quot;Error evaluating shear at x={x}: {e}&quot;)&#10;                    shear_values.append(0)&#10;            &#10;            # Scale for better visualization&#10;            max_shear = max(abs(np.array(shear_values))) if shear_values else 0&#10;            if max_shear &gt; 0:&#10;                shear_scale = 0.15 * length / max_shear&#10;            else:&#10;                shear_scale = 1.0&#10;            &#10;            # Get the global coordinates&#10;            cos_theta = (extract_value(member.jnode.x) - extract_value(member.inode.x)) / length&#10;            sin_theta = (extract_value(member.jnode.y) - extract_value(member.inode.y)) / length&#10;            &#10;            x_global = []&#10;            y_global = []&#10;            hover_texts = []&#10;            &#10;            for i, x in enumerate(x_local):&#10;                # Position along the member in global coordinates&#10;                x_pos = extract_value(member.inode.x) + x * cos_theta&#10;                y_pos = extract_value(member.inode.y) + x * sin_theta&#10;                &#10;                # Add shear value perpendicular to the member&#10;                v = shear_values[i] * shear_scale&#10;                x_pos -= v * sin_theta&#10;                y_pos += v * cos_theta&#10;                &#10;                x_global.append(x_pos)&#10;                y_global.append(y_pos)&#10;                hover_texts.append(f&quot;x: {x:.2f} {display_units['length']}&lt;br&gt;Vy: {shear_values[i]:.2f} {display_units['force']}&quot;)&#10;            &#10;            # Plot the shear diagram&#10;            shear_fig.add_trace(&#10;                go.Scatter(&#10;                    x=x_global,&#10;                    y=y_global,&#10;                    mode='lines',&#10;                    line=dict(color=qualitative.Plotly[member_idx % len(qualitative.Plotly)], width=2),&#10;                    name=f&quot;Member {member.uid}&quot;,&#10;                    text=hover_texts,&#10;                    hoverinfo='text'&#10;                )&#10;            )&#10;            &#10;            # Add value labels at ends&#10;            shear_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[x_global[0], x_global[-1]],&#10;                    y=[y_global[0], y_global[-1]],&#10;                    mode='markers+text',&#10;                    marker=dict(size=5, color=qualitative.Plotly[member_idx % len(qualitative.Plotly)]),&#10;                    text=[f&quot;{shear_values[0]:.2f}&quot;, f&quot;{shear_values[-1]:.2f}&quot;],&#10;                    textposition=[&quot;bottom center&quot;, &quot;bottom center&quot;],&#10;                    showlegend=False&#10;                )&#10;            )&#10;        &#10;        shear_fig.update_layout(&#10;            title_text=f&quot;Shear Force Diagram - {combo}&quot;,&#10;            xaxis=dict(&#10;                title=f&quot;X ({display_units['length']})&quot;,&#10;                constrain=&quot;domain&quot;,&#10;                scaleanchor=&quot;y&quot;,&#10;                scaleratio=1,&#10;            ),&#10;            yaxis=dict(&#10;                title=f&quot;Y ({display_units['length']})&quot;&#10;            ),&#10;            legend=dict(&#10;                yanchor=&quot;top&quot;,&#10;                y=0.99,&#10;                xanchor=&quot;left&quot;,&#10;                x=0.01,&#10;                bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;&#10;            ),&#10;            height=600,&#10;            margin=dict(l=0, r=0, b=0, t=50),&#10;        )&#10;        &#10;        figures.append(shear_fig)&#10;        &#10;        # c. Axial Force Diagram&#10;        axial_fig = go.Figure()&#10;        &#10;        # Add reference structure&#10;        for member in self.members:&#10;            axial_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[extract_value(member.inode.x), extract_value(member.jnode.x)],&#10;                    y=[extract_value(member.inode.y), extract_value(member.jnode.y)],&#10;                    mode='lines',&#10;                    line=dict(color='gray', width=1, dash='dot'),&#10;                    name=&quot;Structure&quot;&#10;                )&#10;            )&#10;        &#10;        # Plot axial diagram for each member&#10;        for member_idx, member in enumerate(self.members):&#10;            if not hasattr(member, 'N') or combo not in member.N:&#10;                continue&#10;            &#10;            length = extract_value(member.length)&#10;            num_points = 31&#10;            &#10;            # Create x positions along member&#10;            x_local = np.linspace(0, length, num_points)&#10;            &#10;            # Get axial values at each position&#10;            axial_values = []&#10;            for x in x_local:&#10;                try:&#10;                    n = extract_value(member.N[combo].evaluate(x))&#10;                    axial_values.append(n)&#10;                except Exception as e:&#10;                    print(f&quot;Error evaluating axial force at x={x}: {e}&quot;)&#10;                    axial_values.append(0)&#10;            &#10;            # Scale for better visualization (smaller scale for axial)&#10;            max_axial = max(abs(np.array(axial_values))) if axial_values else 0&#10;            if max_axial &gt; 0:&#10;                axial_scale = 0.05 * length / max_axial&#10;            else:&#10;                axial_scale = 1.0&#10;            &#10;            # Get member orientation&#10;            cos_theta = (extract_value(member.jnode.x) - extract_value(member.inode.x)) / length&#10;            sin_theta = (extract_value(member.jnode.y) - extract_value(member.inode.y)) / length&#10;            &#10;            # Lines parallel to the member&#10;            x_global = []&#10;            y_global = []&#10;            hover_texts = []&#10;            &#10;            for i, x in enumerate(x_local):&#10;                # Position along the member in global coordinates&#10;                x_pos = extract_value(member.inode.x) + x * cos_theta&#10;                y_pos = extract_value(member.inode.y) + x * sin_theta&#10;                &#10;                # Add axial value perpendicular to the member (rotated 90)&#10;                n = axial_values[i] * axial_scale&#10;                # For axial force, plot offset perpendicular to member direction&#10;                x_pos += n * sin_theta  # Note: Perpendicular direction&#10;                y_pos -= n * cos_theta  # Note: Perpendicular direction&#10;                &#10;                x_global.append(x_pos)&#10;                y_global.append(y_pos)&#10;                hover_texts.append(f&quot;x: {x:.2f} {display_units['length']}&lt;br&gt;N: {axial_values[i]:.2f} {display_units['force']}&quot;)&#10;            &#10;            # Plot the axial diagram&#10;            axial_fig.add_trace(&#10;                go.Scatter(&#10;                    x=x_global,&#10;                    y=y_global,&#10;                    mode='lines',&#10;                    line=dict(color=qualitative.Plotly[member_idx % len(qualitative.Plotly)], width=2),&#10;                    name=f&quot;Member {member.uid}&quot;,&#10;                    text=hover_texts,&#10;                    hoverinfo='text'&#10;                )&#10;            )&#10;            &#10;            # Add value labels at ends&#10;            axial_fig.add_trace(&#10;                go.Scatter(&#10;                    x=[x_global[0], x_global[-1]],&#10;                    y=[y_global[0], y_global[-1]],&#10;                    mode='markers+text',&#10;                    marker=dict(size=5, color=qualitative.Plotly[member_idx % len(qualitative.Plotly)]),&#10;                    text=[f&quot;{axial_values[0]:.2f}&quot;, f&quot;{axial_values[-1]:.2f}&quot;],&#10;                    textposition=[&quot;bottom center&quot;, &quot;bottom center&quot;],&#10;                    showlegend=False&#10;                )&#10;            )&#10;        &#10;        axial_fig.update_layout(&#10;            title_text=f&quot;Axial Force Diagram - {combo}&quot;,&#10;            xaxis=dict(&#10;                title=f&quot;X ({display_units['length']})&quot;,&#10;                constrain=&quot;domain&quot;,&#10;                scaleanchor=&quot;y&quot;,&#10;                scaleratio=1,&#10;            ),&#10;            yaxis=dict(&#10;                title=f&quot;Y ({display_units['length']})&quot;&#10;            ),&#10;            legend=dict(&#10;                yanchor=&quot;top&quot;,&#10;                y=0.99,&#10;                xanchor=&quot;left&quot;,&#10;                x=0.01,&#10;                bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;&#10;            ),&#10;            height=600,&#10;            margin=dict(l=0, r=0, b=0, t=50),&#10;        )&#10;        &#10;        figures.append(axial_fig)&#10;    &#10;    # 5. Tabular results (Node displacements, reactions, member forces)&#10;    # a. Node displacements table&#10;    for combo in loadcombos:&#10;        disp_headers = [&quot;Node ID&quot;, f&quot;Ux ({display_units['length']})&quot;, &#10;                        f&quot;Uy ({display_units['length']})&quot;, &quot;Rz (rad)&quot;]&#10;        disp_data = [[], [], [], []]&#10;        &#10;        for node in sorted(self.nodes, key=lambda n: n.uid):&#10;            if hasattr(node, 'displacements') and combo in node.displacements:&#10;                disp = node.displacements[combo]&#10;                disp_data[0].append(node.uid)&#10;                disp_data[1].append(f&quot;{extract_value(disp[0]):.6e}&quot;)&#10;                disp_data[2].append(f&quot;{extract_value(disp[1]):.6e}&quot;)&#10;                disp_data[3].append(f&quot;{extract_value(disp[2]):.6e}&quot;)&#10;        &#10;        disp_table = go.Figure(data=[go.Table(&#10;            header=dict(&#10;                values=disp_headers,&#10;                fill_color='lightblue',&#10;                align='center',&#10;                font=dict(size=12)&#10;            ),&#10;            cells=dict(&#10;                values=disp_data,&#10;                fill_color='lavender',&#10;                align='right',&#10;                font=dict(size=11)&#10;            )&#10;        )])&#10;        &#10;        disp_table.update_layout(&#10;            title_text=f&quot;Node Displacements - {combo}&quot;,&#10;            height=400,&#10;            margin=dict(l=0, r=0, b=0, t=30),&#10;        )&#10;        &#10;        figures.append(disp_table)&#10;    &#10;    # b. Reaction forces table&#10;    for combo in loadcombos:&#10;        react_headers = [&quot;Node ID&quot;, f&quot;Rx ({display_units['force']})&quot;, &#10;                         f&quot;Ry ({display_units['force']})&quot;, f&quot;Mz ({display_units['moment']})&quot;]&#10;        react_data = [[], [], [], []]&#10;        &#10;        for node in sorted(self.nodes, key=lambda n: n.uid):&#10;            if any(node.restraints) and hasattr(node, 'reactions'):&#10;                if isinstance(node.reactions, dict) and combo in node.reactions:&#10;                    reaction = node.reactions[combo]&#10;                else:&#10;                    reaction = node.reactions  # Direct array&#10;                &#10;                react_data[0].append(node.uid)&#10;                &#10;                # Only show reactions where there are restraints&#10;                rx = extract_value(reaction[0]) if node.restraints[0] else 0&#10;                ry = extract_value(reaction[1]) if node.restraints[1] else 0&#10;                mz = extract_value(reaction[2]) if node.restraints[2] else 0&#10;                &#10;                react_data[1].append(f&quot;{rx:.4f}&quot;)&#10;                react_data[2].append(f&quot;{ry:.4f}&quot;)&#10;                react_data[3].append(f&quot;{mz:.4f}&quot;)&#10;        &#10;        react_table = go.Figure(data=[go.Table(&#10;            header=dict(&#10;                values=react_headers,&#10;                fill_color='lightblue',&#10;                align='center',&#10;                font=dict(size=12)&#10;            ),&#10;            cells=dict(&#10;                values=react_data,&#10;                fill_color='lavender',&#10;                align='right',&#10;                font=dict(size=11)&#10;            )&#10;        )])&#10;        &#10;        react_table.update_layout(&#10;            title_text=f&quot;Support Reactions - {combo}&quot;,&#10;            height=400,&#10;            margin=dict(l=0, r=0, b=0, t=30),&#10;        )&#10;        &#10;        figures.append(react_table)&#10;    &#10;    # c. Member end forces table&#10;    for combo in loadcombos:&#10;        force_headers = [&quot;Member&quot;, &#10;                         f&quot;Axial i ({display_units['force']})&quot;, &#10;                         f&quot;Shear i ({display_units['force']})&quot;, &#10;                         f&quot;Moment i ({display_units['moment']})&quot;,&#10;                         f&quot;Axial j ({display_units['force']})&quot;, &#10;                         f&quot;Shear j ({display_units['force']})&quot;, &#10;                         f&quot;Moment j ({display_units['moment']})&quot;]&#10;        force_data = [[], [], [], [], [], [], []]&#10;        &#10;        for member in sorted(self.members, key=lambda m: m.uid):&#10;            if hasattr(member, 'end_forces_local') and combo in member.end_forces_local:&#10;                forces = member.end_forces_local[combo]&#10;                &#10;                force_data[0].append(member.uid)&#10;                &#10;                # Local end forces - force sign convention&#10;                if len(forces) &gt;= 6:&#10;                    force_data[1].append(f&quot;{extract_value(forces[0]):.4f}&quot;)  # Axial i&#10;                    force_data[2].append(f&quot;{extract_value(forces[1]):.4f}&quot;)  # Shear i&#10;                    force_data[3].append(f&quot;{extract_value(forces[2]):.4f}&quot;)  # Moment i&#10;                    force_data[4].append(f&quot;{extract_value(forces[3]):.4f}&quot;)  # Axial j&#10;                    force_data[5].append(f&quot;{extract_value(forces[4]):.4f}&quot;)  # Shear j&#10;                    force_data[6].append(f&quot;{extract_value(forces[5]):.4f}&quot;)  # Moment j&#10;                else:&#10;                    # Fill with zeros if not enough data&#10;                    for i in range(1, 7):&#10;                        force_data[i].append(&quot;0.0000&quot;)&#10;        &#10;        force_table = go.Figure(data=[go.Table(&#10;            header=dict(&#10;                values=force_headers,&#10;                fill_color='lightblue',&#10;                align='center',&#10;                font=dict(size=12)&#10;            ),&#10;            cells=dict(&#10;                values=force_data,&#10;                fill_color='lavender',&#10;                align='right',&#10;                font=dict(size=11)&#10;            )&#10;        )])&#10;        &#10;        force_table.update_layout(&#10;            title_text=f&quot;Member End Forces (Local) - {combo}&quot;,&#10;            height=400,&#10;            margin=dict(l=0, r=0, b=0, t=30),&#10;        )&#10;        &#10;        figures.append(force_table)&#10;    &#10;    # 6. Member properties table&#10;    prop_headers = [&quot;Member&quot;, &#10;                   f&quot;Length ({display_units['length']})&quot;, &#10;                   &quot;Section&quot;, &#10;                   &quot;Material&quot;,&#10;                   &quot;Angle (deg)&quot;]&#10;    prop_data = [[], [], [], [], []]&#10;    &#10;    for member in sorted(self.members, key=lambda m: m.uid):&#10;        prop_data[0].append(member.uid)&#10;        prop_data[1].append(f&quot;{extract_value(member.length):.4f}&quot;)&#10;        &#10;        # Get section name&#10;        section_name = member.section.name if hasattr(member.section, 'name') else str(member.section.uid)&#10;        prop_data[2].append(section_name)&#10;        &#10;        # Get material name&#10;        material_name = str(member.material.uid)&#10;        prop_data[3].append(material_name)&#10;        &#10;        # Orientation angle&#10;        angle = np.degrees(member.theta) if hasattr(member, 'theta') else 0&#10;        prop_data[4].append(f&quot;{angle:.2f}&quot;)&#10;    &#10;    prop_table = go.Figure(data=[go.Table(&#10;        header=dict(&#10;            values=prop_headers,&#10;            fill_color='lightblue',&#10;            align='center',&#10;            font=dict(size=12)&#10;        ),&#10;        cells=dict(&#10;            values=prop_data,&#10;            fill_color='lavender',&#10;            align='right',&#10;            font=dict(size=11)&#10;        )&#10;    )])&#10;    &#10;    prop_table.update_layout(&#10;        title_text=&quot;Member Properties&quot;,&#10;        height=400,&#10;        margin=dict(l=0, r=0, b=0, t=30),&#10;    )&#10;    &#10;    figures.append(prop_table)&#10;    &#10;    # Combine all figures into an HTML report with navigation tabs&#10;    html_parts = [&quot;&quot;&quot;&#10;    &lt;!DOCTYPE html&gt;&#10;    &lt;html&gt;&#10;    &lt;head&gt;&#10;        &lt;title&gt;Structural Analysis Results&lt;/title&gt;&#10;        &lt;script src=&quot;https://cdn.plot.ly/plotly-latest.min.js&quot;&gt;&lt;/script&gt;&#10;        &lt;style&gt;&#10;            body { font-family: Arial, sans-serif; margin: 0; padding: 0; }&#10;            .header { background-color: #2c3e50; color: white; padding: 20px; text-align: center; }&#10;            .content { padding: 20px; }&#10;            .tab { overflow: hidden; border: 1px solid #ccc; background-color: #f1f1f1; }&#10;            .tab button { background-color: inherit; float: left; border: none; outline: none;&#10;                          cursor: pointer; padding: 14px 16px; transition: 0.3s; }&#10;            .tab button:hover { background-color: #ddd; }&#10;            .tab button.active { background-color: #ccc; }&#10;            .tabcontent { display: none; padding: 6px 12px; border: 1px solid #ccc; border-top: none; }&#10;            .plot-container { width: 100%; height: 100%; }&#10;        &lt;/style&gt;&#10;    &lt;/head&gt;&#10;    &lt;body&gt;&#10;        &lt;div class=&quot;header&quot;&gt;&#10;            &lt;h1&gt;Structural Analysis Results&lt;/h1&gt;&#10;            &lt;p&gt;Interactive visualization of analysis results&lt;/p&gt;&#10;        &lt;/div&gt;&#10;        &#10;        &lt;div class=&quot;tab&quot;&gt;&#10;    &quot;&quot;&quot;]&#10;    &#10;    # Create tabs&#10;    for i, fig in enumerate(figures):&#10;        tab_title = fig.layout.title.text if hasattr(fig.layout, 'title') and hasattr(fig.layout.title, 'text') else f&quot;Figure {i+1}&quot;&#10;        html_parts.append(f'&lt;button class=&quot;tablinks&quot; onclick=&quot;openTab(event, \'tab{i}\')&quot;&gt;{tab_title}&lt;/button&gt;')&#10;    &#10;    html_parts.append('&lt;/div&gt;')&#10;    &#10;    # Create content for each tab&#10;    for i, fig in enumerate(figures):&#10;        html_parts.append(f'&lt;div id=&quot;tab{i}&quot; class=&quot;tabcontent&quot;&gt;')&#10;        html_parts.append(f'&lt;div id=&quot;plot{i}&quot; class=&quot;plot-container&quot;&gt;&lt;/div&gt;')&#10;        html_parts.append('&lt;/div&gt;')&#10;        &#10;    # Add JavaScript for tabs and plots&#10;    html_parts.append(&quot;&quot;&quot;&#10;        &lt;script&gt;&#10;            // Tab functionality&#10;            function openTab(evt, tabName) {&#10;                var i, tabcontent, tablinks;&#10;                tabcontent = document.getElementsByClassName(&quot;tabcontent&quot;);&#10;                for (i = 0; i &lt; tabcontent.length; i++) {&#10;                    tabcontent[i].style.display = &quot;none&quot;;&#10;                }&#10;                tablinks = document.getElementsByClassName(&quot;tablinks&quot;);&#10;                for (i = 0; i &lt; tablinks.length; i++) {&#10;                    tablinks[i].className = tablinks[i].className.replace(&quot; active&quot;, &quot;&quot;);&#10;                }&#10;                document.getElementById(tabName).style.display = &quot;block&quot;;&#10;                evt.currentTarget.className += &quot; active&quot;;&#10;            }&#10;            &#10;            // Open the first tab by default&#10;            document.getElementsByClassName(&quot;tablinks&quot;)[0].click();&#10;        &lt;/script&gt;&#10;    &quot;&quot;&quot;)&#10;    &#10;    # Add plot data&#10;    for i, fig in enumerate(figures):&#10;        fig_json = fig.to_json()&#10;        html_parts.append(f&quot;&quot;&quot;&#10;        &lt;script&gt;&#10;            var plotData{i} = {fig_json};&#10;            Plotly.newPlot('plot{i}', plotData{i}.data, plotData{i}.layout);&#10;        &lt;/script&gt;&#10;        &quot;&quot;&quot;)&#10;    &#10;    html_parts.append(&quot;&quot;&quot;&#10;    &lt;/body&gt;&#10;    &lt;/html&gt;&#10;    &quot;&quot;&quot;)&#10;    &#10;    # Write HTML file&#10;    try:&#10;        with open(output_html, 'w') as f:&#10;            f.write(''.join(html_parts))&#10;        print(f&quot;Successfully created HTML report at: {output_html}&quot;)&#10;        return output_html&#10;    except Exception as e:&#10;        print(f&quot;Error writing HTML file: {e}&quot;)&#10;        return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/structure2d_to_json.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/structure2d_to_json.py" />
              <option name="originalContent" value="def export_results_to_json(structure, load_cases=None, output_file=None, convert_to_display_units=False, display_units=None):&#10;    &quot;&quot;&quot;&#10;    Export calculation results to a JSON file with Pint unit support,&#10;    including units next to magnitude values&#10;&#10;    Parameters&#10;    ----------&#10;    structure : R2Structure&#10;        The analyzed structure containing results&#10;    load_cases : list, optional&#10;        List of load case names to include in export (defaults to all)&#10;    output_file : str, optional&#10;        Path to output file (defaults to 'results.json')&#10;    convert_to_display_units : bool, optional&#10;        Whether to convert values to display units (default: False)&#10;    display_units : dict, optional&#10;        Dictionary of display units to use (default: None, uses system defaults)&#10;&#10;    Returns&#10;    -------&#10;    str&#10;        Path to the created JSON file&#10;    &quot;&quot;&quot;&#10;    import json&#10;    import numpy as np&#10;    import os&#10;&#10;    # Import the centralized unit manager&#10;    from pyMAOS import unit_manager&#10;    ureg = unit_manager.ureg&#10;&#10;    if output_file is None:&#10;        output_file = 'results.json'&#10;&#10;    print(f&quot;Starting export to JSON file: {output_file}&quot;)&#10;&#10;    # Get default display units if needed but not provided&#10;    if convert_to_display_units and display_units is None:&#10;        try:&#10;            from pyMAOS import unit_manager&#10;            display_units = unit_manager.current_system&#10;        except ImportError:&#10;            # Fallback to some standard display units&#10;            display_units = {&#10;                &quot;force&quot;: &quot;kN&quot;,&#10;                &quot;length&quot;: &quot;m&quot;,&#10;                &quot;moment&quot;: &quot;kN*m&quot;,&#10;                &quot;pressure&quot;: &quot;MPa&quot;,&#10;                &quot;area&quot;: &quot;cm^2&quot;,&#10;                &quot;moment_of_inertia&quot;: &quot;cm^4&quot;,&#10;                &quot;distributed_load&quot;: &quot;kN/m&quot;,&#10;                &quot;rotation&quot;: &quot;rad&quot;&#10;            }&#10;            print(f&quot;Using default display units: {display_units}&quot;)&#10;&#10;    # Define internal units based on the unit manager&#10;    internal_units = {&#10;        &quot;force&quot;: str(unit_manager.INTERNAL_FORCE_UNIT),&#10;        &quot;length&quot;: str(unit_manager.INTERNAL_LENGTH_UNIT),&#10;        &quot;moment&quot;: str(unit_manager.INTERNAL_MOMENT_UNIT),&#10;        &quot;pressure&quot;: str(unit_manager.INTERNAL_PRESSURE_UNIT),&#10;        &quot;area&quot;: f&quot;{unit_manager.INTERNAL_LENGTH_UNIT}^2&quot;,&#10;        &quot;moment_of_inertia&quot;: str(unit_manager.INTERNAL_MOMENT_OF_INERTIA_UNIT),&#10;        &quot;distributed_load&quot;: str(unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT),&#10;        &quot;rotation&quot;: str(unit_manager.INTERNAL_ROTATION_UNIT)&#10;    }&#10;&#10;    print(f&quot;Internal units: {internal_units}&quot;)&#10;    print(f&quot;Display units (if converting): {display_units}&quot;)&#10;&#10;    # Prepare data structure for JSON&#10;    results = {&#10;        &quot;units&quot;: display_units if convert_to_display_units else internal_units,&#10;        &quot;nodes&quot;: {},&#10;        &quot;members&quot;: {},&#10;        &quot;analysis_info&quot;: {&#10;            &quot;dof&quot;: structure.NDOF,&#10;            &quot;num_nodes&quot;: structure.NJ,&#10;            &quot;num_members&quot;: structure.NM&#10;        }&#10;    }&#10;&#10;    # Helper function to safely extract value from Pint quantities or regular values&#10;    def extract_value(val):&#10;        &quot;&quot;&quot;Extract numerical value from Pint quantities or regular values&quot;&quot;&quot;&#10;        try:&#10;            # Check if value has a 'magnitude' attribute (Pint Quantity)&#10;            if hasattr(val, 'magnitude'):&#10;                return float(val.magnitude)&#10;            # For numpy types&#10;            elif isinstance(val, (np.number, np.ndarray, np.matrix)):&#10;                return float(val)&#10;            else:&#10;                return float(val)&#10;        except Exception as e:&#10;            print(f&quot;Error extracting value: {e}, using 0.0&quot;)&#10;            return 0.0&#10;&#10;    # Unit conversion helper function&#10;    def convert_unit_with_info(value, dimension):&#10;        &quot;&quot;&quot;Convert value between unit systems and return both value and unit&quot;&quot;&quot;&#10;        try:&#10;            # Determine the unit based on conversion settings&#10;            unit = display_units[dimension] if convert_to_display_units else internal_units[dimension]&#10;&#10;            # Check if value is close to zero without direct float conversion&#10;            # Handle Pint quantities properly&#10;            if hasattr(value, 'magnitude'):&#10;                magnitude = value.magnitude&#10;            else:&#10;                try:&#10;                    magnitude = float(value)&#10;                except (TypeError, ValueError):&#10;                    print(f&quot;Warning: Could not convert {value} to float, using 0&quot;)&#10;                    magnitude = 0.0&#10;&#10;            # Skip conversion for values very close to zero&#10;            if abs(magnitude) &lt; 1e-12:&#10;                return {&quot;value&quot;: 0.0, &quot;unit&quot;: unit}&#10;&#10;            # Extract the raw value&#10;            raw_value = extract_value(value)&#10;&#10;            # If conversion is requested, perform it&#10;            if convert_to_display_units:&#10;                source_unit = internal_units[dimension]&#10;                target_unit = display_units[dimension]&#10;&#10;                # Create quantity with source unit and convert to target unit&#10;                quantity = ureg.Quantity(raw_value, source_unit)&#10;                raw_value = quantity.to(target_unit).magnitude&#10;&#10;            # Return both value and unit&#10;            return {&quot;value&quot;: raw_value, &quot;unit&quot;: unit}&#10;        except Exception as e:&#10;            print(f&quot;Error converting {value} from {internal_units.get(dimension)} to {display_units.get(dimension)}: {e}&quot;)&#10;            unit = internal_units.get(dimension)&#10;            return {&quot;value&quot;: extract_value(value), &quot;unit&quot;: unit}&#10;&#10;    # Helper function to safely extract 6 force values from various array formats&#10;    def extract_force_values(force_array):&#10;        &quot;&quot;&quot;Extract 6 force values from various array formats with Pint support&quot;&quot;&quot;&#10;        values = [0.0] * 6&#10;&#10;        try:&#10;            # Handle Pint quantities in arrays&#10;            if hasattr(force_array, 'magnitude'):&#10;                force_array = force_array.magnitude&#10;&#10;            if isinstance(force_array, np.matrix):&#10;                array_data = np.array(force_array)&#10;                flat_data = array_data.flatten()&#10;                for i in range(min(6, len(flat_data))):&#10;                    values[i] = extract_value(flat_data[i])&#10;            elif isinstance(force_array, np.ndarray):&#10;                flat_data = force_array.flatten()&#10;                for i in range(min(6, len(flat_data))):&#10;                    values[i] = extract_value(flat_data[i])&#10;            elif hasattr(force_array, '__iter__'):&#10;                for i, val in enumerate(force_array):&#10;                    if i &gt;= 6: break&#10;                    values[i] = extract_value(val)&#10;            else:&#10;                # Single value or unknown type&#10;                values[0] = extract_value(force_array)&#10;&#10;            return values&#10;        except Exception as e:&#10;            print(f&quot;Error extracting force values: {e}&quot;)&#10;            return values&#10;&#10;    # Get all load combination names if not specified&#10;    if load_cases is None:&#10;        load_cases = set()&#10;        for node in structure.nodes:&#10;            if hasattr(node, 'displacements'):&#10;                load_cases.update(node.displacements.keys())&#10;        load_cases = list(load_cases)&#10;        print(f&quot;Found {len(load_cases)} load cases: {load_cases}&quot;)&#10;    # Handle case where LoadCombo objects are passed instead of names&#10;    elif all(hasattr(lc, 'name') for lc in load_cases):&#10;        load_cases = [lc.name for lc in load_cases]&#10;&#10;    # Extract node results&#10;    print(f&quot;Processing {len(structure.nodes)} nodes&quot;)&#10;    for node in structure.nodes:&#10;        node_data = {&#10;            &quot;coordinates&quot;: {&#10;                &quot;x&quot;: convert_unit_with_info(node.x, &quot;length&quot;),&#10;                &quot;y&quot;: convert_unit_with_info(node.y, &quot;length&quot;)&#10;            },&#10;            &quot;restraints&quot;: [int(r) for r in node.restraints] if hasattr(node, 'restraints') else [0, 0, 0],&#10;            &quot;displacements&quot;: {},&#10;            &quot;reactions&quot;: {}&#10;        }&#10;&#10;        # Add displacements for each load combo&#10;        if hasattr(node, 'displacements'):&#10;            for lc in load_cases:&#10;                if lc in node.displacements:&#10;                    node_data[&quot;displacements&quot;][lc] = {&#10;                        &quot;ux&quot;: convert_unit_with_info(node.displacements[lc][0], &quot;length&quot;),&#10;                        &quot;uy&quot;: convert_unit_with_info(node.displacements[lc][1], &quot;length&quot;),&#10;                        &quot;rz&quot;: convert_unit_with_info(node.displacements[lc][2], &quot;rotation&quot;)&#10;                    }&#10;&#10;        # Add reactions for each load combo&#10;        if hasattr(node, 'reactions'):&#10;            for lc in load_cases:&#10;                if lc in node.reactions:&#10;                    node_data[&quot;reactions&quot;][lc] = {&#10;                        &quot;rx&quot;: convert_unit_with_info(node.reactions[lc][0], &quot;force&quot;),&#10;                        &quot;ry&quot;: convert_unit_with_info(node.reactions[lc][1], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(node.reactions[lc][2], &quot;moment&quot;)&#10;                    }&#10;&#10;        results[&quot;nodes&quot;][str(node.uid)] = node_data&#10;&#10;    # Extract member results&#10;    print(f&quot;Processing {len(structure.members)} members&quot;)&#10;    for member in structure.members:&#10;        member_data = {&#10;            &quot;connectivity&quot;: {&#10;                &quot;i_node&quot;: int(member.inode.uid),&#10;                &quot;j_node&quot;: int(member.jnode.uid)&#10;            },&#10;            &quot;properties&quot;: {&#10;                &quot;length&quot;: convert_unit_with_info(member.length, &quot;length&quot;),&#10;                &quot;type&quot;: member.type if hasattr(member, 'type') else &quot;FRAME&quot;&#10;            },&#10;            &quot;forces&quot;: {}&#10;        }&#10;&#10;        # Add material and section properties&#10;        if hasattr(member, 'material'):&#10;            member_data[&quot;properties&quot;][&quot;material&quot;] = {&#10;                &quot;id&quot;: str(member.material.uid),&#10;                &quot;E&quot;: convert_unit_with_info(member.material.E, &quot;pressure&quot;)&#10;            }&#10;&#10;        if hasattr(member, 'section'):&#10;            member_data[&quot;properties&quot;][&quot;section&quot;] = {&#10;                &quot;id&quot;: str(member.section.uid),&#10;                &quot;area&quot;: convert_unit_with_info(member.section.Area, &quot;area&quot;),&#10;                &quot;Ixx&quot;: convert_unit_with_info(member.section.Ixx, &quot;moment_of_inertia&quot;)&#10;            }&#10;&#10;        # Add member hinges if applicable&#10;        if hasattr(member, 'hinges'):&#10;            member_data[&quot;properties&quot;][&quot;hinges&quot;] = [int(h) for h in member.hinges]&#10;&#10;        # Add forces for each load combo&#10;        for lc in load_cases:&#10;            # Process member forces if available&#10;            if hasattr(member, 'member_forces') and lc in member.member_forces:&#10;                forces = member.member_forces[lc]&#10;                force_values = extract_force_values(forces)&#10;&#10;                member_data[&quot;forces&quot;][lc] = {&#10;                    &quot;local&quot;: {&#10;                        &quot;i_node&quot;: {&#10;                            &quot;fx&quot;: convert_unit_with_info(force_values[0], &quot;force&quot;),&#10;                            &quot;fy&quot;: convert_unit_with_info(force_values[1], &quot;force&quot;),&#10;                            &quot;mz&quot;: convert_unit_with_info(force_values[2], &quot;moment&quot;)&#10;                        },&#10;                        &quot;j_node&quot;: {&#10;                            &quot;fx&quot;: convert_unit_with_info(force_values[3], &quot;force&quot;),&#10;                            &quot;fy&quot;: convert_unit_with_info(force_values[4], &quot;force&quot;),&#10;                            &quot;mz&quot;: convert_unit_with_info(force_values[5], &quot;moment&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;            # Add global forces if available&#10;            if hasattr(member, 'end_forces_global') and lc in member.end_forces_global:&#10;                forces_global = member.end_forces_global[lc]&#10;                global_values = extract_force_values(forces_global)&#10;&#10;                if &quot;forces&quot; not in member_data:&#10;                    member_data[&quot;forces&quot;] = {}&#10;                if lc not in member_data[&quot;forces&quot;]:&#10;                    member_data[&quot;forces&quot;][lc] = {}&#10;&#10;                member_data[&quot;forces&quot;][lc][&quot;global&quot;] = {&#10;                    &quot;i_node&quot;: {&#10;                        &quot;fx&quot;: convert_unit_with_info(global_values[0], &quot;force&quot;),&#10;                        &quot;fy&quot;: convert_unit_with_info(global_values[1], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(global_values[2], &quot;moment&quot;)&#10;                    },&#10;                    &quot;j_node&quot;: {&#10;                        &quot;fx&quot;: convert_unit_with_info(global_values[3], &quot;force&quot;),&#10;                        &quot;fy&quot;: convert_unit_with_info(global_values[4], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(global_values[5], &quot;moment&quot;)&#10;                    }&#10;                }&#10;&#10;            # Add distributed results if available&#10;            try:&#10;                # Only proceed if the member has generated these functions&#10;                if (hasattr(member, 'A') and lc in member.A and&#10;                    hasattr(member, 'Vy') and lc in member.Vy and&#10;                    hasattr(member, 'Mz') and lc in member.Mz):&#10;&#10;                    ax_func = member.A[lc]&#10;                    vy_func = member.Vy[lc]&#10;                    mz_func = member.Mz[lc]&#10;&#10;                    if ax_func and vy_func and mz_func:&#10;                        num_points = 21  # Number of points to sample along the member&#10;                        length = extract_value(member.length)&#10;                        x_vals = [length * i / (num_points - 1) for i in range(num_points)]&#10;&#10;                        if lc not in member_data[&quot;forces&quot;]:&#10;                            member_data[&quot;forces&quot;][lc] = {}&#10;&#10;                        member_data[&quot;forces&quot;][lc][&quot;distributed&quot;] = {&#10;                            &quot;positions&quot;: [convert_unit_with_info(x, &quot;length&quot;) for x in x_vals],&#10;                            &quot;axial&quot;: [convert_unit_with_info(ax_func.evaluate(x), &quot;force&quot;) for x in x_vals],&#10;                            &quot;shear&quot;: [convert_unit_with_info(vy_func.evaluate(x), &quot;force&quot;) for x in x_vals],&#10;                            &quot;moment&quot;: [convert_unit_with_info(mz_func.evaluate(x), &quot;moment&quot;) for x in x_vals]&#10;                        }&#10;&#10;                        # Add extreme moment values if available&#10;                        if hasattr(member, 'Mzextremes'):&#10;                            try:&#10;                                extremes = member.Mzextremes(lc)&#10;                                if extremes:&#10;                                    member_data[&quot;forces&quot;][lc][&quot;extremes&quot;] = {&#10;                                        &quot;max_moment&quot;: {&#10;                                            &quot;position&quot;: convert_unit_with_info(extremes[&quot;MaxM&quot;][0], &quot;length&quot;),&#10;                                            &quot;value&quot;: convert_unit_with_info(extremes[&quot;MaxM&quot;][1], &quot;moment&quot;)&#10;                                        },&#10;                                        &quot;min_moment&quot;: {&#10;                                            &quot;position&quot;: convert_unit_with_info(extremes[&quot;MinM&quot;][0], &quot;length&quot;),&#10;                                            &quot;value&quot;: convert_unit_with_info(extremes[&quot;MinM&quot;][1], &quot;moment&quot;)&#10;                                        }&#10;                                    }&#10;                            except Exception as e:&#10;                                print(f&quot;Error calculating moment extremes for member {member.uid}: {e}&quot;)&#10;            except Exception as e:&#10;                print(f&quot;Could not generate distributed results for member {member.uid}: {e}&quot;)&#10;&#10;        results[&quot;members&quot;][str(member.uid)] = member_data&#10;&#10;    # Create directory if it doesn't exist&#10;    os.makedirs(os.path.dirname(os.path.abspath(output_file)), exist_ok=True)&#10;&#10;    # Write to JSON file&#10;    print(f&quot;Writing results to {output_file}&quot;)&#10;    with open(output_file, 'w') as f:&#10;        json.dump(results, f, indent=2)&#10;&#10;    print(f&quot;Results successfully exported to {output_file}&quot;)&#10;    return output_file" />
              <option name="updatedContent" value="def export_results_to_json(structure, load_cases=None, output_file=None, convert_to_display_units=False, display_units=None):&#10;    &quot;&quot;&quot;&#10;    Export calculation results to a JSON file with Pint unit support,&#10;    including units next to magnitude values&#10;&#10;    Parameters&#10;    ----------&#10;    structure : R2Structure&#10;        The analyzed structure containing results&#10;    load_cases : list, optional&#10;        List of load case names to include in export (defaults to all)&#10;    output_file : str, optional&#10;        Path to output file (defaults to 'results.json')&#10;    convert_to_display_units : bool, optional&#10;        Whether to convert values to display units (default: False)&#10;    display_units : dict, optional&#10;        Dictionary of display units to use (default: None, uses system defaults)&#10;&#10;    Returns&#10;    -------&#10;    str&#10;        Path to the created JSON file&#10;    &quot;&quot;&quot;&#10;    import json&#10;    import numpy as np&#10;    import os&#10;&#10;    # Import the centralized unit manager&#10;    from pyMAOS import unit_manager&#10;    ureg = unit_manager.ureg&#10;&#10;    if output_file is None:&#10;        output_file = 'results.json'&#10;&#10;    print(f&quot;Starting export to JSON file: {output_file}&quot;)&#10;&#10;    # Get default display units if needed but not provided&#10;    if convert_to_display_units and display_units is None:&#10;        try:&#10;            from pyMAOS import unit_manager&#10;            display_units = unit_manager.current_system&#10;        except ImportError:&#10;            # Fallback to some standard display units&#10;            display_units = {&#10;                &quot;force&quot;: &quot;kN&quot;,&#10;                &quot;length&quot;: &quot;m&quot;,&#10;                &quot;moment&quot;: &quot;kN*m&quot;,&#10;                &quot;pressure&quot;: &quot;MPa&quot;,&#10;                &quot;area&quot;: &quot;cm^2&quot;,&#10;                &quot;moment_of_inertia&quot;: &quot;cm^4&quot;,&#10;                &quot;distributed_load&quot;: &quot;kN/m&quot;,&#10;                &quot;rotation&quot;: &quot;rad&quot;&#10;            }&#10;            print(f&quot;Using default display units: {display_units}&quot;)&#10;&#10;    # Define internal units based on the unit manager&#10;    internal_units = {&#10;        &quot;force&quot;: str(unit_manager.INTERNAL_FORCE_UNIT),&#10;        &quot;length&quot;: str(unit_manager.INTERNAL_LENGTH_UNIT),&#10;        &quot;moment&quot;: str(unit_manager.INTERNAL_MOMENT_UNIT),&#10;        &quot;pressure&quot;: str(unit_manager.INTERNAL_PRESSURE_UNIT),&#10;        &quot;area&quot;: f&quot;{unit_manager.INTERNAL_LENGTH_UNIT}^2&quot;,&#10;        &quot;moment_of_inertia&quot;: str(unit_manager.INTERNAL_MOMENT_OF_INERTIA_UNIT),&#10;        &quot;distributed_load&quot;: str(unit_manager.INTERNAL_DISTRIBUTED_LOAD_UNIT),&#10;        &quot;rotation&quot;: str(unit_manager.INTERNAL_ROTATION_UNIT)&#10;    }&#10;&#10;    print(f&quot;Internal units: {internal_units}&quot;)&#10;    print(f&quot;Display units (if converting): {display_units}&quot;)&#10;&#10;    # Prepare data structure for JSON&#10;    results = {&#10;        &quot;units&quot;: display_units if convert_to_display_units else internal_units,&#10;        &quot;nodes&quot;: {},&#10;        &quot;members&quot;: {},&#10;        &quot;analysis_info&quot;: {&#10;            &quot;dof&quot;: structure.NDOF,&#10;            &quot;num_nodes&quot;: structure.NJ,&#10;            &quot;num_members&quot;: structure.NM&#10;        }&#10;    }&#10;&#10;    # Helper function to safely extract value from Pint quantities or regular values&#10;    def extract_value(val):&#10;        &quot;&quot;&quot;Extract numerical value from Pint quantities or regular values&quot;&quot;&quot;&#10;        try:&#10;            # Check if value has a 'magnitude' attribute (Pint Quantity)&#10;            if hasattr(val, 'magnitude'):&#10;                return float(val.magnitude)&#10;            # For numpy types&#10;            elif isinstance(val, (np.number, np.ndarray, np.matrix)):&#10;                return float(val)&#10;            else:&#10;                return float(val)&#10;        except Exception as e:&#10;            print(f&quot;Error extracting value: {e}, using 0.0&quot;)&#10;            return 0.0&#10;&#10;    # Unit conversion helper function&#10;    def convert_unit_with_info(value, dimension):&#10;        &quot;&quot;&quot;Convert value between unit systems and return both value and unit&quot;&quot;&quot;&#10;        try:&#10;            # Determine the unit based on conversion settings&#10;            unit = display_units[dimension] if convert_to_display_units else internal_units[dimension]&#10;&#10;            # Check if value is close to zero without direct float conversion&#10;            # Handle Pint quantities properly&#10;            if hasattr(value, 'magnitude'):&#10;                magnitude = value.magnitude&#10;            else:&#10;                try:&#10;                    magnitude = float(value)&#10;                except (TypeError, ValueError):&#10;                    print(f&quot;Warning: Could not convert {value} to float, using 0&quot;)&#10;                    magnitude = 0.0&#10;&#10;            # Skip conversion for values very close to zero&#10;            if abs(magnitude) &lt; 1e-12:&#10;                return {&quot;value&quot;: 0.0, &quot;unit&quot;: unit}&#10;&#10;            # Extract the raw value&#10;            raw_value = extract_value(value)&#10;&#10;            # If conversion is requested, perform it&#10;            if convert_to_display_units:&#10;                source_unit = internal_units[dimension]&#10;                target_unit = display_units[dimension]&#10;&#10;                # Create quantity with source unit and convert to target unit&#10;                quantity = ureg.Quantity(raw_value, source_unit)&#10;                raw_value = quantity.to(target_unit).magnitude&#10;&#10;            # Return both value and unit&#10;            return {&quot;value&quot;: raw_value, &quot;unit&quot;: unit}&#10;        except Exception as e:&#10;            print(f&quot;Error converting {value} from {internal_units.get(dimension)} to {display_units.get(dimension)}: {e}&quot;)&#10;            unit = internal_units.get(dimension)&#10;            return {&quot;value&quot;: extract_value(value), &quot;unit&quot;: unit}&#10;&#10;    # Helper function to safely extract 6 force values from various array formats&#10;    def extract_force_values(force_array):&#10;        &quot;&quot;&quot;Extract 6 force values from various array formats with Pint support&quot;&quot;&quot;&#10;        values = [0.0] * 6&#10;&#10;        try:&#10;            # Handle Pint quantities in arrays&#10;            if hasattr(force_array, 'magnitude'):&#10;                force_array = force_array.magnitude&#10;&#10;            if isinstance(force_array, np.matrix):&#10;                array_data = np.array(force_array)&#10;                flat_data = array_data.flatten()&#10;                for i in range(min(6, len(flat_data))):&#10;                    values[i] = extract_value(flat_data[i])&#10;            elif isinstance(force_array, np.ndarray):&#10;                flat_data = force_array.flatten()&#10;                for i in range(min(6, len(flat_data))):&#10;                    values[i] = extract_value(flat_data[i])&#10;            elif hasattr(force_array, '__iter__'):&#10;                for i, val in enumerate(force_array):&#10;                    if i &gt;= 6: break&#10;                    values[i] = extract_value(val)&#10;            else:&#10;                # Single value or unknown type&#10;                values[0] = extract_value(force_array)&#10;&#10;            return values&#10;        except Exception as e:&#10;            print(f&quot;Error extracting force values: {e}&quot;)&#10;            return values&#10;&#10;    # Get all load combination names if not specified&#10;    if load_cases is None:&#10;        load_cases = set()&#10;        for node in structure.nodes:&#10;            if hasattr(node, 'displacements'):&#10;                load_cases.update(node.displacements.keys())&#10;        load_cases = list(load_cases)&#10;        print(f&quot;Found {len(load_cases)} load cases: {load_cases}&quot;)&#10;    # Handle case where LoadCombo objects are passed instead of names&#10;    elif all(hasattr(lc, 'name') for lc in load_cases):&#10;        load_cases = [lc.name for lc in load_cases]&#10;&#10;    # Extract node results&#10;    print(f&quot;Processing {len(structure.nodes)} nodes&quot;)&#10;    for node in structure.nodes:&#10;        node_data = {&#10;            &quot;coordinates&quot;: {&#10;                &quot;x&quot;: convert_unit_with_info(node.x, &quot;length&quot;),&#10;                &quot;y&quot;: convert_unit_with_info(node.y, &quot;length&quot;)&#10;            },&#10;            &quot;restraints&quot;: [int(r) for r in node.restraints] if hasattr(node, 'restraints') else [0, 0, 0],&#10;            &quot;displacements&quot;: {},&#10;            &quot;reactions&quot;: {}&#10;        }&#10;&#10;        # Add displacements for each load combo&#10;        if hasattr(node, 'displacements'):&#10;            for lc in load_cases:&#10;                if lc in node.displacements:&#10;                    node_data[&quot;displacements&quot;][lc] = {&#10;                        &quot;ux&quot;: convert_unit_with_info(node.displacements[lc][0], &quot;length&quot;),&#10;                        &quot;uy&quot;: convert_unit_with_info(node.displacements[lc][1], &quot;length&quot;),&#10;                        &quot;rz&quot;: convert_unit_with_info(node.displacements[lc][2], &quot;rotation&quot;)&#10;                    }&#10;&#10;        # Add reactions for each load combo&#10;        if hasattr(node, 'reactions'):&#10;            for lc in load_cases:&#10;                if lc in node.reactions:&#10;                    node_data[&quot;reactions&quot;][lc] = {&#10;                        &quot;rx&quot;: convert_unit_with_info(node.reactions[lc][0], &quot;force&quot;),&#10;                        &quot;ry&quot;: convert_unit_with_info(node.reactions[lc][1], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(node.reactions[lc][2], &quot;moment&quot;)&#10;                    }&#10;&#10;        results[&quot;nodes&quot;][str(node.uid)] = node_data&#10;&#10;    # Extract member results&#10;    print(f&quot;Processing {len(structure.members)} members&quot;)&#10;    for member in structure.members:&#10;        member_data = {&#10;            &quot;connectivity&quot;: {&#10;                &quot;i_node&quot;: int(member.inode.uid),&#10;                &quot;j_node&quot;: int(member.jnode.uid)&#10;            },&#10;            &quot;properties&quot;: {&#10;                &quot;length&quot;: convert_unit_with_info(member.length, &quot;length&quot;),&#10;                &quot;type&quot;: member.type if hasattr(member, 'type') else &quot;FRAME&quot;&#10;            },&#10;            &quot;forces&quot;: {}&#10;        }&#10;&#10;        # Add material and section properties&#10;        if hasattr(member, 'material'):&#10;            member_data[&quot;properties&quot;][&quot;material&quot;] = {&#10;                &quot;id&quot;: str(member.material.uid),&#10;                &quot;E&quot;: convert_unit_with_info(member.material.E, &quot;pressure&quot;)&#10;            }&#10;&#10;        if hasattr(member, 'section'):&#10;            member_data[&quot;properties&quot;][&quot;section&quot;] = {&#10;                &quot;id&quot;: str(member.section.uid),&#10;                &quot;area&quot;: convert_unit_with_info(member.section.Area, &quot;area&quot;),&#10;                &quot;Ixx&quot;: convert_unit_with_info(member.section.Ixx, &quot;moment_of_inertia&quot;)&#10;            }&#10;&#10;        # Add member hinges if applicable&#10;        if hasattr(member, 'hinges'):&#10;            member_data[&quot;properties&quot;][&quot;hinges&quot;] = [int(h) for h in member.hinges]&#10;&#10;        # Add forces for each load combo&#10;        for lc in load_cases:&#10;            # Process member forces if available&#10;            if hasattr(member, 'member_forces') and lc in member.member_forces:&#10;                forces = member.member_forces[lc]&#10;                force_values = extract_force_values(forces)&#10;&#10;                member_data[&quot;forces&quot;][lc] = {&#10;                    &quot;local&quot;: {&#10;                        &quot;i_node&quot;: {&#10;                            &quot;fx&quot;: convert_unit_with_info(force_values[0], &quot;force&quot;),&#10;                            &quot;fy&quot;: convert_unit_with_info(force_values[1], &quot;force&quot;),&#10;                            &quot;mz&quot;: convert_unit_with_info(force_values[2], &quot;moment&quot;)&#10;                        },&#10;                        &quot;j_node&quot;: {&#10;                            &quot;fx&quot;: convert_unit_with_info(force_values[3], &quot;force&quot;),&#10;                            &quot;fy&quot;: convert_unit_with_info(force_values[4], &quot;force&quot;),&#10;                            &quot;mz&quot;: convert_unit_with_info(force_values[5], &quot;moment&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;            # Add global forces if available&#10;            if hasattr(member, 'end_forces_global') and lc in member.end_forces_global:&#10;                forces_global = member.end_forces_global[lc]&#10;                global_values = extract_force_values(forces_global)&#10;&#10;                if &quot;forces&quot; not in member_data:&#10;                    member_data[&quot;forces&quot;] = {}&#10;                if lc not in member_data[&quot;forces&quot;]:&#10;                    member_data[&quot;forces&quot;][lc] = {}&#10;&#10;                member_data[&quot;forces&quot;][lc][&quot;global&quot;] = {&#10;                    &quot;i_node&quot;: {&#10;                        &quot;fx&quot;: convert_unit_with_info(global_values[0], &quot;force&quot;),&#10;                        &quot;fy&quot;: convert_unit_with_info(global_values[1], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(global_values[2], &quot;moment&quot;)&#10;                    },&#10;                    &quot;j_node&quot;: {&#10;                        &quot;fx&quot;: convert_unit_with_info(global_values[3], &quot;force&quot;),&#10;                        &quot;fy&quot;: convert_unit_with_info(global_values[4], &quot;force&quot;),&#10;                        &quot;mz&quot;: convert_unit_with_info(global_values[5], &quot;moment&quot;)&#10;                    }&#10;                }&#10;&#10;            # Add distributed results if available&#10;            try:&#10;                # Only proceed if the member has generated these functions&#10;                if (hasattr(member, 'A') and lc in member.A and&#10;                    hasattr(member, 'Vy') and lc in member.Vy and&#10;                    hasattr(member, 'Mz') and lc in member.Mz):&#10;&#10;                    ax_func = member.A[lc]&#10;                    vy_func = member.Vy[lc]&#10;                    mz_func = member.Mz[lc]&#10;&#10;                    if ax_func and vy_func and mz_func:&#10;                        num_points = 21  # Number of points to sample along the member&#10;                        length = extract_value(member.length)&#10;                        x_vals = [length * i / (num_points - 1) for i in range(num_points)]&#10;&#10;                        if lc not in member_data[&quot;forces&quot;]:&#10;                            member_data[&quot;forces&quot;][lc] = {}&#10;&#10;                        member_data[&quot;forces&quot;][lc][&quot;distributed&quot;] = {&#10;                            &quot;positions&quot;: [convert_unit_with_info(x, &quot;length&quot;) for x in x_vals],&#10;                            &quot;axial&quot;: [convert_unit_with_info(ax_func.evaluate(x), &quot;force&quot;) for x in x_vals],&#10;                            &quot;shear&quot;: [convert_unit_with_info(vy_func.evaluate(x), &quot;force&quot;) for x in x_vals],&#10;                            &quot;moment&quot;: [convert_unit_with_info(mz_func.evaluate(x), &quot;moment&quot;) for x in x_vals]&#10;                        }&#10;&#10;                        # Add extreme moment values if available&#10;                        if hasattr(member, 'Mzextremes'):&#10;                            try:&#10;                                extremes = member.Mzextremes(lc)&#10;                                if extremes:&#10;                                    member_data[&quot;forces&quot;][lc][&quot;extremes&quot;] = {&#10;                                        &quot;max_moment&quot;: {&#10;                                            &quot;position&quot;: convert_unit_with_info(extremes[&quot;MaxM&quot;][0], &quot;length&quot;),&#10;                                            &quot;value&quot;: convert_unit_with_info(extremes[&quot;MaxM&quot;][1], &quot;moment&quot;)&#10;                                        },&#10;                                        &quot;min_moment&quot;: {&#10;                                            &quot;position&quot;: convert_unit_with_info(extremes[&quot;MinM&quot;][0], &quot;length&quot;),&#10;                                            &quot;value&quot;: convert_unit_with_info(extremes[&quot;MinM&quot;][1], &quot;moment&quot;)&#10;                                        }&#10;                                    }&#10;                            except Exception as e:&#10;                                print(f&quot;Error calculating moment extremes for member {member.uid}: {e}&quot;)&#10;            except Exception as e:&#10;                print(f&quot;Could not generate distributed results for member {member.uid}: {e}&quot;)&#10;&#10;        results[&quot;members&quot;][str(member.uid)] = member_data&#10;&#10;    # Create directory if it doesn't exist&#10;    os.makedirs(os.path.dirname(os.path.abspath(output_file)), exist_ok=True)&#10;&#10;    # Write to JSON file&#10;    print(f&quot;Writing results to {output_file}&quot;)&#10;    with open(output_file, 'w') as f:&#10;        json.dump(results, f, indent=2)&#10;&#10;    print(f&quot;Results successfully exported to {output_file}&quot;)&#10;    return output_file&#10;&#10;def convert_unit_with_info(value):&#10;    &quot;&quot;&quot;&#10;    Convert a value to JSON-serializable format, handling unit information.&#10;    &#10;    Parameters&#10;    ----------&#10;    value : pint.Quantity or scalar&#10;        Value to convert&#10;        &#10;    Returns&#10;    -------&#10;    dict or scalar&#10;        JSON-serializable representation&#10;    &quot;&quot;&quot;&#10;    import pyMAOS&#10;    from pyMAOS.quantity_utils import convert_registry&#10;    &#10;    # Ensure value uses global registry if it's a quantity&#10;    if hasattr(value, '_REGISTRY') and hasattr(value, 'magnitude'):&#10;        value = convert_registry(value, pyMAOS.unit_manager.ureg)&#10;    &#10;    # Check for pint Quantity with units&#10;    if hasattr(value, 'magnitude') and hasattr(value, 'units'):&#10;        # Get numeric value&#10;        magnitude = value.magnitude&#10;        &#10;        # Handle very small values to avoid dimension errors&#10;        if abs(magnitude) &lt; 1e-12:&#10;            magnitude = 0&#10;        &#10;        # Return unit information &#10;        return {&#10;            'value': magnitude,&#10;            'unit': str(value.units),&#10;            'dimension': str(value.dimensionality)&#10;        }&#10;    else:&#10;        # Return scalar value as is&#10;        return value" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>