<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Stairways/cantilevered_stairway_LR.JSON">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Stairways/cantilevered_stairway_LR.JSON" />
              <option name="updatedContent" value="{&#10;    &quot;design_parameters&quot;: {&#10;        &quot;name&quot;: &quot;Cantilevered Stairway Left to Right&quot;,&#10;        &quot;author&quot;: &quot;Structural Design Assistant&quot;,&#10;        &quot;description&quot;: &quot;Stairway descending left to right, attached to wall on back side&quot;&#10;    },&#10;&#10;    &quot;units&quot;: {&#10;        &quot;force&quot;: &quot;kip&quot;,&#10;        &quot;length&quot;: &quot;ft&quot;,&#10;        &quot;pressure&quot;: &quot;ksi&quot;&#10;    },&#10;&#10;    &quot;nodes&quot;: [&#10;        {&quot;id&quot;: 1, &quot;x&quot;: &quot;0 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;        {&quot;id&quot;: 2, &quot;x&quot;: &quot;0 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;        {&quot;id&quot;: 3, &quot;x&quot;: &quot;5 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;        {&quot;id&quot;: 4, &quot;x&quot;: &quot;5 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;&#10;        {&quot;id&quot;: 5, &quot;x&quot;: &quot;5 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;        {&quot;id&quot;: 6, &quot;x&quot;: &quot;5 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;7 ft&quot;},&#10;        {&quot;id&quot;: 7, &quot;x&quot;: &quot;6.67 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;6.42 ft&quot;},&#10;        {&quot;id&quot;: 8, &quot;x&quot;: &quot;6.67 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;6.42 ft&quot;},&#10;        {&quot;id&quot;: 9, &quot;x&quot;: &quot;8.33 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;5.83 ft&quot;},&#10;        {&quot;id&quot;: 10, &quot;x&quot;: &quot;8.33 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;5.83 ft&quot;},&#10;        {&quot;id&quot;: 11, &quot;x&quot;: &quot;10 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;5.25 ft&quot;},&#10;        {&quot;id&quot;: 12, &quot;x&quot;: &quot;10 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;5.25 ft&quot;},&#10;        {&quot;id&quot;: 13, &quot;x&quot;: &quot;11.67 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;4.67 ft&quot;},&#10;        {&quot;id&quot;: 14, &quot;x&quot;: &quot;11.67 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;4.67 ft&quot;},&#10;        {&quot;id&quot;: 15, &quot;x&quot;: &quot;13.33 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;4.08 ft&quot;},&#10;        {&quot;id&quot;: 16, &quot;x&quot;: &quot;13.33 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;4.08 ft&quot;},&#10;        {&quot;id&quot;: 17, &quot;x&quot;: &quot;15 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;3.5 ft&quot;},&#10;        {&quot;id&quot;: 18, &quot;x&quot;: &quot;15 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;3.5 ft&quot;},&#10;        {&quot;id&quot;: 19, &quot;x&quot;: &quot;16.67 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;2.92 ft&quot;},&#10;        {&quot;id&quot;: 20, &quot;x&quot;: &quot;16.67 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;2.92 ft&quot;},&#10;        {&quot;id&quot;: 21, &quot;x&quot;: &quot;18.33 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;2.33 ft&quot;},&#10;        {&quot;id&quot;: 22, &quot;x&quot;: &quot;18.33 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;2.33 ft&quot;},&#10;        {&quot;id&quot;: 23, &quot;x&quot;: &quot;20 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;1.75 ft&quot;},&#10;        {&quot;id&quot;: 24, &quot;x&quot;: &quot;20 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;1.75 ft&quot;},&#10;        {&quot;id&quot;: 25, &quot;x&quot;: &quot;21.67 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;1.17 ft&quot;},&#10;        {&quot;id&quot;: 26, &quot;x&quot;: &quot;21.67 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;1.17 ft&quot;},&#10;        {&quot;id&quot;: 27, &quot;x&quot;: &quot;23.33 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;0.58 ft&quot;},&#10;        {&quot;id&quot;: 28, &quot;x&quot;: &quot;23.33 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;0.58 ft&quot;},&#10;&#10;        {&quot;id&quot;: 29, &quot;x&quot;: &quot;25 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;0 ft&quot;},&#10;        {&quot;id&quot;: 30, &quot;x&quot;: &quot;25 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;0 ft&quot;},&#10;        {&quot;id&quot;: 31, &quot;x&quot;: &quot;30 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;0 ft&quot;},&#10;        {&quot;id&quot;: 32, &quot;x&quot;: &quot;30 ft&quot;, &quot;y&quot;: &quot;4 ft&quot;, &quot;z&quot;: &quot;0 ft&quot;},&#10;        {&quot;id&quot;: 33, &quot;x&quot;: &quot;0 ft&quot;, &quot;y&quot;: &quot;0 ft&quot;, &quot;z&quot;: &quot;0 ft&quot;}&#10;    ],&#10;    &#10;    &quot;supports&quot;: [&#10;        {&quot;node&quot;: 2, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 6, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 10, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 14, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 18, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 22, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 26, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 30, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 31, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 32, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0},&#10;        {&quot;node&quot;: 33, &quot;ux&quot;: 1, &quot;uy&quot;: 1, &quot;uz&quot;: 1, &quot;rx&quot;: 0, &quot;ry&quot;: 0, &quot;rz&quot;: 0}&#10;    ],&#10;&#10;    &quot;members&quot;: [&#10;        {&quot;id&quot;: 1, &quot;i_node&quot;: 1, &quot;j_node&quot;: 2, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 2, &quot;i_node&quot;: 3, &quot;j_node&quot;: 4, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 3, &quot;i_node&quot;: 1, &quot;j_node&quot;: 3, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 4, &quot;i_node&quot;: 2, &quot;j_node&quot;: 4, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;&#10;        {&quot;id&quot;: 5, &quot;i_node&quot;: 5, &quot;j_node&quot;: 7, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 6, &quot;i_node&quot;: 7, &quot;j_node&quot;: 9, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 7, &quot;i_node&quot;: 9, &quot;j_node&quot;: 11, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 8, &quot;i_node&quot;: 11, &quot;j_node&quot;: 13, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 9, &quot;i_node&quot;: 13, &quot;j_node&quot;: 15, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 10, &quot;i_node&quot;: 15, &quot;j_node&quot;: 17, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 11, &quot;i_node&quot;: 17, &quot;j_node&quot;: 19, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 12, &quot;i_node&quot;: 19, &quot;j_node&quot;: 21, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 13, &quot;i_node&quot;: 21, &quot;j_node&quot;: 23, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 14, &quot;i_node&quot;: 23, &quot;j_node&quot;: 25, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 15, &quot;i_node&quot;: 25, &quot;j_node&quot;: 27, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 16, &quot;i_node&quot;: 27, &quot;j_node&quot;: 29, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;&#10;        {&quot;id&quot;: 17, &quot;i_node&quot;: 6, &quot;j_node&quot;: 8, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 18, &quot;i_node&quot;: 8, &quot;j_node&quot;: 10, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 19, &quot;i_node&quot;: 10, &quot;j_node&quot;: 12, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 20, &quot;i_node&quot;: 12, &quot;j_node&quot;: 14, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 21, &quot;i_node&quot;: 14, &quot;j_node&quot;: 16, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 22, &quot;i_node&quot;: 16, &quot;j_node&quot;: 18, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 23, &quot;i_node&quot;: 18, &quot;j_node&quot;: 20, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 24, &quot;i_node&quot;: 20, &quot;j_node&quot;: 22, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 25, &quot;i_node&quot;: 22, &quot;j_node&quot;: 24, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 26, &quot;i_node&quot;: 24, &quot;j_node&quot;: 26, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 27, &quot;i_node&quot;: 26, &quot;j_node&quot;: 28, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 28, &quot;i_node&quot;: 28, &quot;j_node&quot;: 30, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;&#10;        {&quot;id&quot;: 29, &quot;i_node&quot;: 5, &quot;j_node&quot;: 6, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 30, &quot;i_node&quot;: 7, &quot;j_node&quot;: 8, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 31, &quot;i_node&quot;: 9, &quot;j_node&quot;: 10, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 32, &quot;i_node&quot;: 11, &quot;j_node&quot;: 12, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 33, &quot;i_node&quot;: 13, &quot;j_node&quot;: 14, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 34, &quot;i_node&quot;: 15, &quot;j_node&quot;: 16, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 35, &quot;i_node&quot;: 17, &quot;j_node&quot;: 18, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 36, &quot;i_node&quot;: 19, &quot;j_node&quot;: 20, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 37, &quot;i_node&quot;: 21, &quot;j_node&quot;: 22, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 38, &quot;i_node&quot;: 23, &quot;j_node&quot;: 24, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 39, &quot;i_node&quot;: 25, &quot;j_node&quot;: 26, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 40, &quot;i_node&quot;: 27, &quot;j_node&quot;: 28, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;&#10;        {&quot;id&quot;: 41, &quot;i_node&quot;: 29, &quot;j_node&quot;: 31, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 42, &quot;i_node&quot;: 30, &quot;j_node&quot;: 32, &quot;material&quot;: 1, &quot;section&quot;: 1},&#10;        {&quot;id&quot;: 43, &quot;i_node&quot;: 29, &quot;j_node&quot;: 30, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;        {&quot;id&quot;: 44, &quot;i_node&quot;: 31, &quot;j_node&quot;: 32, &quot;material&quot;: 1, &quot;section&quot;: 2},&#10;&#10;        {&quot;id&quot;: 45, &quot;i_node&quot;: 33, &quot;j_node&quot;: 3, &quot;material&quot;: 1, &quot;section&quot;: 5},&#10;        &#10;        {&quot;id&quot;: 46, &quot;i_node&quot;: 5, &quot;j_node&quot;: 10, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 47, &quot;i_node&quot;: 6, &quot;j_node&quot;: 9, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 48, &quot;i_node&quot;: 11, &quot;j_node&quot;: 16, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 49, &quot;i_node&quot;: 12, &quot;j_node&quot;: 15, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 50, &quot;i_node&quot;: 17, &quot;j_node&quot;: 22, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 51, &quot;i_node&quot;: 18, &quot;j_node&quot;: 21, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 52, &quot;i_node&quot;: 23, &quot;j_node&quot;: 28, &quot;material&quot;: 1, &quot;section&quot;: 4},&#10;        {&quot;id&quot;: 53, &quot;i_node&quot;: 24, &quot;j_node&quot;: 27, &quot;material&quot;: 1, &quot;section&quot;: 4}&#10;    ],&#10;&#10;    &quot;member_loads&quot;: [&#10;        {&quot;member_uid&quot;: 1, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 2, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 3, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;5 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 4, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;5 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        &#10;        {&quot;member_uid&quot;: 29, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 30, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 31, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 32, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 33, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 34, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 35, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 36, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 37, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 38, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 39, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 40, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.15 kip/ft&quot;, &quot;wj&quot;: &quot;-0.15 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        &#10;        {&quot;member_uid&quot;: 43, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;},&#10;        {&quot;member_uid&quot;: 44, &quot;load_type&quot;: 3, &quot;wi&quot;: &quot;-0.1 kip/ft&quot;, &quot;wj&quot;: &quot;-0.1 kip/ft&quot;, &quot;a&quot;: &quot;0 ft&quot;, &quot;b&quot;: &quot;4 ft&quot;, &quot;case&quot;: &quot;L&quot;}&#10;    ],&#10;&#10;    &quot;sections&quot;: [&#10;        {&quot;id&quot;: 1, &quot;area&quot;: &quot;7.65 in^2&quot;, &quot;r&quot;: &quot;4.91 in&quot;},&#10;        {&quot;id&quot;: 2, &quot;area&quot;: &quot;5.61 in^2&quot;, &quot;r&quot;: &quot;3.02 in&quot;},&#10;        {&quot;id&quot;: 3, &quot;area&quot;: &quot;4.44 in^2&quot;, &quot;r&quot;: &quot;2.48 in&quot;},&#10;        {&quot;id&quot;: 4, &quot;area&quot;: &quot;3.75 in^2&quot;, &quot;r&quot;: &quot;1.22 in&quot;},&#10;        {&quot;id&quot;: 5, &quot;area&quot;: &quot;10.3 in^2&quot;, &quot;r&quot;: &quot;4.19 in&quot;}&#10;    ],&#10;    &#10;    &quot;materials&quot;: [&#10;        {&#10;            &quot;id&quot;: 1,&#10;            &quot;type&quot;: &quot;isotropic&quot;,&#10;            &quot;E&quot;: &quot;29000 ksi&quot;,&#10;            &quot;G&quot;: &quot;11500 ksi&quot;,&#10;            &quot;nu&quot;: 0.27,&#10;            &quot;rho&quot;: &quot;0.000284 kip/in^3&quot;,&#10;            &quot;alpha&quot;: &quot;0.0000065 1/F&quot;&#10;        }&#10;    ]&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Stairways/run_stairway.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Stairways/run_stairway.py" />
              <option name="originalContent" value="# Can you make a stairway ascending right to left? It is attached to a wall on the back side (when ascending, the wall is to your right). It starts and ends with a landing area. The left landing area (the upper part of the staircase) is supported by a column on the front side besides being attachd to the wall at the back side. I give you the Pratt Space Truss as a hint.&#10;&#10;import yaml&#10;import matplotlib.pyplot as plt&#10;from mpl_toolkits.mplot3d import Axes3D&#10;import numpy as np&#10;&#10;# Create the stairway structure&#10;# load JSON file&#10;stairway_data =&#10;&#10;# Stairway parameters&#10;num_steps = 12&#10;step_rise = 7.0 / 12.0  # 7 inches in feet&#10;step_run = 10.0 / 12.0  # 10 inches in feet&#10;step_width = 4.0  # 4 feet wide&#10;landing_length = 5.0  # 5 feet landing on each end&#10;wall_offset = 0.5  # Distance from wall to stringer&#10;&#10;# Generate nodes&#10;node_id = 1&#10;&#10;# Lower landing nodes (right side, z=0)&#10;lower_landing_nodes = []&#10;for x in [0, landing_length]:&#10;    for y in [0, step_width]:&#10;        stairway_data['nodes'].append({&#10;            'id': node_id,&#10;            'x': f'{x} ft',&#10;            'y': f'{y} ft',&#10;            'z': '0 ft'&#10;        })&#10;        lower_landing_nodes.append(node_id)&#10;        node_id += 1&#10;&#10;# Stair nodes&#10;stair_front_nodes = []&#10;stair_back_nodes = []&#10;for i in range(num_steps + 1):&#10;    x = landing_length + i * step_run&#10;    z = i * step_rise&#10;&#10;    # Front edge (y=0)&#10;    stairway_data['nodes'].append({&#10;        'id': node_id,&#10;        'x': f'{x} ft',&#10;        'y': '0 ft',&#10;        'z': f'{z} ft'&#10;    })&#10;    stair_front_nodes.append(node_id)&#10;    node_id += 1&#10;&#10;    # Back edge (y=step_width)&#10;    stairway_data['nodes'].append({&#10;        'id': node_id,&#10;        'x': f'{x} ft',&#10;        'y': f'{step_width} ft',&#10;        'z': f'{z} ft'&#10;    })&#10;    stair_back_nodes.append(node_id)&#10;    node_id += 1&#10;&#10;# Upper landing nodes (left side)&#10;upper_z = num_steps * step_rise&#10;upper_x_start = landing_length + num_steps * step_run&#10;upper_landing_nodes = []&#10;for x in [upper_x_start, upper_x_start + landing_length]:&#10;    for y in [0, step_width]:&#10;        stairway_data['nodes'].append({&#10;            'id': node_id,&#10;            'x': f'{x} ft',&#10;            'y': f'{y} ft',&#10;            'z': f'{upper_z} ft'&#10;        })&#10;        upper_landing_nodes.append(node_id)&#10;        node_id += 1&#10;&#10;# Column support node at upper landing front corner&#10;column_base_node = node_id&#10;stairway_data['nodes'].append({&#10;    'id': node_id,&#10;    'x': f'{upper_x_start + landing_length} ft',&#10;    'y': '0 ft',&#10;    'z': '0 ft'&#10;})&#10;node_id += 1&#10;&#10;# Define supports&#10;# Wall supports on back side (y=step_width)&#10;# Lower landing wall support&#10;stairway_data['supports'].append({&#10;    'node': lower_landing_nodes[1],  # Back corner of lower landing&#10;    'ux': 1, 'uy': 1, 'uz': 1,&#10;    'rx': 0, 'ry': 0, 'rz': 0&#10;})&#10;&#10;# Wall supports along stairs (every 3rd step)&#10;for i in range(0, len(stair_back_nodes), 3):&#10;    stairway_data['supports'].append({&#10;        'node': stair_back_nodes[i],&#10;        'ux': 1, 'uy': 1, 'uz': 1,&#10;        'rx': 0, 'ry': 0, 'rz': 0&#10;    })&#10;&#10;# Upper landing wall support&#10;stairway_data['supports'].append({&#10;    'node': upper_landing_nodes[3],  # Back corner of upper landing&#10;    'ux': 1, 'uy': 1, 'uz': 1,&#10;    'rx': 0, 'ry': 0, 'rz': 0&#10;})&#10;&#10;# Column base support&#10;stairway_data['supports'].append({&#10;    'node': column_base_node,&#10;    'ux': 1, 'uy': 1, 'uz': 1,&#10;    'rx': 0, 'ry': 0, 'rz': 0&#10;})&#10;&#10;# Generate members&#10;member_id = 1&#10;&#10;# Lower landing frame&#10;# Longitudinal members&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': lower_landing_nodes[0],&#10;    'j_node': lower_landing_nodes[2],&#10;    'material': 1,&#10;    'section': 1&#10;})&#10;member_id += 1&#10;&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': lower_landing_nodes[1],&#10;    'j_node': lower_landing_nodes[3],&#10;    'material': 1,&#10;    'section': 1&#10;})&#10;member_id += 1&#10;&#10;# Transverse members&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': lower_landing_nodes[0],&#10;    'j_node': lower_landing_nodes[1],&#10;    'material': 1,&#10;    'section': 2&#10;})&#10;member_id += 1&#10;&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': lower_landing_nodes[2],&#10;    'j_node': lower_landing_nodes[3],&#10;    'material': 1,&#10;    'section': 2&#10;})&#10;member_id += 1&#10;&#10;# Main stringers along stairs&#10;# Front stringer&#10;for i in range(len(stair_front_nodes) - 1):&#10;    stairway_data['members'].append({&#10;        'id': member_id,&#10;        'i_node': stair_front_nodes[i],&#10;        'j_node': stair_front_nodes[i + 1],&#10;        'material': 1,&#10;        'section': 1&#10;    })&#10;    member_id += 1&#10;&#10;# Back stringer&#10;for i in range(len(stair_back_nodes) - 1):&#10;    stairway_data['members'].append({&#10;        'id': member_id,&#10;        'i_node': stair_back_nodes[i],&#10;        'j_node': stair_back_nodes[i + 1],&#10;        'material': 1,&#10;        'section': 1&#10;    })&#10;    member_id += 1&#10;&#10;# Step/tread members&#10;for i in range(len(stair_front_nodes)):&#10;    stairway_data['members'].append({&#10;        'id': member_id,&#10;        'i_node': stair_front_nodes[i],&#10;        'j_node': stair_back_nodes[i],&#10;        'material': 1,&#10;        'section': 2&#10;    })&#10;    member_id += 1&#10;&#10;# Connect lower landing to stairs&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': lower_landing_nodes[2],&#10;    'j_node': stair_front_nodes[0],&#10;    'material': 1,&#10;    'section': 1&#10;})&#10;member_id += 1&#10;&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': lower_landing_nodes[3],&#10;    'j_node': stair_back_nodes[0],&#10;    'material': 1,&#10;    'section': 1&#10;})&#10;member_id += 1&#10;&#10;# Upper landing frame&#10;# Longitudinal members&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': upper_landing_nodes[0],&#10;    'j_node': upper_landing_nodes[2],&#10;    'material': 1,&#10;    'section': 1&#10;})&#10;member_id += 1&#10;&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': upper_landing_nodes[1],&#10;    'j_node': upper_landing_nodes[3],&#10;    'material': 1,&#10;    'section': 1&#10;})&#10;member_id += 1&#10;&#10;# Transverse members&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': upper_landing_nodes[0],&#10;    'j_node': upper_landing_nodes[1],&#10;    'material': 1,&#10;    'section': 2&#10;})&#10;member_id += 1&#10;&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': upper_landing_nodes[2],&#10;    'j_node': upper_landing_nodes[3],&#10;    'material': 1,&#10;    'section': 2&#10;})&#10;member_id += 1&#10;&#10;# Connect stairs to upper landing&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': stair_front_nodes[-1],&#10;    'j_node': upper_landing_nodes[0],&#10;    'material': 1,&#10;    'section': 1&#10;})&#10;member_id += 1&#10;&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': stair_back_nodes[-1],&#10;    'j_node': upper_landing_nodes[1],&#10;    'material': 1,&#10;    'section': 1&#10;})&#10;member_id += 1&#10;&#10;# Column support&#10;stairway_data['members'].append({&#10;    'id': member_id,&#10;    'i_node': column_base_node,&#10;    'j_node': upper_landing_nodes[2],&#10;    'material': 1,&#10;    'section': 5&#10;})&#10;member_id += 1&#10;&#10;# Add diagonal bracing under stairs for stability&#10;for i in range(0, len(stair_front_nodes) - 2, 2):&#10;    # Diagonal from front to back&#10;    stairway_data['members'].append({&#10;        'id': member_id,&#10;        'i_node': stair_front_nodes[i],&#10;        'j_node': stair_back_nodes[i + 2],&#10;        'material': 1,&#10;        'section': 4&#10;    })&#10;    member_id += 1&#10;&#10;    # Diagonal from back to front&#10;    stairway_data['members'].append({&#10;        'id': member_id,&#10;        'i_node': stair_back_nodes[i],&#10;        'j_node': stair_front_nodes[i + 2],&#10;        'material': 1,&#10;        'section': 4&#10;    })&#10;    member_id += 1&#10;&#10;# Add member loads (live load on steps and landings)&#10;# Lower landing loads&#10;for i in range(4):&#10;    stairway_data['member_loads'].append({&#10;        'member_uid': i + 1,&#10;        'load_type': 3,&#10;        'wi': '-0.1 kip/ft',&#10;        'wj': '-0.1 kip/ft',&#10;        'a': '0 ft',&#10;        'b': f'{landing_length if i &lt; 2 else step_width} ft',&#10;        'case': 'L'&#10;    })&#10;&#10;# Step loads&#10;step_member_start = len(stair_front_nodes) + len(stair_back_nodes) - 2 + 5&#10;for i in range(len(stair_front_nodes)):&#10;    stairway_data['member_loads'].append({&#10;        'member_uid': step_member_start + i,&#10;        'load_type': 3,&#10;        'wi': '-0.15 kip/ft',&#10;        'wj': '-0.15 kip/ft',&#10;        'a': '0 ft',&#10;        'b': f'{step_width} ft',&#10;        'case': 'L'&#10;    })&#10;&#10;# Save to YAML file&#10;with open('Stairway_Space_Truss.YAML', 'w') as file:&#10;    yaml.dump(stairway_data, file, default_flow_style=False, sort_keys=False)&#10;&#10;print(&quot;Stairway structure saved to Stairway_Space_Truss.YAML&quot;)&#10;&#10;# Visualize the structure&#10;fig = plt.figure(figsize=(15, 10))&#10;ax = fig.add_subplot(111, projection='3d')&#10;&#10;# Plot members&#10;for member in stairway_data['members']:&#10;    i_node_data = next(n for n in stairway_data['nodes'] if n['id'] == member['i_node'])&#10;    j_node_data = next(n for n in stairway_data['nodes'] if n['id'] == member['j_node'])&#10;&#10;    x1 = float(i_node_data['x'].split()[0])&#10;    y1 = float(i_node_data['y'].split()[0])&#10;    z1 = float(i_node_data['z'].split()[0])&#10;    x2 = float(j_node_data['x'].split()[0])&#10;    y2 = float(j_node_data['y'].split()[0])&#10;    z2 = float(j_node_data['z'].split()[0])&#10;&#10;    section = member['section']&#10;    if section == 1:&#10;        color = 'blue'&#10;        linewidth = 2&#10;    elif section == 2:&#10;        color = 'green'&#10;        linewidth = 1.5&#10;    elif section == 5:&#10;        color = 'red'&#10;        linewidth = 3&#10;    else:&#10;        color = 'gray'&#10;        linewidth = 1&#10;&#10;    ax.plot([x1, x2], [y1, y2], [z1, z2], color=color, linewidth=linewidth)&#10;&#10;# Plot nodes&#10;for node in stairway_data['nodes']:&#10;    x = float(node['x'].split()[0])&#10;    y = float(node['y'].split()[0])&#10;    z = float(node['z'].split()[0])&#10;    ax.scatter(x, y, z, color='black', s=20)&#10;&#10;# Plot supports&#10;for support in stairway_data['supports']:&#10;    node_data = next(n for n in stairway_data['nodes'] if n['id'] == support['node'])&#10;    x = float(node_data['x'].split()[0])&#10;    y = float(node_data['y'].split()[0])&#10;    z = float(node_data['z'].split()[0])&#10;    ax.scatter(x, y, z, color='red', s=100, marker='s')&#10;&#10;ax.set_xlabel('X (ft)')&#10;ax.set_ylabel('Y (ft)')&#10;ax.set_zlabel('Z (ft)')&#10;ax.set_title('Cantilevered Stairway with Wall Support')&#10;ax.view_init(elev=20, azim=-60)&#10;&#10;plt.tight_layout()&#10;plt.savefig('Stairway_Space_Truss.png', dpi=300, bbox_inches='tight')&#10;plt.show()" />
              <option name="updatedContent" value="# Cantilevered stairway analysis - reads data from JSON file&#10;&#10;import os&#10;import json&#10;import matplotlib.pyplot as plt&#10;from mpl_toolkits.mplot3d import Axes3D&#10;import numpy as np&#10;&#10;# Load stairway structure from JSON file&#10;json_file = 'cantilevered_stairway_LR.JSON'&#10;print(f&quot;Loading stairway structure from {json_file}&quot;)&#10;&#10;with open(os.path.join(os.path.dirname(__file__), json_file), 'r') as file:&#10;    # Remove comments if present in the JSON file&#10;    json_str = &quot;&quot;&#10;    for line in file:&#10;        if '//' not in line:&#10;            json_str += line&#10;&#10;    stairway_data = json.loads(json_str)&#10;&#10;print(f&quot;Successfully loaded stairway structure: {stairway_data['design_parameters']['name']}&quot;)&#10;&#10;# Extract structure data&#10;nodes = stairway_data['nodes']&#10;supports = stairway_data['supports']&#10;members = stairway_data['members']&#10;materials = stairway_data['materials']&#10;sections = stairway_data['sections']&#10;&#10;print(f&quot;Structure contains {len(nodes)} nodes, {len(members)} members, and {len(supports)} supports&quot;)&#10;&#10;# Visualize the structure&#10;fig = plt.figure(figsize=(15, 10))&#10;ax = fig.add_subplot(111, projection='3d')&#10;&#10;# Create node dictionary for quick lookups&#10;node_dict = {}&#10;for node in nodes:&#10;    node_id = node['id']&#10;    x = float(node['x'].split()[0])&#10;    y = float(node['y'].split()[0])&#10;    z = float(node['z'].split()[0])&#10;    node_dict[node_id] = (x, y, z)&#10;&#10;# Plot members&#10;section_colors = {&#10;    1: 'blue',    # Main stringers&#10;    2: 'green',   # Steps/treads&#10;    3: 'cyan',    # Secondary members&#10;    4: 'gray',    # Bracing&#10;    5: 'red'      # Column&#10;}&#10;&#10;section_widths = {&#10;    1: 2,         # Main stringers&#10;    2: 1.5,       # Steps/treads&#10;    3: 1,         # Secondary members&#10;    4: 1,         # Bracing&#10;    5: 3          # Column&#10;}&#10;&#10;for member in members:&#10;    i_node = member['i_node']&#10;    j_node = member['j_node']&#10;    section = member['section']&#10;    &#10;    if i_node not in node_dict or j_node not in node_dict:&#10;        print(f&quot;WARNING: Member {member['id']} references non-existent node(s): {i_node}-{j_node}&quot;)&#10;        continue&#10;    &#10;    x1, y1, z1 = node_dict[i_node]&#10;    x2, y2, z2 = node_dict[j_node]&#10;    &#10;    color = section_colors.get(section, 'black')&#10;    linewidth = section_widths.get(section, 1)&#10;    &#10;    ax.plot([x1, x2], [y1, y2], [z1, z2], color=color, linewidth=linewidth)&#10;&#10;# Plot nodes&#10;for node_id, (x, y, z) in node_dict.items():&#10;    ax.scatter(x, y, z, color='black', s=20)&#10;&#10;# Plot supports with different markers&#10;for support in supports:&#10;    node_id = support['node']&#10;    if node_id not in node_dict:&#10;        print(f&quot;WARNING: Support references non-existent node: {node_id}&quot;)&#10;        continue&#10;        &#10;    x, y, z = node_dict[node_id]&#10;    &#10;    # Full support (fixed in all directions)&#10;    if support['ux'] == 1 and support['uy'] == 1 and support['uz'] == 1:&#10;        ax.scatter(x, y, z, color='red', s=100, marker='s')&#10;    # Partial support&#10;    else:&#10;        ax.scatter(x, y, z, color='orange', s=80, marker='^')&#10;&#10;# Add a wall surface to represent the back wall&#10;# Find the y value for the back of the stairway&#10;back_y = max(pos[1] for pos in node_dict.values())&#10;min_x = min(pos[0] for pos in node_dict.values())&#10;max_x = max(pos[0] for pos in node_dict.values())&#10;min_z = min(pos[2] for pos in node_dict.values())&#10;max_z = max(pos[2] for pos in node_dict.values())&#10;&#10;# Add some margin to the wall&#10;margin = 1&#10;wall_x = np.array([min_x-margin, max_x+margin])&#10;wall_z = np.array([min_z-margin, max_z+margin])&#10;wall_x_grid, wall_z_grid = np.meshgrid(wall_x, wall_z)&#10;wall_y_grid = np.ones_like(wall_x_grid) * back_y&#10;&#10;# Plot the wall with slight transparency&#10;ax.plot_surface(wall_x_grid, wall_y_grid, wall_z_grid, color='gray', alpha=0.3)&#10;&#10;# Create a legend&#10;from matplotlib.lines import Line2D&#10;legend_elements = [&#10;    Line2D([0], [0], color=section_colors[1], lw=section_widths[1], label='Main Stringers'),&#10;    Line2D([0], [0], color=section_colors[2], lw=section_widths[2], label='Steps/Treads'),&#10;    Line2D([0], [0], color=section_colors[4], lw=section_widths[4], label='Bracing'),&#10;    Line2D([0], [0], color=section_colors[5], lw=section_widths[5], label='Column'),&#10;    Line2D([0], [0], marker='s', color='w', markerfacecolor='red', markersize=10, label='Fixed Support'),&#10;    Line2D([0], [0], marker='^', color='w', markerfacecolor='orange', markersize=8, label='Partial Support')&#10;]&#10;ax.legend(handles=legend_elements, loc='upper right')&#10;&#10;# Set axis labels and title&#10;ax.set_xlabel('X (ft)')&#10;ax.set_ylabel('Y (ft)')&#10;ax.set_zlabel('Z (ft)')&#10;title = stairway_data['design_parameters']['name']&#10;ax.set_title(title)&#10;&#10;# Adjust view angle for better visualization&#10;ax.view_init(elev=20, azim=-60)&#10;&#10;# Set equal aspect ratio for a more realistic view&#10;ax.set_box_aspect([max_x-min_x, back_y+1, max_z-min_z])&#10;&#10;# Add text annotations for key structural elements&#10;ax.text(0, 0, max_z+0.5, &quot;Upper Landing&quot;, color='blue')&#10;ax.text(max_x, 0, min_z-0.5, &quot;Lower Landing&quot;, color='blue')&#10;ax.text((max_x-min_x)/2, back_y, max_z/2, &quot;Wall Support&quot;, color='black')&#10;&#10;# Save figure with better resolution&#10;output_filename = 'Stairway_Left_to_Right.png'&#10;plt.tight_layout()&#10;plt.savefig(output_filename, dpi=300, bbox_inches='tight')&#10;print(f&quot;Stairway visualization saved to {output_filename}&quot;)&#10;&#10;plt.show()&#10;&#10;# Print additional structural information&#10;print(&quot;\nStructural Information:&quot;)&#10;print(f&quot;Top landing position: x=0, z={max_z} ft&quot;)&#10;print(f&quot;Bottom landing position: x={max_x} ft, z=0 ft&quot;)&#10;print(f&quot;Stairway span: {max_x} ft horizontal, {max_z} ft vertical&quot;)&#10;print(f&quot;Number of steps: {len([m for m in members if m['section'] == 2 and 5 &lt;= m['id'] &lt;= 40])}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Stairways/run_stairway_interactive.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Stairways/run_stairway_interactive.py" />
              <option name="originalContent" value="# Interactive stairway structure visualization and editing tool&#10;&#10;import os&#10;import json&#10;import sys&#10;import re&#10;import matplotlib&#10;# Force use of TkAgg backend which has better interactive support&#10;matplotlib.use('TkAgg')&#10;import matplotlib.pyplot as plt&#10;from matplotlib.widgets import Button, RadioButtons, Slider, TextBox&#10;from mpl_toolkits.mplot3d import Axes3D&#10;import scipy as sp&#10;import numpy as np&#10;import datetime&#10;&#10;# Import proj3d for 3D to 2D projections&#10;try:&#10;    from mpl_toolkits.mplot3d import proj3d&#10;except ImportError:&#10;    print(&quot;Warning: Could not import proj3d, some 3D functions may be limited&quot;)&#10;&#10;# Global debug flag - set to True for verbose output&#10;DEBUG = True&#10;&#10;def debug_print(*args, **kwargs):&#10;    &quot;&quot;&quot;Helper function for debug printing that respects the global DEBUG flag&quot;&quot;&quot;&#10;    if DEBUG:&#10;        print(*args, **kwargs)&#10;&#10;class StairwayInteractiveVisualizer:&#10;    def __init__(self, json_file):&#10;        debug_print(f&quot;Initializing visualizer with file: {json_file}&quot;)&#10;        self.json_file = json_file&#10;        self.load_data()&#10;&#10;        # Initialize state variables&#10;        self.selected_node = None&#10;        self.selected_member = None&#10;        self.mode = 'view'  # 'view', 'move', 'add_node', 'add_member', 'delete_node', 'delete_member'&#10;&#10;        # For member creation&#10;        self.member_creation_nodes = []&#10;        self.next_member_id = max([m['id'] for m in self.members], default=0) + 1&#10;&#10;        # Create the figure and 3D axes&#10;        self.fig = plt.figure(figsize=(16, 10))&#10;        debug_print(&quot;Figure created&quot;)&#10;        self.ax = self.fig.add_subplot(111, projection='3d')&#10;        debug_print(&quot;3D axes created&quot;)&#10;&#10;        # Setup UI before connecting events&#10;        self.setup_ui()&#10;        debug_print(&quot;UI setup complete&quot;)&#10;&#10;        # Connect event handlers&#10;        debug_print(&quot;Connecting event handlers&quot;)&#10;        self.click_cid = self.fig.canvas.mpl_connect('button_press_event', self.on_click)&#10;        self.motion_cid = self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)&#10;        self.key_cid = self.fig.canvas.mpl_connect('key_press_event', self.on_key)&#10;        self.draw_cid = self.fig.canvas.mpl_connect('draw_event', self.on_draw)&#10;        debug_print(f&quot;Event handlers connected: {self.click_cid}, {self.motion_cid}, {self.key_cid}, {self.draw_cid}&quot;)&#10;&#10;        # Plot the stairway structure last&#10;        self.plot_stairway()&#10;&#10;        # Show debug message when initialization is complete&#10;        debug_print(&quot;Visualizer initialization complete&quot;)&#10;&#10;    def on_draw(self, event):&#10;        &quot;&quot;&quot;Debug handler for draw events&quot;&quot;&quot;&#10;        debug_print(&quot;Draw event occurred&quot;)&#10;&#10;    def load_data(self):&#10;        &quot;&quot;&quot;Load stairway data from JSON file&quot;&quot;&quot;&#10;        print(f&quot;Loading stairway structure from {self.json_file}&quot;)&#10;&#10;        try:&#10;            # Remove comments if present in the JSON file&#10;            with open(os.path.join(os.path.dirname(__file__), self.json_file), 'r') as file:&#10;                json_str = &quot;&quot;&#10;                for line in file:&#10;                    if '//' not in line:&#10;                        json_str += line&#10;&#10;                self.stairway_data = json.loads(json_str)&#10;&#10;            # Extract structure data&#10;            self.nodes = self.stairway_data['nodes']&#10;            self.supports = self.stairway_data['supports']&#10;            self.members = self.stairway_data['members']&#10;            self.materials = self.stairway_data.get('materials', [])&#10;            self.sections = self.stairway_data.get('sections', [])&#10;&#10;            # Create node dictionary for quick lookups&#10;            self.node_dict = {}&#10;            for node in self.nodes:&#10;                node_id = node['id']&#10;                x = float(node['x'].split()[0])&#10;                y = float(node['y'].split()[0])&#10;                z = float(node['z'].split()[0])&#10;                self.node_dict[node_id] = (x, y, z)&#10;&#10;            # Create dictionaries for materials and sections&#10;            self.material_dict = {m['id']: m for m in self.materials}&#10;            self.section_dict = {s['id']: s for s in self.sections}&#10;&#10;            # Create set of supported nodes&#10;            self.supported_nodes = {s['node'] for s in self.supports}&#10;&#10;            # Create map of connected members for each node&#10;            self.node_connections = {}&#10;            for node_id in self.node_dict:&#10;                self.node_connections[node_id] = []&#10;&#10;            for member in self.members:&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                member_id = member['id']&#10;&#10;                if i_node in self.node_connections:&#10;                    self.node_connections[i_node].append(member_id)&#10;                if j_node in self.node_connections:&#10;                    self.node_connections[j_node].append(member_id)&#10;&#10;            print(f&quot;Successfully loaded: {self.stairway_data['design_parameters']['name']}&quot;)&#10;            print(f&quot;Structure contains {len(self.nodes)} nodes, {len(self.members)} members, and {len(self.supports)} supports&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error loading JSON file: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            sys.exit(1)&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;Set up the UI elements for interactive editing&quot;&quot;&quot;&#10;        # Create a smaller subplot for buttons&#10;        self.button_area = plt.axes([0.01, 0.01, 0.20, 0.20])&#10;        self.button_area.axis('off')&#10;&#10;        # Mode selection radio buttons - add member modes&#10;        self.mode_radio_ax = plt.axes([0.01, 0.80, 0.15, 0.15])&#10;        self.mode_radio = RadioButtons(&#10;            self.mode_radio_ax,&#10;            ['View', 'Move Node', 'Add Node', 'Add Member', 'Delete Node', 'Delete Member'],&#10;            activecolor='green'&#10;        )&#10;        self.mode_radio.on_clicked(self.set_mode)&#10;&#10;        # Section selection for new members&#10;        self.section_radio_ax = plt.axes([0.01, 0.55, 0.15, 0.10])&#10;        self.section_radio = RadioButtons(&#10;            self.section_radio_ax,&#10;            ['Section 1', 'Section 2', 'Section 3', 'Section 4', 'Section 5'],&#10;            activecolor='blue'&#10;        )&#10;        self.section_radio.on_clicked(lambda label: debug_print(f&quot;Section changed to: {label}&quot;))&#10;&#10;        # Save button&#10;        self.save_button_ax = plt.axes([0.01, 0.70, 0.15, 0.05])&#10;        self.save_button = Button(self.save_button_ax, 'Save Structure')&#10;        self.save_button.on_clicked(self.save_structure)&#10;&#10;        # Reset view button&#10;        self.reset_view_ax = plt.axes([0.01, 0.65, 0.15, 0.05])&#10;        self.reset_view_button = Button(self.reset_view_ax, 'Reset View')&#10;        self.reset_view_button.on_clicked(self.reset_view)&#10;&#10;        # Information panel&#10;        self.info_ax = plt.axes([0.01, 0.05, 0.20, 0.45])&#10;        self.info_ax.axis('off')&#10;        self.info_text = self.info_ax.text(&#10;            0, 1,&#10;            &quot;Interactive Stairway Editor\n\nClick on a node to select it\n&quot;&#10;            &quot;Use the mode buttons to change actions\n&quot;&#10;            &quot;Hotkeys: v=View, m=Move, a=Add, d=Delete&quot;,&#10;            va='top'&#10;        )&#10;&#10;        # Node editor panel (initially hidden)&#10;        self.node_editor_ax = plt.axes([0.85, 0.65, 0.14, 0.30])&#10;        self.node_editor_ax.axis('off')&#10;        self.node_editor_title = self.node_editor_ax.text(0, 1.1, &quot;Node Editor&quot;, fontsize=10, weight='bold')&#10;        self.node_editor_ax.set_visible(False)&#10;&#10;        # X coordinate slider&#10;        self.x_slider_ax = plt.axes([0.87, 0.85, 0.10, 0.03])&#10;        self.x_slider = Slider(self.x_slider_ax, 'X', 0, 30, valinit=0)&#10;        self.x_slider.on_changed(self.update_node_position)&#10;        self.x_slider_ax.set_visible(False)&#10;&#10;        # Y coordinate slider&#10;        self.y_slider_ax = plt.axes([0.87, 0.80, 0.10, 0.03])&#10;        self.y_slider = Slider(self.y_slider_ax, 'Y', 0, 10, valinit=0)&#10;        self.y_slider.on_changed(self.update_node_position)&#10;        self.y_slider_ax.set_visible(False)&#10;&#10;        # Z coordinate slider&#10;        self.z_slider_ax = plt.axes([0.87, 0.75, 0.10, 0.03])&#10;        self.z_slider = Slider(self.z_slider_ax, 'Z', 0, 10, valinit=0)&#10;        self.z_slider.on_changed(self.update_node_position)&#10;        self.z_slider_ax.set_visible(False)&#10;&#10;    def set_mode(self, mode_label):&#10;        &quot;&quot;&quot;Change the current editing mode&quot;&quot;&quot;&#10;        debug_print(f&quot;\n----- Mode change: {mode_label} -----&quot;)&#10;        mode_map = {&#10;            'View': 'view',&#10;            'Move Node': 'move',&#10;            'Add Node': 'add_node',&#10;            'Add Member': 'add_member',&#10;            'Delete Node': 'delete_node',&#10;            'Delete Member': 'delete_member'&#10;        }&#10;        self.mode = mode_map[mode_label]&#10;        debug_print(f&quot;Mode changed to: {self.mode}&quot;)&#10;&#10;        # Reset state when changing modes&#10;        if self.mode == 'add_member':&#10;            self.member_creation_nodes = []&#10;            debug_print(&quot;Member creation state reset - select two nodes to create a member&quot;)&#10;        elif self.mode != 'move':&#10;            self.hide_node_editor()&#10;&#10;        # Keep appropriate selections based on mode&#10;        if self.mode.startswith('delete_node') and self.selected_member:&#10;            self.selected_member = None  # Clear member selection in node modes&#10;        elif self.mode.startswith('delete_member') and self.selected_node:&#10;            self.selected_node = None    # Clear node selection in member modes&#10;&#10;        # Handle mode-specific actions&#10;        if self.mode == 'move' and self.selected_node:&#10;            debug_print(f&quot;Showing node editor for node {self.selected_node}&quot;)&#10;            self.show_node_editor()&#10;        elif self.mode == 'delete_node' and self.selected_node:&#10;            debug_print(f&quot;Deleting node {self.selected_node}&quot;)&#10;            self.delete_node()&#10;        elif self.mode == 'delete_member' and self.selected_member:&#10;            debug_print(f&quot;Deleting member {self.selected_member}&quot;)&#10;            self.delete_member()&#10;&#10;        self.update_info_text()&#10;        self.plot_stairway()  # Redraw to show/hide appropriate elements&#10;        debug_print(&quot;Calling plt.draw() after mode change&quot;)&#10;        plt.draw()&#10;&#10;    def update_info_text(self):&#10;        &quot;&quot;&quot;Update the information panel text based on current state&quot;&quot;&quot;&#10;        info = f&quot;Mode: {self.mode.capitalize().replace('_', ' ')}\n\n&quot;&#10;&#10;        if self.mode == 'add_member':&#10;            info += f&quot;Creating new member - &quot;&#10;            if len(self.member_creation_nodes) == 0:&#10;                info += &quot;Select first node\n&quot;&#10;            elif len(self.member_creation_nodes) == 1:&#10;                info += f&quot;Node {self.member_creation_nodes[0]} selected\nSelect second node\n&quot;&#10;&#10;        if self.selected_node:&#10;            node_pos = self.node_dict[self.selected_node]&#10;            info += f&quot;Selected Node: {self.selected_node}\n&quot;&#10;            info += f&quot;Position: ({node_pos[0]:.2f}, {node_pos[1]:.2f}, {node_pos[2]:.2f})\n&quot;&#10;            info += f&quot;Connected to {len(self.node_connections[self.selected_node])} members\n&quot;&#10;&#10;            if self.selected_node in self.supported_nodes:&#10;                info += &quot;This node has support constraints\n&quot;&#10;        elif self.selected_member:&#10;            member = next((m for m in self.members if m['id'] == self.selected_member), None)&#10;            if member:&#10;                info += f&quot;Selected Member: {self.selected_member}\n&quot;&#10;                info += f&quot;Connects nodes: {member['i_node']} - {member['j_node']}\n&quot;&#10;                info += f&quot;Section: {member['section']}, Material: {member['material']}\n&quot;&#10;&#10;                # Get member length&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                if i_node in self.node_dict and j_node in self.node_dict:&#10;                    x1, y1, z1 = self.node_dict[i_node]&#10;                    x2, y2, z2 = self.node_dict[j_node]&#10;                    length = np.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)&#10;                    info += f&quot;Length: {length:.2f} ft\n&quot;&#10;&#10;        self.info_text.set_text(info)&#10;        plt.draw()&#10;&#10;    def plot_stairway(self):&#10;        &quot;&quot;&quot;Plot the stairway structure&quot;&quot;&quot;&#10;        self.ax.clear()&#10;&#10;        # Define colors and widths for different section types&#10;        section_colors = {&#10;            1: 'blue',    # Main stringers&#10;            2: 'green',   # Steps/treads&#10;            3: 'cyan',    # Secondary members&#10;            4: 'gray',    # Bracing&#10;            5: 'red'      # Column&#10;        }&#10;&#10;        section_widths = {&#10;            1: 2,         # Main stringers&#10;            2: 1.5,       # Steps/treads&#10;            3: 1,         # Secondary members&#10;            4: 1,         # Bracing&#10;            5: 3          # Column&#10;        }&#10;&#10;        # Plot members&#10;        self.member_lines = {}&#10;        for member in self.members:&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;            member_id = member['id']&#10;            section = member['section']&#10;&#10;            if i_node not in self.node_dict or j_node not in self.node_dict:&#10;                print(f&quot;WARNING: Member {member_id} references non-existent node(s): {i_node}-{j_node}&quot;)&#10;                continue&#10;&#10;            x1, y1, z1 = self.node_dict[i_node]&#10;            x2, y2, z2 = self.node_dict[j_node]&#10;&#10;            color = section_colors.get(section, 'black')&#10;            linewidth = section_widths.get(section, 1)&#10;&#10;            # Highlight selected member&#10;            if member_id == self.selected_member:&#10;                color = 'red'&#10;                linewidth += 1&#10;&#10;            line = self.ax.plot([x1, x2], [y1, y2], [z1, z2],&#10;                          color=color, linewidth=linewidth)[0]&#10;            self.member_lines[member_id] = line&#10;&#10;        # Plot nodes&#10;        self.node_points = {}&#10;        for node_id, (x, y, z) in self.node_dict.items():&#10;            # Different marker for nodes in the member creation process&#10;            if node_id in self.member_creation_nodes:&#10;                point = self.ax.scatter(x, y, z, color='blue', s=60, marker='o', edgecolors='black')&#10;            else:&#10;                point = self.ax.scatter(x, y, z, color='black', s=20)&#10;            self.node_points[node_id] = point&#10;&#10;        # Plot supports&#10;        for support in self.supports:&#10;            node_id = support['node']&#10;            if node_id not in self.node_dict:&#10;                print(f&quot;WARNING: Support references non-existent node: {node_id}&quot;)&#10;                continue&#10;&#10;            x, y, z = self.node_dict[node_id]&#10;&#10;            # Full support (fixed in all directions)&#10;            if support['ux'] == 1 and support['uy'] == 1 and support['uz'] == 1:&#10;                self.ax.scatter(x, y, z, color='red', s=100, marker='s')&#10;            # Partial support&#10;            else:&#10;                self.ax.scatter(x, y, z, color='orange', s=80, marker='^')&#10;&#10;        # Add a wall surface to represent the back wall&#10;        # Find the y value for the back of the stairway&#10;        back_y = max(pos[1] for pos in self.node_dict.values())&#10;        min_x = min(pos[0] for pos in self.node_dict.values())&#10;        max_x = max(pos[0] for pos in self.node_dict.values())&#10;        min_z = min(pos[2] for pos in self.node_dict.values())&#10;        max_z = max(pos[2] for pos in self.node_dict.values())&#10;&#10;        # Add some margin to the wall&#10;        margin = 1&#10;        wall_x = np.array([min_x-margin, max_x+margin])&#10;        wall_z = np.array([min_z-margin, max_z+margin])&#10;        wall_x_grid, wall_z_grid = np.meshgrid(wall_x, wall_z)&#10;        wall_y_grid = np.ones_like(wall_x_grid) * back_y&#10;&#10;        # Plot the wall with slight transparency&#10;        self.ax.plot_surface(wall_x_grid, wall_y_grid, wall_z_grid, color='gray', alpha=0.2)&#10;&#10;        # Create a legend&#10;        from matplotlib.lines import Line2D&#10;        legend_elements = [&#10;            Line2D([0], [0], color=section_colors[1], lw=section_widths[1], label='Main Stringers'),&#10;            Line2D([0], [0], color=section_colors[2], lw=section_widths[2], label='Steps/Treads'),&#10;            Line2D([0], [0], color=section_colors[4], lw=section_widths[4], label='Bracing'),&#10;            Line2D([0], [0], color=section_colors[5], lw=section_widths[5], label='Column'),&#10;            Line2D([0], [0], marker='s', color='w', markerfacecolor='red', markersize=10, label='Fixed Support'),&#10;            Line2D([0], [0], marker='^', color='w', markerfacecolor='orange', markersize=8, label='Partial Support')&#10;        ]&#10;        self.ax.legend(handles=legend_elements, loc='upper right')&#10;&#10;        # Set axis labels and title&#10;        self.ax.set_xlabel('X (ft)')&#10;        self.ax.set_ylabel('Y (ft)')&#10;        self.ax.set_zlabel('Z (ft)')&#10;        title = self.stairway_data['design_parameters']['name']&#10;        self.ax.set_title(title)&#10;&#10;        # Adjust view angle for better visualization&#10;        self.ax.view_init(elev=20, azim=-60)&#10;&#10;        # Set equal aspect ratio for a more realistic view&#10;        self.ax.set_box_aspect([max_x-min_x, back_y+1, max_z-min_z])&#10;&#10;        # Add text annotations for key structural elements&#10;        self.ax.text(0, 0, max_z+0.5, &quot;Upper Landing&quot;, color='blue')&#10;        self.ax.text(max_x, 0, min_z-0.5, &quot;Lower Landing&quot;, color='blue')&#10;&#10;        # Highlight selected node if any&#10;        if self.selected_node and self.selected_node in self.node_dict:&#10;            x, y, z = self.node_dict[self.selected_node]&#10;            self.ax.scatter(x, y, z, color='red', s=100, marker='o', edgecolors='black')&#10;&#10;    def find_closest_node(self, event):&#10;        &quot;&quot;&quot;Find the closest node to the clicked position&quot;&quot;&quot;&#10;        debug_print(&quot;\n===== Finding closest node =====&quot;)&#10;        if not event.inaxes:&#10;            debug_print(&quot;Click not in any axes&quot;)&#10;            return None&#10;&#10;        if event.inaxes != self.ax:&#10;            debug_print(f&quot;Click in wrong axes: {event.inaxes}&quot;)&#10;            return None&#10;&#10;        # Get screen coordinates of all nodes&#10;        closest_node = None&#10;        min_dist = float('inf')&#10;&#10;        # Raw click coordinates&#10;        click_x, click_y = event.x, event.y&#10;        debug_print(f&quot;Raw click at screen coordinates: ({click_x}, {click_y})&quot;)&#10;&#10;        try:&#10;            # Directly use screen coordinates with imported proj3d module&#10;            from mpl_toolkits.mplot3d import proj3d&#10;&#10;            for node_id, (x, y, z) in self.node_dict.items():&#10;                try:&#10;                    # Convert 3D coordinates to display coordinates&#10;                    xs, ys, _ = proj3d.proj_transform(x, y, z, self.ax.get_proj())&#10;&#10;                    # Convert to display coordinates&#10;                    display_coords = self.ax.transData.transform([(xs, ys)])&#10;                    if len(display_coords) &gt; 0:&#10;                        sx, sy = display_coords[0]&#10;                        dist = np.sqrt((click_x - sx)**2 + (click_y - sy)**2)&#10;&#10;                        debug_print(f&quot;Node {node_id} at 3D=({x:.1f},{y:.1f},{z:.1f}), &quot;&#10;                                   f&quot;screen=({sx:.1f},{sy:.1f}), dist={dist:.1f}&quot;)&#10;&#10;                        if dist &lt; min_dist:&#10;                            min_dist = dist&#10;                            closest_node = node_id&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error projecting node {node_id}: {e}&quot;)&#10;                    continue&#10;&#10;        except ImportError:&#10;            # Fallback method if proj3d import fails&#10;            debug_print(&quot;Using fallback node detection method&quot;)&#10;&#10;            # Get view angles&#10;            elev, azim = self.ax.elev, self.ax.azim&#10;&#10;            # Convert azimuth from degrees to radians&#10;            azim_rad = np.radians(azim)&#10;            elev_rad = np.radians(elev)&#10;&#10;            for node_id, (x, y, z) in self.node_dict.items():&#10;                try:&#10;                    # Simple projection based on view angles&#10;                    # This is an approximation but works reasonably for most views&#10;                    sx = x * np.cos(azim_rad) - y * np.sin(azim_rad)&#10;                    sy = z * np.cos(elev_rad) + np.sin(elev_rad) * (x * np.sin(azim_rad) + y * np.cos(azim_rad))&#10;&#10;                    # Convert to display coordinates (simplified)&#10;                    display_coords = self.ax.transData.transform([(sx, sy)])&#10;                    if len(display_coords) &gt; 0:&#10;                        disp_x, disp_y = display_coords[0]&#10;                        dist = np.sqrt((click_x - disp_x)**2 + (click_y - disp_y)**2)&#10;&#10;                        if dist &lt; min_dist:&#10;                            min_dist = dist&#10;                            closest_node = node_id&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error in fallback projection for node {node_id}: {e}&quot;)&#10;                    continue&#10;&#10;        # Use a reasonable threshold (in pixels)&#10;        threshold = 30&#10;        if min_dist &lt; threshold:&#10;            debug_print(f&quot;Found closest node: {closest_node} (distance: {min_dist:.1f}px)&quot;)&#10;            return closest_node&#10;        else:&#10;            debug_print(f&quot;No node within threshold. Closest was {min_dist:.1f}px away.&quot;)&#10;            return None&#10;&#10;    def find_closest_member(self, event):&#10;        &quot;&quot;&quot;Find the closest member to the clicked position&quot;&quot;&quot;&#10;        debug_print(&quot;\n===== Finding closest member =====&quot;)&#10;        if not event.inaxes or event.inaxes != self.ax:&#10;            return None&#10;&#10;        # Raw click coordinates&#10;        click_x, click_y = event.x, event.y&#10;        debug_print(f&quot;Raw click at screen coordinates: ({click_x}, {click_y})&quot;)&#10;&#10;        # Find closest member by measuring distance to line segments in screen coordinates&#10;        closest_member = None&#10;        min_dist = float('inf')&#10;&#10;        for member in self.members:&#10;            member_id = member['id']&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;&#10;            if i_node not in self.node_dict or j_node not in self.node_dict:&#10;                continue&#10;&#10;            # Get 3D coordinates&#10;            x1, y1, z1 = self.node_dict[i_node]&#10;            x2, y2, z2 = self.node_dict[j_node]&#10;&#10;            try:&#10;                # Project to 2D screen coordinates&#10;                from mpl_toolkits.mplot3d import proj3d&#10;&#10;                # Project endpoints&#10;                xs1, ys1, _ = proj3d.proj_transform(x1, y1, z1, self.ax.get_proj())&#10;                xs2, ys2, _ = proj3d.proj_transform(x2, y2, z2, self.ax.get_proj())&#10;&#10;                # Transform to display coordinates&#10;                display_coords1 = self.ax.transData.transform([(xs1, ys1)])&#10;                display_coords2 = self.ax.transData.transform([(xs2, ys2)])&#10;&#10;                if len(display_coords1) &gt; 0 and len(display_coords2) &gt; 0:&#10;                    sx1, sy1 = display_coords1[0]&#10;                    sx2, sy2 = display_coords2[0]&#10;&#10;                    # Calculate distance from click to line segment&#10;                    dist = point_to_line_distance(click_x, click_y, sx1, sy1, sx2, sy2)&#10;&#10;                    debug_print(f&quot;Member {member_id} distance: {dist:.1f}px&quot;)&#10;&#10;                    if dist &lt; min_dist:&#10;                        min_dist = dist&#10;                        closest_member = member_id&#10;            except Exception as e:&#10;                debug_print(f&quot;Error projecting member {member_id}: {e}&quot;)&#10;                continue&#10;&#10;        # Use a reasonable threshold (in pixels)&#10;        threshold = 15  # Smaller than node threshold&#10;        if min_dist &lt; threshold:&#10;            debug_print(f&quot;Found closest member: {closest_member} (distance: {min_dist:.1f}px)&quot;)&#10;            return closest_member&#10;        else:&#10;            debug_print(f&quot;No member within threshold. Closest was {min_dist:.1f}px away.&quot;)&#10;            return None&#10;&#10;    def on_click(self, event):&#10;        &quot;&quot;&quot;Handle mouse click events&quot;&quot;&quot;&#10;        debug_print(f&quot;\n***** Click event at ({event.x}, {event.y}) *****&quot;)&#10;&#10;        # Check if click is in the main axes&#10;        if event.inaxes != self.ax:&#10;            debug_print(f&quot;Click not in main axes but in {event.inaxes}&quot;)&#10;            # Let the widgets handle their own events&#10;            return&#10;&#10;        # Handle different modes&#10;        if self.mode == 'add_member':&#10;            # In add_member mode, we select two nodes to create a member between them&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                # If we already have this node in our selection, ignore the click&#10;                if node_id in self.member_creation_nodes:&#10;                    debug_print(f&quot;Node {node_id} already selected for member creation&quot;)&#10;                    return&#10;&#10;                # Add the node to our member creation list&#10;                self.member_creation_nodes.append(node_id)&#10;                debug_print(f&quot;Added node {node_id} to member creation (nodes: {self.member_creation_nodes})&quot;)&#10;&#10;                # If we have two nodes, create the member&#10;                if len(self.member_creation_nodes) == 2:&#10;                    self.create_member(self.member_creation_nodes[0], self.member_creation_nodes[1])&#10;                    # Reset for the next member&#10;                    self.member_creation_nodes = []&#10;&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        elif self.mode == 'delete_member':&#10;            # Try to find a member to delete&#10;            member_id = self.find_closest_member(event)&#10;            if member_id:&#10;                debug_print(f&quot;Selected member {member_id} for deletion&quot;)&#10;                self.selected_member = member_id&#10;                self.delete_member()&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        elif self.mode.startswith('delete_node'):&#10;            # Find closest node to the click&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                debug_print(f&quot;Selected node: {node_id} for deletion&quot;)&#10;                self.selected_node = node_id&#10;                self.delete_node()&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        else:  # View or other modes&#10;            # Try to find a node first&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                debug_print(f&quot;Selected node: {node_id}&quot;)&#10;                self.selected_node = node_id&#10;                self.selected_member = None&#10;&#10;                # If in move mode, show the position sliders&#10;                if self.mode == 'move':&#10;                    debug_print(f&quot;Move mode active - showing node editor for node {node_id}&quot;)&#10;                    self.show_node_editor()&#10;&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;            else:&#10;                # If no node found, try to find a member&#10;                member_id = self.find_closest_member(event)&#10;                if member_id:&#10;                    debug_print(f&quot;Selected member: {member_id}&quot;)&#10;                    self.selected_member = member_id&#10;                    self.selected_node = None&#10;                    self.update_info_text()&#10;                    self.plot_stairway()&#10;                    plt.draw()&#10;                else:&#10;                    # Clicked empty space - deselect everything&#10;                    if self.selected_node or self.selected_member:&#10;                        debug_print(&quot;Deselecting current selection&quot;)&#10;                        self.selected_node = None&#10;                        self.selected_member = None&#10;                        self.hide_node_editor()&#10;                        self.update_info_text()&#10;                        self.plot_stairway()&#10;                        plt.draw()&#10;&#10;    def on_motion(self, event):&#10;        &quot;&quot;&quot;Handle mouse motion events&quot;&quot;&quot;&#10;        # Simple implementation to avoid AttributeError&#10;        if not event.inaxes or event.inaxes != self.ax:&#10;            return&#10;&#10;        # Could implement hover highlighting here&#10;        pass&#10;&#10;    def on_key(self, event):&#10;        &quot;&quot;&quot;Handle keyboard events&quot;&quot;&quot;&#10;        debug_print(f&quot;\n##### Key press: {event.key} #####&quot;)&#10;&#10;        if event.key == 'v':&#10;            debug_print(&quot;Switching to View mode&quot;)&#10;            self.mode_radio.set_active(0)&#10;            self.mode = 'view'&#10;            self.hide_node_editor()&#10;        elif event.key == 'm':&#10;            debug_print(&quot;Switching to Move mode&quot;)&#10;            self.mode_radio.set_active(1)&#10;            self.mode = 'move'&#10;            if self.selected_node:&#10;                self.show_node_editor()&#10;        elif event.key == 'a':&#10;            debug_print(&quot;Switching to Add Node mode&quot;)&#10;            self.mode_radio.set_active(2)&#10;            self.mode = 'add_node'&#10;            self.hide_node_editor()&#10;        elif event.key == 'shift+a':&#10;            debug_print(&quot;Switching to Add Member mode&quot;)&#10;            self.mode_radio.set_active(3)&#10;            self.mode = 'add_member'&#10;            self.member_creation_nodes = []&#10;            self.hide_node_editor()&#10;        elif event.key == 'd':&#10;            debug_print(&quot;Switching to Delete Node mode&quot;)&#10;            self.mode_radio.set_active(4)&#10;            self.mode = 'delete_node'&#10;            self.hide_node_editor()&#10;            if self.selected_node and self.mode == 'delete_node':&#10;                self.delete_node()&#10;        elif event.key == 'shift+d':&#10;            debug_print(&quot;Switching to Delete Member mode&quot;)&#10;            self.mode_radio.set_active(5)&#10;            self.mode = 'delete_member'&#10;            self.hide_node_editor()&#10;            if self.selected_member and self.mode == 'delete_member':&#10;                self.delete_member()&#10;        elif event.key == 'escape':&#10;            debug_print(&quot;Escape pressed - deselecting&quot;)&#10;            self.selected_node = None&#10;            self.selected_member = None&#10;            self.member_creation_nodes = []&#10;            self.hide_node_editor()&#10;            self.plot_stairway()  # Redraw without selection highlight&#10;&#10;        self.update_info_text()&#10;        plt.draw()&#10;&#10;    def show_node_editor(self):&#10;        &quot;&quot;&quot;Show the node editor panel with current node position&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            debug_print(&quot;Cannot show node editor: no node selected&quot;)&#10;            return&#10;&#10;        debug_print(f&quot;Showing node editor for node {self.selected_node}&quot;)&#10;        x, y, z = self.node_dict[self.selected_node]&#10;&#10;        # Adjust slider ranges to encompass the current value&#10;        self.x_slider.valmin = max(0, x - 10)&#10;        self.x_slider.valmax = x + 10&#10;        self.y_slider.valmin = max(0, y - 5)&#10;        self.y_slider.valmax = y + 5&#10;        self.z_slider.valmin = max(0, z - 5)&#10;        self.z_slider.valmax = z + 5&#10;&#10;        # Update slider values&#10;        self.x_slider.set_val(x)&#10;        self.y_slider.set_val(y)&#10;        self.z_slider.set_val(z)&#10;&#10;        # Make the editor visible&#10;        debug_print(&quot;Setting editor UI elements to visible&quot;)&#10;        self.node_editor_ax.set_visible(True)&#10;        self.x_slider_ax.set_visible(True)&#10;        self.y_slider_ax.set_visible(True)&#10;        self.z_slider_ax.set_visible(True)&#10;        debug_print(&quot;Calling plt.draw() to update visibility&quot;)&#10;        plt.draw()&#10;&#10;    def hide_node_editor(self):&#10;        &quot;&quot;&quot;Hide the node editor panel&quot;&quot;&quot;&#10;        debug_print(&quot;Hiding node editor&quot;)&#10;        self.node_editor_ax.set_visible(False)&#10;        self.x_slider_ax.set_visible(False)&#10;        self.y_slider_ax.set_visible(False)&#10;        self.z_slider_ax.set_visible(False)&#10;        plt.draw()&#10;&#10;    def update_node_position(self, val):&#10;        &quot;&quot;&quot;Update the selected node's position from slider values&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            debug_print(&quot;Cannot update position: no node selected&quot;)&#10;            return&#10;&#10;        # Get new position from sliders&#10;        x = self.x_slider.val&#10;        y = self.y_slider.val&#10;        z = self.z_slider.val&#10;&#10;        debug_print(f&quot;Updating node {self.selected_node} position to ({x:.2f}, {y:.2f}, {z:.2f})&quot;)&#10;&#10;        # Update node position&#10;        self.node_dict[self.selected_node] = (x, y, z)&#10;&#10;        # Update position in the nodes list too&#10;        for node in self.nodes:&#10;            if node['id'] == self.selected_node:&#10;                node['x'] = f&quot;{x} ft&quot;&#10;                node['y'] = f&quot;{y} ft&quot;&#10;                node['z'] = f&quot;{z} ft&quot;&#10;                break&#10;&#10;        # Redraw structure&#10;        debug_print(&quot;Redrawing structure after position update&quot;)&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;&#10;    def delete_node(self):&#10;        &quot;&quot;&quot;Delete the selected node and connected members&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            print(&quot;Cannot delete: no node selected&quot;)&#10;            return&#10;&#10;        print(f&quot;Attempting to delete node {self.selected_node}&quot;)&#10;&#10;        # Check if node has any supports&#10;        if self.selected_node in self.supported_nodes:&#10;            print(f&quot;Cannot delete node {self.selected_node} because it has support constraints.&quot;)&#10;            return&#10;&#10;        # Get connected members&#10;        connected_members = self.node_connections[self.selected_node].copy()  # Make a copy to avoid modification during iteration&#10;        if connected_members:&#10;            print(f&quot;Deleting {len(connected_members)} members connected to node {self.selected_node}&quot;)&#10;&#10;            # Delete members&#10;            self.members = [m for m in self.members&#10;                           if m['id'] not in connected_members]&#10;&#10;            # Update connections dict for affected nodes&#10;            for member_id in connected_members:&#10;                member = next((m for m in self.members if m['id'] == member_id), None)&#10;                if member:&#10;                    other_node = member['i_node'] if member['j_node'] == self.selected_node else member['j_node']&#10;                    if other_node in self.node_connections and member_id in self.node_connections[other_node]:&#10;                        self.node_connections[other_node].remove(member_id)&#10;&#10;        # Delete node&#10;        self.nodes = [n for n in self.nodes if n['id'] != self.selected_node]&#10;        if self.selected_node in self.node_dict:&#10;            del self.node_dict[self.selected_node]&#10;        if self.selected_node in self.node_connections:&#10;            del self.node_connections[self.selected_node]&#10;&#10;        # Clear selection&#10;        self.selected_node = None&#10;        self.hide_node_editor()&#10;&#10;        # Redraw structure&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;&#10;    def reset_view(self, event):&#10;        &quot;&quot;&quot;Reset the 3D view to default angle&quot;&quot;&quot;&#10;        print(&quot;Resetting view&quot;)&#10;        self.ax.view_init(elev=20, azim=-60)&#10;        plt.draw()&#10;&#10;    def save_structure(self, event):&#10;        &quot;&quot;&quot;Save the modified structure back to a JSON file&quot;&quot;&quot;&#10;        print(&quot;Saving structure...&quot;)&#10;        # Update the structure data with modified nodes&#10;        self.stairway_data['nodes'] = self.nodes&#10;        self.stairway_data['members'] = self.members&#10;&#10;        # Generate a timestamped filename&#10;        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')&#10;        base_name = os.path.splitext(self.json_file)[0]&#10;        output_file = f&quot;{base_name}_edited_{timestamp}.json&quot;&#10;&#10;        try:&#10;            with open(os.path.join(os.path.dirname(__file__), output_file), 'w') as f:&#10;                json.dump(self.stairway_data, f, indent=4)&#10;            print(f&quot;Successfully saved structure to {output_file}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error saving structure: {e}&quot;)&#10;&#10;    def create_member(self, node1, node2):&#10;        &quot;&quot;&quot;Create a new member between two nodes&quot;&quot;&quot;&#10;        # Determine the section type from the radio button&#10;        section_label = self.section_radio.value_selected&#10;        section_number = int(section_label.split()[-1])&#10;&#10;        # Create a new member&#10;        new_member = {&#10;            'id': self.next_member_id,&#10;            'i_node': node1,&#10;            'j_node': node2,&#10;            'material': 1,  # Default material&#10;            'section': section_number&#10;        }&#10;&#10;        debug_print(f&quot;Creating new member: {new_member}&quot;)&#10;&#10;        # Add to members list&#10;        self.members.append(new_member)&#10;&#10;        # Update connections dictionary&#10;        self.node_connections[node1].append(self.next_member_id)&#10;        self.node_connections[node2].append(self.next_member_id)&#10;&#10;        # Increment ID counter for next member&#10;        self.next_member_id += 1&#10;&#10;        # Highlight the new member temporarily&#10;        self.selected_member = new_member['id']&#10;&#10;        # Provide feedback&#10;        debug_print(f&quot;Member {new_member['id']} created between nodes {node1} and {node2}&quot;)&#10;&#10;    def delete_member(self):&#10;        &quot;&quot;&quot;Delete the selected member&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot delete: no member selected&quot;)&#10;            return&#10;&#10;        member_id = self.selected_member&#10;        debug_print(f&quot;Deleting member {member_id}&quot;)&#10;&#10;        # Find the member&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            debug_print(f&quot;Member {member_id} not found&quot;)&#10;            return&#10;&#10;        # Remove member from connections&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        if i_node in self.node_connections and member_id in self.node_connections[i_node]:&#10;            self.node_connections[i_node].remove(member_id)&#10;&#10;        if j_node in self.node_connections and member_id in self.node_connections[j_node]:&#10;            self.node_connections[j_node].remove(member_id)&#10;&#10;        # Remove member from list&#10;        self.members = [m for m in self.members if m['id'] != member_id]&#10;&#10;        # Clear selection&#10;        self.selected_member = None&#10;&#10;        debug_print(f&quot;Member {member_id} deleted&quot;)&#10;&#10;&#10;# Helper functions for distance calculations&#10;def point_to_line_distance(x, y, x1, y1, x2, y2):&#10;    &quot;&quot;&quot;Calculate the distance from point (x,y) to line segment (x1,y1)-(x2,y2)&quot;&quot;&quot;&#10;    # Line segment length squared&#10;    l2 = (x2 - x1)**2 + (y2 - y1)**2&#10;&#10;    if l2 == 0:  # Line segment is a point&#10;        return np.sqrt((x - x1)**2 + (y - y1)**2)&#10;&#10;    # Calculate projection ratio (0-1 if within segment)&#10;    t = max(0, min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2))&#10;&#10;    # Calculate closest point on segment&#10;    px = x1 + t * (x2 - x1)&#10;    py = y1 + t * (y2 - y1)&#10;&#10;    # Return distance to that point&#10;    return np.sqrt((x - px)**2 + (y - py)**2)&#10;" />
              <option name="updatedContent" value="# Interactive stairway structure visualization and editing tool&#10;&#10;import os&#10;import json&#10;import sys&#10;import re&#10;import matplotlib&#10;# Force use of TkAgg backend which has better interactive support&#10;matplotlib.use('TkAgg')&#10;import matplotlib.pyplot as plt&#10;from matplotlib.widgets import Button, RadioButtons, Slider, TextBox&#10;from mpl_toolkits.mplot3d import Axes3D&#10;import scipy as sp&#10;import numpy as np&#10;import datetime&#10;&#10;# Import proj3d for 3D to 2D projections&#10;try:&#10;    from mpl_toolkits.mplot3d import proj3d&#10;except ImportError:&#10;    print(&quot;Warning: Could not import proj3d, some 3D functions may be limited&quot;)&#10;&#10;# Global debug flag - set to True for verbose output&#10;DEBUG = True&#10;&#10;def debug_print(*args, **kwargs):&#10;    &quot;&quot;&quot;Helper function for debug printing that respects the global DEBUG flag&quot;&quot;&quot;&#10;    if DEBUG:&#10;        print(*args, **kwargs)&#10;&#10;class StairwayInteractiveVisualizer:&#10;    def __init__(self, json_file):&#10;        debug_print(f&quot;Initializing visualizer with file: {json_file}&quot;)&#10;        self.json_file = json_file&#10;        self.load_data()&#10;&#10;        # Initialize state variables&#10;        self.selected_node = None&#10;        self.selected_member = None&#10;        self.mode = 'view'  # 'view', 'move', 'add_node', 'add_member', 'delete_node', 'delete_member', 'edit_member'&#10;&#10;        # For member creation&#10;        self.member_creation_nodes = []&#10;        self.next_member_id = max([m['id'] for m in self.members], default=0) + 1&#10;&#10;        # Create the figure and 3D axes&#10;        self.fig = plt.figure(figsize=(16, 10))&#10;        debug_print(&quot;Figure created&quot;)&#10;        self.ax = self.fig.add_subplot(111, projection='3d')&#10;        debug_print(&quot;3D axes created&quot;)&#10;&#10;        # Setup UI before connecting events&#10;        self.setup_ui()&#10;        debug_print(&quot;UI setup complete&quot;)&#10;&#10;        # Connect event handlers&#10;        debug_print(&quot;Connecting event handlers&quot;)&#10;        self.click_cid = self.fig.canvas.mpl_connect('button_press_event', self.on_click)&#10;        self.motion_cid = self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)&#10;        self.key_cid = self.fig.canvas.mpl_connect('key_press_event', self.on_key)&#10;        self.draw_cid = self.fig.canvas.mpl_connect('draw_event', self.on_draw)&#10;        debug_print(f&quot;Event handlers connected: {self.click_cid}, {self.motion_cid}, {self.key_cid}, {self.draw_cid}&quot;)&#10;&#10;        # Plot the stairway structure last&#10;        self.plot_stairway()&#10;&#10;        # Show debug message when initialization is complete&#10;        debug_print(&quot;Visualizer initialization complete&quot;)&#10;&#10;    def on_draw(self, event):&#10;        &quot;&quot;&quot;Debug handler for draw events&quot;&quot;&quot;&#10;        debug_print(&quot;Draw event occurred&quot;)&#10;&#10;    def load_data(self):&#10;        &quot;&quot;&quot;Load stairway data from JSON file&quot;&quot;&quot;&#10;        print(f&quot;Loading stairway structure from {self.json_file}&quot;)&#10;&#10;        try:&#10;            # Remove comments if present in the JSON file&#10;            with open(os.path.join(os.path.dirname(__file__), self.json_file), 'r') as file:&#10;                json_str = &quot;&quot;&#10;                for line in file:&#10;                    if '//' not in line:&#10;                        json_str += line&#10;&#10;                self.stairway_data = json.loads(json_str)&#10;&#10;            # Extract structure data&#10;            self.nodes = self.stairway_data['nodes']&#10;            self.supports = self.stairway_data['supports']&#10;            self.members = self.stairway_data['members']&#10;            self.materials = self.stairway_data.get('materials', [])&#10;            self.sections = self.stairway_data.get('sections', [])&#10;&#10;            # Create node dictionary for quick lookups&#10;            self.node_dict = {}&#10;            for node in self.nodes:&#10;                node_id = node['id']&#10;                x = float(node['x'].split()[0])&#10;                y = float(node['y'].split()[0])&#10;                z = float(node['z'].split()[0])&#10;                self.node_dict[node_id] = (x, y, z)&#10;&#10;            # Create dictionaries for materials and sections&#10;            self.material_dict = {m['id']: m for m in self.materials}&#10;            self.section_dict = {s['id']: s for s in self.sections}&#10;&#10;            # Create set of supported nodes&#10;            self.supported_nodes = {s['node'] for s in self.supports}&#10;&#10;            # Create map of connected members for each node&#10;            self.node_connections = {}&#10;            for node_id in self.node_dict:&#10;                self.node_connections[node_id] = []&#10;&#10;            for member in self.members:&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                member_id = member['id']&#10;&#10;                if i_node in self.node_connections:&#10;                    self.node_connections[i_node].append(member_id)&#10;                if j_node in self.node_connections:&#10;                    self.node_connections[j_node].append(member_id)&#10;&#10;            print(f&quot;Successfully loaded: {self.stairway_data['design_parameters']['name']}&quot;)&#10;            print(f&quot;Structure contains {len(self.nodes)} nodes, {len(self.members)} members, and {len(self.supports)} supports&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error loading JSON file: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            sys.exit(1)&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;Set up the UI elements for interactive editing&quot;&quot;&quot;&#10;        # Create a smaller subplot for buttons&#10;        self.button_area = plt.axes([0.01, 0.01, 0.20, 0.20])&#10;        self.button_area.axis('off')&#10;&#10;        # Mode selection radio buttons - add member modes&#10;        self.mode_radio_ax = plt.axes([0.01, 0.80, 0.15, 0.15])&#10;        self.mode_radio = RadioButtons(&#10;            self.mode_radio_ax,&#10;            ['View', 'Move Node', 'Add Node', 'Add Member', 'Delete Node', 'Delete Member', 'Edit Member'],&#10;            activecolor='green'&#10;        )&#10;        self.mode_radio.on_clicked(self.set_mode)&#10;&#10;        # Section selection for new members&#10;        self.section_radio_ax = plt.axes([0.01, 0.55, 0.15, 0.10])&#10;        section_labels = [f&quot;Section {i}&quot; for i in range(1, 6)]&#10;        self.section_radio = RadioButtons(&#10;            self.section_radio_ax,&#10;            section_labels,&#10;            activecolor='blue'&#10;        )&#10;        self.section_radio.on_clicked(lambda label: debug_print(f&quot;Section changed to: {label}&quot;))&#10;&#10;        # Save button&#10;        self.save_button_ax = plt.axes([0.01, 0.70, 0.15, 0.05])&#10;        self.save_button = Button(self.save_button_ax, 'Save Structure')&#10;        self.save_button.on_clicked(self.save_structure)&#10;&#10;        # Reset view button&#10;        self.reset_view_ax = plt.axes([0.01, 0.65, 0.15, 0.05])&#10;        self.reset_view_button = Button(self.reset_view_ax, 'Reset View')&#10;        self.reset_view_button.on_clicked(self.reset_view)&#10;&#10;        # Information panel&#10;        self.info_ax = plt.axes([0.01, 0.05, 0.20, 0.45])&#10;        self.info_ax.axis('off')&#10;        self.info_text = self.info_ax.text(&#10;            0, 1,&#10;            &quot;Interactive Stairway Editor\n\nClick on a node to select it\n&quot;&#10;            &quot;Use the mode buttons to change actions\n&quot;&#10;            &quot;Hotkeys: v=View, m=Move, a=Add, d=Delete, e=Edit&quot;,&#10;            va='top'&#10;        )&#10;&#10;        # Node editor panel (initially hidden)&#10;        self.node_editor_ax = plt.axes([0.85, 0.65, 0.14, 0.30])&#10;        self.node_editor_ax.axis('off')&#10;        self.node_editor_title = self.node_editor_ax.text(0, 1.1, &quot;Node Editor&quot;, fontsize=10, weight='bold')&#10;        self.node_editor_ax.set_visible(False)&#10;&#10;        # X coordinate slider&#10;        self.x_slider_ax = plt.axes([0.87, 0.85, 0.10, 0.03])&#10;        self.x_slider = Slider(self.x_slider_ax, 'X', 0, 30, valinit=0)&#10;        self.x_slider.on_changed(self.update_node_position)&#10;        self.x_slider_ax.set_visible(False)&#10;&#10;        # Y coordinate slider&#10;        self.y_slider_ax = plt.axes([0.87, 0.80, 0.10, 0.03])&#10;        self.y_slider = Slider(self.y_slider_ax, 'Y', 0, 10, valinit=0)&#10;        self.y_slider.on_changed(self.update_node_position)&#10;        self.y_slider_ax.set_visible(False)&#10;&#10;        # Z coordinate slider&#10;        self.z_slider_ax = plt.axes([0.87, 0.75, 0.10, 0.03])&#10;        self.z_slider = Slider(self.z_slider_ax, 'Z', 0, 10, valinit=0)&#10;        self.z_slider.on_changed(self.update_node_position)&#10;        self.z_slider_ax.set_visible(False)&#10;        &#10;        # Member editor panel (initially hidden)&#10;        self.member_editor_ax = plt.axes([0.85, 0.35, 0.14, 0.25])&#10;        self.member_editor_ax.axis('off')&#10;        self.member_editor_title = self.member_editor_ax.text(0, 1.1, &quot;Member Editor&quot;, fontsize=10, weight='bold')&#10;        self.member_editor_ax.set_visible(False)&#10;        &#10;        # Member section radio buttons&#10;        self.member_section_ax = plt.axes([0.87, 0.45, 0.10, 0.10])&#10;        self.member_section_radio = RadioButtons(&#10;            self.member_section_ax,&#10;            [f&quot;Section {i}&quot; for i in range(1, 6)],&#10;            activecolor='blue'&#10;        )&#10;        self.member_section_radio.on_clicked(self.update_member_section)&#10;        self.member_section_ax.set_visible(False)&#10;        &#10;        # Member material radio buttons&#10;        self.member_material_ax = plt.axes([0.87, 0.30, 0.10, 0.10])&#10;        self.member_material_radio = RadioButtons(&#10;            self.member_material_ax,&#10;            [f&quot;Material {i}&quot; for i in range(1, 4)],&#10;            activecolor='orange'&#10;        )&#10;        self.member_material_radio.on_clicked(self.update_member_material)&#10;        self.member_material_ax.set_visible(False)&#10;        &#10;        # Change member nodes button&#10;        self.change_nodes_ax = plt.axes([0.87, 0.25, 0.10, 0.04])&#10;        self.change_nodes_button = Button(self.change_nodes_ax, 'Change Nodes')&#10;        self.change_nodes_button.on_clicked(self.start_change_member_nodes)&#10;        self.change_nodes_ax.set_visible(False)&#10;&#10;    def set_mode(self, mode_label):&#10;        &quot;&quot;&quot;Change the current editing mode&quot;&quot;&quot;&#10;        debug_print(f&quot;\n----- Mode change: {mode_label} -----&quot;)&#10;        mode_map = {&#10;            'View': 'view',&#10;            'Move Node': 'move',&#10;            'Add Node': 'add_node',&#10;            'Add Member': 'add_member',&#10;            'Delete Node': 'delete_node',&#10;            'Delete Member': 'delete_member',&#10;            'Edit Member': 'edit_member'&#10;        }&#10;        self.mode = mode_map[mode_label]&#10;        debug_print(f&quot;Mode changed to: {self.mode}&quot;)&#10;&#10;        # Reset state when changing modes&#10;        if self.mode == 'add_member':&#10;            self.member_creation_nodes = []&#10;            debug_print(&quot;Member creation state reset - select two nodes to create a member&quot;)&#10;        elif self.mode == 'change_member_nodes':&#10;            self.member_creation_nodes = []&#10;            debug_print(&quot;Member node change state reset - select two nodes to reconnect the member&quot;)&#10;&#10;        # Hide/show appropriate editors&#10;        self.hide_node_editor()&#10;        self.hide_member_editor()&#10;        &#10;        if self.mode == 'move' and self.selected_node:&#10;            self.show_node_editor()&#10;        elif self.mode == 'edit_member' and self.selected_member:&#10;            self.show_member_editor()&#10;&#10;        # Handle mode-specific actions&#10;        if self.mode == 'delete_node' and self.selected_node:&#10;            debug_print(f&quot;Deleting node {self.selected_node}&quot;)&#10;            self.delete_node()&#10;        elif self.mode == 'delete_member' and self.selected_member:&#10;            debug_print(f&quot;Deleting member {self.selected_member}&quot;)&#10;            self.delete_member()&#10;&#10;        self.update_info_text()&#10;        self.plot_stairway()  # Redraw to show/hide appropriate elements&#10;        debug_print(&quot;Calling plt.draw() after mode change&quot;)&#10;        plt.draw()&#10;&#10;    def update_info_text(self):&#10;        &quot;&quot;&quot;Update the information panel text based on current state&quot;&quot;&quot;&#10;        info = f&quot;Mode: {self.mode.capitalize().replace('_', ' ')}\n\n&quot;&#10;&#10;        if self.mode == 'add_member':&#10;            info += f&quot;Creating new member - &quot;&#10;            if len(self.member_creation_nodes) == 0:&#10;                info += &quot;Select first node\n&quot;&#10;            elif len(self.member_creation_nodes) == 1:&#10;                info += f&quot;Node {self.member_creation_nodes[0]} selected\nSelect second node\n&quot;&#10;        elif self.mode == 'change_member_nodes':&#10;            info += f&quot;Changing member {self.selected_member} nodes - &quot;&#10;            if len(self.member_creation_nodes) == 0:&#10;                info += &quot;Select first node\n&quot;&#10;            elif len(self.member_creation_nodes) == 1:&#10;                info += f&quot;Node {self.member_creation_nodes[0]} selected\nSelect second node\n&quot;&#10;&#10;        if self.selected_node:&#10;            node_pos = self.node_dict[self.selected_node]&#10;            info += f&quot;Selected Node: {self.selected_node}\n&quot;&#10;            info += f&quot;Position: ({node_pos[0]:.2f}, {node_pos[1]:.2f}, {node_pos[2]:.2f})\n&quot;&#10;            info += f&quot;Connected to {len(self.node_connections[self.selected_node])} members\n&quot;&#10;&#10;            if self.selected_node in self.supported_nodes:&#10;                info += &quot;This node has support constraints\n&quot;&#10;        elif self.selected_member:&#10;            member = next((m for m in self.members if m['id'] == self.selected_member), None)&#10;            if member:&#10;                info += f&quot;Selected Member: {self.selected_member}\n&quot;&#10;                info += f&quot;Connects nodes: {member['i_node']} - {member['j_node']}\n&quot;&#10;                info += f&quot;Section: {member['section']}, Material: {member['material']}\n&quot;&#10;&#10;                # Get member length&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                if i_node in self.node_dict and j_node in self.node_dict:&#10;                    x1, y1, z1 = self.node_dict[i_node]&#10;                    x2, y2, z2 = self.node_dict[j_node]&#10;                    length = np.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)&#10;                    info += f&quot;Length: {length:.2f} ft\n&quot;&#10;&#10;        self.info_text.set_text(info)&#10;        plt.draw()&#10;&#10;    def plot_stairway(self):&#10;        &quot;&quot;&quot;Plot the stairway structure&quot;&quot;&quot;&#10;        self.ax.clear()&#10;&#10;        # Define colors and widths for different section types&#10;        section_colors = {&#10;            1: 'blue',    # Main stringers&#10;            2: 'green',   # Steps/treads&#10;            3: 'cyan',    # Secondary members&#10;            4: 'gray',    # Bracing&#10;            5: 'red'      # Column&#10;        }&#10;&#10;        section_widths = {&#10;            1: 2,         # Main stringers&#10;            2: 1.5,       # Steps/treads&#10;            3: 1,         # Secondary members&#10;            4: 1,         # Bracing&#10;            5: 3          # Column&#10;        }&#10;&#10;        # Plot members&#10;        self.member_lines = {}&#10;        for member in self.members:&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;            member_id = member['id']&#10;            section = member['section']&#10;&#10;            if i_node not in self.node_dict or j_node not in self.node_dict:&#10;                print(f&quot;WARNING: Member {member_id} references non-existent node(s): {i_node}-{j_node}&quot;)&#10;                continue&#10;&#10;            x1, y1, z1 = self.node_dict[i_node]&#10;            x2, y2, z2 = self.node_dict[j_node]&#10;&#10;            color = section_colors.get(section, 'black')&#10;            linewidth = section_widths.get(section, 1)&#10;&#10;            # Highlight selected member&#10;            if member_id == self.selected_member:&#10;                color = 'red'&#10;                linewidth += 1&#10;&#10;            line = self.ax.plot([x1, x2], [y1, y2], [z1, z2],&#10;                          color=color, linewidth=linewidth)[0]&#10;            self.member_lines[member_id] = line&#10;&#10;        # Plot nodes&#10;        self.node_points = {}&#10;        for node_id, (x, y, z) in self.node_dict.items():&#10;            # Different marker for nodes in the member creation process&#10;            if node_id in self.member_creation_nodes:&#10;                point = self.ax.scatter(x, y, z, color='blue', s=60, marker='o', edgecolors='black')&#10;            else:&#10;                point = self.ax.scatter(x, y, z, color='black', s=20)&#10;            self.node_points[node_id] = point&#10;&#10;        # Plot supports&#10;        for support in self.supports:&#10;            node_id = support['node']&#10;            if node_id not in self.node_dict:&#10;                print(f&quot;WARNING: Support references non-existent node: {node_id}&quot;)&#10;                continue&#10;&#10;            x, y, z = self.node_dict[node_id]&#10;&#10;            # Full support (fixed in all directions)&#10;            if support['ux'] == 1 and support['uy'] == 1 and support['uz'] == 1:&#10;                self.ax.scatter(x, y, z, color='red', s=100, marker='s')&#10;            # Partial support&#10;            else:&#10;                self.ax.scatter(x, y, z, color='orange', s=80, marker='^')&#10;&#10;        # Add a wall surface to represent the back wall&#10;        # Find the y value for the back of the stairway&#10;        back_y = max(pos[1] for pos in self.node_dict.values())&#10;        min_x = min(pos[0] for pos in self.node_dict.values())&#10;        max_x = max(pos[0] for pos in self.node_dict.values())&#10;        min_z = min(pos[2] for pos in self.node_dict.values())&#10;        max_z = max(pos[2] for pos in self.node_dict.values())&#10;&#10;        # Add some margin to the wall&#10;        margin = 1&#10;        wall_x = np.array([min_x-margin, max_x+margin])&#10;        wall_z = np.array([min_z-margin, max_z+margin])&#10;        wall_x_grid, wall_z_grid = np.meshgrid(wall_x, wall_z)&#10;        wall_y_grid = np.ones_like(wall_x_grid) * back_y&#10;&#10;        # Plot the wall with slight transparency&#10;        self.ax.plot_surface(wall_x_grid, wall_y_grid, wall_z_grid, color='gray', alpha=0.2)&#10;&#10;        # Create a legend&#10;        from matplotlib.lines import Line2D&#10;        legend_elements = [&#10;            Line2D([0], [0], color=section_colors[1], lw=section_widths[1], label='Main Stringers'),&#10;            Line2D([0], [0], color=section_colors[2], lw=section_widths[2], label='Steps/Treads'),&#10;            Line2D([0], [0], color=section_colors[4], lw=section_widths[4], label='Bracing'),&#10;            Line2D([0], [0], color=section_colors[5], lw=section_widths[5], label='Column'),&#10;            Line2D([0], [0], marker='s', color='w', markerfacecolor='red', markersize=10, label='Fixed Support'),&#10;            Line2D([0], [0], marker='^', color='w', markerfacecolor='orange', markersize=8, label='Partial Support')&#10;        ]&#10;        self.ax.legend(handles=legend_elements, loc='upper right')&#10;&#10;        # Set axis labels and title&#10;        self.ax.set_xlabel('X (ft)')&#10;        self.ax.set_ylabel('Y (ft)')&#10;        self.ax.set_zlabel('Z (ft)')&#10;        title = self.stairway_data['design_parameters']['name']&#10;        self.ax.set_title(title)&#10;&#10;        # Adjust view angle for better visualization&#10;        self.ax.view_init(elev=20, azim=-60)&#10;&#10;        # Set equal aspect ratio for a more realistic view&#10;        self.ax.set_box_aspect([max_x-min_x, back_y+1, max_z-min_z])&#10;&#10;        # Add text annotations for key structural elements&#10;        self.ax.text(0, 0, max_z+0.5, &quot;Upper Landing&quot;, color='blue')&#10;        self.ax.text(max_x, 0, min_z-0.5, &quot;Lower Landing&quot;, color='blue')&#10;&#10;        # Highlight selected node if any&#10;        if self.selected_node and self.selected_node in self.node_dict:&#10;            x, y, z = self.node_dict[self.selected_node]&#10;            self.ax.scatter(x, y, z, color='red', s=100, marker='o', edgecolors='black')&#10;&#10;    def find_closest_node(self, event):&#10;        &quot;&quot;&quot;Find the closest node to the clicked position&quot;&quot;&quot;&#10;        debug_print(&quot;\n===== Finding closest node =====&quot;)&#10;        if not event.inaxes:&#10;            debug_print(&quot;Click not in any axes&quot;)&#10;            return None&#10;&#10;        if event.inaxes != self.ax:&#10;            debug_print(f&quot;Click in wrong axes: {event.inaxes}&quot;)&#10;            return None&#10;&#10;        # Get screen coordinates of all nodes&#10;        closest_node = None&#10;        min_dist = float('inf')&#10;&#10;        # Raw click coordinates&#10;        click_x, click_y = event.x, event.y&#10;        debug_print(f&quot;Raw click at screen coordinates: ({click_x}, {click_y})&quot;)&#10;&#10;        try:&#10;            # Directly use screen coordinates with imported proj3d module&#10;            from mpl_toolkits.mplot3d import proj3d&#10;&#10;            for node_id, (x, y, z) in self.node_dict.items():&#10;                try:&#10;                    # Convert 3D coordinates to display coordinates&#10;                    xs, ys, _ = proj3d.proj_transform(x, y, z, self.ax.get_proj())&#10;&#10;                    # Convert to display coordinates&#10;                    display_coords = self.ax.transData.transform([(xs, ys)])&#10;                    if len(display_coords) &gt; 0:&#10;                        sx, sy = display_coords[0]&#10;                        dist = np.sqrt((click_x - sx)**2 + (click_y - sy)**2)&#10;&#10;                        debug_print(f&quot;Node {node_id} at 3D=({x:.1f},{y:.1f},{z:.1f}), &quot;&#10;                                   f&quot;screen=({sx:.1f},{sy:.1f}), dist={dist:.1f}&quot;)&#10;&#10;                        if dist &lt; min_dist:&#10;                            min_dist = dist&#10;                            closest_node = node_id&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error projecting node {node_id}: {e}&quot;)&#10;                    continue&#10;&#10;        except ImportError:&#10;            # Fallback method if proj3d import fails&#10;            debug_print(&quot;Using fallback node detection method&quot;)&#10;&#10;            # Get view angles&#10;            elev, azim = self.ax.elev, self.ax.azim&#10;&#10;            # Convert azimuth from degrees to radians&#10;            azim_rad = np.radians(azim)&#10;            elev_rad = np.radians(elev)&#10;&#10;            for node_id, (x, y, z) in self.node_dict.items():&#10;                try:&#10;                    # Simple projection based on view angles&#10;                    # This is an approximation but works reasonably for most views&#10;                    sx = x * np.cos(azim_rad) - y * np.sin(azim_rad)&#10;                    sy = z * np.cos(elev_rad) + np.sin(elev_rad) * (x * np.sin(azim_rad) + y * np.cos(azim_rad))&#10;&#10;                    # Convert to display coordinates (simplified)&#10;                    display_coords = self.ax.transData.transform([(sx, sy)])&#10;                    if len(display_coords) &gt; 0:&#10;                        disp_x, disp_y = display_coords[0]&#10;                        dist = np.sqrt((click_x - disp_x)**2 + (click_y - disp_y)**2)&#10;&#10;                        if dist &lt; min_dist:&#10;                            min_dist = dist&#10;                            closest_node = node_id&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error in fallback projection for node {node_id}: {e}&quot;)&#10;                    continue&#10;&#10;        # Use a reasonable threshold (in pixels)&#10;        threshold = 30&#10;        if min_dist &lt; threshold:&#10;            debug_print(f&quot;Found closest node: {closest_node} (distance: {min_dist:.1f}px)&quot;)&#10;            return closest_node&#10;        else:&#10;            debug_print(f&quot;No node within threshold. Closest was {min_dist:.1f}px away.&quot;)&#10;            return None&#10;&#10;    def find_closest_member(self, event):&#10;        &quot;&quot;&quot;Find the closest member to the clicked position&quot;&quot;&quot;&#10;        debug_print(&quot;\n===== Finding closest member =====&quot;)&#10;        if not event.inaxes or event.inaxes != self.ax:&#10;            return None&#10;&#10;        # Raw click coordinates&#10;        click_x, click_y = event.x, event.y&#10;        debug_print(f&quot;Raw click at screen coordinates: ({click_x}, {click_y})&quot;)&#10;&#10;        # Find closest member by measuring distance to line segments in screen coordinates&#10;        closest_member = None&#10;        min_dist = float('inf')&#10;&#10;        for member in self.members:&#10;            member_id = member['id']&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;&#10;            if i_node not in self.node_dict or j_node not in self.node_dict:&#10;                continue&#10;&#10;            # Get 3D coordinates&#10;            x1, y1, z1 = self.node_dict[i_node]&#10;            x2, y2, z2 = self.node_dict[j_node]&#10;&#10;            try:&#10;                # Project to 2D screen coordinates&#10;                from mpl_toolkits.mplot3d import proj3d&#10;&#10;                # Project endpoints&#10;                xs1, ys1, _ = proj3d.proj_transform(x1, y1, z1, self.ax.get_proj())&#10;                xs2, ys2, _ = proj3d.proj_transform(x2, y2, z2, self.ax.get_proj())&#10;&#10;                # Transform to display coordinates&#10;                display_coords1 = self.ax.transData.transform([(xs1, ys1)])&#10;                display_coords2 = self.ax.transData.transform([(xs2, ys2)])&#10;&#10;                if len(display_coords1) &gt; 0 and len(display_coords2) &gt; 0:&#10;                    sx1, sy1 = display_coords1[0]&#10;                    sx2, sy2 = display_coords2[0]&#10;&#10;                    # Calculate distance from click to line segment&#10;                    dist = point_to_line_distance(click_x, click_y, sx1, sy1, sx2, sy2)&#10;&#10;                    debug_print(f&quot;Member {member_id} distance: {dist:.1f}px&quot;)&#10;&#10;                    if dist &lt; min_dist:&#10;                        min_dist = dist&#10;                        closest_member = member_id&#10;            except Exception as e:&#10;                debug_print(f&quot;Error projecting member {member_id}: {e}&quot;)&#10;                continue&#10;&#10;        # Use a reasonable threshold (in pixels)&#10;        threshold = 15  # Smaller than node threshold&#10;        if min_dist &lt; threshold:&#10;            debug_print(f&quot;Found closest member: {closest_member} (distance: {min_dist:.1f}px)&quot;)&#10;            return closest_member&#10;        else:&#10;            debug_print(f&quot;No member within threshold. Closest was {min_dist:.1f}px away.&quot;)&#10;            return None&#10;&#10;    def on_click(self, event):&#10;        &quot;&quot;&quot;Handle mouse click events&quot;&quot;&quot;&#10;        debug_print(f&quot;\n***** Click event at ({event.x}, {event.y}) *****&quot;)&#10;&#10;        # Check if click is in the main axes&#10;        if event.inaxes != self.ax:&#10;            debug_print(f&quot;Click not in main axes but in {event.inaxes}&quot;)&#10;            # Let the widgets handle their own events&#10;            return&#10;&#10;        # Handle different modes&#10;        if self.mode == 'add_member':&#10;            # In add_member mode, we select two nodes to create a member between them&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                # If we already have this node in our selection, ignore the click&#10;                if node_id in self.member_creation_nodes:&#10;                    debug_print(f&quot;Node {node_id} already selected for member creation&quot;)&#10;                    return&#10;&#10;                # Add the node to our member creation list&#10;                self.member_creation_nodes.append(node_id)&#10;                debug_print(f&quot;Added node {node_id} to member creation (nodes: {self.member_creation_nodes})&quot;)&#10;&#10;                # If we have two nodes, create the member&#10;                if len(self.member_creation_nodes) == 2:&#10;                    self.create_member(self.member_creation_nodes[0], self.member_creation_nodes[1])&#10;                    # Reset for the next member&#10;                    self.member_creation_nodes = []&#10;&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;                &#10;        elif self.mode == 'change_member_nodes':&#10;            # In change_member_nodes mode, we select two nodes to reconnect an existing member&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                # If we already have this node in our selection, ignore the click&#10;                if node_id in self.member_creation_nodes:&#10;                    debug_print(f&quot;Node {node_id} already selected for member reconnection&quot;)&#10;                    return&#10;&#10;                # Add the node to our member creation list&#10;                self.member_creation_nodes.append(node_id)&#10;                debug_print(f&quot;Added node {node_id} to member reconnection (nodes: {self.member_creation_nodes})&quot;)&#10;&#10;                # If we have two nodes, update the member&#10;                if len(self.member_creation_nodes) == 2:&#10;                    self.update_member_nodes(self.selected_member, &#10;                                           self.member_creation_nodes[0], &#10;                                           self.member_creation_nodes[1])&#10;                    # Reset state and mode&#10;                    self.member_creation_nodes = []&#10;                    self.mode = 'edit_member'&#10;                    self.mode_radio.set_active(6)  # Select 'Edit Member' in the UI&#10;&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        elif self.mode == 'delete_member':&#10;            # Try to find a member to delete&#10;            member_id = self.find_closest_member(event)&#10;            if member_id:&#10;                debug_print(f&quot;Selected member {member_id} for deletion&quot;)&#10;                self.selected_member = member_id&#10;                self.delete_member()&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        elif self.mode.startswith('delete_node'):&#10;            # Find closest node to the click&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                debug_print(f&quot;Selected node: {node_id} for deletion&quot;)&#10;                self.selected_node = node_id&#10;                self.delete_node()&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;                &#10;        elif self.mode == 'edit_member':&#10;            # Try to find a member to edit&#10;            member_id = self.find_closest_member(event)&#10;            if member_id:&#10;                debug_print(f&quot;Selected member {member_id} for editing&quot;)&#10;                self.selected_member = member_id&#10;                self.selected_node = None&#10;                self.show_member_editor()&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;&#10;        else:  # View or other modes&#10;            # Try to find a node first&#10;            node_id = self.find_closest_node(event)&#10;            if node_id:&#10;                debug_print(f&quot;Selected node: {node_id}&quot;)&#10;                self.selected_node = node_id&#10;                self.selected_member = None&#10;&#10;                # If in move mode, show the position sliders&#10;                if self.mode == 'move':&#10;                    debug_print(f&quot;Move mode active - showing node editor for node {node_id}&quot;)&#10;                    self.show_node_editor()&#10;&#10;                self.update_info_text()&#10;                self.plot_stairway()&#10;                plt.draw()&#10;            else:&#10;                # If no node found, try to find a member&#10;                member_id = self.find_closest_member(event)&#10;                if member_id:&#10;                    debug_print(f&quot;Selected member: {member_id}&quot;)&#10;                    self.selected_member = member_id&#10;                    self.selected_node = None&#10;                    self.update_info_text()&#10;                    self.plot_stairway()&#10;                    plt.draw()&#10;                else:&#10;                    # Clicked empty space - deselect everything&#10;                    if self.selected_node or self.selected_member:&#10;                        debug_print(&quot;Deselecting current selection&quot;)&#10;                        self.selected_node = None&#10;                        self.selected_member = None&#10;                        self.hide_node_editor()&#10;                        self.hide_member_editor()&#10;                        self.update_info_text()&#10;                        self.plot_stairway()&#10;                        plt.draw()&#10;&#10;    def on_motion(self, event):&#10;        &quot;&quot;&quot;Handle mouse motion events&quot;&quot;&quot;&#10;        # Simple implementation to avoid AttributeError&#10;        if not event.inaxes or event.inaxes != self.ax:&#10;            return&#10;&#10;        # Could implement hover highlighting here&#10;        pass&#10;&#10;    def on_key(self, event):&#10;        &quot;&quot;&quot;Handle keyboard events&quot;&quot;&quot;&#10;        debug_print(f&quot;\n##### Key press: {event.key} #####&quot;)&#10;&#10;        if event.key == 'v':&#10;            debug_print(&quot;Switching to View mode&quot;)&#10;            self.mode_radio.set_active(0)&#10;            self.mode = 'view'&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;        elif event.key == 'm':&#10;            debug_print(&quot;Switching to Move mode&quot;)&#10;            self.mode_radio.set_active(1)&#10;            self.mode = 'move'&#10;            if self.selected_node:&#10;                self.show_node_editor()&#10;                self.hide_member_editor()&#10;        elif event.key == 'a':&#10;            debug_print(&quot;Switching to Add Node mode&quot;)&#10;            self.mode_radio.set_active(2)&#10;            self.mode = 'add_node'&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;        elif event.key == 'shift+a':&#10;            debug_print(&quot;Switching to Add Member mode&quot;)&#10;            self.mode_radio.set_active(3)&#10;            self.mode = 'add_member'&#10;            self.member_creation_nodes = []&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;        elif event.key == 'd':&#10;            debug_print(&quot;Switching to Delete Node mode&quot;)&#10;            self.mode_radio.set_active(4)&#10;            self.mode = 'delete_node'&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;            if self.selected_node and self.mode == 'delete_node':&#10;                self.delete_node()&#10;        elif event.key == 'shift+d':&#10;            debug_print(&quot;Switching to Delete Member mode&quot;)&#10;            self.mode_radio.set_active(5)&#10;            self.mode = 'delete_member'&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;            if self.selected_member and self.mode == 'delete_member':&#10;                self.delete_member()&#10;        elif event.key == 'e':&#10;            debug_print(&quot;Switching to Edit Member mode&quot;)&#10;            self.mode_radio.set_active(6)&#10;            self.mode = 'edit_member'&#10;            self.hide_node_editor()&#10;            if self.selected_member:&#10;                self.show_member_editor()&#10;        elif event.key == 'escape':&#10;            debug_print(&quot;Escape pressed - deselecting&quot;)&#10;            self.selected_node = None&#10;            self.selected_member = None&#10;            self.member_creation_nodes = []&#10;            self.hide_node_editor()&#10;            self.hide_member_editor()&#10;            self.plot_stairway()  # Redraw without selection highlight&#10;&#10;        self.update_info_text()&#10;        plt.draw()&#10;&#10;    def show_node_editor(self):&#10;        &quot;&quot;&quot;Show the node editor panel with current node position&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            debug_print(&quot;Cannot show node editor: no node selected&quot;)&#10;            return&#10;&#10;        debug_print(f&quot;Showing node editor for node {self.selected_node}&quot;)&#10;        x, y, z = self.node_dict[self.selected_node]&#10;&#10;        # Adjust slider ranges to encompass the current value&#10;        self.x_slider.valmin = max(0, x - 10)&#10;        self.x_slider.valmax = x + 10&#10;        self.y_slider.valmin = max(0, y - 5)&#10;        self.y_slider.valmax = y + 5&#10;        self.z_slider.valmin = max(0, z - 5)&#10;        self.z_slider.valmax = z + 5&#10;&#10;        # Update slider values&#10;        self.x_slider.set_val(x)&#10;        self.y_slider.set_val(y)&#10;        self.z_slider.set_val(z)&#10;&#10;        # Make the editor visible&#10;        debug_print(&quot;Setting editor UI elements to visible&quot;)&#10;        self.node_editor_ax.set_visible(True)&#10;        self.x_slider_ax.set_visible(True)&#10;        self.y_slider_ax.set_visible(True)&#10;        self.z_slider_ax.set_visible(True)&#10;        debug_print(&quot;Calling plt.draw() to update visibility&quot;)&#10;        plt.draw()&#10;        &#10;    def show_member_editor(self):&#10;        &quot;&quot;&quot;Show the member editor panel with current member properties&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot show member editor: no member selected&quot;)&#10;            return&#10;            &#10;        debug_print(f&quot;Showing member editor for member {self.selected_member}&quot;)&#10;        &#10;        # Get current member properties&#10;        member = next((m for m in self.members if m['id'] == self.selected_member), None)&#10;        if not member:&#10;            debug_print(f&quot;Member {self.selected_member} not found in members list&quot;)&#10;            return&#10;            &#10;        # Set the radio button selections to match current properties&#10;        section_idx = member['section'] - 1  # Adjust for 0-based indexing&#10;        material_idx = member['material'] - 1  # Adjust for 0-based indexing&#10;        &#10;        # Set active radio buttons&#10;        for i, circle in enumerate(self.member_section_radio.circles):&#10;            circle.set_facecolor('white')&#10;        self.member_section_radio.circles[section_idx].set_facecolor('blue')&#10;        &#10;        for i, circle in enumerate(self.member_material_radio.circles):&#10;            circle.set_facecolor('white')&#10;        self.member_material_radio.circles[material_idx].set_facecolor('orange')&#10;        &#10;        # Make the editor visible&#10;        self.member_editor_ax.set_visible(True)&#10;        self.member_section_ax.set_visible(True)&#10;        self.member_material_ax.set_visible(True)&#10;        self.change_nodes_ax.set_visible(True)&#10;        &#10;        plt.draw()&#10;&#10;    def hide_node_editor(self):&#10;        &quot;&quot;&quot;Hide the node editor panel&quot;&quot;&quot;&#10;        debug_print(&quot;Hiding node editor&quot;)&#10;        self.node_editor_ax.set_visible(False)&#10;        self.x_slider_ax.set_visible(False)&#10;        self.y_slider_ax.set_visible(False)&#10;        self.z_slider_ax.set_visible(False)&#10;        plt.draw()&#10;        &#10;    def hide_member_editor(self):&#10;        &quot;&quot;&quot;Hide the member editor panel&quot;&quot;&quot;&#10;        debug_print(&quot;Hiding member editor&quot;)&#10;        self.member_editor_ax.set_visible(False)&#10;        self.member_section_ax.set_visible(False)&#10;        self.member_material_ax.set_visible(False)&#10;        self.change_nodes_ax.set_visible(False)&#10;        plt.draw()&#10;&#10;    def update_node_position(self, val):&#10;        &quot;&quot;&quot;Update the selected node's position from slider values&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            debug_print(&quot;Cannot update position: no node selected&quot;)&#10;            return&#10;&#10;        # Get new position from sliders&#10;        x = self.x_slider.val&#10;        y = self.y_slider.val&#10;        z = self.z_slider.val&#10;&#10;        debug_print(f&quot;Updating node {self.selected_node} position to ({x:.2f}, {y:.2f}, {z:.2f})&quot;)&#10;&#10;        # Update node position&#10;        self.node_dict[self.selected_node] = (x, y, z)&#10;&#10;        # Update position in the nodes list too&#10;        for node in self.nodes:&#10;            if node['id'] == self.selected_node:&#10;                node['x'] = f&quot;{x} ft&quot;&#10;                node['y'] = f&quot;{y} ft&quot;&#10;                node['z'] = f&quot;{z} ft&quot;&#10;                break&#10;&#10;        # Redraw structure&#10;        debug_print(&quot;Redrawing structure after position update&quot;)&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;        &#10;    def update_member_section(self, label):&#10;        &quot;&quot;&quot;Update the selected member's section type&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot update section: no member selected&quot;)&#10;            return&#10;            &#10;        section = int(label.split()[-1])  # Extract number from &quot;Section X&quot;&#10;        debug_print(f&quot;Updating member {self.selected_member} section to {section}&quot;)&#10;        &#10;        # Update member section&#10;        for member in self.members:&#10;            if member['id'] == self.selected_member:&#10;                member['section'] = section&#10;                break&#10;                &#10;        # Redraw structure&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;        &#10;    def update_member_material(self, label):&#10;        &quot;&quot;&quot;Update the selected member's material&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot update material: no member selected&quot;)&#10;            return&#10;            &#10;        material = int(label.split()[-1])  # Extract number from &quot;Material X&quot;&#10;        debug_print(f&quot;Updating member {self.selected_member} material to {material}&quot;)&#10;        &#10;        # Update member material&#10;        for member in self.members:&#10;            if member['id'] == self.selected_member:&#10;                member['material'] = material&#10;                break&#10;                &#10;        # Redraw structure&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;        &#10;    def start_change_member_nodes(self, event):&#10;        &quot;&quot;&quot;Start the process of changing a member's nodes&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot change nodes: no member selected&quot;)&#10;            return&#10;            &#10;        debug_print(f&quot;Starting node change for member {self.selected_member}&quot;)&#10;        self.mode = 'change_member_nodes'&#10;        self.member_creation_nodes = []&#10;        self.update_info_text()&#10;        &#10;    def update_member_nodes(self, member_id, new_i_node, new_j_node):&#10;        &quot;&quot;&quot;Update a member's connected nodes&quot;&quot;&quot;&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            debug_print(f&quot;Member {member_id} not found&quot;)&#10;            return&#10;            &#10;        old_i_node = member['i_node']&#10;        old_j_node = member['j_node']&#10;        &#10;        debug_print(f&quot;Updating member {member_id} nodes from {old_i_node}-{old_j_node} to {new_i_node}-{new_j_node}&quot;)&#10;        &#10;        # Remove member from old node connections&#10;        if old_i_node in self.node_connections and member_id in self.node_connections[old_i_node]:&#10;            self.node_connections[old_i_node].remove(member_id)&#10;            &#10;        if old_j_node in self.node_connections and member_id in self.node_connections[old_j_node]:&#10;            self.node_connections[old_j_node].remove(member_id)&#10;            &#10;        # Update member endpoints&#10;        member['i_node'] = new_i_node&#10;        member['j_node'] = new_j_node&#10;        &#10;        # Add to new node connections&#10;        if new_i_node not in self.node_connections:&#10;            self.node_connections[new_i_node] = []&#10;        self.node_connections[new_i_node].append(member_id)&#10;        &#10;        if new_j_node not in self.node_connections:&#10;            self.node_connections[new_j_node] = []&#10;        self.node_connections[new_j_node].append(member_id)&#10;        &#10;        debug_print(f&quot;Member {member_id} nodes updated successfully&quot;)&#10;&#10;    def delete_node(self):&#10;        &quot;&quot;&quot;Delete the selected node and connected members&quot;&quot;&quot;&#10;        if not self.selected_node:&#10;            print(&quot;Cannot delete: no node selected&quot;)&#10;            return&#10;&#10;        print(f&quot;Attempting to delete node {self.selected_node}&quot;)&#10;&#10;        # Check if node has any supports&#10;        if self.selected_node in self.supported_nodes:&#10;            print(f&quot;Cannot delete node {self.selected_node} because it has support constraints.&quot;)&#10;            return&#10;&#10;        # Get connected members&#10;        connected_members = self.node_connections[self.selected_node].copy()  # Make a copy to avoid modification during iteration&#10;        if connected_members:&#10;            print(f&quot;Deleting {len(connected_members)} members connected to node {self.selected_node}&quot;)&#10;&#10;            # Delete members&#10;            self.members = [m for m in self.members&#10;                           if m['id'] not in connected_members]&#10;&#10;            # Update connections dict for affected nodes&#10;            for member_id in connected_members:&#10;                member = next((m for m in self.members if m['id'] == member_id), None)&#10;                if member:&#10;                    other_node = member['i_node'] if member['j_node'] == self.selected_node else member['j_node']&#10;                    if other_node in self.node_connections and member_id in self.node_connections[other_node]:&#10;                        self.node_connections[other_node].remove(member_id)&#10;&#10;        # Delete node&#10;        self.nodes = [n for n in self.nodes if n['id'] != self.selected_node]&#10;        if self.selected_node in self.node_dict:&#10;            del self.node_dict[self.selected_node]&#10;        if self.selected_node in self.node_connections:&#10;            del self.node_connections[self.selected_node]&#10;&#10;        # Clear selection&#10;        self.selected_node = None&#10;        self.hide_node_editor()&#10;&#10;        # Redraw structure&#10;        self.plot_stairway()&#10;        self.update_info_text()&#10;&#10;    def delete_member(self):&#10;        &quot;&quot;&quot;Delete the selected member&quot;&quot;&quot;&#10;        if not self.selected_member:&#10;            debug_print(&quot;Cannot delete: no member selected&quot;)&#10;            return&#10;&#10;        member_id = self.selected_member&#10;        debug_print(f&quot;Deleting member {member_id}&quot;)&#10;&#10;        # Find the member&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            debug_print(f&quot;Member {member_id} not found&quot;)&#10;            return&#10;&#10;        # Remove member from connections&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        if i_node in self.node_connections and member_id in self.node_connections[i_node]:&#10;            self.node_connections[i_node].remove(member_id)&#10;&#10;        if j_node in self.node_connections and member_id in self.node_connections[j_node]:&#10;            self.node_connections[j_node].remove(member_id)&#10;&#10;        # Remove member from list&#10;        self.members = [m for m in self.members if m['id'] != member_id]&#10;&#10;        # Clear selection&#10;        self.selected_member = None&#10;        self.hide_member_editor()&#10;&#10;        debug_print(f&quot;Member {member_id} deleted&quot;)&#10;&#10;    def reset_view(self, event):&#10;        &quot;&quot;&quot;Reset the 3D view to default angle&quot;&quot;&quot;&#10;        print(&quot;Resetting view&quot;)&#10;        self.ax.view_init(elev=20, azim=-60)&#10;        plt.draw()&#10;&#10;    def save_structure(self, event):&#10;        &quot;&quot;&quot;Save the modified structure back to a JSON file&quot;&quot;&quot;&#10;        print(&quot;Saving structure...&quot;)&#10;        # Update the structure data with modified nodes&#10;        self.stairway_data['nodes'] = self.nodes&#10;        self.stairway_data['members'] = self.members&#10;&#10;        # Generate a timestamped filename&#10;        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')&#10;        base_name = os.path.splitext(self.json_file)[0]&#10;        output_file = f&quot;{base_name}_edited_{timestamp}.json&quot;&#10;&#10;        try:&#10;            with open(os.path.join(os.path.dirname(__file__), output_file), 'w') as f:&#10;                json.dump(self.stairway_data, f, indent=4)&#10;            print(f&quot;Successfully saved structure to {output_file}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error saving structure: {e}&quot;)&#10;&#10;    def create_member(self, node1, node2):&#10;        &quot;&quot;&quot;Create a new member between two nodes&quot;&quot;&quot;&#10;        # Determine the section type from the radio button&#10;        section_label = self.section_radio.value_selected&#10;        section_number = int(section_label.split()[-1])&#10;&#10;        # Create a new member&#10;        new_member = {&#10;            'id': self.next_member_id,&#10;            'i_node': node1,&#10;            'j_node': node2,&#10;            'material': 1,  # Default material&#10;            'section': section_number&#10;        }&#10;&#10;        debug_print(f&quot;Creating new member: {new_member}&quot;)&#10;&#10;        # Add to members list&#10;        self.members.append(new_member)&#10;&#10;        # Update connections dictionary&#10;        self.node_connections[node1].append(self.next_member_id)&#10;        self.node_connections[node2].append(self.next_member_id)&#10;&#10;        # Increment ID counter for next member&#10;        self.next_member_id += 1&#10;&#10;        # Highlight the new member temporarily&#10;        self.selected_member = new_member['id']&#10;&#10;        # Provide feedback&#10;        debug_print(f&quot;Member {new_member['id']} created between nodes {node1} and {node2}&quot;)&#10;&#10;&#10;# Helper functions for distance calculations&#10;def point_to_line_distance(x, y, x1, y1, x2, y2):&#10;    &quot;&quot;&quot;Calculate the distance from point (x,y) to line segment (x1,y1)-(x2,y2)&quot;&quot;&quot;&#10;    # Line segment length squared&#10;    l2 = (x2 - x1)**2 + (y2 - y1)**2&#10;&#10;    if l2 == 0:  # Line segment is a point&#10;        return np.sqrt((x - x1)**2 + (y - y1)**2)&#10;&#10;    # Calculate projection ratio (0-1 if within segment)&#10;    t = max(0, min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2))&#10;&#10;    # Calculate closest point on segment&#10;    px = x1 + t * (x2 - x1)&#10;    py = y1 + t * (y2 - y1)&#10;&#10;    # Return distance to that point&#10;    return np.sqrt((x - px)**2 + (y - py)**2)&#10;&#10;&#10;# Main execution&#10;if __name__ == &quot;__main__&quot;:&#10;    # Check if a file was provided as a command line argument&#10;    if len(sys.argv) &gt; 1:&#10;        json_file = sys.argv[1]&#10;    else:&#10;        # Default to a sample file if none specified&#10;        json_file = &quot;stairway_structure.json&quot;&#10;        print(f&quot;No file specified, using default: {json_file}&quot;)&#10;        &#10;        # Check if the file exists&#10;        if not os.path.exists(os.path.join(os.path.dirname(__file__), json_file)):&#10;            print(f&quot;Default file {json_file} not found.&quot;)&#10;            available_files = [f for f in os.listdir(os.path.dirname(__file__)) &#10;                              if f.endswith('.json')]&#10;            &#10;            if available_files:&#10;                json_file = available_files[0]&#10;                print(f&quot;Using first available JSON file: {json_file}&quot;)&#10;            else:&#10;                print(&quot;No JSON files found in the current directory.&quot;)&#10;                sys.exit(1)&#10;    &#10;    # Create and run the visualizer&#10;    visualizer = StairwayInteractiveVisualizer(json_file)&#10;    plt.show()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Stairways/run_stairway_interactive_pyqt.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Stairways/run_stairway_interactive_pyqt.py" />
              <option name="originalContent" value="# Interactive stairway structure visualization and editing tool using PyQt5 and OpenGL&#10;&#10;import os&#10;import json&#10;import sys&#10;import datetime&#10;import scipy as sp&#10;from scipy.spatial import distance&#10;from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,&#10;                            QHBoxLayout, QPushButton, QLabel, QSlider,&#10;                            QGroupBox, QRadioButton, QButtonGroup, QSplitter,&#10;                            QTextEdit, QFileDialog, QMessageBox, QSpinBox,&#10;                            QDoubleSpinBox, QComboBox, QTreeWidget, QTreeWidgetItem,&#10;                            QCheckBox)&#10;from PyQt5.QtCore import Qt, QTimer, pyqtSignal, QPoint&#10;from PyQt5.QtGui import QVector3D, QMatrix4x4, QQuaternion, QPainter, QFont, QColor&#10;from PyQt5.QtOpenGL import QGLWidget&#10;from OpenGL.GL import *&#10;from OpenGL.GLU import *&#10;&#10;# Global debug flag&#10;DEBUG = True&#10;&#10;def debug_print(*args, **kwargs):&#10;    &quot;&quot;&quot;Helper function for debug printing&quot;&quot;&quot;&#10;    if DEBUG:&#10;        print(*args, **kwargs)&#10;&#10;class StructureGLWidget(QGLWidget):&#10;    &quot;&quot;&quot;OpenGL widget for 3D structure visualization&quot;&quot;&quot;&#10;&#10;    nodeSelected = pyqtSignal(int)&#10;    memberSelected = pyqtSignal(int)&#10;&#10;    def __init__(self, parent=None):&#10;        super().__init__(parent)&#10;&#10;        # Set focus policy to receive keyboard events&#10;        self.setFocusPolicy(Qt.StrongFocus)&#10;&#10;        # Enable tracking mouse movements (even without button press)&#10;        self.setMouseTracking(True)&#10;&#10;        # Camera parameters&#10;        self.camera_distance = 50.0&#10;        self.camera_rotation = [20.0, -60.0]  # elevation, azimuth&#10;        self.camera_target = [0.0, 0.0, 0.0]&#10;&#10;        # Mouse interaction&#10;        self.last_mouse_pos = None&#10;        self.mouse_sensitivity = 0.5&#10;&#10;        # Structure data&#10;        self.nodes = {}&#10;        self.members = []&#10;        self.supports = []&#10;&#10;        # Selection&#10;        self.selected_node = None&#10;        self.selected_member = None&#10;        self.hover_node = None&#10;        self.hover_member = None&#10;&#10;        # Display options&#10;        self.show_node_ids = True&#10;        self.show_member_ids = False&#10;        self.show_grid = True&#10;&#10;        # Colors for sections&#10;        self.section_colors = {&#10;            1: (0.0, 0.0, 1.0),    # Blue - Main stringers&#10;            2: (0.0, 1.0, 0.0),    # Green - Steps/treads&#10;            3: (0.0, 1.0, 1.0),    # Cyan - Secondary members&#10;            4: (0.5, 0.5, 0.5),    # Gray - Bracing&#10;            5: (1.0, 0.0, 0.0)     # Red - Column&#10;        }&#10;&#10;        # Lists for text rendering (using QPainter instead of renderText)&#10;        self.node_labels = []  # Stores (x, y, text) for node labels&#10;        self.member_labels = []  # Stores (x, y, text) for member labels&#10;&#10;    def initializeGL(self):&#10;        &quot;&quot;&quot;Initialize OpenGL settings&quot;&quot;&quot;&#10;        debug_print(&quot;Initializing OpenGL...&quot;)&#10;&#10;        glClearColor(0.95, 0.95, 0.95, 1.0)&#10;        glEnable(GL_DEPTH_TEST)&#10;        glEnable(GL_LINE_SMOOTH)&#10;        glEnable(GL_BLEND)&#10;        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)&#10;        glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)&#10;&#10;        # Disable lighting initially - we'll use simple colors&#10;        glDisable(GL_LIGHTING)&#10;&#10;        debug_print(&quot;OpenGL initialized successfully&quot;)&#10;&#10;    def resizeGL(self, width, height):&#10;        &quot;&quot;&quot;Handle widget resize&quot;&quot;&quot;&#10;        debug_print(f&quot;Resizing GL widget to {width}x{height}&quot;)&#10;        glViewport(0, 0, width, height)&#10;        glMatrixMode(GL_PROJECTION)&#10;        glLoadIdentity()&#10;        aspect = width / float(height) if height &gt; 0 else 1.0&#10;        gluPerspective(45.0, aspect, 0.1, 1000.0)&#10;        glMatrixMode(GL_MODELVIEW)&#10;&#10;    def paintGL(self):&#10;        &quot;&quot;&quot;Render the scene&quot;&quot;&quot;&#10;        # Clear lists for text rendering&#10;        self.node_labels = []&#10;        self.member_labels = []&#10;&#10;        # Clear buffers&#10;        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)&#10;        glLoadIdentity()&#10;&#10;        # Set up camera&#10;        eye_x = self.camera_target[0] + self.camera_distance * sp.cos(sp.radians(self.camera_rotation[0])) * sp.cos(sp.radians(self.camera_rotation[1]))&#10;        eye_y = self.camera_target[1] + self.camera_distance * sp.cos(sp.radians(self.camera_rotation[0])) * sp.sin(sp.radians(self.camera_rotation[1]))&#10;        eye_z = self.camera_target[2] + self.camera_distance * sp.sin(sp.radians(self.camera_rotation[0]))&#10;&#10;        try:&#10;            gluLookAt(eye_x, eye_y, eye_z,&#10;                    self.camera_target[0], self.camera_target[1], self.camera_target[2],&#10;                    0.0, 0.0, 1.0)&#10;&#10;            # Draw grid&#10;            if self.show_grid:&#10;                self.drawGrid()&#10;&#10;            # Draw structure&#10;            self.drawMembers()&#10;            self.drawNodes()&#10;            self.drawSupports()&#10;&#10;            # Draw axes&#10;            self.drawAxes()&#10;&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in paintGL: {e}&quot;)&#10;&#10;    def paintEvent(self, event):&#10;        &quot;&quot;&quot;Override to combine OpenGL rendering with QPainter for text&quot;&quot;&quot;&#10;        # First do the standard OpenGL rendering&#10;        self.makeCurrent()&#10;        super().paintEvent(event)&#10;&#10;        # Then overlay text with QPainter&#10;        painter = QPainter(self)&#10;        painter.setRenderHint(QPainter.Antialiasing)&#10;        font = painter.font()&#10;        font.setPointSize(10)&#10;        painter.setFont(font)&#10;&#10;        # Draw node labels&#10;        if self.show_node_ids:&#10;            painter.setPen(Qt.black)&#10;            for x, y, text in self.node_labels:&#10;                painter.drawText(int(x), int(y), text)&#10;&#10;        # Draw member labels&#10;        if self.show_member_ids:&#10;            painter.setPen(Qt.darkGray)&#10;            for x, y, text in self.member_labels:&#10;                painter.drawText(int(x), int(y), text)&#10;&#10;        painter.end()&#10;&#10;    def drawGrid(self):&#10;        &quot;&quot;&quot;Draw reference grid&quot;&quot;&quot;&#10;        glColor3f(0.8, 0.8, 0.8)&#10;        glLineWidth(1.0)&#10;&#10;        glBegin(GL_LINES)&#10;        grid_size = 50&#10;        grid_step = 5&#10;        for i in range(-grid_size, grid_size + 1, grid_step):&#10;            glVertex3f(i, -grid_size, 0)&#10;            glVertex3f(i, grid_size, 0)&#10;            glVertex3f(-grid_size, i, 0)&#10;            glVertex3f(grid_size, i, 0)&#10;        glEnd()&#10;&#10;    def drawAxes(self):&#10;        &quot;&quot;&quot;Draw coordinate axes&quot;&quot;&quot;&#10;        glLineWidth(2.0)&#10;&#10;        # X axis - red&#10;        glColor3f(1.0, 0.0, 0.0)&#10;        glBegin(GL_LINES)&#10;        glVertex3f(0, 0, 0)&#10;        glVertex3f(10, 0, 0)&#10;        glEnd()&#10;&#10;        # Y axis - green&#10;        glColor3f(0.0, 1.0, 0.0)&#10;        glBegin(GL_LINES)&#10;        glVertex3f(0, 0, 0)&#10;        glVertex3f(0, 10, 0)&#10;        glEnd()&#10;&#10;        # Z axis - blue&#10;        glColor3f(0.0, 0.0, 1.0)&#10;        glBegin(GL_LINES)&#10;        glVertex3f(0, 0, 0)&#10;        glVertex3f(0, 0, 10)&#10;        glEnd()&#10;&#10;    def drawNodes(self):&#10;        &quot;&quot;&quot;Draw all nodes&quot;&quot;&quot;&#10;        for node_id, (x, y, z) in self.nodes.items():&#10;            # Set color based on selection/hover state&#10;            if node_id == self.selected_node:&#10;                glColor3f(1.0, 0.0, 0.0)&#10;                size = 10.0&#10;            elif node_id == self.hover_node:&#10;                glColor3f(1.0, 0.5, 0.0)&#10;                size = 8.0&#10;            else:&#10;                glColor3f(0.0, 0.0, 0.0)&#10;                size = 6.0&#10;&#10;            # Draw node as point&#10;            glPointSize(size)&#10;            glBegin(GL_POINTS)&#10;            glVertex3f(x, y, z)&#10;            glEnd()&#10;&#10;            # Add node ID to the list for later text rendering&#10;            if self.show_node_ids:&#10;                screen_pos = self.project3DToScreen(x, y, z)&#10;                if screen_pos:&#10;                    self.node_labels.append((screen_pos[0], screen_pos[1], str(node_id)))&#10;&#10;    def drawMembers(self):&#10;        &quot;&quot;&quot;Draw all members&quot;&quot;&quot;&#10;        for member in self.members:&#10;            try:&#10;                member_id = member['id']&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                section = member['section']&#10;&#10;                if i_node not in self.nodes or j_node not in self.nodes:&#10;                    continue&#10;&#10;                x1, y1, z1 = self.nodes[i_node]&#10;                x2, y2, z2 = self.nodes[j_node]&#10;&#10;                # Set color and width based on section and selection&#10;                if member_id == self.selected_member:&#10;                    glColor3f(1.0, 0.0, 0.0)&#10;                    line_width = 4.0&#10;                elif member_id == self.hover_member:&#10;                    glColor3f(1.0, 0.5, 0.0)&#10;                    line_width = 3.0&#10;                else:&#10;                    color = self.section_colors.get(section, (0.0, 0.0, 0.0))&#10;                    glColor3f(*color)&#10;                    line_width = 2.0 if section == 1 else 1.5&#10;&#10;                # Apply line width&#10;                glLineWidth(line_width)&#10;&#10;                # Draw member as line&#10;                glBegin(GL_LINES)&#10;                glVertex3f(x1, y1, z1)&#10;                glVertex3f(x2, y2, z2)&#10;                glEnd()&#10;&#10;                # Add member ID to the list for later text rendering&#10;                if self.show_member_ids:&#10;                    mid_x = (x1 + x2) / 2&#10;                    mid_y = (y1 + y2) / 2&#10;                    mid_z = (z1 + z2) / 2&#10;                    screen_pos = self.project3DToScreen(mid_x, mid_y, mid_z)&#10;                    if screen_pos:&#10;                        self.member_labels.append((screen_pos[0], screen_pos[1], str(member_id)))&#10;            except Exception as e:&#10;                debug_print(f&quot;Error drawing member {member.get('id', 'unknown')}: {e}&quot;)&#10;&#10;    def drawSupports(self):&#10;        &quot;&quot;&quot;Draw support constraints&quot;&quot;&quot;&#10;        for support in self.supports:&#10;            try:&#10;                node_id = support['node']&#10;                if node_id not in self.nodes:&#10;                    continue&#10;&#10;                x, y, z = self.nodes[node_id]&#10;&#10;                # Full support (fixed)&#10;                if support['ux'] == 1 and support['uy'] == 1 and support['uz'] == 1:&#10;                    glColor3f(1.0, 0.0, 0.0)&#10;                    # Draw as pyramid (simple triangle)&#10;                    glBegin(GL_TRIANGLES)&#10;                    glVertex3f(x - 0.5, y - 0.5, z - 0.5)&#10;                    glVertex3f(x + 0.5, y - 0.5, z - 0.5)&#10;                    glVertex3f(x, y + 0.5, z - 0.5)&#10;                    glEnd()&#10;                else:&#10;                    # Partial support&#10;                    glColor3f(1.0, 0.5, 0.0)&#10;                    # Draw as simple square&#10;                    glBegin(GL_QUADS)&#10;                    glVertex3f(x - 0.5, y - 0.5, z - 0.5)&#10;                    glVertex3f(x + 0.5, y - 0.5, z - 0.5)&#10;                    glVertex3f(x + 0.5, y + 0.5, z - 0.5)&#10;                    glVertex3f(x - 0.5, y + 0.5, z - 0.5)&#10;                    glEnd()&#10;            except Exception as e:&#10;                debug_print(f&quot;Error drawing support for node {support.get('node', 'unknown')}: {e}&quot;)&#10;&#10;    def mousePressEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse press events&quot;&quot;&quot;&#10;        self.last_mouse_pos = event.pos()&#10;&#10;        if event.button() == Qt.LeftButton and event.modifiers() != Qt.ControlModifier:&#10;            # Selection&#10;            node_id = self.pickNode(event.x(), event.y())&#10;            if node_id is not None:&#10;                self.selected_node = node_id&#10;                self.selected_member = None&#10;                self.nodeSelected.emit(node_id)&#10;                debug_print(f&quot;Selected node: {node_id}&quot;)&#10;            else:&#10;                member_id = self.pickMember(event.x(), event.y())&#10;                if member_id is not None:&#10;                    self.selected_member = member_id&#10;                    self.selected_node = None&#10;                    self.memberSelected.emit(member_id)&#10;                    debug_print(f&quot;Selected member: {member_id}&quot;)&#10;                else:&#10;                    self.selected_node = None&#10;                    self.selected_member = None&#10;&#10;            self.update()&#10;&#10;    def mouseMoveEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse move events&quot;&quot;&quot;&#10;        if self.last_mouse_pos is None:&#10;            return&#10;&#10;        dx = event.x() - self.last_mouse_pos.x()&#10;        dy = event.y() - self.last_mouse_pos.y()&#10;&#10;        if event.buttons() &amp; Qt.LeftButton and event.modifiers() &amp; Qt.ControlModifier:&#10;            # Rotate camera&#10;            self.camera_rotation[1] += dx * self.mouse_sensitivity&#10;            self.camera_rotation[0] += dy * self.mouse_sensitivity&#10;            self.camera_rotation[0] = max(-89, min(89, self.camera_rotation[0]))&#10;            self.update()&#10;        elif event.buttons() &amp; Qt.MiddleButton:&#10;            # Pan camera&#10;            pan_speed = 0.1&#10;            self.camera_target[0] -= dx * pan_speed&#10;            self.camera_target[1] += dy * pan_speed&#10;            self.update()&#10;&#10;        self.last_mouse_pos = event.pos()&#10;&#10;    def wheelEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse wheel events&quot;&quot;&quot;&#10;        delta = event.angleDelta().y()&#10;        zoom_speed = 0.1&#10;        self.camera_distance *= (1.0 - delta / 120.0 * zoom_speed)&#10;        self.camera_distance = max(5.0, min(200.0, self.camera_distance))&#10;        self.update()&#10;&#10;    def pickNode(self, x, y):&#10;        &quot;&quot;&quot;Find node at screen coordinates&quot;&quot;&quot;&#10;        min_dist = float('inf')&#10;        picked_node = None&#10;&#10;        for node_id, (nx, ny, nz) in self.nodes.items():&#10;            # Project 3D point to screen&#10;            screen_pos = self.project3DToScreen(nx, ny, nz)&#10;            if screen_pos is not None:&#10;                sx, sy = screen_pos&#10;                dist = sp.sqrt((x - sx)**2 + (y - sy)**2)&#10;                if dist &lt; 20 and dist &lt; min_dist:  # 20 pixel threshold&#10;                    min_dist = dist&#10;                    picked_node = node_id&#10;&#10;        return picked_node&#10;&#10;    def pickMember(self, x, y):&#10;        &quot;&quot;&quot;Find member at screen coordinates&quot;&quot;&quot;&#10;        min_dist = float('inf')&#10;        picked_member = None&#10;&#10;        for member in self.members:&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;&#10;            if i_node not in self.nodes or j_node not in self.nodes:&#10;                continue&#10;&#10;            x1, y1, z1 = self.nodes[i_node]&#10;            x2, y2, z2 = self.nodes[j_node]&#10;&#10;            # Project endpoints to screen&#10;            p1 = self.project3DToScreen(x1, y1, z1)&#10;            p2 = self.project3DToScreen(x2, y2, z2)&#10;&#10;            if p1 is not None and p2 is not None:&#10;                # Calculate distance from point to line segment&#10;                dist = self.pointToLineDistance(x, y, p1[0], p1[1], p2[0], p2[1])&#10;                if dist &lt; 10 and dist &lt; min_dist:  # 10 pixel threshold&#10;                    min_dist = dist&#10;                    picked_member = member['id']&#10;&#10;        return picked_member&#10;&#10;    def project3DToScreen(self, x, y, z):&#10;        &quot;&quot;&quot;Project 3D point to screen coordinates&quot;&quot;&quot;&#10;        try:&#10;            # Get viewport&#10;            viewport = glGetIntegerv(GL_VIEWPORT)&#10;&#10;            # Get matrices&#10;            modelview = glGetDoublev(GL_MODELVIEW_MATRIX)&#10;            projection = glGetDoublev(GL_PROJECTION_MATRIX)&#10;&#10;            # Project&#10;            result = gluProject(x, y, z, modelview, projection, viewport)&#10;            if result[2] &lt; 0 or result[2] &gt; 1:  # Behind camera or too far&#10;                return None&#10;&#10;            return (result[0], viewport[3] - result[1])  # Flip Y coordinate&#10;        except Exception as e:&#10;            debug_print(f&quot;Error projecting point: {e}&quot;)&#10;            return None&#10;&#10;    def pointToLineDistance(self, px, py, x1, y1, x2, y2):&#10;        &quot;&quot;&quot;Calculate distance from point to line segment&quot;&quot;&quot;&#10;        line_length_sq = (x2 - x1)**2 + (y2 - y1)**2&#10;        if line_length_sq == 0:&#10;            return sp.sqrt((px - x1)**2 + (py - y1)**2)&#10;&#10;        t = max(0, min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / line_length_sq))&#10;        proj_x = x1 + t * (x2 - x1)&#10;        proj_y = y1 + t * (y2 - y1)&#10;&#10;        return sp.sqrt((px - proj_x)**2 + (py - proj_y)**2)&#10;&#10;    def setStructureData(self, nodes, members, supports):&#10;        &quot;&quot;&quot;Update structure data&quot;&quot;&quot;&#10;        debug_print(f&quot;Setting structure data: {len(nodes)} nodes, {len(members)} members&quot;)&#10;        self.nodes = nodes&#10;        self.members = members&#10;        self.supports = supports&#10;        self.update()&#10;&#10;    def resetView(self):&#10;        &quot;&quot;&quot;Reset camera to default view&quot;&quot;&quot;&#10;        debug_print(&quot;Resetting view&quot;)&#10;        self.camera_distance = 50.0&#10;        self.camera_rotation = [20.0, -60.0]&#10;        self.camera_target = [0.0, 0.0, 0.0]&#10;        self.update()&#10;&#10;class StairwayInteractiveEditor(QMainWindow):&#10;    &quot;&quot;&quot;Main application window&quot;&quot;&quot;&#10;&#10;    def __init__(self, json_file):&#10;        super().__init__()&#10;        debug_print(f&quot;Initializing editor with file: {json_file}&quot;)&#10;        self.json_file = json_file&#10;        self.stairway_data = None&#10;        self.current_mode = &quot;view&quot;&#10;&#10;        # Create GL widget first so it's available for connecting signals&#10;        self.gl_widget = StructureGLWidget()&#10;&#10;        # Initialize data&#10;        self.load_data()&#10;&#10;        # Set up UI&#10;        self.init_ui()&#10;&#10;        # Update GL widget with structure data&#10;        debug_print(&quot;Setting initial structure data to GL widget&quot;)&#10;        self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;&#10;        # Connect signals&#10;        self.gl_widget.nodeSelected.connect(self.on_node_selected)&#10;        self.gl_widget.memberSelected.connect(self.on_member_selected)&#10;&#10;        # Setup mode state for member editing&#10;        self.member_creation_nodes = []&#10;&#10;        debug_print(&quot;Editor initialization complete&quot;)&#10;&#10;    def init_ui(self):&#10;        &quot;&quot;&quot;Initialize the user interface&quot;&quot;&quot;&#10;        self.setWindowTitle(f&quot;Stairway Structure Editor - {os.path.basename(self.json_file)}&quot;)&#10;        self.setGeometry(100, 100, 1400, 900)&#10;&#10;        # Central widget&#10;        central_widget = QWidget()&#10;        self.setCentralWidget(central_widget)&#10;&#10;        # Main layout&#10;        main_layout = QHBoxLayout()&#10;        central_widget.setLayout(main_layout)&#10;&#10;        # Left panel - controls&#10;        left_panel = self.create_left_panel()&#10;        main_layout.addWidget(left_panel, 1)&#10;&#10;        # Center - GL widget (already created in __init__)&#10;        main_layout.addWidget(self.gl_widget, 4)&#10;&#10;        # Right panel - properties&#10;        right_panel = self.create_right_panel()&#10;        main_layout.addWidget(right_panel, 1)&#10;&#10;    def create_left_panel(self):&#10;        &quot;&quot;&quot;Create the left control panel&quot;&quot;&quot;&#10;        panel = QWidget()&#10;        layout = QVBoxLayout()&#10;        panel.setLayout(layout)&#10;&#10;        # Mode selection&#10;        mode_group = QGroupBox(&quot;Edit Mode&quot;)&#10;        mode_layout = QVBoxLayout()&#10;        mode_group.setLayout(mode_layout)&#10;&#10;        self.mode_buttons = QButtonGroup()&#10;        modes = [&quot;View&quot;, &quot;Move Node&quot;, &quot;Add Node&quot;, &quot;Add Member&quot;, &quot;Delete Node&quot;, &quot;Delete Member&quot;, &quot;Edit Member&quot;]&#10;        for i, mode in enumerate(modes):&#10;            radio = QRadioButton(mode)&#10;            mode_layout.addWidget(radio)&#10;            self.mode_buttons.addButton(radio, i)&#10;            if i == 0:&#10;                radio.setChecked(True)&#10;&#10;        self.mode_buttons.buttonClicked.connect(self.on_mode_changed)&#10;        layout.addWidget(mode_group)&#10;&#10;        # Section selection for new members&#10;        section_group = QGroupBox(&quot;Member Section&quot;)&#10;        section_layout = QVBoxLayout()&#10;        section_group.setLayout(section_layout)&#10;&#10;        self.section_combo = QComboBox()&#10;        self.section_combo.addItems([f&quot;Section {i}&quot; for i in range(1, 6)])&#10;        section_layout.addWidget(self.section_combo)&#10;        layout.addWidget(section_group)&#10;&#10;        # Material selection&#10;        material_group = QGroupBox(&quot;Member Material&quot;)&#10;        material_layout = QVBoxLayout()&#10;        material_group.setLayout(material_layout)&#10;&#10;        self.material_combo = QComboBox()&#10;        self.material_combo.addItems([f&quot;Material {i}&quot; for i in range(1, 4)])&#10;        material_layout.addWidget(self.material_combo)&#10;        layout.addWidget(material_group)&#10;&#10;        # Action buttons&#10;        self.save_button = QPushButton(&quot;Save Structure&quot;)&#10;        self.save_button.clicked.connect(self.save_structure)&#10;        layout.addWidget(self.save_button)&#10;&#10;        self.reset_view_button = QPushButton(&quot;Reset View&quot;)&#10;        self.reset_view_button.clicked.connect(self.reset_view)  # Now connects to our method&#10;        layout.addWidget(self.reset_view_button)&#10;&#10;        # Display options&#10;        display_group = QGroupBox(&quot;Display Options&quot;)&#10;        display_layout = QVBoxLayout()&#10;        display_group.setLayout(display_layout)&#10;&#10;        self.show_nodes_cb = QCheckBox(&quot;Show Node IDs&quot;)&#10;        self.show_nodes_cb.setChecked(True)&#10;        self.show_nodes_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_nodes_cb)&#10;&#10;        self.show_members_cb = QCheckBox(&quot;Show Member IDs&quot;)&#10;        self.show_members_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_members_cb)&#10;&#10;        self.show_grid_cb = QCheckBox(&quot;Show Grid&quot;)&#10;        self.show_grid_cb.setChecked(True)&#10;        self.show_grid_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_grid_cb)&#10;&#10;        layout.addWidget(display_group)&#10;&#10;        # Info text&#10;        self.info_text = QTextEdit()&#10;        self.info_text.setReadOnly(True)&#10;        self.info_text.setMaximumHeight(200)&#10;        layout.addWidget(self.info_text)&#10;&#10;        layout.addStretch()&#10;&#10;        return panel&#10;&#10;    def create_right_panel(self):&#10;        &quot;&quot;&quot;Create the right properties panel&quot;&quot;&quot;&#10;        panel = QWidget()&#10;        layout = QVBoxLayout()&#10;        panel.setLayout(layout)&#10;&#10;        # Node properties&#10;        self.node_group = QGroupBox(&quot;Node Properties&quot;)&#10;        node_layout = QVBoxLayout()&#10;        self.node_group.setLayout(node_layout)&#10;&#10;        # Node ID&#10;        node_id_layout = QHBoxLayout()&#10;        node_id_layout.addWidget(QLabel(&quot;ID:&quot;))&#10;        self.node_id_label = QLabel(&quot;-&quot;)&#10;        node_id_layout.addWidget(self.node_id_label)&#10;        node_id_layout.addStretch()&#10;        node_layout.addLayout(node_id_layout)&#10;&#10;        # Node coordinates&#10;        self.node_x_spin = QDoubleSpinBox()&#10;        self.node_x_spin.setRange(-1000, 1000)&#10;        self.node_x_spin.setSingleStep(0.1)&#10;        self.node_x_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        self.node_y_spin = QDoubleSpinBox()&#10;        self.node_y_spin.setRange(-1000, 1000)&#10;        self.node_y_spin.setSingleStep(0.1)&#10;        self.node_y_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        self.node_z_spin = QDoubleSpinBox()&#10;        self.node_z_spin.setRange(-1000, 1000)&#10;        self.node_z_spin.setSingleStep(0.1)&#10;        self.node_z_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        coord_layout = QVBoxLayout()&#10;        for label, spin in [(&quot;X:&quot;, self.node_x_spin), (&quot;Y:&quot;, self.node_y_spin), (&quot;Z:&quot;, self.node_z_spin)]:&#10;            row = QHBoxLayout()&#10;            row.addWidget(QLabel(label))&#10;            row.addWidget(spin)&#10;            coord_layout.addLayout(row)&#10;&#10;        node_layout.addLayout(coord_layout)&#10;        self.node_group.setEnabled(False)&#10;        layout.addWidget(self.node_group)&#10;&#10;        # Member properties&#10;        self.member_group = QGroupBox(&quot;Member Properties&quot;)&#10;        member_layout = QVBoxLayout()&#10;        self.member_group.setLayout(member_layout)&#10;&#10;        # Member ID&#10;        member_id_layout = QHBoxLayout()&#10;        member_id_layout.addWidget(QLabel(&quot;ID:&quot;))&#10;        self.member_id_label = QLabel(&quot;-&quot;)&#10;        member_id_layout.addWidget(self.member_id_label)&#10;        member_id_layout.addStretch()&#10;        member_layout.addLayout(member_id_layout)&#10;&#10;        # Member nodes&#10;        nodes_layout = QHBoxLayout()&#10;        nodes_layout.addWidget(QLabel(&quot;Nodes:&quot;))&#10;        self.member_nodes_label = QLabel(&quot;-&quot;)&#10;        nodes_layout.addWidget(self.member_nodes_label)&#10;        nodes_layout.addStretch()&#10;        member_layout.addLayout(nodes_layout)&#10;&#10;        # Member section&#10;        self.member_section_combo = QComboBox()&#10;        self.member_section_combo.addItems([f&quot;Section {i}&quot; for i in range(1, 6)])&#10;        self.member_section_combo.currentIndexChanged.connect(self.update_member_properties)&#10;&#10;        section_layout = QHBoxLayout()&#10;        section_layout.addWidget(QLabel(&quot;Section:&quot;))&#10;        section_layout.addWidget(self.member_section_combo)&#10;        member_layout.addLayout(section_layout)&#10;&#10;        # Member material&#10;        self.member_material_combo = QComboBox()&#10;        self.member_material_combo.addItems([f&quot;Material {i}&quot; for i in range(1, 4)])&#10;        self.member_material_combo.currentIndexChanged.connect(self.update_member_properties)&#10;&#10;        material_layout = QHBoxLayout()&#10;        material_layout.addWidget(QLabel(&quot;Material:&quot;))&#10;        material_layout.addWidget(self.member_material_combo)&#10;        member_layout.addLayout(material_layout)&#10;&#10;        # Change nodes button&#10;        self.change_nodes_button = QPushButton(&quot;Change Connected Nodes&quot;)&#10;        self.change_nodes_button.clicked.connect(self.start_change_member_nodes)&#10;        member_layout.addWidget(self.change_nodes_button)&#10;&#10;        self.member_group.setEnabled(False)&#10;        layout.addWidget(self.member_group)&#10;&#10;        # Structure tree&#10;        tree_group = QGroupBox(&quot;Structure Tree&quot;)&#10;        tree_layout = QVBoxLayout()&#10;        tree_group.setLayout(tree_layout)&#10;&#10;        self.structure_tree = QTreeWidget()&#10;        self.structure_tree.setHeaderLabels([&quot;Element&quot;, &quot;Type&quot;, &quot;Properties&quot;])&#10;        tree_layout.addWidget(self.structure_tree)&#10;        self.populate_structure_tree()&#10;&#10;        layout.addWidget(tree_group)&#10;&#10;        layout.addStretch()&#10;&#10;        return panel&#10;&#10;    def populate_structure_tree(self):&#10;        &quot;&quot;&quot;Populate the structure tree with nodes and members&quot;&quot;&quot;&#10;        self.structure_tree.clear()&#10;&#10;        # Add nodes&#10;        nodes_item = QTreeWidgetItem([&quot;Nodes&quot;, f&quot;{len(self.nodes)}&quot;, &quot;&quot;])&#10;        self.structure_tree.addTopLevelItem(nodes_item)&#10;&#10;        # Add members grouped by section&#10;        sections = {}&#10;        for member in self.members:&#10;            section = member['section']&#10;            if section not in sections:&#10;                sections[section] = []&#10;            sections[section].append(member)&#10;&#10;        for section, members in sections.items():&#10;            section_item = QTreeWidgetItem([f&quot;Section {section}&quot;, f&quot;{len(members)} members&quot;, &quot;&quot;])&#10;            self.structure_tree.addTopLevelItem(section_item)&#10;&#10;        self.structure_tree.expandAll()&#10;&#10;    def load_data(self):&#10;        &quot;&quot;&quot;Load structure data from JSON file&quot;&quot;&quot;&#10;        debug_print(f&quot;Loading structure from {self.json_file}&quot;)&#10;&#10;        try:&#10;            with open(self.json_file, 'r') as file:&#10;                json_str = &quot;&quot;&#10;                for line in file:&#10;                    if '//' not in line:&#10;                        json_str += line&#10;&#10;                self.stairway_data = json.loads(json_str)&#10;&#10;            # Extract data&#10;            self.nodes = self.stairway_data['nodes']&#10;            self.supports = self.stairway_data['supports']&#10;            self.members = self.stairway_data['members']&#10;            self.materials = self.stairway_data.get('materials', [])&#10;            self.sections = self.stairway_data.get('sections', [])&#10;&#10;            # Create node dictionary&#10;            self.node_dict = {}&#10;            for node in self.nodes:&#10;                node_id = node['id']&#10;                x = float(node['x'].split()[0])&#10;                y = float(node['y'].split()[0])&#10;                z = float(node['z'].split()[0])&#10;                self.node_dict[node_id] = (x, y, z)&#10;&#10;            # Create connections map&#10;            self.node_connections = {node_id: [] for node_id in self.node_dict}&#10;            for member in self.members:&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                member_id = member['id']&#10;&#10;                if i_node in self.node_connections:&#10;                    self.node_connections[i_node].append(member_id)&#10;                if j_node in self.node_connections:&#10;                    self.node_connections[j_node].append(member_id)&#10;&#10;            debug_print(f&quot;Loaded {len(self.nodes)} nodes, {len(self.members)} members&quot;)&#10;&#10;        except Exception as e:&#10;            debug_print(f&quot;Error loading file: {str(e)}&quot;)&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Failed to load file: {str(e)}&quot;)&#10;            sys.exit(1)&#10;&#10;    def update_display_options(self):&#10;        &quot;&quot;&quot;Update display options in GL widget&quot;&quot;&quot;&#10;        self.gl_widget.show_node_ids = self.show_nodes_cb.isChecked()&#10;        self.gl_widget.show_member_ids = self.show_members_cb.isChecked()&#10;        self.gl_widget.show_grid = self.show_grid_cb.isChecked()&#10;        self.gl_widget.update()&#10;&#10;    def on_mode_changed(self, button):&#10;        &quot;&quot;&quot;Handle mode change&quot;&quot;&quot;&#10;        mode_index = self.mode_buttons.id(button)&#10;        modes = [&quot;view&quot;, &quot;move&quot;, &quot;add_node&quot;, &quot;add_member&quot;, &quot;delete_node&quot;, &quot;delete_member&quot;, &quot;edit_member&quot;]&#10;        self.current_mode = modes[mode_index]&#10;        debug_print(f&quot;Mode changed to: {self.current_mode}&quot;)&#10;&#10;        # Reset state when changing modes&#10;        if self.current_mode == &quot;add_member&quot;:&#10;            self.member_creation_nodes = []&#10;&#10;        # Update UI based on mode&#10;        if self.current_mode == &quot;move&quot;:&#10;            self.node_group.setEnabled(self.gl_widget.selected_node is not None)&#10;            self.member_group.setEnabled(False)&#10;        elif self.current_mode == &quot;edit_member&quot;:&#10;            self.node_group.setEnabled(False)&#10;            self.member_group.setEnabled(self.gl_widget.selected_member is not None)&#10;        else:&#10;            self.node_group.setEnabled(False)&#10;            self.member_group.setEnabled(False)&#10;&#10;        self.update_info_text()&#10;&#10;    def on_node_selected(self, node_id):&#10;        &quot;&quot;&quot;Handle node selection&quot;&quot;&quot;&#10;        debug_print(f&quot;Node {node_id} selected&quot;)&#10;&#10;        # Handle node selection for add_member mode&#10;        if self.current_mode == &quot;add_member&quot;:&#10;            if node_id in self.member_creation_nodes:&#10;                debug_print(f&quot;Node {node_id} already selected&quot;)&#10;                return&#10;&#10;            self.member_creation_nodes.append(node_id)&#10;            debug_print(f&quot;Added node {node_id} to member creation (nodes: {self.member_creation_nodes})&quot;)&#10;&#10;            if len(self.member_creation_nodes) == 2:&#10;                self.create_member(self.member_creation_nodes[0], self.member_creation_nodes[1])&#10;                self.member_creation_nodes = []&#10;&#10;            self.update_info_text()&#10;            return&#10;&#10;        # Update node properties panel&#10;        self.node_id_label.setText(str(node_id))&#10;        x, y, z = self.node_dict[node_id]&#10;&#10;        # Block signals to prevent recursive updates&#10;        self.node_x_spin.blockSignals(True)&#10;        self.node_y_spin.blockSignals(True)&#10;        self.node_z_spin.blockSignals(True)&#10;&#10;        self.node_x_spin.setValue(x)&#10;        self.node_y_spin.setValue(y)&#10;        self.node_z_spin.setValue(z)&#10;&#10;        self.node_x_spin.blockSignals(False)&#10;        self.node_y_spin.blockSignals(False)&#10;        self.node_z_spin.blockSignals(False)&#10;&#10;        # Enable/disable panels based on mode&#10;        if self.current_mode == &quot;move&quot;:&#10;            self.node_group.setEnabled(True)&#10;        elif self.current_mode == &quot;delete_node&quot;:&#10;            self.delete_node(node_id)&#10;&#10;        self.member_group.setEnabled(False)&#10;        self.update_info_text()&#10;&#10;    def on_member_selected(self, member_id):&#10;        &quot;&quot;&quot;Handle member selection&quot;&quot;&quot;&#10;        debug_print(f&quot;Member {member_id} selected&quot;)&#10;&#10;        if self.current_mode == &quot;delete_member&quot;:&#10;            self.delete_member(member_id)&#10;            return&#10;&#10;        # Find member data&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            return&#10;&#10;        # Update member properties panel&#10;        self.member_id_label.setText(str(member_id))&#10;        self.member_nodes_label.setText(f&quot;{member['i_node']} - {member['j_node']}&quot;)&#10;&#10;        # Block signals&#10;        self.member_section_combo.blockSignals(True)&#10;        self.member_material_combo.blockSignals(True)&#10;&#10;        self.member_section_combo.setCurrentIndex(member['section'] - 1)&#10;        self.member_material_combo.setCurrentIndex(member['material'] - 1)&#10;&#10;        self.member_section_combo.blockSignals(False)&#10;        self.member_material_combo.blockSignals(False)&#10;&#10;        # Enable/disable panels based on mode&#10;        self.node_group.setEnabled(False)&#10;        if self.current_mode == &quot;edit_member&quot;:&#10;            self.member_group.setEnabled(True)&#10;&#10;        self.update_info_text()&#10;&#10;    def update_node_position(self):&#10;        &quot;&quot;&quot;Update selected node position from spinboxes&quot;&quot;&quot;&#10;        if not self.gl_widget.selected_node:&#10;            return&#10;&#10;        node_id = self.gl_widget.selected_node&#10;        x = self.node_x_spin.value()&#10;        y = self.node_y_spin.value()&#10;        z = self.node_z_spin.value()&#10;&#10;        # Update internal data&#10;        self.node_dict[node_id] = (x, y, z)&#10;&#10;        # Update node in list&#10;        for node in self.nodes:&#10;            if node['id'] == node_id:&#10;                node['x'] = f&quot;{x} ft&quot;&#10;                node['y'] = f&quot;{y} ft&quot;&#10;                node['z'] = f&quot;{z} ft&quot;&#10;                break&#10;&#10;        # Update GL widget&#10;        self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;&#10;    def update_member_properties(self):&#10;        &quot;&quot;&quot;Update selected member properties&quot;&quot;&quot;&#10;        if not self.gl_widget.selected_member:&#10;            return&#10;&#10;        member_id = self.gl_widget.selected_member&#10;&#10;        # Find member&#10;        for member in self.members:&#10;            if member['id'] == member_id:&#10;                member['section'] = self.member_section_combo.currentIndex() + 1&#10;                member['material'] = self.member_material_combo.currentIndex() + 1&#10;                break&#10;&#10;        # Update GL widget&#10;        self.gl_widget.update()&#10;&#10;    def start_change_member_nodes(self):&#10;        &quot;&quot;&quot;Start process to change member's connected nodes&quot;&quot;&quot;&#10;        if not self.gl_widget.selected_member:&#10;            return&#10;&#10;        # Switch to special mode for changing member nodes&#10;        self.current_mode = &quot;change_member_nodes&quot;&#10;        self.member_creation_nodes = []&#10;&#10;        QMessageBox.information(self, &quot;Change Nodes&quot;,&#10;                              &quot;Select two nodes to reconnect the member&quot;)&#10;        self.update_info_text()&#10;&#10;    def update_member_nodes(self, member_id, new_i_node, new_j_node):&#10;        &quot;&quot;&quot;Update a member's connected nodes&quot;&quot;&quot;&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            return&#10;&#10;        old_i_node = member['i_node']&#10;        old_j_node = member['j_node']&#10;&#10;        # Remove member from old node connections&#10;        if old_i_node in self.node_connections and member_id in self.node_connections[old_i_node]:&#10;            self.node_connections[old_i_node].remove(member_id)&#10;&#10;        if old_j_node in self.node_connections and member_id in self.node_connections[old_j_node]:&#10;            self.node_connections[old_j_node].remove(member_id)&#10;&#10;        # Update member endpoints&#10;        member['i_node'] = new_i_node&#10;        member['j_node'] = new_j_node&#10;&#10;        # Add to new node connections&#10;        if new_i_node not in self.node_connections:&#10;            self.node_connections[new_i_node] = []&#10;        self.node_connections[new_i_node].append(member_id)&#10;&#10;        if new_j_node not in self.node_connections:&#10;            self.node_connections[new_j_node] = []&#10;        self.node_connections[new_j_node].append(member_id)&#10;&#10;        # Update GL widget&#10;        self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;&#10;    def create_member(self, node1, node2):&#10;        &quot;&quot;&quot;Create a new member between two nodes&quot;&quot;&quot;&#10;        section = self.section_combo.currentIndex() + 1&#10;        material = self.material_combo.currentIndex() + 1&#10;&#10;        # Get next member ID&#10;        next_id = max([m['id'] for m in self.members], default=0) + 1&#10;&#10;        # Create new member&#10;        new_member = {&#10;            'id': next_id,&#10;            'i_node': node1,&#10;            'j_node': node2,&#10;            'section': section,&#10;            'material': material&#10;        }&#10;&#10;        debug_print(f&quot;Creating member {next_id} between nodes {node1}-{node2}&quot;)&#10;&#10;        # Add to data structures&#10;        self.members.append(new_member)&#10;&#10;        # Update connections&#10;        if node1 not in self.node_connections:&#10;            self.node_connections[node1] = []&#10;        self.node_connections[node1].append(next_id)&#10;&#10;        if node2 not in self.node_connections:&#10;            self.node_connections[node2] = []&#10;        self.node_connections[node2].append(next_id)&#10;&#10;        # Update visualization&#10;        self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;        self.populate_structure_tree()&#10;&#10;    def delete_node(self, node_id):&#10;        &quot;&quot;&quot;Delete a node and its connected members&quot;&quot;&quot;&#10;        debug_print(f&quot;Deleting node {node_id}&quot;)&#10;&#10;        # Get connected members&#10;        connected_members = self.node_connections.get(node_id, [])[:]&#10;&#10;        # Delete connected members&#10;        if connected_members:&#10;            for member_id in connected_members:&#10;                self.delete_member(member_id, update_viz=False)&#10;&#10;        # Delete node&#10;        self.nodes = [n for n in self.nodes if n['id'] != node_id]&#10;        if node_id in self.node_dict:&#10;            del self.node_dict[node_id]&#10;        if node_id in self.node_connections:&#10;            del self.node_connections[node_id]&#10;&#10;        # Update GL widget&#10;        self.gl_widget.selected_node = None&#10;        self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;        self.populate_structure_tree()&#10;        self.update_info_text()&#10;&#10;    def delete_member(self, member_id, update_viz=True):&#10;        &quot;&quot;&quot;Delete a member&quot;&quot;&quot;&#10;        debug_print(f&quot;Deleting member {member_id}&quot;)&#10;&#10;        # Find member&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            return&#10;&#10;        # Remove from connections&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        if i_node in self.node_connections and member_id in self.node_connections[i_node]:&#10;            self.node_connections[i_node].remove(member_id)&#10;&#10;        if j_node in self.node_connections and member_id in self.node_connections[j_node]:&#10;            self.node_connections[j_node].remove(member_id)&#10;&#10;        # Remove from list&#10;        self.members = [m for m in self.members if m['id'] != member_id]&#10;&#10;        # Update visualization if requested&#10;        if update_viz:&#10;            self.gl_widget.selected_member = None&#10;            self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;            self.populate_structure_tree()&#10;            self.update_info_text()&#10;&#10;    def update_info_text(self):&#10;        &quot;&quot;&quot;Update information text&quot;&quot;&quot;&#10;        info = f&quot;Mode: {self.current_mode.replace('_', ' ').title()}\n\n&quot;&#10;&#10;        if self.current_mode == &quot;add_member&quot;:&#10;            info += f&quot;Select nodes to create a member.\n&quot;&#10;            info += f&quot;Selected nodes: {len(self.member_creation_nodes)}/2\n\n&quot;&#10;        elif self.current_mode == &quot;change_member_nodes&quot;:&#10;            info += f&quot;Select nodes to reconnect member {self.gl_widget.selected_member}.\n&quot;&#10;            info += f&quot;Selected nodes: {len(self.member_creation_nodes)}/2\n\n&quot;&#10;&#10;        if self.gl_widget.selected_node:&#10;            node_id = self.gl_widget.selected_node&#10;            x, y, z = self.node_dict[node_id]&#10;            info += f&quot;Selected Node: {node_id}\n&quot;&#10;            info += f&quot;Position: ({x:.2f}, {y:.2f}, {z:.2f})\n&quot;&#10;            info += f&quot;Connected Members: {len(self.node_connections[node_id])}\n&quot;&#10;&#10;        elif self.gl_widget.selected_member:&#10;            member = next((m for m in self.members if m['id'] == self.gl_widget.selected_member), None)&#10;            if member:&#10;                info += f&quot;Selected Member: {member['id']}\n&quot;&#10;                info += f&quot;Nodes: {member['i_node']} - {member['j_node']}\n&quot;&#10;                info += f&quot;Section: {member['section']}, Material: {member['material']}\n&quot;&#10;&#10;                # Calculate length&#10;                i_pos = self.node_dict[member['i_node']]&#10;                j_pos = self.node_dict[member['j_node']]&#10;                length = sp.sqrt(sum((j_pos[i] - i_pos[i])**2 for i in range(3)))&#10;                info += f&quot;Length: {length:.2f} ft\n&quot;&#10;&#10;        self.info_text.setText(info)&#10;&#10;    def reset_view(self):&#10;        &quot;&quot;&quot;Reset camera view in GL widget&quot;&quot;&quot;&#10;        debug_print(&quot;Resetting view&quot;)&#10;        self.gl_widget.resetView()&#10;&#10;    def save_structure(self):&#10;        &quot;&quot;&quot;Save structure to JSON file&quot;&quot;&quot;&#10;        # Update structure data&#10;        self.stairway_data['nodes'] = self.nodes&#10;        self.stairway_data['members'] = self.members&#10;&#10;        # Generate filename&#10;        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')&#10;        base_name = os.path.splitext(self.json_file)[0]&#10;        output_file = f&quot;{base_name}_edited_{timestamp}.json&quot;&#10;&#10;        try:&#10;            with open(output_file, 'w') as f:&#10;                json.dump(self.stairway_data, f, indent=4)&#10;            QMessageBox.information(self, &quot;Success&quot;, f&quot;Structure saved to {output_file}&quot;)&#10;            debug_print(f&quot;Saved structure to {output_file}&quot;)&#10;        except Exception as e:&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Failed to save: {str(e)}&quot;)&#10;            debug_print(f&quot;Error saving: {str(e)}&quot;)&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main entry point&quot;&quot;&quot;&#10;    app = QApplication(sys.argv)&#10;&#10;    # Get JSON file&#10;    if len(sys.argv) &gt; 1:&#10;        json_file = sys.argv[1]&#10;    else:&#10;        json_file = &quot;stairway_structure.json&quot;&#10;        if not os.path.exists(json_file):&#10;            # Try to find any JSON file&#10;            json_files = [f for f in os.listdir('.') if f.endswith('.json')]&#10;            if json_files:&#10;                json_file = json_files[0]&#10;            else:&#10;                print(&quot;No JSON files found&quot;)&#10;                sys.exit(1)&#10;&#10;    # Create and show main window&#10;    try:&#10;        editor = StairwayInteractiveEditor(json_file)&#10;        editor.show()&#10;        sys.exit(app.exec_())&#10;    except Exception as e:&#10;        print(f&quot;Fatal error: {str(e)}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;        sys.exit(1)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="# Interactive stairway structure visualization and editing tool using PyQt5 and OpenGL&#10;&#10;import os&#10;import json&#10;import sys&#10;import datetime&#10;import scipy as sp&#10;from scipy.spatial import distance&#10;from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,&#10;                            QHBoxLayout, QPushButton, QLabel, QSlider,&#10;                            QGroupBox, QRadioButton, QButtonGroup, QSplitter,&#10;                            QTextEdit, QFileDialog, QMessageBox, QSpinBox,&#10;                            QDoubleSpinBox, QComboBox, QTreeWidget, QTreeWidgetItem,&#10;                            QCheckBox)&#10;from PyQt5.QtCore import Qt, QTimer, pyqtSignal, QPoint&#10;from PyQt5.QtGui import QVector3D, QMatrix4x4, QQuaternion, QPainter, QFont, QColor&#10;from PyQt5.QtOpenGL import QGLWidget&#10;from OpenGL.GL import *&#10;from OpenGL.GLU import *&#10;&#10;# Global debug flag&#10;DEBUG = True&#10;&#10;def debug_print(*args, **kwargs):&#10;    &quot;&quot;&quot;Helper function for debug printing&quot;&quot;&quot;&#10;    if DEBUG:&#10;        print(*args, **kwargs)&#10;&#10;class StructureGLWidget(QGLWidget):&#10;    &quot;&quot;&quot;OpenGL widget for 3D structure visualization&quot;&quot;&quot;&#10;&#10;    nodeSelected = pyqtSignal(int)&#10;    memberSelected = pyqtSignal(int)&#10;&#10;    def __init__(self, parent=None):&#10;        super().__init__(parent)&#10;&#10;        # Set focus policy to receive keyboard events&#10;        self.setFocusPolicy(Qt.StrongFocus)&#10;&#10;        # Enable tracking mouse movements (even without button press)&#10;        self.setMouseTracking(True)&#10;&#10;        # Camera parameters&#10;        self.camera_distance = 50.0&#10;        self.camera_rotation = [20.0, -60.0]  # elevation, azimuth&#10;        self.camera_target = [0.0, 0.0, 0.0]&#10;&#10;        # Mouse interaction&#10;        self.last_mouse_pos = None&#10;        self.mouse_sensitivity = 0.5&#10;&#10;        # Structure data&#10;        self.nodes = {}&#10;        self.members = []&#10;        self.supports = []&#10;&#10;        # Selection&#10;        self.selected_node = None&#10;        self.selected_member = None&#10;        self.hover_node = None&#10;        self.hover_member = None&#10;&#10;        # Display options&#10;        self.show_node_ids = True&#10;        self.show_member_ids = False&#10;        self.show_grid = True&#10;        self.show_axes_labels = True&#10;&#10;        # Colors for sections&#10;        self.section_colors = {&#10;            1: (0.0, 0.0, 1.0),    # Blue - Main stringers&#10;            2: (0.0, 1.0, 0.0),    # Green - Steps/treads&#10;            3: (0.0, 1.0, 1.0),    # Cyan - Secondary members&#10;            4: (0.5, 0.5, 0.5),    # Gray - Bracing&#10;            5: (1.0, 0.0, 0.0)     # Red - Column&#10;        }&#10;&#10;        # Lists for text rendering (using QPainter instead of renderText)&#10;        self.node_labels = []  # Stores (x, y, text) for node labels&#10;        self.member_labels = []  # Stores (x, y, text) for member labels&#10;        self.axes_labels = []  # Stores (x, y, text) for axis labels&#10;&#10;    def initializeGL(self):&#10;        &quot;&quot;&quot;Initialize OpenGL settings&quot;&quot;&quot;&#10;        debug_print(&quot;Initializing OpenGL...&quot;)&#10;&#10;        glClearColor(0.95, 0.95, 0.95, 1.0)&#10;        glEnable(GL_DEPTH_TEST)&#10;        glEnable(GL_LINE_SMOOTH)&#10;        glEnable(GL_BLEND)&#10;        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)&#10;        glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)&#10;&#10;        # Disable lighting initially - we'll use simple colors&#10;        glDisable(GL_LIGHTING)&#10;&#10;        # Set up right-handed coordinate system by default in OpenGL&#10;        # OpenGL uses right-handed by default, no change needed&#10;        &#10;        debug_print(&quot;OpenGL initialized successfully&quot;)&#10;&#10;    def resizeGL(self, width, height):&#10;        &quot;&quot;&quot;Handle widget resize&quot;&quot;&quot;&#10;        debug_print(f&quot;Resizing GL widget to {width}x{height}&quot;)&#10;        glViewport(0, 0, width, height)&#10;        glMatrixMode(GL_PROJECTION)&#10;        glLoadIdentity()&#10;        aspect = width / float(height) if height &gt; 0 else 1.0&#10;        gluPerspective(45.0, aspect, 0.1, 1000.0)&#10;        glMatrixMode(GL_MODELVIEW)&#10;&#10;    def paintGL(self):&#10;        &quot;&quot;&quot;Render the scene&quot;&quot;&quot;&#10;        # Clear lists for text rendering&#10;        self.node_labels = []&#10;        self.member_labels = []&#10;&#10;        # Clear buffers&#10;        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)&#10;        glLoadIdentity()&#10;&#10;        # Set up camera&#10;        eye_x = self.camera_target[0] + self.camera_distance * sp.cos(sp.radians(self.camera_rotation[0])) * sp.cos(sp.radians(self.camera_rotation[1]))&#10;        eye_y = self.camera_target[1] + self.camera_distance * sp.cos(sp.radians(self.camera_rotation[0])) * sp.sin(sp.radians(self.camera_rotation[1]))&#10;        eye_z = self.camera_target[2] + self.camera_distance * sp.sin(sp.radians(self.camera_rotation[0]))&#10;&#10;        try:&#10;            gluLookAt(eye_x, eye_y, eye_z,&#10;                    self.camera_target[0], self.camera_target[1], self.camera_target[2],&#10;                    0.0, 0.0, 1.0)&#10;&#10;            # Draw grid&#10;            if self.show_grid:&#10;                self.drawGrid()&#10;&#10;            # Draw structure&#10;            self.drawMembers()&#10;            self.drawNodes()&#10;            self.drawSupports()&#10;&#10;            # Draw axes&#10;            self.drawAxes()&#10;&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in paintGL: {e}&quot;)&#10;&#10;    def paintEvent(self, event):&#10;        &quot;&quot;&quot;Override to combine OpenGL rendering with QPainter for text&quot;&quot;&quot;&#10;        # First do the standard OpenGL rendering&#10;        self.makeCurrent()&#10;        super().paintEvent(event)&#10;&#10;        # Then overlay text with QPainter&#10;        painter = QPainter(self)&#10;        painter.setRenderHint(QPainter.Antialiasing)&#10;        font = painter.font()&#10;        font.setPointSize(10)&#10;        painter.setFont(font)&#10;&#10;        # Draw node labels&#10;        if self.show_node_ids:&#10;            painter.setPen(Qt.black)&#10;            for x, y, text in self.node_labels:&#10;                painter.drawText(int(x), int(y), text)&#10;&#10;        # Draw member labels&#10;        if self.show_member_ids:&#10;            painter.setPen(Qt.darkGray)&#10;            for x, y, text in self.member_labels:&#10;                painter.drawText(int(x), int(y), text)&#10;&#10;        # Draw axis labels&#10;        if self.show_axes_labels:&#10;            painter.setPen(Qt.black)&#10;            for x, y, text in self.axes_labels:&#10;                if text == &quot;Right-handed system&quot;:&#10;                    font = painter.font()&#10;                    font.setPointSize(8)&#10;                    painter.setFont(font)&#10;                    painter.drawText(int(x), int(y), text)&#10;                    font.setPointSize(10)&#10;                    painter.setFont(font)&#10;                else:&#10;                    painter.drawText(int(x), int(y), text)&#10;&#10;        painter.end()&#10;&#10;    def drawGrid(self):&#10;        &quot;&quot;&quot;Draw reference grid&quot;&quot;&quot;&#10;        glColor3f(0.8, 0.8, 0.8)&#10;        glLineWidth(1.0)&#10;&#10;        glBegin(GL_LINES)&#10;        grid_size = 50&#10;        grid_step = 5&#10;        for i in range(-grid_size, grid_size + 1, grid_step):&#10;            glVertex3f(i, -grid_size, 0)&#10;            glVertex3f(i, grid_size, 0)&#10;            glVertex3f(-grid_size, i, 0)&#10;            glVertex3f(grid_size, i, 0)&#10;        glEnd()&#10;&#10;    def drawAxes(self):&#10;        &quot;&quot;&quot;Draw coordinate axes with right-hand rule indicator&quot;&quot;&quot;&#10;        glLineWidth(2.0)&#10;&#10;        # X axis - red&#10;        glColor3f(1.0, 0.0, 0.0)&#10;        glBegin(GL_LINES)&#10;        glVertex3f(0, 0, 0)&#10;        glVertex3f(10, 0, 0)&#10;        glEnd()&#10;&#10;        # Y axis - green&#10;        glColor3f(0.0, 1.0, 0.0)&#10;        glBegin(GL_LINES)&#10;        glVertex3f(0, 0, 0)&#10;        glVertex3f(0, 10, 0)&#10;        glEnd()&#10;&#10;        # Z axis - blue&#10;        glColor3f(0.0, 0.0, 1.0)&#10;        glBegin(GL_LINES)&#10;        glVertex3f(0, 0, 0)&#10;        glVertex3f(0, 0, 10)&#10;        glEnd()&#10;        &#10;        # Add a small circular arrow indicating the right-hand rule from X to Y&#10;        # Small circle in XY plane&#10;        glColor3f(0.5, 0.5, 0.5)&#10;        glLineWidth(1.5)&#10;        &#10;        radius = 3.0&#10;        segments = 20&#10;        angle_step = 2 * sp.pi / segments&#10;        &#10;        # Draw 3/4 of a circle&#10;        glBegin(GL_LINE_STRIP)&#10;        for i in range(int(segments * 0.75)):&#10;            angle = i * angle_step&#10;            glVertex3f(radius * sp.cos(angle), radius * sp.sin(angle), 0.1)&#10;        glEnd()&#10;        &#10;        # Add arrowhead&#10;        arrowhead_angle = sp.pi * 3 / 2&#10;        arrowhead_length = 0.8&#10;        glBegin(GL_TRIANGLES)&#10;        glVertex3f(radius * sp.cos(arrowhead_angle), radius * sp.sin(arrowhead_angle), 0.1)&#10;        glVertex3f(radius * sp.cos(arrowhead_angle) - arrowhead_length, radius * sp.sin(arrowhead_angle) + arrowhead_length, 0.1)&#10;        glVertex3f(radius * sp.cos(arrowhead_angle) + arrowhead_length, radius * sp.sin(arrowhead_angle) + arrowhead_length, 0.1)&#10;        glEnd()&#10;        &#10;        # Store axis labels for later rendering with QPainter&#10;        if self.show_axes_labels:&#10;            # Project axis endpoints to screen&#10;            x_end = self.project3DToScreen(10, 0, 0)&#10;            y_end = self.project3DToScreen(0, 10, 0)&#10;            z_end = self.project3DToScreen(0, 0, 10)&#10;            origin = self.project3DToScreen(0, 0, 0)&#10;            &#10;            if x_end and y_end and z_end and origin:&#10;                self.axes_labels.append((x_end[0] + 5, x_end[1], &quot;X&quot;))&#10;                self.axes_labels.append((y_end[0] + 5, y_end[1], &quot;Y&quot;))&#10;                self.axes_labels.append((z_end[0] + 5, z_end[1], &quot;Z&quot;))&#10;                self.axes_labels.append((origin[0] + 10, origin[1] + 15, &quot;Right-handed system&quot;))&#10;&#10;    def drawNodes(self):&#10;        &quot;&quot;&quot;Draw all nodes&quot;&quot;&quot;&#10;        for node_id, (x, y, z) in self.nodes.items():&#10;            # Set color based on selection/hover state&#10;            if node_id == self.selected_node:&#10;                glColor3f(1.0, 0.0, 0.0)&#10;                size = 10.0&#10;            elif node_id == self.hover_node:&#10;                glColor3f(1.0, 0.5, 0.0)&#10;                size = 8.0&#10;            else:&#10;                glColor3f(0.0, 0.0, 0.0)&#10;                size = 6.0&#10;&#10;            # Draw node as point&#10;            glPointSize(size)&#10;            glBegin(GL_POINTS)&#10;            glVertex3f(x, y, z)&#10;            glEnd()&#10;&#10;            # Add node ID to the list for later text rendering&#10;            if self.show_node_ids:&#10;                screen_pos = self.project3DToScreen(x, y, z)&#10;                if screen_pos:&#10;                    self.node_labels.append((screen_pos[0], screen_pos[1], str(node_id)))&#10;&#10;    def drawMembers(self):&#10;        &quot;&quot;&quot;Draw all members&quot;&quot;&quot;&#10;        for member in self.members:&#10;            try:&#10;                member_id = member['id']&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                section = member['section']&#10;&#10;                if i_node not in self.nodes or j_node not in self.nodes:&#10;                    continue&#10;&#10;                x1, y1, z1 = self.nodes[i_node]&#10;                x2, y2, z2 = self.nodes[j_node]&#10;&#10;                # Set color and width based on section and selection&#10;                if member_id == self.selected_member:&#10;                    glColor3f(1.0, 0.0, 0.0)&#10;                    line_width = 4.0&#10;                elif member_id == self.hover_member:&#10;                    glColor3f(1.0, 0.5, 0.0)&#10;                    line_width = 3.0&#10;                else:&#10;                    color = self.section_colors.get(section, (0.0, 0.0, 0.0))&#10;                    glColor3f(*color)&#10;                    line_width = 2.0 if section == 1 else 1.5&#10;&#10;                # Apply line width&#10;                glLineWidth(line_width)&#10;&#10;                # Draw member as line&#10;                glBegin(GL_LINES)&#10;                glVertex3f(x1, y1, z1)&#10;                glVertex3f(x2, y2, z2)&#10;                glEnd()&#10;&#10;                # Add member ID to the list for later text rendering&#10;                if self.show_member_ids:&#10;                    mid_x = (x1 + x2) / 2&#10;                    mid_y = (y1 + y2) / 2&#10;                    mid_z = (z1 + z2) / 2&#10;                    screen_pos = self.project3DToScreen(mid_x, mid_y, mid_z)&#10;                    if screen_pos:&#10;                        self.member_labels.append((screen_pos[0], screen_pos[1], str(member_id)))&#10;            except Exception as e:&#10;                debug_print(f&quot;Error drawing member {member.get('id', 'unknown')}: {e}&quot;)&#10;&#10;    def drawSupports(self):&#10;        &quot;&quot;&quot;Draw support constraints&quot;&quot;&quot;&#10;        for support in self.supports:&#10;            try:&#10;                node_id = support['node']&#10;                if node_id not in self.nodes:&#10;                    continue&#10;&#10;                x, y, z = self.nodes[node_id]&#10;&#10;                # Full support (fixed)&#10;                if support['ux'] == 1 and support['uy'] == 1 and support['uz'] == 1:&#10;                    glColor3f(1.0, 0.0, 0.0)&#10;                    # Draw as pyramid (simple triangle)&#10;                    glBegin(GL_TRIANGLES)&#10;                    glVertex3f(x - 0.5, y - 0.5, z - 0.5)&#10;                    glVertex3f(x + 0.5, y - 0.5, z - 0.5)&#10;                    glVertex3f(x, y + 0.5, z - 0.5)&#10;                    glEnd()&#10;                else:&#10;                    # Partial support&#10;                    glColor3f(1.0, 0.5, 0.0)&#10;                    # Draw as simple square&#10;                    glBegin(GL_QUADS)&#10;                    glVertex3f(x - 0.5, y - 0.5, z - 0.5)&#10;                    glVertex3f(x + 0.5, y - 0.5, z - 0.5)&#10;                    glVertex3f(x + 0.5, y + 0.5, z - 0.5)&#10;                    glVertex3f(x - 0.5, y + 0.5, z - 0.5)&#10;                    glEnd()&#10;            except Exception as e:&#10;                debug_print(f&quot;Error drawing support for node {support.get('node', 'unknown')}: {e}&quot;)&#10;&#10;    def mousePressEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse press events&quot;&quot;&quot;&#10;        self.last_mouse_pos = event.pos()&#10;&#10;        if event.button() == Qt.LeftButton and event.modifiers() != Qt.ControlModifier:&#10;            # Selection&#10;            node_id = self.pickNode(event.x(), event.y())&#10;            if node_id is not None:&#10;                self.selected_node = node_id&#10;                self.selected_member = None&#10;                self.nodeSelected.emit(node_id)&#10;                debug_print(f&quot;Selected node: {node_id}&quot;)&#10;            else:&#10;                member_id = self.pickMember(event.x(), event.y())&#10;                if member_id is not None:&#10;                    self.selected_member = member_id&#10;                    self.selected_node = None&#10;                    self.memberSelected.emit(member_id)&#10;                    debug_print(f&quot;Selected member: {member_id}&quot;)&#10;                else:&#10;                    self.selected_node = None&#10;                    self.selected_member = None&#10;&#10;            self.update()&#10;&#10;    def mouseMoveEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse move events&quot;&quot;&quot;&#10;        if self.last_mouse_pos is None:&#10;            return&#10;&#10;        dx = event.x() - self.last_mouse_pos.x()&#10;        dy = event.y() - self.last_mouse_pos.y()&#10;&#10;        if event.buttons() &amp; Qt.LeftButton and event.modifiers() &amp; Qt.ControlModifier:&#10;            # Rotate camera&#10;            self.camera_rotation[1] += dx * self.mouse_sensitivity&#10;            self.camera_rotation[0] += dy * self.mouse_sensitivity&#10;            self.camera_rotation[0] = max(-89, min(89, self.camera_rotation[0]))&#10;            self.update()&#10;        elif event.buttons() &amp; Qt.MiddleButton:&#10;            # Pan camera&#10;            pan_speed = 0.1&#10;            self.camera_target[0] -= dx * pan_speed&#10;            self.camera_target[1] += dy * pan_speed&#10;            self.update()&#10;&#10;        self.last_mouse_pos = event.pos()&#10;&#10;    def wheelEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse wheel events&quot;&quot;&quot;&#10;        delta = event.angleDelta().y()&#10;        zoom_speed = 0.1&#10;        self.camera_distance *= (1.0 - delta / 120.0 * zoom_speed)&#10;        self.camera_distance = max(5.0, min(200.0, self.camera_distance))&#10;        self.update()&#10;&#10;    def pickNode(self, x, y):&#10;        &quot;&quot;&quot;Find node at screen coordinates&quot;&quot;&quot;&#10;        min_dist = float('inf')&#10;        picked_node = None&#10;&#10;        for node_id, (nx, ny, nz) in self.nodes.items():&#10;            # Project 3D point to screen&#10;            screen_pos = self.project3DToScreen(nx, ny, nz)&#10;            if screen_pos is not None:&#10;                sx, sy = screen_pos&#10;                dist = sp.sqrt((x - sx)**2 + (y - sy)**2)&#10;                if dist &lt; 20 and dist &lt; min_dist:  # 20 pixel threshold&#10;                    min_dist = dist&#10;                    picked_node = node_id&#10;&#10;        return picked_node&#10;&#10;    def pickMember(self, x, y):&#10;        &quot;&quot;&quot;Find member at screen coordinates&quot;&quot;&quot;&#10;        min_dist = float('inf')&#10;        picked_member = None&#10;&#10;        for member in self.members:&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;&#10;            if i_node not in self.nodes or j_node not in self.nodes:&#10;                continue&#10;&#10;            x1, y1, z1 = self.nodes[i_node]&#10;            x2, y2, z2 = self.nodes[j_node]&#10;&#10;            # Project endpoints to screen&#10;            p1 = self.project3DToScreen(x1, y1, z1)&#10;            p2 = self.project3DToScreen(x2, y2, z2)&#10;&#10;            if p1 is not None and p2 is not None:&#10;                # Calculate distance from point to line segment&#10;                dist = self.pointToLineDistance(x, y, p1[0], p1[1], p2[0], p2[1])&#10;                if dist &lt; 10 and dist &lt; min_dist:  # 10 pixel threshold&#10;                    min_dist = dist&#10;                    picked_member = member['id']&#10;&#10;        return picked_member&#10;&#10;    def project3DToScreen(self, x, y, z):&#10;        &quot;&quot;&quot;Project 3D point to screen coordinates&quot;&quot;&quot;&#10;        try:&#10;            # Get viewport&#10;            viewport = glGetIntegerv(GL_VIEWPORT)&#10;&#10;            # Get matrices&#10;            modelview = glGetDoublev(GL_MODELVIEW_MATRIX)&#10;            projection = glGetDoublev(GL_PROJECTION_MATRIX)&#10;&#10;            # Project&#10;            result = gluProject(x, y, z, modelview, projection, viewport)&#10;            if result[2] &lt; 0 or result[2] &gt; 1:  # Behind camera or too far&#10;                return None&#10;&#10;            return (result[0], viewport[3] - result[1])  # Flip Y coordinate&#10;        except Exception as e:&#10;            debug_print(f&quot;Error projecting point: {e}&quot;)&#10;            return None&#10;&#10;    def pointToLineDistance(self, px, py, x1, y1, x2, y2):&#10;        &quot;&quot;&quot;Calculate distance from point to line segment&quot;&quot;&quot;&#10;        line_length_sq = (x2 - x1)**2 + (y2 - y1)**2&#10;        if line_length_sq == 0:&#10;            return sp.sqrt((px - x1)**2 + (py - y1)**2)&#10;&#10;        t = max(0, min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / line_length_sq))&#10;        proj_x = x1 + t * (x2 - x1)&#10;        proj_y = y1 + t * (y2 - y1)&#10;&#10;        return sp.sqrt((px - proj_x)**2 + (py - proj_y)**2)&#10;&#10;    def setStructureData(self, nodes, members, supports):&#10;        &quot;&quot;&quot;Update structure data&quot;&quot;&quot;&#10;        debug_print(f&quot;Setting structure data: {len(nodes)} nodes, {len(members)} members&quot;)&#10;        self.nodes = nodes&#10;        self.members = members&#10;        self.supports = supports&#10;        self.update()&#10;&#10;    def resetView(self):&#10;        &quot;&quot;&quot;Reset camera to default view&quot;&quot;&quot;&#10;        debug_print(&quot;Resetting view&quot;)&#10;        self.camera_distance = 50.0&#10;        self.camera_rotation = [20.0, -60.0]&#10;        self.camera_target = [0.0, 0.0, 0.0]&#10;        self.update()&#10;&#10;class StairwayInteractiveEditor(QMainWindow):&#10;    &quot;&quot;&quot;Main application window&quot;&quot;&quot;&#10;&#10;    def __init__(self, json_file):&#10;        super().__init__()&#10;        debug_print(f&quot;Initializing editor with file: {json_file}&quot;)&#10;        self.json_file = json_file&#10;        self.stairway_data = None&#10;        self.current_mode = &quot;view&quot;&#10;&#10;        # Create GL widget first so it's available for connecting signals&#10;        self.gl_widget = StructureGLWidget()&#10;&#10;        # Initialize data&#10;        self.load_data()&#10;&#10;        # Set up UI&#10;        self.init_ui()&#10;&#10;        # Update GL widget with structure data&#10;        debug_print(&quot;Setting initial structure data to GL widget&quot;)&#10;        self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;&#10;        # Connect signals&#10;        self.gl_widget.nodeSelected.connect(self.on_node_selected)&#10;        self.gl_widget.memberSelected.connect(self.on_member_selected)&#10;&#10;        # Setup mode state for member editing&#10;        self.member_creation_nodes = []&#10;&#10;        debug_print(&quot;Editor initialization complete&quot;)&#10;&#10;    def init_ui(self):&#10;        &quot;&quot;&quot;Initialize the user interface&quot;&quot;&quot;&#10;        self.setWindowTitle(f&quot;Stairway Structure Editor - {os.path.basename(self.json_file)}&quot;)&#10;        self.setGeometry(100, 100, 1400, 900)&#10;&#10;        # Central widget&#10;        central_widget = QWidget()&#10;        self.setCentralWidget(central_widget)&#10;&#10;        # Main layout&#10;        main_layout = QHBoxLayout()&#10;        central_widget.setLayout(main_layout)&#10;&#10;        # Left panel - controls&#10;        left_panel = self.create_left_panel()&#10;        main_layout.addWidget(left_panel, 1)&#10;&#10;        # Center - GL widget (already created in __init__)&#10;        main_layout.addWidget(self.gl_widget, 4)&#10;&#10;        # Right panel - properties&#10;        right_panel = self.create_right_panel()&#10;        main_layout.addWidget(right_panel, 1)&#10;&#10;    def create_left_panel(self):&#10;        &quot;&quot;&quot;Create the left control panel&quot;&quot;&quot;&#10;        panel = QWidget()&#10;        layout = QVBoxLayout()&#10;        panel.setLayout(layout)&#10;&#10;        # Mode selection&#10;        mode_group = QGroupBox(&quot;Edit Mode&quot;)&#10;        mode_layout = QVBoxLayout()&#10;        mode_group.setLayout(mode_layout)&#10;&#10;        self.mode_buttons = QButtonGroup()&#10;        modes = [&quot;View&quot;, &quot;Move Node&quot;, &quot;Add Node&quot;, &quot;Add Member&quot;, &quot;Delete Node&quot;, &quot;Delete Member&quot;, &quot;Edit Member&quot;]&#10;        for i, mode in enumerate(modes):&#10;            radio = QRadioButton(mode)&#10;            mode_layout.addWidget(radio)&#10;            self.mode_buttons.addButton(radio, i)&#10;            if i == 0:&#10;                radio.setChecked(True)&#10;&#10;        self.mode_buttons.buttonClicked.connect(self.on_mode_changed)&#10;        layout.addWidget(mode_group)&#10;&#10;        # Section selection for new members&#10;        section_group = QGroupBox(&quot;Member Section&quot;)&#10;        section_layout = QVBoxLayout()&#10;        section_group.setLayout(section_layout)&#10;&#10;        self.section_combo = QComboBox()&#10;        self.section_combo.addItems([f&quot;Section {i}&quot; for i in range(1, 6)])&#10;        section_layout.addWidget(self.section_combo)&#10;        layout.addWidget(section_group)&#10;&#10;        # Material selection&#10;        material_group = QGroupBox(&quot;Member Material&quot;)&#10;        material_layout = QVBoxLayout()&#10;        material_group.setLayout(material_layout)&#10;&#10;        self.material_combo = QComboBox()&#10;        self.material_combo.addItems([f&quot;Material {i}&quot; for i in range(1, 4)])&#10;        material_layout.addWidget(self.material_combo)&#10;        layout.addWidget(material_group)&#10;&#10;        # Action buttons&#10;        self.save_button = QPushButton(&quot;Save Structure&quot;)&#10;        self.save_button.clicked.connect(self.save_structure)&#10;        layout.addWidget(self.save_button)&#10;&#10;        self.reset_view_button = QPushButton(&quot;Reset View&quot;)&#10;        self.reset_view_button.clicked.connect(self.reset_view)  # Now connects to our method&#10;        layout.addWidget(self.reset_view_button)&#10;&#10;        # Display options&#10;        display_group = QGroupBox(&quot;Display Options&quot;)&#10;        display_layout = QVBoxLayout()&#10;        display_group.setLayout(display_layout)&#10;&#10;        self.show_nodes_cb = QCheckBox(&quot;Show Node IDs&quot;)&#10;        self.show_nodes_cb.setChecked(True)&#10;        self.show_nodes_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_nodes_cb)&#10;&#10;        self.show_members_cb = QCheckBox(&quot;Show Member IDs&quot;)&#10;        self.show_members_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_members_cb)&#10;&#10;        self.show_grid_cb = QCheckBox(&quot;Show Grid&quot;)&#10;        self.show_grid_cb.setChecked(True)&#10;        self.show_grid_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_grid_cb)&#10;&#10;        layout.addWidget(display_group)&#10;&#10;        # Info text&#10;        self.info_text = QTextEdit()&#10;        self.info_text.setReadOnly(True)&#10;        self.info_text.setMaximumHeight(200)&#10;        layout.addWidget(self.info_text)&#10;&#10;        layout.addStretch()&#10;&#10;        return panel&#10;&#10;    def create_right_panel(self):&#10;        &quot;&quot;&quot;Create the right properties panel&quot;&quot;&quot;&#10;        panel = QWidget()&#10;        layout = QVBoxLayout()&#10;        panel.setLayout(layout)&#10;&#10;        # Node properties&#10;        self.node_group = QGroupBox(&quot;Node Properties&quot;)&#10;        node_layout = QVBoxLayout()&#10;        self.node_group.setLayout(node_layout)&#10;&#10;        # Node ID&#10;        node_id_layout = QHBoxLayout()&#10;        node_id_layout.addWidget(QLabel(&quot;ID:&quot;))&#10;        self.node_id_label = QLabel(&quot;-&quot;)&#10;        node_id_layout.addWidget(self.node_id_label)&#10;        node_id_layout.addStretch()&#10;        node_layout.addLayout(node_id_layout)&#10;&#10;        # Node coordinates&#10;        self.node_x_spin = QDoubleSpinBox()&#10;        self.node_x_spin.setRange(-1000, 1000)&#10;        self.node_x_spin.setSingleStep(0.1)&#10;        self.node_x_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        self.node_y_spin = QDoubleSpinBox()&#10;        self.node_y_spin.setRange(-1000, 1000)&#10;        self.node_y_spin.setSingleStep(0.1)&#10;        self.node_y_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        self.node_z_spin = QDoubleSpinBox()&#10;        self.node_z_spin.setRange(-1000, 1000)&#10;        self.node_z_spin.setSingleStep(0.1)&#10;        self.node_z_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        coord_layout = QVBoxLayout()&#10;        for label, spin in [(&quot;X:&quot;, self.node_x_spin), (&quot;Y:&quot;, self.node_y_spin), (&quot;Z:&quot;, self.node_z_spin)]:&#10;            row = QHBoxLayout()&#10;            row.addWidget(QLabel(label))&#10;            row.addWidget(spin)&#10;            coord_layout.addLayout(row)&#10;&#10;        node_layout.addLayout(coord_layout)&#10;        self.node_group.setEnabled(False)&#10;        layout.addWidget(self.node_group)&#10;&#10;        # Member properties&#10;        self.member_group = QGroupBox(&quot;Member Properties&quot;)&#10;        member_layout = QVBoxLayout()&#10;        self.member_group.setLayout(member_layout)&#10;&#10;        # Member ID&#10;        member_id_layout = QHBoxLayout()&#10;        member_id_layout.addWidget(QLabel(&quot;ID:&quot;))&#10;        self.member_id_label = QLabel(&quot;-&quot;)&#10;        member_id_layout.addWidget(self.member_id_label)&#10;        member_id_layout.addStretch()&#10;        member_layout.addLayout(member_id_layout)&#10;&#10;        # Member nodes&#10;        nodes_layout = QHBoxLayout()&#10;        nodes_layout.addWidget(QLabel(&quot;Nodes:&quot;))&#10;        self.member_nodes_label = QLabel(&quot;-&quot;)&#10;        nodes_layout.addWidget(self.member_nodes_label)&#10;        nodes_layout.addStretch()&#10;        member_layout.addLayout(nodes_layout)&#10;&#10;        # Member section&#10;        self.member_section_combo = QComboBox()&#10;        self.member_section_combo.addItems([f&quot;Section {i}&quot; for i in range(1, 6)])&#10;        self.member_section_combo.currentIndexChanged.connect(self.update_member_properties)&#10;&#10;        section_layout = QHBoxLayout()&#10;        section_layout.addWidget(QLabel(&quot;Section:&quot;))&#10;        section_layout.addWidget(self.member_section_combo)&#10;        member_layout.addLayout(section_layout)&#10;&#10;        # Member material&#10;        self.member_material_combo = QComboBox()&#10;        self.member_material_combo.addItems([f&quot;Material {i}&quot; for i in range(1, 4)])&#10;        self.member_material_combo.currentIndexChanged.connect(self.update_member_properties)&#10;&#10;        material_layout = QHBoxLayout()&#10;        material_layout.addWidget(QLabel(&quot;Material:&quot;))&#10;        material_layout.addWidget(self.member_material_combo)&#10;        member_layout.addLayout(material_layout)&#10;&#10;        # Change nodes button&#10;        self.change_nodes_button = QPushButton(&quot;Change Connected Nodes&quot;)&#10;        self.change_nodes_button.clicked.connect(self.start_change_member_nodes)&#10;        member_layout.addWidget(self.change_nodes_button)&#10;&#10;        self.member_group.setEnabled(False)&#10;        layout.addWidget(self.member_group)&#10;&#10;        # Structure tree&#10;        tree_group = QGroupBox(&quot;Structure Tree&quot;)&#10;        tree_layout = QVBoxLayout()&#10;        tree_group.setLayout(tree_layout)&#10;&#10;        self.structure_tree = QTreeWidget()&#10;        self.structure_tree.setHeaderLabels([&quot;Element&quot;, &quot;Type&quot;, &quot;Properties&quot;])&#10;        tree_layout.addWidget(self.structure_tree)&#10;        self.populate_structure_tree()&#10;&#10;        layout.addWidget(tree_group)&#10;&#10;        layout.addStretch()&#10;&#10;        return panel&#10;&#10;    def populate_structure_tree(self):&#10;        &quot;&quot;&quot;Populate the structure tree with nodes and members&quot;&quot;&quot;&#10;        self.structure_tree.clear()&#10;&#10;        # Add nodes&#10;        nodes_item = QTreeWidgetItem([&quot;Nodes&quot;, f&quot;{len(self.nodes)}&quot;, &quot;&quot;])&#10;        self.structure_tree.addTopLevelItem(nodes_item)&#10;&#10;        # Add members grouped by section&#10;        sections = {}&#10;        for member in self.members:&#10;            section = member['section']&#10;            if section not in sections:&#10;                sections[section] = []&#10;            sections[section].append(member)&#10;&#10;        for section, members in sections.items():&#10;            section_item = QTreeWidgetItem([f&quot;Section {section}&quot;, f&quot;{len(members)} members&quot;, &quot;&quot;])&#10;            self.structure_tree.addTopLevelItem(section_item)&#10;&#10;        self.structure_tree.expandAll()&#10;&#10;    def load_data(self):&#10;        &quot;&quot;&quot;Load structure data from JSON file&quot;&quot;&quot;&#10;        debug_print(f&quot;Loading structure from {self.json_file}&quot;)&#10;&#10;        try:&#10;            with open(self.json_file, 'r') as file:&#10;                json_str = &quot;&quot;&#10;                for line in file:&#10;                    if '//' not in line:&#10;                        json_str += line&#10;&#10;                self.stairway_data = json.loads(json_str)&#10;&#10;            # Extract data&#10;            self.nodes = self.stairway_data['nodes']&#10;            self.supports = self.stairway_data['supports']&#10;            self.members = self.stairway_data['members']&#10;            self.materials = self.stairway_data.get('materials', [])&#10;            self.sections = self.stairway_data.get('sections', [])&#10;&#10;            # Create node dictionary&#10;            self.node_dict = {}&#10;            for node in self.nodes:&#10;                node_id = node['id']&#10;                x = float(node['x'].split()[0])&#10;                y = float(node['y'].split()[0])&#10;                z = float(node['z'].split()[0])&#10;                self.node_dict[node_id] = (x, y, z)&#10;&#10;            # Create connections map&#10;            self.node_connections = {node_id: [] for node_id in self.node_dict}&#10;            for member in self.members:&#10;                i_node = member['i_node']&#10;                j_node = member['j_node']&#10;                member_id = member['id']&#10;&#10;                if i_node in self.node_connections:&#10;                    self.node_connections[i_node].append(member_id)&#10;                if j_node in self.node_connections:&#10;                    self.node_connections[j_node].append(member_id)&#10;&#10;            debug_print(f&quot;Loaded {len(self.nodes)} nodes, {len(self.members)} members&quot;)&#10;&#10;        except Exception as e:&#10;            debug_print(f&quot;Error loading file: {str(e)}&quot;)&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Failed to load file: {str(e)}&quot;)&#10;            sys.exit(1)&#10;&#10;    def update_display_options(self):&#10;        &quot;&quot;&quot;Update display options in GL widget&quot;&quot;&quot;&#10;        self.gl_widget.show_node_ids = self.show_nodes_cb.isChecked()&#10;        self.gl_widget.show_member_ids = self.show_members_cb.isChecked()&#10;        self.gl_widget.show_grid = self.show_grid_cb.isChecked()&#10;        self.gl_widget.update()&#10;&#10;    def on_mode_changed(self, button):&#10;        &quot;&quot;&quot;Handle mode change&quot;&quot;&quot;&#10;        mode_index = self.mode_buttons.id(button)&#10;        modes = [&quot;view&quot;, &quot;move&quot;, &quot;add_node&quot;, &quot;add_member&quot;, &quot;delete_node&quot;, &quot;delete_member&quot;, &quot;edit_member&quot;]&#10;        self.current_mode = modes[mode_index]&#10;        debug_print(f&quot;Mode changed to: {self.current_mode}&quot;)&#10;&#10;        # Reset state when changing modes&#10;        if self.current_mode == &quot;add_member&quot;:&#10;            self.member_creation_nodes = []&#10;&#10;        # Update UI based on mode&#10;        if self.current_mode == &quot;move&quot;:&#10;            self.node_group.setEnabled(self.gl_widget.selected_node is not None)&#10;            self.member_group.setEnabled(False)&#10;        elif self.current_mode == &quot;edit_member&quot;:&#10;            self.node_group.setEnabled(False)&#10;            self.member_group.setEnabled(self.gl_widget.selected_member is not None)&#10;        else:&#10;            self.node_group.setEnabled(False)&#10;            self.member_group.setEnabled(False)&#10;&#10;        self.update_info_text()&#10;&#10;    def on_node_selected(self, node_id):&#10;        &quot;&quot;&quot;Handle node selection&quot;&quot;&quot;&#10;        debug_print(f&quot;Node {node_id} selected&quot;)&#10;&#10;        # Handle node selection for add_member mode&#10;        if self.current_mode == &quot;add_member&quot;:&#10;            if node_id in self.member_creation_nodes:&#10;                debug_print(f&quot;Node {node_id} already selected&quot;)&#10;                return&#10;&#10;            self.member_creation_nodes.append(node_id)&#10;            debug_print(f&quot;Added node {node_id} to member creation (nodes: {self.member_creation_nodes})&quot;)&#10;&#10;            if len(self.member_creation_nodes) == 2:&#10;                self.create_member(self.member_creation_nodes[0], self.member_creation_nodes[1])&#10;                self.member_creation_nodes = []&#10;&#10;            self.update_info_text()&#10;            return&#10;&#10;        # Update node properties panel&#10;        self.node_id_label.setText(str(node_id))&#10;        x, y, z = self.node_dict[node_id]&#10;&#10;        # Block signals to prevent recursive updates&#10;        self.node_x_spin.blockSignals(True)&#10;        self.node_y_spin.blockSignals(True)&#10;        self.node_z_spin.blockSignals(True)&#10;&#10;        self.node_x_spin.setValue(x)&#10;        self.node_y_spin.setValue(y)&#10;        self.node_z_spin.setValue(z)&#10;&#10;        self.node_x_spin.blockSignals(False)&#10;        self.node_y_spin.blockSignals(False)&#10;        self.node_z_spin.blockSignals(False)&#10;&#10;        # Enable/disable panels based on mode&#10;        if self.current_mode == &quot;move&quot;:&#10;            self.node_group.setEnabled(True)&#10;        elif self.current_mode == &quot;delete_node&quot;:&#10;            self.delete_node(node_id)&#10;&#10;        self.member_group.setEnabled(False)&#10;        self.update_info_text()&#10;&#10;    def on_member_selected(self, member_id):&#10;        &quot;&quot;&quot;Handle member selection&quot;&quot;&quot;&#10;        debug_print(f&quot;Member {member_id} selected&quot;)&#10;&#10;        if self.current_mode == &quot;delete_member&quot;:&#10;            self.delete_member(member_id)&#10;            return&#10;&#10;        # Find member data&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            return&#10;&#10;        # Update member properties panel&#10;        self.member_id_label.setText(str(member_id))&#10;        self.member_nodes_label.setText(f&quot;{member['i_node']} - {member['j_node']}&quot;)&#10;&#10;        # Block signals&#10;        self.member_section_combo.blockSignals(True)&#10;        self.member_material_combo.blockSignals(True)&#10;&#10;        self.member_section_combo.setCurrentIndex(member['section'] - 1)&#10;        self.member_material_combo.setCurrentIndex(member['material'] - 1)&#10;&#10;        self.member_section_combo.blockSignals(False)&#10;        self.member_material_combo.blockSignals(False)&#10;&#10;        # Enable/disable panels based on mode&#10;        self.node_group.setEnabled(False)&#10;        if self.current_mode == &quot;edit_member&quot;:&#10;            self.member_group.setEnabled(True)&#10;&#10;        self.update_info_text()&#10;&#10;    def update_node_position(self):&#10;        &quot;&quot;&quot;Update selected node position from spinboxes&quot;&quot;&quot;&#10;        if not self.gl_widget.selected_node:&#10;            return&#10;&#10;        node_id = self.gl_widget.selected_node&#10;        x = self.node_x_spin.value()&#10;        y = self.node_y_spin.value()&#10;        z = self.node_z_spin.value()&#10;&#10;        # Update internal data&#10;        self.node_dict[node_id] = (x, y, z)&#10;&#10;        # Update node in list&#10;        for node in self.nodes:&#10;            if node['id'] == node_id:&#10;                node['x'] = f&quot;{x} ft&quot;&#10;                node['y'] = f&quot;{y} ft&quot;&#10;                node['z'] = f&quot;{z} ft&quot;&#10;                break&#10;&#10;        # Update GL widget&#10;        self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;&#10;    def update_member_properties(self):&#10;        &quot;&quot;&quot;Update selected member properties&quot;&quot;&quot;&#10;        if not self.gl_widget.selected_member:&#10;            return&#10;&#10;        member_id = self.gl_widget.selected_member&#10;&#10;        # Find member&#10;        for member in self.members:&#10;            if member['id'] == member_id:&#10;                member['section'] = self.member_section_combo.currentIndex() + 1&#10;                member['material'] = self.member_material_combo.currentIndex() + 1&#10;                break&#10;&#10;        # Update GL widget&#10;        self.gl_widget.update()&#10;&#10;    def start_change_member_nodes(self):&#10;        &quot;&quot;&quot;Start process to change member's connected nodes&quot;&quot;&quot;&#10;        if not self.gl_widget.selected_member:&#10;            return&#10;&#10;        # Switch to special mode for changing member nodes&#10;        self.current_mode = &quot;change_member_nodes&quot;&#10;        self.member_creation_nodes = []&#10;&#10;        QMessageBox.information(self, &quot;Change Nodes&quot;,&#10;                              &quot;Select two nodes to reconnect the member&quot;)&#10;        self.update_info_text()&#10;&#10;    def update_member_nodes(self, member_id, new_i_node, new_j_node):&#10;        &quot;&quot;&quot;Update a member's connected nodes&quot;&quot;&quot;&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            return&#10;&#10;        old_i_node = member['i_node']&#10;        old_j_node = member['j_node']&#10;&#10;        # Remove member from old node connections&#10;        if old_i_node in self.node_connections and member_id in self.node_connections[old_i_node]:&#10;            self.node_connections[old_i_node].remove(member_id)&#10;&#10;        if old_j_node in self.node_connections and member_id in self.node_connections[old_j_node]:&#10;            self.node_connections[old_j_node].remove(member_id)&#10;&#10;        # Update member endpoints&#10;        member['i_node'] = new_i_node&#10;        member['j_node'] = new_j_node&#10;&#10;        # Add to new node connections&#10;        if new_i_node not in self.node_connections:&#10;            self.node_connections[new_i_node] = []&#10;        self.node_connections[new_i_node].append(member_id)&#10;&#10;        if new_j_node not in self.node_connections:&#10;            self.node_connections[new_j_node] = []&#10;        self.node_connections[new_j_node].append(member_id)&#10;&#10;        # Update GL widget&#10;        self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;&#10;    def create_member(self, node1, node2):&#10;        &quot;&quot;&quot;Create a new member between two nodes&quot;&quot;&quot;&#10;        section = self.section_combo.currentIndex() + 1&#10;        material = self.material_combo.currentIndex() + 1&#10;&#10;        # Get next member ID&#10;        next_id = max([m['id'] for m in self.members], default=0) + 1&#10;&#10;        # Create new member&#10;        new_member = {&#10;            'id': next_id,&#10;            'i_node': node1,&#10;            'j_node': node2,&#10;            'section': section,&#10;            'material': material&#10;        }&#10;&#10;        debug_print(f&quot;Creating member {next_id} between nodes {node1}-{node2}&quot;)&#10;&#10;        # Add to data structures&#10;        self.members.append(new_member)&#10;&#10;        # Update connections&#10;        if node1 not in self.node_connections:&#10;            self.node_connections[node1] = []&#10;        self.node_connections[node1].append(next_id)&#10;&#10;        if node2 not in self.node_connections:&#10;            self.node_connections[node2] = []&#10;        self.node_connections[node2].append(next_id)&#10;&#10;        # Update visualization&#10;        self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;        self.populate_structure_tree()&#10;&#10;    def delete_node(self, node_id):&#10;        &quot;&quot;&quot;Delete a node and its connected members&quot;&quot;&quot;&#10;        debug_print(f&quot;Deleting node {node_id}&quot;)&#10;&#10;        # Get connected members&#10;        connected_members = self.node_connections.get(node_id, [])[:]&#10;&#10;        # Delete connected members&#10;        if connected_members:&#10;            for member_id in connected_members:&#10;                self.delete_member(member_id, update_viz=False)&#10;&#10;        # Delete node&#10;        self.nodes = [n for n in self.nodes if n['id'] != node_id]&#10;        if node_id in self.node_dict:&#10;            del self.node_dict[node_id]&#10;        if node_id in self.node_connections:&#10;            del self.node_connections[node_id]&#10;&#10;        # Update GL widget&#10;        self.gl_widget.selected_node = None&#10;        self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;        self.populate_structure_tree()&#10;        self.update_info_text()&#10;&#10;    def delete_member(self, member_id, update_viz=True):&#10;        &quot;&quot;&quot;Delete a member&quot;&quot;&quot;&#10;        debug_print(f&quot;Deleting member {member_id}&quot;)&#10;&#10;        # Find member&#10;        member = next((m for m in self.members if m['id'] == member_id), None)&#10;        if not member:&#10;            return&#10;&#10;        # Remove from connections&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        if i_node in self.node_connections and member_id in self.node_connections[i_node]:&#10;            self.node_connections[i_node].remove(member_id)&#10;&#10;        if j_node in self.node_connections and member_id in self.node_connections[j_node]:&#10;            self.node_connections[j_node].remove(member_id)&#10;&#10;        # Remove from list&#10;        self.members = [m for m in self.members if m['id'] != member_id]&#10;&#10;        # Update visualization if requested&#10;        if update_viz:&#10;            self.gl_widget.selected_member = None&#10;            self.gl_widget.setStructureData(self.node_dict, self.members, self.supports)&#10;            self.populate_structure_tree()&#10;            self.update_info_text()&#10;&#10;    def update_info_text(self):&#10;        &quot;&quot;&quot;Update information text&quot;&quot;&quot;&#10;        info = f&quot;Mode: {self.current_mode.replace('_', ' ').title()}\n\n&quot;&#10;&#10;        if self.current_mode == &quot;add_member&quot;:&#10;            info += f&quot;Select nodes to create a member.\n&quot;&#10;            info += f&quot;Selected nodes: {len(self.member_creation_nodes)}/2\n\n&quot;&#10;        elif self.current_mode == &quot;change_member_nodes&quot;:&#10;            info += f&quot;Select nodes to reconnect member {self.gl_widget.selected_member}.\n&quot;&#10;            info += f&quot;Selected nodes: {len(self.member_creation_nodes)}/2\n\n&quot;&#10;&#10;        if self.gl_widget.selected_node:&#10;            node_id = self.gl_widget.selected_node&#10;            x, y, z = self.node_dict[node_id]&#10;            info += f&quot;Selected Node: {node_id}\n&quot;&#10;            info += f&quot;Position: ({x:.2f}, {y:.2f}, {z:.2f})\n&quot;&#10;            info += f&quot;Connected Members: {len(self.node_connections[node_id])}\n&quot;&#10;&#10;        elif self.gl_widget.selected_member:&#10;            member = next((m for m in self.members if m['id'] == self.gl_widget.selected_member), None)&#10;            if member:&#10;                info += f&quot;Selected Member: {member['id']}\n&quot;&#10;                info += f&quot;Nodes: {member['i_node']} - {member['j_node']}\n&quot;&#10;                info += f&quot;Section: {member['section']}, Material: {member['material']}\n&quot;&#10;&#10;                # Calculate length&#10;                i_pos = self.node_dict[member['i_node']]&#10;                j_pos = self.node_dict[member['j_node']]&#10;                length = sp.sqrt(sum((j_pos[i] - i_pos[i])**2 for i in range(3)))&#10;                info += f&quot;Length: {length:.2f} ft\n&quot;&#10;&#10;        self.info_text.setText(info)&#10;&#10;    def reset_view(self):&#10;        &quot;&quot;&quot;Reset camera view in GL widget&quot;&quot;&quot;&#10;        debug_print(&quot;Resetting view&quot;)&#10;        self.gl_widget.resetView()&#10;&#10;    def save_structure(self):&#10;        &quot;&quot;&quot;Save structure to JSON file&quot;&quot;&quot;&#10;        # Update structure data&#10;        self.stairway_data['nodes'] = self.nodes&#10;        self.stairway_data['members'] = self.members&#10;&#10;        # Generate filename&#10;        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')&#10;        base_name = os.path.splitext(self.json_file)[0]&#10;        output_file = f&quot;{base_name}_edited_{timestamp}.json&quot;&#10;&#10;        try:&#10;            with open(output_file, 'w') as f:&#10;                json.dump(self.stairway_data, f, indent=4)&#10;            QMessageBox.information(self, &quot;Success&quot;, f&quot;Structure saved to {output_file}&quot;)&#10;            debug_print(f&quot;Saved structure to {output_file}&quot;)&#10;        except Exception as e:&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Failed to save: {str(e)}&quot;)&#10;            debug_print(f&quot;Error saving: {str(e)}&quot;)&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main entry point&quot;&quot;&quot;&#10;    app = QApplication(sys.argv)&#10;&#10;    # Get JSON file&#10;    if len(sys.argv) &gt; 1:&#10;        json_file = sys.argv[1]&#10;    else:&#10;        json_file = &quot;stairway_structure.json&quot;&#10;        if not os.path.exists(json_file):&#10;            # Try to find any JSON file&#10;            json_files = [f for f in os.listdir('.') if f.endswith('.json')]&#10;            if json_files:&#10;                json_file = json_files[0]&#10;            else:&#10;                print(&quot;No JSON files found&quot;)&#10;                sys.exit(1)&#10;&#10;    # Create and show main window&#10;    try:&#10;        editor = StairwayInteractiveEditor(json_file)&#10;        editor.show()&#10;        sys.exit(app.exec_())&#10;    except Exception as e:&#10;        print(f&quot;Fatal error: {str(e)}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;        sys.exit(1)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Stairways/run_stairway_interactive_qt.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Stairways/run_stairway_interactive_qt.py" />
              <option name="originalContent" value="# Interactive stairway structure visualization and editing tool using pure PyQt (no OpenGL)&#10;&#10;import os&#10;import json&#10;import sys&#10;import math  # Add math module import for sqrt function&#10;import datetime&#10;import traceback&#10;import scipy as sp&#10;from scipy.spatial import distance&#10;# Import specific math functions from scipy&#10;from scipy import special&#10;from scipy import linalg&#10;from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,&#10;                            QHBoxLayout, QPushButton, QLabel, QSlider,&#10;                            QGroupBox, QRadioButton, QButtonGroup, QSplitter,&#10;                            QTextEdit, QFileDialog, QMessageBox, QSpinBox,&#10;                            QDoubleSpinBox, QComboBox, QTreeWidget, QTreeWidgetItem,&#10;                            QCheckBox, QGraphicsView, QGraphicsScene, QGraphicsItem)&#10;from PyQt5.QtCore import Qt, QTimer, pyqtSignal, QPoint, QRectF&#10;from PyQt5.QtGui import QPainter, QPen, QBrush, QColor, QPainterPath, QFont, QTransform&#10;&#10;# Global debug flag&#10;DEBUG = True&#10;&#10;def debug_print(*args, **kwargs):&#10;    &quot;&quot;&quot;Helper function for debug printing&quot;&quot;&quot;&#10;    if DEBUG:&#10;        print(*args, **kwargs)&#10;        sys.stdout.flush()  # Ensure output is flushed immediately&#10;&#10;class StructureView(QGraphicsView):&#10;    &quot;&quot;&quot;Custom graphics view for 2D visualization of 3D structure&quot;&quot;&quot;&#10;&#10;    nodeSelected = pyqtSignal(int)&#10;    memberSelected = pyqtSignal(int)&#10;&#10;    def __init__(self, parent=None):&#10;        debug_print(&quot;Initializing StructureView&quot;)&#10;        super().__init__(parent)&#10;&#10;        # Setup the scene&#10;        self.scene = QGraphicsScene(self)&#10;        self.setScene(self.scene)&#10;&#10;        # Enable antialiasing&#10;        self.setRenderHint(QPainter.Antialiasing)&#10;        self.setRenderHint(QPainter.TextAntialiasing)&#10;&#10;        # Set background color&#10;        self.setBackgroundBrush(QBrush(QColor(245, 245, 245)))&#10;&#10;        # View settings&#10;        self.scale_factor = 20.0  # Scaling for better visibility&#10;        self.center_offset = (0, 0)  # Pan offset&#10;&#10;        # Structure data&#10;        self.nodes = {}&#10;        self.members = []&#10;        self.supports = []&#10;&#10;        # Selection&#10;        self.selected_node = None&#10;        self.selected_member = None&#10;&#10;        # Colors for sections&#10;        self.section_colors = {&#10;            1: QColor(0, 0, 255),     # Blue - Main stringers&#10;            2: QColor(0, 180, 0),     # Green - Steps/treads&#10;            3: QColor(0, 200, 200),   # Cyan - Secondary members&#10;            4: QColor(100, 100, 100), # Gray - Bracing&#10;            5: QColor(200, 0, 0)      # Red - Column&#10;        }&#10;&#10;        # Mouse tracking for pan and zoom&#10;        self.setMouseTracking(True)&#10;        self.last_mouse_pos = None&#10;&#10;        # Enable drag mode&#10;        self.setDragMode(QGraphicsView.NoDrag)&#10;&#10;        # Add axes display property&#10;        self.show_axes = True&#10;&#10;        # Change projection coefficients to fix right-handed coordinate system&#10;        self.projection_coef_x = 0.5  # Controls how much Y affects X projection&#10;        self.projection_coef_y = 0.5  # Controls how much X affects Y projection&#10;&#10;        debug_print(&quot;StructureView initialization complete&quot;)&#10;&#10;    def wheelEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse wheel for zooming&quot;&quot;&quot;&#10;        try:&#10;            debug_print(&quot;Wheel event&quot;)&#10;            # Save the scene pos&#10;            old_pos = self.mapToScene(event.pos())&#10;&#10;            # Zoom factor&#10;            zoom_factor = 1.15&#10;&#10;            # Zoom in or out&#10;            if event.angleDelta().y() &gt; 0:&#10;                self.scale(zoom_factor, zoom_factor)&#10;            else:&#10;                self.scale(1.0 / zoom_factor, 1.0 / zoom_factor)&#10;&#10;            # Get the new position&#10;            new_pos = self.mapToScene(event.pos())&#10;&#10;            # Move scene to old position&#10;            delta = new_pos - old_pos&#10;            self.translate(delta.x(), delta.y())&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in wheelEvent: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def mousePressEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse press events&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Mouse press at {event.pos().x()}, {event.pos().y()}&quot;)&#10;            self.last_mouse_pos = event.pos()&#10;&#10;            if event.button() == Qt.LeftButton:&#10;                # Convert to scene coordinates&#10;                scene_pos = self.mapToScene(event.pos())&#10;                debug_print(f&quot;Scene position: {scene_pos.x()}, {scene_pos.y()}&quot;)&#10;&#10;                # Try to find closest node&#10;                try:&#10;                    node_id = self.find_closest_node(scene_pos.x(), scene_pos.y())&#10;                    if node_id is not None:&#10;                        debug_print(f&quot;Selected node {node_id}&quot;)&#10;                        self.selected_node = node_id&#10;                        self.selected_member = None&#10;                        self.nodeSelected.emit(node_id)&#10;                        self.update_scene()&#10;                        return&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error finding closest node: {str(e)}&quot;)&#10;                    traceback.print_exc()&#10;&#10;                # Try to find closest member&#10;                try:&#10;                    member_id = self.find_closest_member(scene_pos.x(), scene_pos.y())&#10;                    if member_id is not None:&#10;                        debug_print(f&quot;Selected member {member_id}&quot;)&#10;                        self.selected_member = member_id&#10;                        self.selected_node = None&#10;                        self.memberSelected.emit(member_id)&#10;                        self.update_scene()&#10;                        return&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error finding closest member: {str(e)}&quot;)&#10;                    traceback.print_exc()&#10;&#10;                # If clicked on empty space&#10;                self.selected_node = None&#10;                self.selected_member = None&#10;                self.update_scene()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in mousePressEvent: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;        super().mousePressEvent(event)&#10;&#10;    def mouseMoveEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse movement for panning&quot;&quot;&quot;&#10;        try:&#10;            if event.buttons() &amp; Qt.MiddleButton and self.last_mouse_pos:&#10;                # Calculate movement&#10;                delta = event.pos() - self.last_mouse_pos&#10;                self.last_mouse_pos = event.pos()&#10;&#10;                # Pan the view&#10;                self.translate(delta.x(), delta.y())&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in mouseMoveEvent: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;        super().mouseMoveEvent(event)&#10;&#10;    def find_closest_node(self, x, y, threshold=10):&#10;        &quot;&quot;&quot;Find the closest node to the given coordinates&quot;&quot;&quot;&#10;        debug_print(f&quot;Finding closest node to {x}, {y}&quot;)&#10;&#10;        try:&#10;            closest_node = None&#10;            min_dist = threshold&#10;&#10;            # Safety check for nodes&#10;            if not self.nodes:&#10;                debug_print(&quot;No nodes available&quot;)&#10;                return None&#10;&#10;            debug_print(f&quot;Checking {len(self.nodes)} nodes&quot;)&#10;            for node_id, coords in self.nodes.items():&#10;                if not coords or len(coords) != 3:&#10;                    debug_print(f&quot;Invalid node data for node {node_id}: {coords}&quot;)&#10;                    continue&#10;&#10;                nx, ny, nz = coords&#10;                if not isinstance(nx, (int, float)) or not isinstance(ny, (int, float)) or not isinstance(nz, (int, float)):&#10;                    debug_print(f&quot;Non-numeric coordinates for node {node_id}: {coords}&quot;)&#10;                    continue&#10;&#10;                # Project 3D point to 2D using simple projection&#10;                try:&#10;                    proj_x, proj_y = self.project_3d_to_2d(nx, ny, nz)&#10;&#10;                    # Calculate distance - using math.sqrt instead of sp.sqrt&#10;                    try:&#10;                        dist = math.sqrt((x - proj_x)**2 + (y - proj_y)**2)&#10;&#10;                        if dist &lt; min_dist:&#10;                            min_dist = dist&#10;                            closest_node = node_id&#10;                    except Exception as e:&#10;                        debug_print(f&quot;Error calculating distance for node {node_id}: {str(e)}&quot;)&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error projecting node {node_id}: {str(e)}&quot;)&#10;&#10;            if closest_node is not None:&#10;                debug_print(f&quot;Found closest node: {closest_node} at distance {min_dist:.2f}&quot;)&#10;            else:&#10;                debug_print(&quot;No node found within threshold&quot;)&#10;&#10;            return closest_node&#10;&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in find_closest_node: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;            return None&#10;&#10;    def find_closest_member(self, x, y, threshold=5):&#10;        &quot;&quot;&quot;Find the closest member to the given coordinates&quot;&quot;&quot;&#10;        debug_print(f&quot;Finding closest member to {x}, {y}&quot;)&#10;&#10;        try:&#10;            closest_member = None&#10;            min_dist = threshold&#10;&#10;            # Safety check for members&#10;            if not self.members:&#10;                debug_print(&quot;No members available&quot;)&#10;                return None&#10;&#10;            for member in self.members:&#10;                try:&#10;                    i_node = member.get('i_node')&#10;                    j_node = member.get('j_node')&#10;&#10;                    if i_node is None or j_node is None:&#10;                        debug_print(f&quot;Missing node references in member {member.get('id')}&quot;)&#10;                        continue&#10;&#10;                    if i_node not in self.nodes or j_node not in self.nodes:&#10;                        debug_print(f&quot;Member {member.get('id')} refers to non-existent node(s)&quot;)&#10;                        continue&#10;&#10;                    # Project endpoints&#10;                    x1, y1, z1 = self.nodes[i_node]&#10;                    x2, y2, z2 = self.nodes[j_node]&#10;&#10;                    p1x, p1y = self.project_3d_to_2d(x1, y1, z1)&#10;                    p2x, p2y = self.project_3d_to_2d(x2, y2, z2)&#10;&#10;                    # Calculate distance to line segment&#10;                    dist = self.point_to_line_dist(x, y, p1x, p1y, p2x, p2y)&#10;&#10;                    if dist &lt; min_dist:&#10;                        min_dist = dist&#10;                        closest_member = member['id']&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error processing member {member.get('id')}: {str(e)}&quot;)&#10;&#10;            return closest_member&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in find_closest_member: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;            return None&#10;&#10;    def point_to_line_dist(self, x, y, x1, y1, x2, y2):&#10;        &quot;&quot;&quot;Calculate distance from point to line segment&quot;&quot;&quot;&#10;        try:&#10;            # Calculate line segment length squared&#10;            l2 = (x2 - x1)**2 + (y2 - y1)**2&#10;&#10;            if l2 == 0:  # Points are the same&#10;                return math.sqrt((x - x1)**2 + (y - y1)**2)&#10;&#10;            # Calculate projection parameter&#10;            t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2&#10;            t = max(0, min(1, t))  # Clamp to segment&#10;&#10;            # Calculate nearest point on segment&#10;            px = x1 + t * (x2 - x1)&#10;            py = y1 + t * (y2 - y1)&#10;&#10;            # Return distance to that point&#10;            return math.sqrt((x - px)**2 + (y - py)**2)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in point_to_line_dist: {str(e)}&quot;)&#10;            return float('inf')  # Return infinite distance on error&#10;&#10;    def project_3d_to_2d(self, x, y, z):&#10;        &quot;&quot;&quot;Project 3D point to 2D using a simple projection with right-handed coordinate system&quot;&quot;&quot;&#10;        try:&#10;            # Modified projection for right-handed coordinate system&#10;            # In a right-handed system: X right, Y forward (into screen), Z up&#10;            # We want to project this isometrically&#10;            proj_x = x - y * self.projection_coef_x  # X - Y contribution&#10;            proj_y = z + x * self.projection_coef_y - y * self.projection_coef_y  # Z + X contribution - Y contribution&#10;&#10;            # Apply scale and offset&#10;            proj_x = proj_x * self.scale_factor + 500 + self.center_offset[0]&#10;            proj_y = -proj_y * self.scale_factor + 300 + self.center_offset[1]  # Y is inverted in screen coords&#10;&#10;            return proj_x, proj_y&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in project_3d_to_2d: {str(e)}&quot;)&#10;            return 0, 0  # Return origin on error&#10;&#10;    def setStructureData(self, nodes, members, supports):&#10;        &quot;&quot;&quot;Update the structure data&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Setting structure data: {len(nodes)} nodes, {len(members)} members&quot;)&#10;            self.nodes = nodes&#10;            self.members = members&#10;            self.supports = supports&#10;&#10;            # Recenter the view on the structure&#10;            self.recenter_view()&#10;&#10;            # Update the scene with the new data&#10;            self.update_scene()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in setStructureData: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def recenter_view(self):&#10;        &quot;&quot;&quot;Center the view on the structure&quot;&quot;&quot;&#10;        try:&#10;            debug_print(&quot;Recentering view&quot;)&#10;            if not self.nodes:&#10;                debug_print(&quot;No nodes to center on&quot;)&#10;                return&#10;&#10;            # Find structure bounds&#10;            x_vals = []&#10;            y_vals = []&#10;            z_vals = []&#10;&#10;            for pos in self.nodes.values():&#10;                if len(pos) == 3:&#10;                    x, y, z = pos&#10;                    if isinstance(x, (int, float)) and isinstance(y, (int, float)) and isinstance(z, (int, float)):&#10;                        x_vals.append(x)&#10;                        y_vals.append(y)&#10;                        z_vals.append(z)&#10;&#10;            if not x_vals or not y_vals or not z_vals:&#10;                debug_print(&quot;No valid coordinates to center on&quot;)&#10;                return&#10;&#10;            x_min, x_max = min(x_vals), max(x_vals)&#10;            y_min, y_max = min(y_vals), max(y_vals)&#10;            z_min, z_max = min(z_vals), max(z_vals)&#10;&#10;            # Calculate center&#10;            x_center = (x_min + x_max) / 2&#10;            y_center = (y_min + y_max) / 2&#10;            z_center = (z_min + z_max) / 2&#10;&#10;            # Set center offset to center the structure&#10;            # We'll use the projection to determine the offset&#10;            center_x, center_y = self.project_3d_to_2d(x_center, y_center, z_center)&#10;&#10;            # Determine the view center&#10;            view_center_x = self.width() / 2&#10;            view_center_y = self.height() / 2&#10;&#10;            # Calculate offset to center the structure&#10;            self.center_offset = (&#10;                view_center_x - center_x + 500,  # Add 500 because that's our base offset&#10;                view_center_y - center_y + 300   # Add 300 because that's our base offset&#10;            )&#10;&#10;            # Reset the view&#10;            self.resetTransform()&#10;            self.centerOn(view_center_x, view_center_y)&#10;&#10;            debug_print(f&quot;View centered. Center offset: {self.center_offset}&quot;)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in recenter_view: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def update_scene(self):&#10;        &quot;&quot;&quot;Update the scene with current structure data&quot;&quot;&quot;&#10;        debug_print(&quot;Updating scene&quot;)&#10;        try:&#10;            # Clear previous scene&#10;            self.scene.clear()&#10;&#10;            # Draw grid&#10;            self.draw_grid()&#10;&#10;            # Draw coordinate axes&#10;            if self.show_axes:&#10;                self.draw_axes()&#10;&#10;            # Draw members first (so nodes are on top)&#10;            self.draw_members()&#10;&#10;            # Draw nodes&#10;            self.draw_nodes()&#10;&#10;            # Draw supports&#10;            self.draw_supports()&#10;&#10;            # Update the view&#10;            self.update()&#10;            debug_print(&quot;Scene updated successfully&quot;)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating scene: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def draw_axes(self):&#10;        &quot;&quot;&quot;Draw X, Y, Z coordinate axes with clear right-handed system&quot;&quot;&quot;&#10;        debug_print(&quot;Drawing coordinate axes&quot;)&#10;        try:&#10;            # Get origin position&#10;            origin_x, origin_y = self.project_3d_to_2d(0, 0, 0)&#10;&#10;            # Draw X axis (red) - points right&#10;            x_end_x, x_end_y = self.project_3d_to_2d(10, 0, 0)&#10;            x_pen = QPen(QColor(255, 0, 0))  # Red&#10;            x_pen.setWidth(2)&#10;            self.scene.addLine(origin_x, origin_y, x_end_x, x_end_y, x_pen)&#10;            self.scene.addText(&quot;X&quot;).setPos(x_end_x + 5, x_end_y - 10)&#10;&#10;            # Draw Y axis (green) - points forward/into screen&#10;            y_end_x, y_end_y = self.project_3d_to_2d(0, 10, 0)&#10;            y_pen = QPen(QColor(0, 180, 0))  # Green&#10;            y_pen.setWidth(2)&#10;            self.scene.addLine(origin_x, origin_y, y_end_x, y_end_y, y_pen)&#10;            self.scene.addText(&quot;Y&quot;).setPos(y_end_x + 5, y_end_y - 10)&#10;&#10;            # Draw Z axis (blue) - points up&#10;            z_end_x, z_end_y = self.project_3d_to_2d(0, 0, 10)&#10;            z_pen = QPen(QColor(0, 0, 255))  # Blue&#10;            z_pen.setWidth(2)&#10;            self.scene.addLine(origin_x, origin_y, z_end_x, z_end_y, z_pen)&#10;            self.scene.addText(&quot;Z&quot;).setPos(z_end_x + 5, z_end_y - 10)&#10;&#10;            # Add a small circle at origin&#10;            self.scene.addEllipse(origin_x - 3, origin_y - 3, 6, 6,&#10;                                 QPen(QColor(0, 0, 0)), QBrush(QColor(0, 0, 0)))&#10;&#10;            # Add right-handed coordinate system indicator&#10;            self.scene.addText(&quot;Right-handed coordinate system:&quot;).setPos(origin_x - 80, origin_y + 20)&#10;            self.scene.addText(&quot;X = right, Y = forward, Z = up&quot;).setPos(origin_x - 80, origin_y + 40)&#10;&#10;        except Exception as e:&#10;            debug_print(f&quot;Error drawing axes: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def draw_grid(self):&#10;        &quot;&quot;&quot;Draw a reference grid&quot;&quot;&quot;&#10;        debug_print(&quot;Drawing grid&quot;)&#10;        try:&#10;            # Create a light gray pen&#10;            grid_pen = QPen(QColor(200, 200, 200))&#10;            grid_pen.setWidth(1)&#10;&#10;            # Draw grid lines&#10;            grid_size = 30&#10;            step = 5&#10;&#10;            for i in range(-grid_size, grid_size + 1, step):&#10;                # Get projected coordinates&#10;                start_x, start_y = self.project_3d_to_2d(i, -grid_size, 0)&#10;                end_x, end_y = self.project_3d_to_2d(i, grid_size, 0)&#10;                self.scene.addLine(start_x, start_y, end_x, end_y, grid_pen)&#10;&#10;                start_x, start_y = self.project_3d_to_2d(-grid_size, i, 0)&#10;                end_x, end_y = self.project_3d_to_2d(grid_size, i, 0)&#10;                self.scene.addLine(start_x, start_y, end_x, end_y, grid_pen)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error drawing grid: {str(e)}&quot;)&#10;&#10;    def draw_nodes(self):&#10;        &quot;&quot;&quot;Draw all nodes&quot;&quot;&quot;&#10;        debug_print(&quot;Drawing nodes&quot;)&#10;        try:&#10;            for node_id, coords in self.nodes.items():&#10;                try:&#10;                    if len(coords) != 3:&#10;                        debug_print(f&quot;Invalid coordinates for node {node_id}: {coords}&quot;)&#10;                        continue&#10;&#10;                    x, y, z = coords&#10;&#10;                    # Validate coordinates&#10;                    if not (isinstance(x, (int, float)) and isinstance(y, (int, float)) and isinstance(z, (int, float))):&#10;                        debug_print(f&quot;Non-numeric coordinates for node {node_id}: {coords}&quot;)&#10;                        continue&#10;&#10;                    # Project the 3D coordinates to 2D&#10;                    proj_x, proj_y = self.project_3d_to_2d(x, y, z)&#10;&#10;                    # Determine size and color based on selection&#10;                    if node_id == self.selected_node:&#10;                        size = 10&#10;                        color = QColor(255, 0, 0)  # Red for selected&#10;                    else:&#10;                        size = 6&#10;                        color = QColor(0, 0, 0)    # Black for normal&#10;&#10;                    # Create node representation&#10;                    node_item = self.scene.addEllipse(&#10;                        proj_x - size/2, proj_y - size/2, size, size,&#10;                        QPen(color), QBrush(color)&#10;                    )&#10;&#10;                    # Add node ID text&#10;                    text_item = self.scene.addText(str(node_id))&#10;                    text_item.setPos(proj_x + 5, proj_y - 15)&#10;                    text_item.setDefaultTextColor(QColor(0, 0, 0))&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error drawing node {node_id}: {str(e)}&quot;)&#10;                    continue&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in draw_nodes: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def draw_members(self):&#10;        &quot;&quot;&quot;Draw all members&quot;&quot;&quot;&#10;        debug_print(&quot;Drawing members&quot;)&#10;        try:&#10;            for member in self.members:&#10;                try:&#10;                    member_id = member.get('id')&#10;                    i_node = member.get('i_node')&#10;                    j_node = member.get('j_node')&#10;                    section = member.get('section')&#10;&#10;                    if any(param is None for param in [member_id, i_node, j_node, section]):&#10;                        debug_print(f&quot;Incomplete member data: {member}&quot;)&#10;                        continue&#10;&#10;                    # Skip if nodes don't exist&#10;                    if i_node not in self.nodes or j_node not in self.nodes:&#10;                        debug_print(f&quot;Member {member_id} references non-existent node(s)&quot;)&#10;                        continue&#10;&#10;                    # Get node positions&#10;                    coords1 = self.nodes[i_node]&#10;                    coords2 = self.nodes[j_node]&#10;&#10;                    if len(coords1) != 3 or len(coords2) != 3:&#10;                        debug_print(f&quot;Invalid node coordinates for member {member_id}&quot;)&#10;                        continue&#10;&#10;                    x1, y1, z1 = coords1&#10;                    x2, y2, z2 = coords2&#10;&#10;                    # Validate coordinates&#10;                    if not all(isinstance(val, (int, float)) for val in [x1, y1, z1, x2, y2, z2]):&#10;                        debug_print(f&quot;Non-numeric coordinates for member {member_id}&quot;)&#10;                        continue&#10;&#10;                    # Project to 2D&#10;                    p1x, p1y = self.project_3d_to_2d(x1, y1, z1)&#10;                    p2x, p2y = self.project_3d_to_2d(x2, y2, z2)&#10;&#10;                    # Determine line properties&#10;                    if member_id == self.selected_member:&#10;                        color = QColor(255, 0, 0)  # Red for selected&#10;                        width = 3&#10;                    else:&#10;                        color = self.section_colors.get(section, QColor(0, 0, 0))&#10;                        width = 2 if section == 1 else 1&#10;&#10;                    # Create pen&#10;                    pen = QPen(color)&#10;                    pen.setWidth(width)&#10;&#10;                    # Add line&#10;                    line_item = self.scene.addLine(p1x, p1y, p2x, p2y, pen)&#10;&#10;                    # Add member ID at midpoint&#10;                    mid_x = (p1x + p2x) / 2&#10;                    mid_y = (p1y + p2y) / 2&#10;&#10;                    text_item = self.scene.addText(str(member_id))&#10;                    text_item.setPos(mid_x, mid_y)&#10;                    text_item.setDefaultTextColor(QColor(100, 100, 100))  # Gray text&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error drawing member {member.get('id')}: {str(e)}&quot;)&#10;                    continue&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in draw_members: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def draw_supports(self):&#10;        &quot;&quot;&quot;Draw support indicators&quot;&quot;&quot;&#10;        debug_print(&quot;Drawing supports&quot;)&#10;        try:&#10;            for support in self.supports:&#10;                try:&#10;                    node_id = support.get('node')&#10;&#10;                    if node_id is None:&#10;                        debug_print(f&quot;Support missing node reference: {support}&quot;)&#10;                        continue&#10;&#10;                    # Skip if node doesn't exist&#10;                    if node_id not in self.nodes:&#10;                        debug_print(f&quot;Support references non-existent node: {node_id}&quot;)&#10;                        continue&#10;&#10;                    coords = self.nodes[node_id]&#10;                    if len(coords) != 3:&#10;                        debug_print(f&quot;Invalid coordinates for node {node_id}: {coords}&quot;)&#10;                        continue&#10;&#10;                    # Get node position&#10;                    x, y, z = coords&#10;&#10;                    # Validate coordinates&#10;                    if not all(isinstance(val, (int, float)) for val in [x, y, z]):&#10;                        debug_print(f&quot;Non-numeric coordinates for node {node_id}&quot;)&#10;                        continue&#10;&#10;                    # Project to 2D&#10;                    proj_x, proj_y = self.project_3d_to_2d(x, y, z)&#10;&#10;                    # Determine support type&#10;                    is_fixed = support.get('ux') == 1 and support.get('uy') == 1 and support.get('uz') == 1&#10;&#10;                    if is_fixed:&#10;                        # Draw triangle for fixed support&#10;                        triangle_path = QPainterPath()&#10;                        triangle_path.moveTo(proj_x, proj_y + 10)&#10;                        triangle_path.lineTo(proj_x - 10, proj_y + 20)&#10;                        triangle_path.lineTo(proj_x + 10, proj_y + 20)&#10;                        triangle_path.closeSubpath()&#10;&#10;                        self.scene.addPath(triangle_path, QPen(QColor(255, 0, 0)), QBrush(QColor(255, 0, 0)))&#10;                    else:&#10;                        # Draw circle for other support&#10;                        self.scene.addEllipse(&#10;                            proj_x - 6, proj_y + 10, 12, 12,&#10;                            QPen(QColor(255, 100, 0)), QBrush(QColor(255, 100, 0))&#10;                        )&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error drawing support for node {support.get('node')}: {str(e)}&quot;)&#10;                    continue&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in draw_supports: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def resetView(self):&#10;        &quot;&quot;&quot;Reset the view to default position&quot;&quot;&quot;&#10;        debug_print(&quot;Resetting view&quot;)&#10;        try:&#10;            self.resetTransform()&#10;            self.recenter_view()&#10;            self.update_scene()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in resetView: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;&#10;class StairwayInteractiveEditor(QMainWindow):&#10;    &quot;&quot;&quot;Main application window&quot;&quot;&quot;&#10;&#10;    def __init__(self, json_file):&#10;        super().__init__()&#10;        try:&#10;            debug_print(f&quot;Initializing editor with file: {json_file}&quot;)&#10;            self.json_file = json_file&#10;            self.stairway_data = None&#10;            self.current_mode = &quot;view&quot;&#10;&#10;            # Create the structure view&#10;            self.structure_view = StructureView()&#10;&#10;            # Initialize data&#10;            self.load_data()&#10;&#10;            # Set up UI&#10;            self.init_ui()&#10;&#10;            # Update view with structure data&#10;            debug_print(&quot;Setting initial structure data to view&quot;)&#10;            self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;&#10;            # Connect signals&#10;            self.structure_view.nodeSelected.connect(self.on_node_selected)&#10;            self.structure_view.memberSelected.connect(self.on_member_selected)&#10;&#10;            # Setup mode state for member editing&#10;            self.member_creation_nodes = []&#10;&#10;            debug_print(&quot;Editor initialization complete&quot;)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error initializing editor: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;            QMessageBox.critical(self, &quot;Initialization Error&quot;,&#10;                               f&quot;Failed to initialize application: {str(e)}&quot;)&#10;&#10;    def init_ui(self):&#10;        &quot;&quot;&quot;Initialize the user interface&quot;&quot;&quot;&#10;        self.setWindowTitle(f&quot;Stairway Structure Editor - {os.path.basename(self.json_file)}&quot;)&#10;        self.setGeometry(100, 100, 1400, 900)&#10;&#10;        # Central widget&#10;        central_widget = QWidget()&#10;        self.setCentralWidget(central_widget)&#10;&#10;        # Main layout&#10;        main_layout = QHBoxLayout()&#10;        central_widget.setLayout(main_layout)&#10;&#10;        # Left panel - controls&#10;        left_panel = self.create_left_panel()&#10;        main_layout.addWidget(left_panel, 1)&#10;&#10;        # Center - structure view (already created in __init__)&#10;        main_layout.addWidget(self.structure_view, 4)&#10;&#10;        # Right panel - properties&#10;        right_panel = self.create_right_panel()&#10;        main_layout.addWidget(right_panel, 1)&#10;&#10;    def create_left_panel(self):&#10;        &quot;&quot;&quot;Create the left control panel&quot;&quot;&quot;&#10;        debug_print(&quot;Creating left panel&quot;)&#10;        panel = QWidget()&#10;        layout = QVBoxLayout()&#10;        panel.setLayout(layout)&#10;&#10;        # Mode selection&#10;        mode_group = QGroupBox(&quot;Edit Mode&quot;)&#10;        mode_layout = QVBoxLayout()&#10;        mode_group.setLayout(mode_layout)&#10;&#10;        self.mode_buttons = QButtonGroup()&#10;        modes = [&quot;View&quot;, &quot;Move Node&quot;, &quot;Add Node&quot;, &quot;Add Member&quot;, &quot;Delete Node&quot;, &quot;Delete Member&quot;, &quot;Edit Member&quot;]&#10;        for i, mode in enumerate(modes):&#10;            radio = QRadioButton(mode)&#10;            mode_layout.addWidget(radio)&#10;            self.mode_buttons.addButton(radio, i)&#10;            if i == 0:&#10;                radio.setChecked(True)&#10;&#10;        self.mode_buttons.buttonClicked.connect(self.on_mode_changed)&#10;        layout.addWidget(mode_group)&#10;&#10;        # Section selection for new members&#10;        section_group = QGroupBox(&quot;Member Section&quot;)&#10;        section_layout = QVBoxLayout()&#10;        section_group.setLayout(section_layout)&#10;&#10;        self.section_combo = QComboBox()&#10;        self.section_combo.addItems([f&quot;Section {i}&quot; for i in range(1, 6)])&#10;        section_layout.addWidget(self.section_combo)&#10;        layout.addWidget(section_group)&#10;&#10;        # Material selection&#10;        material_group = QGroupBox(&quot;Member Material&quot;)&#10;        material_layout = QVBoxLayout()&#10;        material_group.setLayout(material_layout)&#10;&#10;        self.material_combo = QComboBox()&#10;        self.material_combo.addItems([f&quot;Material {i}&quot; for i in range(1, 4)])&#10;        material_layout.addWidget(self.material_combo)&#10;        layout.addWidget(material_group)&#10;&#10;        # Action buttons&#10;        self.save_button = QPushButton(&quot;Save Structure&quot;)&#10;        self.save_button.clicked.connect(self.save_structure)&#10;        layout.addWidget(self.save_button)&#10;&#10;        self.reset_view_button = QPushButton(&quot;Reset View&quot;)&#10;        self.reset_view_button.clicked.connect(self.structure_view.resetView)&#10;        layout.addWidget(self.reset_view_button)&#10;&#10;        # Display options&#10;        display_group = QGroupBox(&quot;Display Options&quot;)&#10;        display_layout = QVBoxLayout()&#10;        display_group.setLayout(display_layout)&#10;&#10;        self.show_nodes_cb = QCheckBox(&quot;Show Node IDs&quot;)&#10;        self.show_nodes_cb.setChecked(True)&#10;        self.show_nodes_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_nodes_cb)&#10;&#10;        self.show_members_cb = QCheckBox(&quot;Show Member IDs&quot;)&#10;        self.show_members_cb.setChecked(True)&#10;        self.show_members_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_members_cb)&#10;&#10;        # Add checkbox for coordinate axes&#10;        self.show_axes_cb = QCheckBox(&quot;Show Coordinate Axes&quot;)&#10;        self.show_axes_cb.setChecked(True)&#10;        self.show_axes_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_axes_cb)&#10;&#10;        layout.addWidget(display_group)&#10;&#10;        # Info text&#10;        self.info_text = QTextEdit()&#10;        self.info_text.setReadOnly(True)&#10;        self.info_text.setMaximumHeight(200)&#10;        layout.addWidget(self.info_text)&#10;&#10;        layout.addStretch()&#10;&#10;        return panel&#10;&#10;    def create_right_panel(self):&#10;        &quot;&quot;&quot;Create the right properties panel&quot;&quot;&quot;&#10;        debug_print(&quot;Creating right panel&quot;)&#10;        panel = QWidget()&#10;        layout = QVBoxLayout()&#10;        panel.setLayout(layout)&#10;&#10;        # Node properties&#10;        self.node_group = QGroupBox(&quot;Node Properties&quot;)&#10;        node_layout = QVBoxLayout()&#10;        self.node_group.setLayout(node_layout)&#10;&#10;        # Node ID&#10;        node_id_layout = QHBoxLayout()&#10;        node_id_layout.addWidget(QLabel(&quot;ID:&quot;))&#10;        self.node_id_label = QLabel(&quot;-&quot;)&#10;        node_id_layout.addWidget(self.node_id_label)&#10;        node_id_layout.addStretch()&#10;        node_layout.addLayout(node_id_layout)&#10;&#10;        # Node coordinates&#10;        self.node_x_spin = QDoubleSpinBox()&#10;        self.node_x_spin.setRange(-1000, 1000)&#10;        self.node_x_spin.setSingleStep(0.1)&#10;        self.node_x_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        self.node_y_spin = QDoubleSpinBox()&#10;        self.node_y_spin.setRange(-1000, 1000)&#10;        self.node_y_spin.setSingleStep(0.1)&#10;        self.node_y_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        self.node_z_spin = QDoubleSpinBox()&#10;        self.node_z_spin.setRange(-1000, 1000)&#10;        self.node_z_spin.setSingleStep(0.1)&#10;        self.node_z_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        coord_layout = QVBoxLayout()&#10;        for label, spin in [(&quot;X:&quot;, self.node_x_spin), (&quot;Y:&quot;, self.node_y_spin), (&quot;Z:&quot;, self.node_z_spin)]:&#10;            row = QHBoxLayout()&#10;            row.addWidget(QLabel(label))&#10;            row.addWidget(spin)&#10;            coord_layout.addLayout(row)&#10;&#10;        node_layout.addLayout(coord_layout)&#10;        self.node_group.setEnabled(False)&#10;        layout.addWidget(self.node_group)&#10;&#10;        # Member properties&#10;        self.member_group = QGroupBox(&quot;Member Properties&quot;)&#10;        member_layout = QVBoxLayout()&#10;        self.member_group.setLayout(member_layout)&#10;&#10;        # Member ID&#10;        member_id_layout = QHBoxLayout()&#10;        member_id_layout.addWidget(QLabel(&quot;ID:&quot;))&#10;        self.member_id_label = QLabel(&quot;-&quot;)&#10;        member_id_layout.addWidget(self.member_id_label)&#10;        member_id_layout.addStretch()&#10;        member_layout.addLayout(member_id_layout)&#10;&#10;        # Member nodes&#10;        nodes_layout = QHBoxLayout()&#10;        nodes_layout.addWidget(QLabel(&quot;Nodes:&quot;))&#10;        self.member_nodes_label = QLabel(&quot;-&quot;)&#10;        nodes_layout.addWidget(self.member_nodes_label)&#10;        nodes_layout.addStretch()&#10;        member_layout.addLayout(nodes_layout)&#10;&#10;        # Member section&#10;        self.member_section_combo = QComboBox()&#10;        self.member_section_combo.addItems([f&quot;Section {i}&quot; for i in range(1, 6)])&#10;        self.member_section_combo.currentIndexChanged.connect(self.update_member_properties)&#10;&#10;        section_layout = QHBoxLayout()&#10;        section_layout.addWidget(QLabel(&quot;Section:&quot;))&#10;        section_layout.addWidget(self.member_section_combo)&#10;        member_layout.addLayout(section_layout)&#10;&#10;        # Member material&#10;        self.member_material_combo = QComboBox()&#10;        self.member_material_combo.addItems([f&quot;Material {i}&quot; for i in range(1, 4)])&#10;        self.member_material_combo.currentIndexChanged.connect(self.update_member_properties)&#10;&#10;        material_layout = QHBoxLayout()&#10;        material_layout.addWidget(QLabel(&quot;Material:&quot;))&#10;        material_layout.addWidget(self.member_material_combo)&#10;        member_layout.addLayout(material_layout)&#10;&#10;        # Change nodes button&#10;        self.change_nodes_button = QPushButton(&quot;Change Connected Nodes&quot;)&#10;        self.change_nodes_button.clicked.connect(self.start_change_member_nodes)&#10;        member_layout.addWidget(self.change_nodes_button)&#10;&#10;        self.member_group.setEnabled(False)&#10;        layout.addWidget(self.member_group)&#10;&#10;        # Structure tree&#10;        tree_group = QGroupBox(&quot;Structure Tree&quot;)&#10;        tree_layout = QVBoxLayout()&#10;        tree_group.setLayout(tree_layout)&#10;&#10;        self.structure_tree = QTreeWidget()&#10;        self.structure_tree.setHeaderLabels([&quot;Element&quot;, &quot;Type&quot;, &quot;Properties&quot;])&#10;        tree_layout.addWidget(self.structure_tree)&#10;        self.populate_structure_tree()&#10;&#10;        layout.addWidget(tree_group)&#10;&#10;        layout.addStretch()&#10;&#10;        return panel&#10;&#10;    def populate_structure_tree(self):&#10;        &quot;&quot;&quot;Populate the structure tree with nodes and members&quot;&quot;&quot;&#10;        debug_print(&quot;Populating structure tree&quot;)&#10;        try:&#10;            self.structure_tree.clear()&#10;&#10;            # Add nodes&#10;            nodes_item = QTreeWidgetItem([&quot;Nodes&quot;, f&quot;{len(self.nodes)}&quot;, &quot;&quot;])&#10;            self.structure_tree.addTopLevelItem(nodes_item)&#10;&#10;            # Add members grouped by section&#10;            sections = {}&#10;            for member in self.members:&#10;                section = member.get('section', 0)&#10;                if section not in sections:&#10;                    sections[section] = []&#10;                sections[section].append(member)&#10;&#10;            for section, members in sections.items():&#10;                section_item = QTreeWidgetItem([f&quot;Section {section}&quot;, f&quot;{len(members)} members&quot;, &quot;&quot;])&#10;                self.structure_tree.addTopLevelItem(section_item)&#10;&#10;            self.structure_tree.expandAll()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error populating structure tree: {str(e)}&quot;)&#10;&#10;    def load_data(self):&#10;        &quot;&quot;&quot;Load structure data from JSON file&quot;&quot;&quot;&#10;        debug_print(f&quot;Loading structure from {self.json_file}&quot;)&#10;&#10;        try:&#10;            with open(self.json_file, 'r') as file:&#10;                json_str = &quot;&quot;&#10;                for line in file:&#10;                    if '//' not in line:&#10;                        json_str += line&#10;&#10;                self.stairway_data = json.loads(json_str)&#10;&#10;            # Extract data&#10;            self.nodes = self.stairway_data.get('nodes', [])&#10;            self.supports = self.stairway_data.get('supports', [])&#10;            self.members = self.stairway_data.get('members', [])&#10;            self.materials = self.stairway_data.get('materials', [])&#10;            self.sections = self.stairway_data.get('sections', [])&#10;&#10;            # Create node dictionary&#10;            self.node_dict = {}&#10;            for node in self.nodes:&#10;                try:&#10;                    node_id = node.get('id')&#10;                    if node_id is None:&#10;                        continue&#10;&#10;                    # Extract and convert coordinates&#10;                    x_str = node.get('x', '0 ft')&#10;                    y_str = node.get('y', '0 ft')&#10;                    z_str = node.get('z', '0 ft')&#10;&#10;                    # Handle different format strings&#10;                    try:&#10;                        x = float(x_str.split()[0])&#10;                        y = float(y_str.split()[0])&#10;                        z = float(z_str.split()[0])&#10;                    except (ValueError, IndexError):&#10;                        debug_print(f&quot;Error parsing coordinates for node {node_id}: {x_str}, {y_str}, {z_str}&quot;)&#10;                        continue&#10;&#10;                    self.node_dict[node_id] = (x, y, z)&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error processing node: {str(e)}&quot;)&#10;                    continue&#10;&#10;            # Create connections map&#10;            self.node_connections = {node_id: [] for node_id in self.node_dict}&#10;            for member in self.members:&#10;                try:&#10;                    i_node = member.get('i_node')&#10;                    j_node = member.get('j_node')&#10;                    member_id = member.get('id')&#10;&#10;                    if None in (i_node, j_node, member_id):&#10;                        debug_print(f&quot;Incomplete member data: {member}&quot;)&#10;                        continue&#10;&#10;                    if i_node in self.node_connections:&#10;                        self.node_connections[i_node].append(member_id)&#10;                    if j_node in self.node_connections:&#10;                        self.node_connections[j_node].append(member_id)&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error processing member connection: {str(e)}&quot;)&#10;                    continue&#10;&#10;            debug_print(f&quot;Loaded {len(self.nodes)} nodes, {len(self.members)} members&quot;)&#10;&#10;        except Exception as e:&#10;            debug_print(f&quot;Error loading file: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Failed to load file: {str(e)}&quot;)&#10;            sys.exit(1)&#10;&#10;    def update_display_options(self):&#10;        &quot;&quot;&quot;Update display options&quot;&quot;&quot;&#10;        try:&#10;            debug_print(&quot;Updating display options&quot;)&#10;            # Update the display options in the view&#10;            self.structure_view.show_axes = self.show_axes_cb.isChecked()&#10;            self.structure_view.update_scene()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating display options: {str(e)}&quot;)&#10;&#10;    def on_mode_changed(self, button):&#10;        &quot;&quot;&quot;Handle mode change&quot;&quot;&quot;&#10;        try:&#10;            mode_index = self.mode_buttons.id(button)&#10;            modes = [&quot;view&quot;, &quot;move&quot;, &quot;add_node&quot;, &quot;add_member&quot;, &quot;delete_node&quot;, &quot;delete_member&quot;, &quot;edit_member&quot;]&#10;            self.current_mode = modes[mode_index]&#10;            debug_print(f&quot;Mode changed to: {self.current_mode}&quot;)&#10;&#10;            # Reset state when changing modes&#10;            if self.current_mode == &quot;add_member&quot;:&#10;                self.member_creation_nodes = []&#10;&#10;            # Update UI based on mode&#10;            if self.current_mode == &quot;move&quot;:&#10;                self.node_group.setEnabled(self.structure_view.selected_node is not None)&#10;                self.member_group.setEnabled(False)&#10;            elif self.current_mode == &quot;edit_member&quot;:&#10;                self.node_group.setEnabled(False)&#10;                self.member_group.setEnabled(self.structure_view.selected_member is not None)&#10;            else:&#10;                self.node_group.setEnabled(False)&#10;                self.member_group.setEnabled(False)&#10;&#10;            self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error changing mode: {str(e)}&quot;)&#10;&#10;    def on_node_selected(self, node_id):&#10;        &quot;&quot;&quot;Handle node selection&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Node {node_id} selected&quot;)&#10;&#10;            # Handle node selection for add_member mode&#10;            if self.current_mode == &quot;add_member&quot;:&#10;                if node_id in self.member_creation_nodes:&#10;                    debug_print(f&quot;Node {node_id} already selected&quot;)&#10;                    return&#10;&#10;                self.member_creation_nodes.append(node_id)&#10;                debug_print(f&quot;Added node {node_id} to member creation (nodes: {self.member_creation_nodes})&quot;)&#10;&#10;                if len(self.member_creation_nodes) == 2:&#10;                    self.create_member(self.member_creation_nodes[0], self.member_creation_nodes[1])&#10;                    self.member_creation_nodes = []&#10;&#10;                self.update_info_text()&#10;                return&#10;&#10;            # Ensure node exists in dictionary&#10;            if node_id not in self.node_dict:&#10;                debug_print(f&quot;Selected node {node_id} not found in node dictionary&quot;)&#10;                return&#10;&#10;            # Update node properties panel&#10;            self.node_id_label.setText(str(node_id))&#10;            x, y, z = self.node_dict[node_id]&#10;&#10;            # Block signals to prevent recursive updates&#10;            self.node_x_spin.blockSignals(True)&#10;            self.node_y_spin.blockSignals(True)&#10;            self.node_z_spin.blockSignals(True)&#10;&#10;            self.node_x_spin.setValue(x)&#10;            self.node_y_spin.setValue(y)&#10;            self.node_z_spin.setValue(z)&#10;&#10;            self.node_x_spin.blockSignals(False)&#10;            self.node_y_spin.blockSignals(False)&#10;            self.node_z_spin.blockSignals(False)&#10;&#10;            # Enable/disable panels based on mode&#10;            if self.current_mode == &quot;move&quot;:&#10;                self.node_group.setEnabled(True)&#10;            elif self.current_mode == &quot;delete_node&quot;:&#10;                self.delete_node(node_id)&#10;&#10;            self.member_group.setEnabled(False)&#10;            self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in node selection: {str(e)}&quot;)&#10;&#10;    def on_member_selected(self, member_id):&#10;        &quot;&quot;&quot;Handle member selection&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Member {member_id} selected&quot;)&#10;&#10;            if self.current_mode == &quot;delete_member&quot;:&#10;                self.delete_member(member_id)&#10;                return&#10;&#10;            # Find member data&#10;            member = next((m for m in self.members if m.get('id') == member_id), None)&#10;            if not member:&#10;                debug_print(f&quot;Member {member_id} not found in members list&quot;)&#10;                return&#10;&#10;            # Update member properties panel&#10;            self.member_id_label.setText(str(member_id))&#10;            i_node = member.get('i_node', '-')&#10;            j_node = member.get('j_node', '-')&#10;            self.member_nodes_label.setText(f&quot;{i_node} - {j_node}&quot;)&#10;&#10;            # Block signals&#10;            self.member_section_combo.blockSignals(True)&#10;            self.member_material_combo.blockSignals(True)&#10;&#10;            # Update combo box selections&#10;            section = member.get('section', 1)&#10;            material = member.get('material', 1)&#10;            self.member_section_combo.setCurrentIndex(section - 1)&#10;            self.member_material_combo.setCurrentIndex(material - 1)&#10;&#10;            self.member_section_combo.blockSignals(False)&#10;            self.member_material_combo.blockSignals(False)&#10;&#10;            # Enable/disable panels based on mode&#10;            self.node_group.setEnabled(False)&#10;            if self.current_mode == &quot;edit_member&quot;:&#10;                self.member_group.setEnabled(True)&#10;&#10;            self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in member selection: {str(e)}&quot;)&#10;&#10;    def update_node_position(self):&#10;        &quot;&quot;&quot;Update selected node position from spinboxes&quot;&quot;&quot;&#10;        try:&#10;            if not self.structure_view.selected_node:&#10;                return&#10;&#10;            node_id = self.structure_view.selected_node&#10;            x = self.node_x_spin.value()&#10;            y = self.node_y_spin.value()&#10;            z = self.node_z_spin.value()&#10;&#10;            # Update internal data&#10;            self.node_dict[node_id] = (x, y, z)&#10;&#10;            # Update node in list&#10;            for node in self.nodes:&#10;                if node.get('id') == node_id:&#10;                    node['x'] = f&quot;{x} ft&quot;&#10;                    node['y'] = f&quot;{y} ft&quot;&#10;                    node['z'] = f&quot;{z} ft&quot;&#10;                    break&#10;&#10;            # Update view&#10;            self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating node position: {str(e)}&quot;)&#10;&#10;    def update_member_properties(self):&#10;        &quot;&quot;&quot;Update selected member properties&quot;&quot;&quot;&#10;        try:&#10;            if not self.structure_view.selected_member:&#10;                return&#10;&#10;            member_id = self.structure_view.selected_member&#10;&#10;            # Find member&#10;            for member in self.members:&#10;                if member.get('id') == member_id:&#10;                    member['section'] = self.member_section_combo.currentIndex() + 1&#10;                    member['material'] = self.member_material_combo.currentIndex() + 1&#10;                    break&#10;&#10;            # Update view&#10;            self.structure_view.update_scene()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating member properties: {str(e)}&quot;)&#10;&#10;    def start_change_member_nodes(self):&#10;        &quot;&quot;&quot;Start process to change member's connected nodes&quot;&quot;&quot;&#10;        try:&#10;            if not self.structure_view.selected_member:&#10;                return&#10;&#10;            # Switch to special mode for changing member nodes&#10;            self.current_mode = &quot;change_member_nodes&quot;&#10;            self.member_creation_nodes = []&#10;&#10;            QMessageBox.information(self, &quot;Change Nodes&quot;,&#10;                                  &quot;Select two nodes to reconnect the member&quot;)&#10;            self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error starting member node change: {str(e)}&quot;)&#10;&#10;    def update_member_nodes(self, member_id, new_i_node, new_j_node):&#10;        &quot;&quot;&quot;Update a member's connected nodes&quot;&quot;&quot;&#10;        try:&#10;            member = next((m for m in self.members if m.get('id') == member_id), None)&#10;            if not member:&#10;                return&#10;&#10;            old_i_node = member.get('i_node')&#10;            old_j_node = member.get('j_node')&#10;&#10;            # Remove member from old node connections&#10;            if old_i_node in self.node_connections and member_id in self.node_connections[old_i_node]:&#10;                self.node_connections[old_i_node].remove(member_id)&#10;&#10;            if old_j_node in self.node_connections and member_id in self.node_connections[old_j_node]:&#10;                self.node_connections[old_j_node].remove(member_id)&#10;&#10;            # Update member endpoints&#10;            member['i_node'] = new_i_node&#10;            member['j_node'] = new_j_node&#10;&#10;            # Add to new node connections&#10;            if new_i_node not in self.node_connections:&#10;                self.node_connections[new_i_node] = []&#10;            self.node_connections[new_i_node].append(member_id)&#10;&#10;            if new_j_node not in self.node_connections:&#10;                self.node_connections[new_j_node] = []&#10;            self.node_connections[new_j_node].append(member_id)&#10;&#10;            # Update view&#10;            self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating member nodes: {str(e)}&quot;)&#10;&#10;    def create_member(self, node1, node2):&#10;        &quot;&quot;&quot;Create a new member between two nodes&quot;&quot;&quot;&#10;        try:&#10;            section = self.section_combo.currentIndex() + 1&#10;            material = self.material_combo.currentIndex() + 1&#10;&#10;            # Get next member ID&#10;            member_ids = [m.get('id', 0) for m in self.members]&#10;            next_id = max(member_ids, default=0) + 1&#10;&#10;            # Create new member&#10;            new_member = {&#10;                'id': next_id,&#10;                'i_node': node1,&#10;                'j_node': node2,&#10;                'section': section,&#10;                'material': material&#10;            }&#10;&#10;            debug_print(f&quot;Creating member {next_id} between nodes {node1}-{node2}&quot;)&#10;&#10;            # Add to data structures&#10;            self.members.append(new_member)&#10;&#10;            # Update connections&#10;            if node1 not in self.node_connections:&#10;                self.node_connections[node1] = []&#10;            self.node_connections[node1].append(next_id)&#10;&#10;            if node2 not in self.node_connections:&#10;                self.node_connections[node2] = []&#10;            self.node_connections[node2].append(next_id)&#10;&#10;            # Update view&#10;            self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;            self.populate_structure_tree()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error creating member: {str(e)}&quot;)&#10;&#10;    def delete_node(self, node_id):&#10;        &quot;&quot;&quot;Delete a node and its connected members&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Deleting node {node_id}&quot;)&#10;&#10;            # Get connected members&#10;            connected_members = self.node_connections.get(node_id, [])[:]&#10;&#10;            # Delete connected members&#10;            if connected_members:&#10;                for member_id in connected_members:&#10;                    self.delete_member(member_id, update_viz=False)&#10;&#10;            # Delete node&#10;            self.nodes = [n for n in self.nodes if n.get('id') != node_id]&#10;            if node_id in self.node_dict:&#10;                del self.node_dict[node_id]&#10;            if node_id in self.node_connections:&#10;                del self.node_connections[node_id]&#10;&#10;            # Update view&#10;            self.structure_view.selected_node = None&#10;            self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;            self.populate_structure_tree()&#10;            self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error deleting node: {str(e)}&quot;)&#10;&#10;    def delete_member(self, member_id, update_viz=True):&#10;        &quot;&quot;&quot;Delete a member&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Deleting member {member_id}&quot;)&#10;&#10;            # Find member&#10;            member = next((m for m in self.members if m.get('id') == member_id), None)&#10;            if not member:&#10;                return&#10;&#10;            # Remove from connections&#10;            i_node = member.get('i_node')&#10;            j_node = member.get('j_node')&#10;&#10;            if i_node in self.node_connections and member_id in self.node_connections[i_node]:&#10;                self.node_connections[i_node].remove(member_id)&#10;&#10;            if j_node in self.node_connections and member_id in self.node_connections[j_node]:&#10;                self.node_connections[j_node].remove(member_id)&#10;&#10;            # Remove from list&#10;            self.members = [m for m in self.members if m.get('id') != member_id]&#10;&#10;            # Update visualization if requested&#10;            if update_viz:&#10;                self.structure_view.selected_member = None&#10;                self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;                self.populate_structure_tree()&#10;                self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error deleting member: {str(e)}&quot;)&#10;&#10;    def update_info_text(self):&#10;        &quot;&quot;&quot;Update information text&quot;&quot;&quot;&#10;        try:&#10;            info = f&quot;Mode: {self.current_mode.replace('_', ' ').title()}\n\n&quot;&#10;&#10;            if self.current_mode == &quot;add_member&quot;:&#10;                info += f&quot;Select nodes to create a member.\n&quot;&#10;                info += f&quot;Selected nodes: {len(self.member_creation_nodes)}/2\n\n&quot;&#10;            elif self.current_mode == &quot;change_member_nodes&quot;:&#10;                info += f&quot;Select nodes to reconnect member {self.structure_view.selected_member}.\n&quot;&#10;                info += f&quot;Selected nodes: {len(self.member_creation_nodes)}/2\n\n&quot;&#10;&#10;            if self.structure_view.selected_node:&#10;                node_id = self.structure_view.selected_node&#10;                if node_id in self.node_dict:&#10;                    x, y, z = self.node_dict[node_id]&#10;                    info += f&quot;Selected Node: {node_id}\n&quot;&#10;                    info += f&quot;Position: ({x:.2f}, {y:.2f}, {z:.2f})\n&quot;&#10;                    info += f&quot;Connected Members: {len(self.node_connections.get(node_id, []))}\n&quot;&#10;&#10;            elif self.structure_view.selected_member:&#10;                member = next((m for m in self.members if m.get('id') == self.structure_view.selected_member), None)&#10;                if member:&#10;                    info += f&quot;Selected Member: {member.get('id')}\n&quot;&#10;                    info += f&quot;Nodes: {member.get('i_node')} - {member.get('j_node')}\n&quot;&#10;                    info += f&quot;Section: {member.get('section')}, Material: {member.get('material')}\n&quot;&#10;&#10;                    # Calculate length if both nodes exist&#10;                    i_node = member.get('i_node')&#10;                    j_node = member.get('j_node')&#10;                    if i_node in self.node_dict and j_node in self.node_dict:&#10;                        i_pos = self.node_dict[i_node]&#10;                        j_pos = self.node_dict[j_node]&#10;                        # Use math.sqrt instead of sp.sqrt&#10;                        length = math.sqrt(sum((j_pos[i] - i_pos[i])**2 for i in range(3)))&#10;                        info += f&quot;Length: {length:.2f} ft\n&quot;&#10;&#10;            self.info_text.setText(info)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating info text: {str(e)}&quot;)&#10;&#10;    def save_structure(self):&#10;        &quot;&quot;&quot;Save structure to JSON file&quot;&quot;&quot;&#10;        try:&#10;            # Update structure data&#10;            self.stairway_data['nodes'] = self.nodes&#10;            self.stairway_data['members'] = self.members&#10;&#10;            # Generate filename&#10;            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')&#10;            base_name = os.path.splitext(self.json_file)[0]&#10;            output_file = f&quot;{base_name}_edited_{timestamp}.json&quot;&#10;&#10;            try:&#10;                with open(output_file, 'w') as f:&#10;                    json.dump(self.stairway_data, f, indent=4)&#10;                QMessageBox.information(self, &quot;Success&quot;, f&quot;Structure saved to {output_file}&quot;)&#10;                debug_print(f&quot;Saved structure to {output_file}&quot;)&#10;            except Exception as e:&#10;                QMessageBox.critical(self, &quot;Error&quot;, f&quot;Failed to save: {str(e)}&quot;)&#10;                debug_print(f&quot;Error saving: {str(e)}&quot;)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in save_structure: {str(e)}&quot;)&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main entry point&quot;&quot;&quot;&#10;    try:&#10;        # Direct console output to stderr for debugging&#10;        sys.stdout.flush()&#10;&#10;        debug_print(f&quot;Starting application with Python {sys.version}&quot;)&#10;&#10;        # Create QApplication&#10;        app = QApplication(sys.argv)&#10;&#10;        # Get JSON file&#10;        if len(sys.argv) &gt; 1:&#10;            json_file = sys.argv[1]&#10;        else:&#10;            json_file = &quot;stairway_structure.json&quot;&#10;            if not os.path.exists(json_file):&#10;                # Try to find any JSON file&#10;                json_files = [f for f in os.listdir('.') if f.endswith('.json')]&#10;                if json_files:&#10;                    json_file = json_files[0]&#10;                else:&#10;                    debug_print(&quot;No JSON files found&quot;)&#10;                    QMessageBox.critical(None, &quot;Error&quot;, &quot;No JSON files found in the current directory&quot;)&#10;                    sys.exit(1)&#10;&#10;        # Create and show main window with exception handling&#10;        editor = StairwayInteractiveEditor(json_file)&#10;        editor.show()&#10;        debug_print(&quot;Application started successfully&quot;)&#10;&#10;        # Set up a timer to periodically flush stdout&#10;        flush_timer = QTimer()&#10;        flush_timer.timeout.connect(lambda: sys.stdout.flush())&#10;        flush_timer.start(1000)  # Flush every second&#10;&#10;        sys.exit(app.exec_())&#10;    except Exception as e:&#10;        debug_print(f&quot;Fatal error in main: {str(e)}&quot;)&#10;        traceback.print_exc()&#10;&#10;        # Try to show error message to user&#10;        try:&#10;            app = QApplication.instance() or QApplication(sys.argv)&#10;            error_msg = QMessageBox()&#10;            error_msg.setIcon(QMessageBox.Critical)&#10;            error_msg.setWindowTitle(&quot;Fatal Error&quot;)&#10;            error_msg.setText(&quot;The application has encountered a critical error and needs to close.&quot;)&#10;            error_msg.setDetailedText(f&quot;Error: {str(e)}\n\n{traceback.format_exc()}&quot;)&#10;            error_msg.exec_()&#10;        except:&#10;            pass&#10;&#10;        sys.exit(1)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="# Interactive stairway structure visualization and editing tool using pure PyQt (no OpenGL)&#10;&#10;import os&#10;import json&#10;import sys&#10;import math  # Add math module import for sqrt function&#10;import datetime&#10;import traceback&#10;import scipy as sp&#10;from scipy.spatial import distance&#10;# Import specific math functions from scipy&#10;from scipy import special&#10;from scipy import linalg&#10;from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,&#10;                            QHBoxLayout, QPushButton, QLabel, QSlider,&#10;                            QGroupBox, QRadioButton, QButtonGroup, QSplitter,&#10;                            QTextEdit, QFileDialog, QMessageBox, QSpinBox,&#10;                            QDoubleSpinBox, QComboBox, QTreeWidget, QTreeWidgetItem,&#10;                            QCheckBox, QGraphicsView, QGraphicsScene, QGraphicsItem)&#10;from PyQt5.QtCore import Qt, QTimer, pyqtSignal, QPoint, QRectF&#10;from PyQt5.QtGui import QPainter, QPen, QBrush, QColor, QPainterPath, QFont, QTransform&#10;&#10;# Global debug flag&#10;DEBUG = True&#10;&#10;def debug_print(*args, **kwargs):&#10;    &quot;&quot;&quot;Helper function for debug printing&quot;&quot;&quot;&#10;    if DEBUG:&#10;        print(*args, **kwargs)&#10;        sys.stdout.flush()  # Ensure output is flushed immediately&#10;&#10;class StructureView(QGraphicsView):&#10;    &quot;&quot;&quot;Custom graphics view for 2D visualization of 3D structure&quot;&quot;&quot;&#10;&#10;    nodeSelected = pyqtSignal(int)&#10;    memberSelected = pyqtSignal(int)&#10;&#10;    def __init__(self, parent=None):&#10;        debug_print(&quot;Initializing StructureView&quot;)&#10;        super().__init__(parent)&#10;&#10;        # Setup the scene&#10;        self.scene = QGraphicsScene(self)&#10;        self.setScene(self.scene)&#10;&#10;        # Enable antialiasing&#10;        self.setRenderHint(QPainter.Antialiasing)&#10;        self.setRenderHint(QPainter.TextAntialiasing)&#10;&#10;        # Set background color&#10;        self.setBackgroundBrush(QBrush(QColor(245, 245, 245)))&#10;&#10;        # View settings&#10;        self.scale_factor = 20.0  # Scaling for better visibility&#10;        self.center_offset = (0, 0)  # Pan offset&#10;&#10;        # Structure data&#10;        self.nodes = {}&#10;        self.members = []&#10;        self.supports = []&#10;&#10;        # Selection&#10;        self.selected_node = None&#10;        self.selected_member = None&#10;&#10;        # Colors for sections&#10;        self.section_colors = {&#10;            1: QColor(0, 0, 255),     # Blue - Main stringers&#10;            2: QColor(0, 180, 0),     # Green - Steps/treads&#10;            3: QColor(0, 200, 200),   # Cyan - Secondary members&#10;            4: QColor(100, 100, 100), # Gray - Bracing&#10;            5: QColor(200, 0, 0)      # Red - Column&#10;        }&#10;&#10;        # Mouse tracking for pan and zoom&#10;        self.setMouseTracking(True)&#10;        self.last_mouse_pos = None&#10;&#10;        # Enable drag mode&#10;        self.setDragMode(QGraphicsView.NoDrag)&#10;&#10;        # Add axes display property&#10;        self.show_axes = True&#10;&#10;        # Use standard isometric projection angles for right-handed system&#10;        # These are based on standard 30 isometric angles&#10;        self.iso_angle = math.radians(30)  # Standard isometric angle&#10;        self.cos_angle = math.cos(self.iso_angle)&#10;        self.sin_angle = math.sin(self.iso_angle)&#10;&#10;        debug_print(&quot;StructureView initialization complete&quot;)&#10;&#10;    def wheelEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse wheel for zooming&quot;&quot;&quot;&#10;        try:&#10;            debug_print(&quot;Wheel event&quot;)&#10;            # Save the scene pos&#10;            old_pos = self.mapToScene(event.pos())&#10;&#10;            # Zoom factor&#10;            zoom_factor = 1.15&#10;&#10;            # Zoom in or out&#10;            if event.angleDelta().y() &gt; 0:&#10;                self.scale(zoom_factor, zoom_factor)&#10;            else:&#10;                self.scale(1.0 / zoom_factor, 1.0 / zoom_factor)&#10;&#10;            # Get the new position&#10;            new_pos = self.mapToScene(event.pos())&#10;&#10;            # Move scene to old position&#10;            delta = new_pos - old_pos&#10;            self.translate(delta.x(), delta.y())&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in wheelEvent: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def mousePressEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse press events&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Mouse press at {event.pos().x()}, {event.pos().y()}&quot;)&#10;            self.last_mouse_pos = event.pos()&#10;&#10;            if event.button() == Qt.LeftButton:&#10;                # Convert to scene coordinates&#10;                scene_pos = self.mapToScene(event.pos())&#10;                debug_print(f&quot;Scene position: {scene_pos.x()}, {scene_pos.y()}&quot;)&#10;&#10;                # Try to find closest node&#10;                try:&#10;                    node_id = self.find_closest_node(scene_pos.x(), scene_pos.y())&#10;                    if node_id is not None:&#10;                        debug_print(f&quot;Selected node {node_id}&quot;)&#10;                        self.selected_node = node_id&#10;                        self.selected_member = None&#10;                        self.nodeSelected.emit(node_id)&#10;                        self.update_scene()&#10;                        return&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error finding closest node: {str(e)}&quot;)&#10;                    traceback.print_exc()&#10;&#10;                # Try to find closest member&#10;                try:&#10;                    member_id = self.find_closest_member(scene_pos.x(), scene_pos.y())&#10;                    if member_id is not None:&#10;                        debug_print(f&quot;Selected member {member_id}&quot;)&#10;                        self.selected_member = member_id&#10;                        self.selected_node = None&#10;                        self.memberSelected.emit(member_id)&#10;                        self.update_scene()&#10;                        return&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error finding closest member: {str(e)}&quot;)&#10;                    traceback.print_exc()&#10;&#10;                # If clicked on empty space&#10;                self.selected_node = None&#10;                self.selected_member = None&#10;                self.update_scene()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in mousePressEvent: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;        super().mousePressEvent(event)&#10;&#10;    def mouseMoveEvent(self, event):&#10;        &quot;&quot;&quot;Handle mouse movement for panning&quot;&quot;&quot;&#10;        try:&#10;            if event.buttons() &amp; Qt.MiddleButton and self.last_mouse_pos:&#10;                # Calculate movement&#10;                delta = event.pos() - self.last_mouse_pos&#10;                self.last_mouse_pos = event.pos()&#10;&#10;                # Pan the view&#10;                self.translate(delta.x(), delta.y())&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in mouseMoveEvent: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;        super().mouseMoveEvent(event)&#10;&#10;    def find_closest_node(self, x, y, threshold=10):&#10;        &quot;&quot;&quot;Find the closest node to the given coordinates&quot;&quot;&quot;&#10;        debug_print(f&quot;Finding closest node to {x}, {y}&quot;)&#10;&#10;        try:&#10;            closest_node = None&#10;            min_dist = threshold&#10;&#10;            # Safety check for nodes&#10;            if not self.nodes:&#10;                debug_print(&quot;No nodes available&quot;)&#10;                return None&#10;&#10;            debug_print(f&quot;Checking {len(self.nodes)} nodes&quot;)&#10;            for node_id, coords in self.nodes.items():&#10;                if not coords or len(coords) != 3:&#10;                    debug_print(f&quot;Invalid node data for node {node_id}: {coords}&quot;)&#10;                    continue&#10;&#10;                nx, ny, nz = coords&#10;                if not isinstance(nx, (int, float)) or not isinstance(ny, (int, float)) or not isinstance(nz, (int, float)):&#10;                    debug_print(f&quot;Non-numeric coordinates for node {node_id}: {coords}&quot;)&#10;                    continue&#10;&#10;                # Project 3D point to 2D using simple projection&#10;                try:&#10;                    proj_x, proj_y = self.project_3d_to_2d(nx, ny, nz)&#10;&#10;                    # Calculate distance - using math.sqrt instead of sp.sqrt&#10;                    try:&#10;                        dist = math.sqrt((x - proj_x)**2 + (y - proj_y)**2)&#10;&#10;                        if dist &lt; min_dist:&#10;                            min_dist = dist&#10;                            closest_node = node_id&#10;                    except Exception as e:&#10;                        debug_print(f&quot;Error calculating distance for node {node_id}: {str(e)}&quot;)&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error projecting node {node_id}: {str(e)}&quot;)&#10;&#10;            if closest_node is not None:&#10;                debug_print(f&quot;Found closest node: {closest_node} at distance {min_dist:.2f}&quot;)&#10;            else:&#10;                debug_print(&quot;No node found within threshold&quot;)&#10;&#10;            return closest_node&#10;&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in find_closest_node: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;            return None&#10;&#10;    def find_closest_member(self, x, y, threshold=5):&#10;        &quot;&quot;&quot;Find the closest member to the given coordinates&quot;&quot;&quot;&#10;        debug_print(f&quot;Finding closest member to {x}, {y}&quot;)&#10;&#10;        try:&#10;            closest_member = None&#10;            min_dist = threshold&#10;&#10;            # Safety check for members&#10;            if not self.members:&#10;                debug_print(&quot;No members available&quot;)&#10;                return None&#10;&#10;            for member in self.members:&#10;                try:&#10;                    i_node = member.get('i_node')&#10;                    j_node = member.get('j_node')&#10;&#10;                    if i_node is None or j_node is None:&#10;                        debug_print(f&quot;Missing node references in member {member.get('id')}&quot;)&#10;                        continue&#10;&#10;                    if i_node not in self.nodes or j_node not in self.nodes:&#10;                        debug_print(f&quot;Member {member.get('id')} refers to non-existent node(s)&quot;)&#10;                        continue&#10;&#10;                    # Project endpoints&#10;                    x1, y1, z1 = self.nodes[i_node]&#10;                    x2, y2, z2 = self.nodes[j_node]&#10;&#10;                    p1x, p1y = self.project_3d_to_2d(x1, y1, z1)&#10;                    p2x, p2y = self.project_3d_to_2d(x2, y2, z2)&#10;&#10;                    # Calculate distance to line segment&#10;                    dist = self.point_to_line_dist(x, y, p1x, p1y, p2x, p2y)&#10;&#10;                    if dist &lt; min_dist:&#10;                        min_dist = dist&#10;                        closest_member = member['id']&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error processing member {member.get('id')}: {str(e)}&quot;)&#10;&#10;            return closest_member&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in find_closest_member: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;            return None&#10;&#10;    def point_to_line_dist(self, x, y, x1, y1, x2, y2):&#10;        &quot;&quot;&quot;Calculate distance from point to line segment&quot;&quot;&quot;&#10;        try:&#10;            # Calculate line segment length squared&#10;            l2 = (x2 - x1)**2 + (y2 - y1)**2&#10;&#10;            if l2 == 0:  # Points are the same&#10;                return math.sqrt((x - x1)**2 + (y - y1)**2)&#10;&#10;            # Calculate projection parameter&#10;            t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2&#10;            t = max(0, min(1, t))  # Clamp to segment&#10;&#10;            # Calculate nearest point on segment&#10;            px = x1 + t * (x2 - x1)&#10;            py = y1 + t * (y2 - y1)&#10;&#10;            # Return distance to that point&#10;            return math.sqrt((x - px)**2 + (y - py)**2)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in point_to_line_dist: {str(e)}&quot;)&#10;            return float('inf')  # Return infinite distance on error&#10;&#10;    def project_3d_to_2d(self, x, y, z):&#10;        &quot;&quot;&quot;Project 3D point to 2D using a standard isometric projection with right-handed coordinate system&quot;&quot;&quot;&#10;        try:&#10;            # Implement standard isometric projection for right-handed system&#10;            # X right, Y forward (into screen), Z up&#10;            # When rotating from X to Y with right-hand rule, thumb points up along Z&#10;            &#10;            # Standard isometric projection coefficients (30 angles)&#10;            proj_x = x * self.cos_angle - y * self.cos_angle  # X and Y contributions to screen X&#10;            proj_y = z + x * self.sin_angle + y * self.sin_angle  # Z, X and Y contributions to screen Y&#10;&#10;            # Apply scale and offset&#10;            proj_x = proj_x * self.scale_factor + 500 + self.center_offset[0]&#10;            proj_y = -proj_y * self.scale_factor + 300 + self.center_offset[1]  # Y is inverted in screen coords&#10;&#10;            return proj_x, proj_y&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in project_3d_to_2d: {str(e)}&quot;)&#10;            return 0, 0  # Return origin on error&#10;&#10;    def setStructureData(self, nodes, members, supports):&#10;        &quot;&quot;&quot;Update the structure data&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Setting structure data: {len(nodes)} nodes, {len(members)} members&quot;)&#10;            self.nodes = nodes&#10;            self.members = members&#10;            self.supports = supports&#10;&#10;            # Recenter the view on the structure&#10;            self.recenter_view()&#10;&#10;            # Update the scene with the new data&#10;            self.update_scene()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in setStructureData: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def recenter_view(self):&#10;        &quot;&quot;&quot;Center the view on the structure&quot;&quot;&quot;&#10;        try:&#10;            debug_print(&quot;Recentering view&quot;)&#10;            if not self.nodes:&#10;                debug_print(&quot;No nodes to center on&quot;)&#10;                return&#10;&#10;            # Find structure bounds&#10;            x_vals = []&#10;            y_vals = []&#10;            z_vals = []&#10;&#10;            for pos in self.nodes.values():&#10;                if len(pos) == 3:&#10;                    x, y, z = pos&#10;                    if isinstance(x, (int, float)) and isinstance(y, (int, float)) and isinstance(z, (int, float)):&#10;                        x_vals.append(x)&#10;                        y_vals.append(y)&#10;                        z_vals.append(z)&#10;&#10;            if not x_vals or not y_vals or not z_vals:&#10;                debug_print(&quot;No valid coordinates to center on&quot;)&#10;                return&#10;&#10;            x_min, x_max = min(x_vals), max(x_vals)&#10;            y_min, y_max = min(y_vals), max(y_vals)&#10;            z_min, z_max = min(z_vals), max(z_vals)&#10;&#10;            # Calculate center&#10;            x_center = (x_min + x_max) / 2&#10;            y_center = (y_min + y_max) / 2&#10;            z_center = (z_min + z_max) / 2&#10;&#10;            # Set center offset to center the structure&#10;            # We'll use the projection to determine the offset&#10;            center_x, center_y = self.project_3d_to_2d(x_center, y_center, z_center)&#10;&#10;            # Determine the view center&#10;            view_center_x = self.width() / 2&#10;            view_center_y = self.height() / 2&#10;&#10;            # Calculate offset to center the structure&#10;            self.center_offset = (&#10;                view_center_x - center_x + 500,  # Add 500 because that's our base offset&#10;                view_center_y - center_y + 300   # Add 300 because that's our base offset&#10;            )&#10;&#10;            # Reset the view&#10;            self.resetTransform()&#10;            self.centerOn(view_center_x, view_center_y)&#10;&#10;            debug_print(f&quot;View centered. Center offset: {self.center_offset}&quot;)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in recenter_view: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def update_scene(self):&#10;        &quot;&quot;&quot;Update the scene with current structure data&quot;&quot;&quot;&#10;        debug_print(&quot;Updating scene&quot;)&#10;        try:&#10;            # Clear previous scene&#10;            self.scene.clear()&#10;&#10;            # Draw grid&#10;            self.draw_grid()&#10;&#10;            # Draw coordinate axes&#10;            if self.show_axes:&#10;                self.draw_axes()&#10;&#10;            # Draw members first (so nodes are on top)&#10;            self.draw_members()&#10;&#10;            # Draw nodes&#10;            self.draw_nodes()&#10;&#10;            # Draw supports&#10;            self.draw_supports()&#10;&#10;            # Update the view&#10;            self.update()&#10;            debug_print(&quot;Scene updated successfully&quot;)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating scene: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def draw_axes(self):&#10;        &quot;&quot;&quot;Draw X, Y, Z coordinate axes with clear right-handed system&quot;&quot;&quot;&#10;        debug_print(&quot;Drawing coordinate axes&quot;)&#10;        try:&#10;            # Get origin position&#10;            origin_x, origin_y = self.project_3d_to_2d(0, 0, 0)&#10;&#10;            # Draw X axis (red) - points right&#10;            x_end_x, x_end_y = self.project_3d_to_2d(10, 0, 0)&#10;            x_pen = QPen(QColor(255, 0, 0))  # Red&#10;            x_pen.setWidth(2)&#10;            self.scene.addLine(origin_x, origin_y, x_end_x, x_end_y, x_pen)&#10;            self.scene.addText(&quot;X&quot;).setPos(x_end_x + 5, x_end_y - 10)&#10;&#10;            # Draw Y axis (green) - points forward/into screen&#10;            y_end_x, y_end_y = self.project_3d_to_2d(0, 10, 0)&#10;            y_pen = QPen(QColor(0, 180, 0))  # Green&#10;            y_pen.setWidth(2)&#10;            self.scene.addLine(origin_x, origin_y, y_end_x, y_end_y, y_pen)&#10;            self.scene.addText(&quot;Y&quot;).setPos(y_end_x + 5, y_end_y - 10)&#10;&#10;            # Draw Z axis (blue) - points up&#10;            z_end_x, z_end_y = self.project_3d_to_2d(0, 0, 10)&#10;            z_pen = QPen(QColor(0, 0, 255))  # Blue&#10;            z_pen.setWidth(2)&#10;            self.scene.addLine(origin_x, origin_y, z_end_x, z_end_y, z_pen)&#10;            self.scene.addText(&quot;Z&quot;).setPos(z_end_x + 5, z_end_y - 10)&#10;&#10;            # Add a small circle at origin&#10;            self.scene.addEllipse(origin_x - 3, origin_y - 3, 6, 6,&#10;                                 QPen(QColor(0, 0, 0)), QBrush(QColor(0, 0, 0)))&#10;&#10;            # Draw the right-hand rule illustration&#10;            # Draw a small curved arrow showing the rotation from X to Y&#10;            arrow_path = QPainterPath()&#10;            arrow_path.moveTo(origin_x + 15, origin_y - 5)&#10;            arrow_path.arcTo(origin_x - 10, origin_y - 15, 30, 30, 0, -90)&#10;            arrow_pen = QPen(QColor(100, 100, 100))&#10;            arrow_pen.setWidth(1)&#10;            self.scene.addPath(arrow_path, arrow_pen)&#10;            &#10;            # Add text explaining the right-hand rule&#10;            self.scene.addText(&quot;Right-handed system: rotate XY, thumb points to Z&quot;).setPos(origin_x - 100, origin_y + 20)&#10;&#10;        except Exception as e:&#10;            debug_print(f&quot;Error drawing axes: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def draw_grid(self):&#10;        &quot;&quot;&quot;Draw a reference grid&quot;&quot;&quot;&#10;        debug_print(&quot;Drawing grid&quot;)&#10;        try:&#10;            # Create a light gray pen&#10;            grid_pen = QPen(QColor(200, 200, 200))&#10;            grid_pen.setWidth(1)&#10;&#10;            # Draw grid lines&#10;            grid_size = 30&#10;            step = 5&#10;&#10;            for i in range(-grid_size, grid_size + 1, step):&#10;                # Get projected coordinates&#10;                start_x, start_y = self.project_3d_to_2d(i, -grid_size, 0)&#10;                end_x, end_y = self.project_3d_to_2d(i, grid_size, 0)&#10;                self.scene.addLine(start_x, start_y, end_x, end_y, grid_pen)&#10;&#10;                start_x, start_y = self.project_3d_to_2d(-grid_size, i, 0)&#10;                end_x, end_y = self.project_3d_to_2d(grid_size, i, 0)&#10;                self.scene.addLine(start_x, start_y, end_x, end_y, grid_pen)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error drawing grid: {str(e)}&quot;)&#10;&#10;    def draw_nodes(self):&#10;        &quot;&quot;&quot;Draw all nodes&quot;&quot;&quot;&#10;        debug_print(&quot;Drawing nodes&quot;)&#10;        try:&#10;            for node_id, coords in self.nodes.items():&#10;                try:&#10;                    if len(coords) != 3:&#10;                        debug_print(f&quot;Invalid coordinates for node {node_id}: {coords}&quot;)&#10;                        continue&#10;&#10;                    x, y, z = coords&#10;&#10;                    # Validate coordinates&#10;                    if not (isinstance(x, (int, float)) and isinstance(y, (int, float)) and isinstance(z, (int, float))):&#10;                        debug_print(f&quot;Non-numeric coordinates for node {node_id}: {coords}&quot;)&#10;                        continue&#10;&#10;                    # Project the 3D coordinates to 2D&#10;                    proj_x, proj_y = self.project_3d_to_2d(x, y, z)&#10;&#10;                    # Determine size and color based on selection&#10;                    if node_id == self.selected_node:&#10;                        size = 10&#10;                        color = QColor(255, 0, 0)  # Red for selected&#10;                    else:&#10;                        size = 6&#10;                        color = QColor(0, 0, 0)    # Black for normal&#10;&#10;                    # Create node representation&#10;                    node_item = self.scene.addEllipse(&#10;                        proj_x - size/2, proj_y - size/2, size, size,&#10;                        QPen(color), QBrush(color)&#10;                    )&#10;&#10;                    # Add node ID text&#10;                    text_item = self.scene.addText(str(node_id))&#10;                    text_item.setPos(proj_x + 5, proj_y - 15)&#10;                    text_item.setDefaultTextColor(QColor(0, 0, 0))&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error drawing node {node_id}: {str(e)}&quot;)&#10;                    continue&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in draw_nodes: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def draw_members(self):&#10;        &quot;&quot;&quot;Draw all members&quot;&quot;&quot;&#10;        debug_print(&quot;Drawing members&quot;)&#10;        try:&#10;            for member in self.members:&#10;                try:&#10;                    member_id = member.get('id')&#10;                    i_node = member.get('i_node')&#10;                    j_node = member.get('j_node')&#10;                    section = member.get('section')&#10;&#10;                    if any(param is None for param in [member_id, i_node, j_node, section]):&#10;                        debug_print(f&quot;Incomplete member data: {member}&quot;)&#10;                        continue&#10;&#10;                    # Skip if nodes don't exist&#10;                    if i_node not in self.nodes or j_node not in self.nodes:&#10;                        debug_print(f&quot;Member {member_id} references non-existent node(s)&quot;)&#10;                        continue&#10;&#10;                    # Get node positions&#10;                    coords1 = self.nodes[i_node]&#10;                    coords2 = self.nodes[j_node]&#10;&#10;                    if len(coords1) != 3 or len(coords2) != 3:&#10;                        debug_print(f&quot;Invalid node coordinates for member {member_id}&quot;)&#10;                        continue&#10;&#10;                    x1, y1, z1 = coords1&#10;                    x2, y2, z2 = coords2&#10;&#10;                    # Validate coordinates&#10;                    if not all(isinstance(val, (int, float)) for val in [x1, y1, z1, x2, y2, z2]):&#10;                        debug_print(f&quot;Non-numeric coordinates for member {member_id}&quot;)&#10;                        continue&#10;&#10;                    # Project to 2D&#10;                    p1x, p1y = self.project_3d_to_2d(x1, y1, z1)&#10;                    p2x, p2y = self.project_3d_to_2d(x2, y2, z2)&#10;&#10;                    # Determine line properties&#10;                    if member_id == self.selected_member:&#10;                        color = QColor(255, 0, 0)  # Red for selected&#10;                        width = 3&#10;                    else:&#10;                        color = self.section_colors.get(section, QColor(0, 0, 0))&#10;                        width = 2 if section == 1 else 1&#10;&#10;                    # Create pen&#10;                    pen = QPen(color)&#10;                    pen.setWidth(width)&#10;&#10;                    # Add line&#10;                    line_item = self.scene.addLine(p1x, p1y, p2x, p2y, pen)&#10;&#10;                    # Add member ID at midpoint&#10;                    mid_x = (p1x + p2x) / 2&#10;                    mid_y = (p1y + p2y) / 2&#10;&#10;                    text_item = self.scene.addText(str(member_id))&#10;                    text_item.setPos(mid_x, mid_y)&#10;                    text_item.setDefaultTextColor(QColor(100, 100, 100))  # Gray text&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error drawing member {member.get('id')}: {str(e)}&quot;)&#10;                    continue&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in draw_members: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def draw_supports(self):&#10;        &quot;&quot;&quot;Draw support indicators&quot;&quot;&quot;&#10;        debug_print(&quot;Drawing supports&quot;)&#10;        try:&#10;            for support in self.supports:&#10;                try:&#10;                    node_id = support.get('node')&#10;&#10;                    if node_id is None:&#10;                        debug_print(f&quot;Support missing node reference: {support}&quot;)&#10;                        continue&#10;&#10;                    # Skip if node doesn't exist&#10;                    if node_id not in self.nodes:&#10;                        debug_print(f&quot;Support references non-existent node: {node_id}&quot;)&#10;                        continue&#10;&#10;                    coords = self.nodes[node_id]&#10;                    if len(coords) != 3:&#10;                        debug_print(f&quot;Invalid coordinates for node {node_id}: {coords}&quot;)&#10;                        continue&#10;&#10;                    # Get node position&#10;                    x, y, z = coords&#10;&#10;                    # Validate coordinates&#10;                    if not all(isinstance(val, (int, float)) for val in [x, y, z]):&#10;                        debug_print(f&quot;Non-numeric coordinates for node {node_id}&quot;)&#10;                        continue&#10;&#10;                    # Project to 2D&#10;                    proj_x, proj_y = self.project_3d_to_2d(x, y, z)&#10;&#10;                    # Determine support type&#10;                    is_fixed = support.get('ux') == 1 and support.get('uy') == 1 and support.get('uz') == 1&#10;&#10;                    if is_fixed:&#10;                        # Draw triangle for fixed support&#10;                        triangle_path = QPainterPath()&#10;                        triangle_path.moveTo(proj_x, proj_y + 10)&#10;                        triangle_path.lineTo(proj_x - 10, proj_y + 20)&#10;                        triangle_path.lineTo(proj_x + 10, proj_y + 20)&#10;                        triangle_path.closeSubpath()&#10;&#10;                        self.scene.addPath(triangle_path, QPen(QColor(255, 0, 0)), QBrush(QColor(255, 0, 0)))&#10;                    else:&#10;                        # Draw circle for other support&#10;                        self.scene.addEllipse(&#10;                            proj_x - 6, proj_y + 10, 12, 12,&#10;                            QPen(QColor(255, 100, 0)), QBrush(QColor(255, 100, 0))&#10;                        )&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error drawing support for node {support.get('node')}: {str(e)}&quot;)&#10;                    continue&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in draw_supports: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;    def resetView(self):&#10;        &quot;&quot;&quot;Reset the view to default position&quot;&quot;&quot;&#10;        debug_print(&quot;Resetting view&quot;)&#10;        try:&#10;            self.resetTransform()&#10;            self.recenter_view()&#10;            self.update_scene()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in resetView: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;&#10;&#10;class StairwayInteractiveEditor(QMainWindow):&#10;    &quot;&quot;&quot;Main application window&quot;&quot;&quot;&#10;&#10;    def __init__(self, json_file):&#10;        super().__init__()&#10;        try:&#10;            debug_print(f&quot;Initializing editor with file: {json_file}&quot;)&#10;            self.json_file = json_file&#10;            self.stairway_data = None&#10;            self.current_mode = &quot;view&quot;&#10;&#10;            # Create the structure view&#10;            self.structure_view = StructureView()&#10;&#10;            # Initialize data&#10;            self.load_data()&#10;&#10;            # Set up UI&#10;            self.init_ui()&#10;&#10;            # Update view with structure data&#10;            debug_print(&quot;Setting initial structure data to view&quot;)&#10;            self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;&#10;            # Connect signals&#10;            self.structure_view.nodeSelected.connect(self.on_node_selected)&#10;            self.structure_view.memberSelected.connect(self.on_member_selected)&#10;&#10;            # Setup mode state for member editing&#10;            self.member_creation_nodes = []&#10;&#10;            debug_print(&quot;Editor initialization complete&quot;)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error initializing editor: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;            QMessageBox.critical(self, &quot;Initialization Error&quot;,&#10;                               f&quot;Failed to initialize application: {str(e)}&quot;)&#10;&#10;    def init_ui(self):&#10;        &quot;&quot;&quot;Initialize the user interface&quot;&quot;&quot;&#10;        self.setWindowTitle(f&quot;Stairway Structure Editor - {os.path.basename(self.json_file)}&quot;)&#10;        self.setGeometry(100, 100, 1400, 900)&#10;&#10;        # Central widget&#10;        central_widget = QWidget()&#10;        self.setCentralWidget(central_widget)&#10;&#10;        # Main layout&#10;        main_layout = QHBoxLayout()&#10;        central_widget.setLayout(main_layout)&#10;&#10;        # Left panel - controls&#10;        left_panel = self.create_left_panel()&#10;        main_layout.addWidget(left_panel, 1)&#10;&#10;        # Center - structure view (already created in __init__)&#10;        main_layout.addWidget(self.structure_view, 4)&#10;&#10;        # Right panel - properties&#10;        right_panel = self.create_right_panel()&#10;        main_layout.addWidget(right_panel, 1)&#10;&#10;    def create_left_panel(self):&#10;        &quot;&quot;&quot;Create the left control panel&quot;&quot;&quot;&#10;        debug_print(&quot;Creating left panel&quot;)&#10;        panel = QWidget()&#10;        layout = QVBoxLayout()&#10;        panel.setLayout(layout)&#10;&#10;        # Mode selection&#10;        mode_group = QGroupBox(&quot;Edit Mode&quot;)&#10;        mode_layout = QVBoxLayout()&#10;        mode_group.setLayout(mode_layout)&#10;&#10;        self.mode_buttons = QButtonGroup()&#10;        modes = [&quot;View&quot;, &quot;Move Node&quot;, &quot;Add Node&quot;, &quot;Add Member&quot;, &quot;Delete Node&quot;, &quot;Delete Member&quot;, &quot;Edit Member&quot;]&#10;        for i, mode in enumerate(modes):&#10;            radio = QRadioButton(mode)&#10;            mode_layout.addWidget(radio)&#10;            self.mode_buttons.addButton(radio, i)&#10;            if i == 0:&#10;                radio.setChecked(True)&#10;&#10;        self.mode_buttons.buttonClicked.connect(self.on_mode_changed)&#10;        layout.addWidget(mode_group)&#10;&#10;        # Section selection for new members&#10;        section_group = QGroupBox(&quot;Member Section&quot;)&#10;        section_layout = QVBoxLayout()&#10;        section_group.setLayout(section_layout)&#10;&#10;        self.section_combo = QComboBox()&#10;        self.section_combo.addItems([f&quot;Section {i}&quot; for i in range(1, 6)])&#10;        section_layout.addWidget(self.section_combo)&#10;        layout.addWidget(section_group)&#10;&#10;        # Material selection&#10;        material_group = QGroupBox(&quot;Member Material&quot;)&#10;        material_layout = QVBoxLayout()&#10;        material_group.setLayout(material_layout)&#10;&#10;        self.material_combo = QComboBox()&#10;        self.material_combo.addItems([f&quot;Material {i}&quot; for i in range(1, 4)])&#10;        material_layout.addWidget(self.material_combo)&#10;        layout.addWidget(material_group)&#10;&#10;        # Action buttons&#10;        self.save_button = QPushButton(&quot;Save Structure&quot;)&#10;        self.save_button.clicked.connect(self.save_structure)&#10;        layout.addWidget(self.save_button)&#10;&#10;        self.reset_view_button = QPushButton(&quot;Reset View&quot;)&#10;        self.reset_view_button.clicked.connect(self.structure_view.resetView)&#10;        layout.addWidget(self.reset_view_button)&#10;&#10;        # Display options&#10;        display_group = QGroupBox(&quot;Display Options&quot;)&#10;        display_layout = QVBoxLayout()&#10;        display_group.setLayout(display_layout)&#10;&#10;        self.show_nodes_cb = QCheckBox(&quot;Show Node IDs&quot;)&#10;        self.show_nodes_cb.setChecked(True)&#10;        self.show_nodes_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_nodes_cb)&#10;&#10;        self.show_members_cb = QCheckBox(&quot;Show Member IDs&quot;)&#10;        self.show_members_cb.setChecked(True)&#10;        self.show_members_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_members_cb)&#10;&#10;        # Add checkbox for coordinate axes&#10;        self.show_axes_cb = QCheckBox(&quot;Show Coordinate Axes&quot;)&#10;        self.show_axes_cb.setChecked(True)&#10;        self.show_axes_cb.stateChanged.connect(self.update_display_options)&#10;        display_layout.addWidget(self.show_axes_cb)&#10;&#10;        layout.addWidget(display_group)&#10;&#10;        # Info text&#10;        self.info_text = QTextEdit()&#10;        self.info_text.setReadOnly(True)&#10;        self.info_text.setMaximumHeight(200)&#10;        layout.addWidget(self.info_text)&#10;&#10;        layout.addStretch()&#10;&#10;        return panel&#10;&#10;    def create_right_panel(self):&#10;        &quot;&quot;&quot;Create the right properties panel&quot;&quot;&quot;&#10;        debug_print(&quot;Creating right panel&quot;)&#10;        panel = QWidget()&#10;        layout = QVBoxLayout()&#10;        panel.setLayout(layout)&#10;&#10;        # Node properties&#10;        self.node_group = QGroupBox(&quot;Node Properties&quot;)&#10;        node_layout = QVBoxLayout()&#10;        self.node_group.setLayout(node_layout)&#10;&#10;        # Node ID&#10;        node_id_layout = QHBoxLayout()&#10;        node_id_layout.addWidget(QLabel(&quot;ID:&quot;))&#10;        self.node_id_label = QLabel(&quot;-&quot;)&#10;        node_id_layout.addWidget(self.node_id_label)&#10;        node_id_layout.addStretch()&#10;        node_layout.addLayout(node_id_layout)&#10;&#10;        # Node coordinates&#10;        self.node_x_spin = QDoubleSpinBox()&#10;        self.node_x_spin.setRange(-1000, 1000)&#10;        self.node_x_spin.setSingleStep(0.1)&#10;        self.node_x_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        self.node_y_spin = QDoubleSpinBox()&#10;        self.node_y_spin.setRange(-1000, 1000)&#10;        self.node_y_spin.setSingleStep(0.1)&#10;        self.node_y_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        self.node_z_spin = QDoubleSpinBox()&#10;        self.node_z_spin.setRange(-1000, 1000)&#10;        self.node_z_spin.setSingleStep(0.1)&#10;        self.node_z_spin.valueChanged.connect(self.update_node_position)&#10;&#10;        coord_layout = QVBoxLayout()&#10;        for label, spin in [(&quot;X:&quot;, self.node_x_spin), (&quot;Y:&quot;, self.node_y_spin), (&quot;Z:&quot;, self.node_z_spin)]:&#10;            row = QHBoxLayout()&#10;            row.addWidget(QLabel(label))&#10;            row.addWidget(spin)&#10;            coord_layout.addLayout(row)&#10;&#10;        node_layout.addLayout(coord_layout)&#10;        self.node_group.setEnabled(False)&#10;        layout.addWidget(self.node_group)&#10;&#10;        # Member properties&#10;        self.member_group = QGroupBox(&quot;Member Properties&quot;)&#10;        member_layout = QVBoxLayout()&#10;        self.member_group.setLayout(member_layout)&#10;&#10;        # Member ID&#10;        member_id_layout = QHBoxLayout()&#10;        member_id_layout.addWidget(QLabel(&quot;ID:&quot;))&#10;        self.member_id_label = QLabel(&quot;-&quot;)&#10;        member_id_layout.addWidget(self.member_id_label)&#10;        member_id_layout.addStretch()&#10;        member_layout.addLayout(member_id_layout)&#10;&#10;        # Member nodes&#10;        nodes_layout = QHBoxLayout()&#10;        nodes_layout.addWidget(QLabel(&quot;Nodes:&quot;))&#10;        self.member_nodes_label = QLabel(&quot;-&quot;)&#10;        nodes_layout.addWidget(self.member_nodes_label)&#10;        nodes_layout.addStretch()&#10;        member_layout.addLayout(nodes_layout)&#10;&#10;        # Member section&#10;        self.member_section_combo = QComboBox()&#10;        self.member_section_combo.addItems([f&quot;Section {i}&quot; for i in range(1, 6)])&#10;        self.member_section_combo.currentIndexChanged.connect(self.update_member_properties)&#10;&#10;        section_layout = QHBoxLayout()&#10;        section_layout.addWidget(QLabel(&quot;Section:&quot;))&#10;        section_layout.addWidget(self.member_section_combo)&#10;        member_layout.addLayout(section_layout)&#10;&#10;        # Member material&#10;        self.member_material_combo = QComboBox()&#10;        self.member_material_combo.addItems([f&quot;Material {i}&quot; for i in range(1, 4)])&#10;        self.member_material_combo.currentIndexChanged.connect(self.update_member_properties)&#10;&#10;        material_layout = QHBoxLayout()&#10;        material_layout.addWidget(QLabel(&quot;Material:&quot;))&#10;        material_layout.addWidget(self.member_material_combo)&#10;        member_layout.addLayout(material_layout)&#10;&#10;        # Change nodes button&#10;        self.change_nodes_button = QPushButton(&quot;Change Connected Nodes&quot;)&#10;        self.change_nodes_button.clicked.connect(self.start_change_member_nodes)&#10;        member_layout.addWidget(self.change_nodes_button)&#10;&#10;        self.member_group.setEnabled(False)&#10;        layout.addWidget(self.member_group)&#10;&#10;        # Structure tree&#10;        tree_group = QGroupBox(&quot;Structure Tree&quot;)&#10;        tree_layout = QVBoxLayout()&#10;        tree_group.setLayout(tree_layout)&#10;&#10;        self.structure_tree = QTreeWidget()&#10;        self.structure_tree.setHeaderLabels([&quot;Element&quot;, &quot;Type&quot;, &quot;Properties&quot;])&#10;        tree_layout.addWidget(self.structure_tree)&#10;        self.populate_structure_tree()&#10;&#10;        layout.addWidget(tree_group)&#10;&#10;        layout.addStretch()&#10;&#10;        return panel&#10;&#10;    def populate_structure_tree(self):&#10;        &quot;&quot;&quot;Populate the structure tree with nodes and members&quot;&quot;&quot;&#10;        debug_print(&quot;Populating structure tree&quot;)&#10;        try:&#10;            self.structure_tree.clear()&#10;&#10;            # Add nodes&#10;            nodes_item = QTreeWidgetItem([&quot;Nodes&quot;, f&quot;{len(self.nodes)}&quot;, &quot;&quot;])&#10;            self.structure_tree.addTopLevelItem(nodes_item)&#10;&#10;            # Add members grouped by section&#10;            sections = {}&#10;            for member in self.members:&#10;                section = member.get('section', 0)&#10;                if section not in sections:&#10;                    sections[section] = []&#10;                sections[section].append(member)&#10;&#10;            for section, members in sections.items():&#10;                section_item = QTreeWidgetItem([f&quot;Section {section}&quot;, f&quot;{len(members)} members&quot;, &quot;&quot;])&#10;                self.structure_tree.addTopLevelItem(section_item)&#10;&#10;            self.structure_tree.expandAll()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error populating structure tree: {str(e)}&quot;)&#10;&#10;    def load_data(self):&#10;        &quot;&quot;&quot;Load structure data from JSON file&quot;&quot;&quot;&#10;        debug_print(f&quot;Loading structure from {self.json_file}&quot;)&#10;&#10;        try:&#10;            with open(self.json_file, 'r') as file:&#10;                json_str = &quot;&quot;&#10;                for line in file:&#10;                    if '//' not in line:&#10;                        json_str += line&#10;&#10;                self.stairway_data = json.loads(json_str)&#10;&#10;            # Extract data&#10;            self.nodes = self.stairway_data.get('nodes', [])&#10;            self.supports = self.stairway_data.get('supports', [])&#10;            self.members = self.stairway_data.get('members', [])&#10;            self.materials = self.stairway_data.get('materials', [])&#10;            self.sections = self.stairway_data.get('sections', [])&#10;&#10;            # Create node dictionary&#10;            self.node_dict = {}&#10;            for node in self.nodes:&#10;                try:&#10;                    node_id = node.get('id')&#10;                    if node_id is None:&#10;                        continue&#10;&#10;                    # Extract and convert coordinates&#10;                    x_str = node.get('x', '0 ft')&#10;                    y_str = node.get('y', '0 ft')&#10;                    z_str = node.get('z', '0 ft')&#10;&#10;                    # Handle different format strings&#10;                    try:&#10;                        x = float(x_str.split()[0])&#10;                        y = float(y_str.split()[0])&#10;                        z = float(z_str.split()[0])&#10;                    except (ValueError, IndexError):&#10;                        debug_print(f&quot;Error parsing coordinates for node {node_id}: {x_str}, {y_str}, {z_str}&quot;)&#10;                        continue&#10;&#10;                    self.node_dict[node_id] = (x, y, z)&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error processing node: {str(e)}&quot;)&#10;                    continue&#10;&#10;            # Create connections map&#10;            self.node_connections = {node_id: [] for node_id in self.node_dict}&#10;            for member in self.members:&#10;                try:&#10;                    i_node = member.get('i_node')&#10;                    j_node = member.get('j_node')&#10;                    member_id = member.get('id')&#10;&#10;                    if None in (i_node, j_node, member_id):&#10;                        debug_print(f&quot;Incomplete member data: {member}&quot;)&#10;                        continue&#10;&#10;                    if i_node in self.node_connections:&#10;                        self.node_connections[i_node].append(member_id)&#10;                    if j_node in self.node_connections:&#10;                        self.node_connections[j_node].append(member_id)&#10;                except Exception as e:&#10;                    debug_print(f&quot;Error processing member connection: {str(e)}&quot;)&#10;                    continue&#10;&#10;            debug_print(f&quot;Loaded {len(self.nodes)} nodes, {len(self.members)} members&quot;)&#10;&#10;        except Exception as e:&#10;            debug_print(f&quot;Error loading file: {str(e)}&quot;)&#10;            traceback.print_exc()&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Failed to load file: {str(e)}&quot;)&#10;            sys.exit(1)&#10;&#10;    def update_display_options(self):&#10;        &quot;&quot;&quot;Update display options&quot;&quot;&quot;&#10;        try:&#10;            debug_print(&quot;Updating display options&quot;)&#10;            # Update the display options in the view&#10;            self.structure_view.show_axes = self.show_axes_cb.isChecked()&#10;            self.structure_view.update_scene()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating display options: {str(e)}&quot;)&#10;&#10;    def on_mode_changed(self, button):&#10;        &quot;&quot;&quot;Handle mode change&quot;&quot;&quot;&#10;        try:&#10;            mode_index = self.mode_buttons.id(button)&#10;            modes = [&quot;view&quot;, &quot;move&quot;, &quot;add_node&quot;, &quot;add_member&quot;, &quot;delete_node&quot;, &quot;delete_member&quot;, &quot;edit_member&quot;]&#10;            self.current_mode = modes[mode_index]&#10;            debug_print(f&quot;Mode changed to: {self.current_mode}&quot;)&#10;&#10;            # Reset state when changing modes&#10;            if self.current_mode == &quot;add_member&quot;:&#10;                self.member_creation_nodes = []&#10;&#10;            # Update UI based on mode&#10;            if self.current_mode == &quot;move&quot;:&#10;                self.node_group.setEnabled(self.structure_view.selected_node is not None)&#10;                self.member_group.setEnabled(False)&#10;            elif self.current_mode == &quot;edit_member&quot;:&#10;                self.node_group.setEnabled(False)&#10;                self.member_group.setEnabled(self.structure_view.selected_member is not None)&#10;            else:&#10;                self.node_group.setEnabled(False)&#10;                self.member_group.setEnabled(False)&#10;&#10;            self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error changing mode: {str(e)}&quot;)&#10;&#10;    def on_node_selected(self, node_id):&#10;        &quot;&quot;&quot;Handle node selection&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Node {node_id} selected&quot;)&#10;&#10;            # Handle node selection for add_member mode&#10;            if self.current_mode == &quot;add_member&quot;:&#10;                if node_id in self.member_creation_nodes:&#10;                    debug_print(f&quot;Node {node_id} already selected&quot;)&#10;                    return&#10;&#10;                self.member_creation_nodes.append(node_id)&#10;                debug_print(f&quot;Added node {node_id} to member creation (nodes: {self.member_creation_nodes})&quot;)&#10;&#10;                if len(self.member_creation_nodes) == 2:&#10;                    self.create_member(self.member_creation_nodes[0], self.member_creation_nodes[1])&#10;                    self.member_creation_nodes = []&#10;&#10;                self.update_info_text()&#10;                return&#10;&#10;            # Ensure node exists in dictionary&#10;            if node_id not in self.node_dict:&#10;                debug_print(f&quot;Selected node {node_id} not found in node dictionary&quot;)&#10;                return&#10;&#10;            # Update node properties panel&#10;            self.node_id_label.setText(str(node_id))&#10;            x, y, z = self.node_dict[node_id]&#10;&#10;            # Block signals to prevent recursive updates&#10;            self.node_x_spin.blockSignals(True)&#10;            self.node_y_spin.blockSignals(True)&#10;            self.node_z_spin.blockSignals(True)&#10;&#10;            self.node_x_spin.setValue(x)&#10;            self.node_y_spin.setValue(y)&#10;            self.node_z_spin.setValue(z)&#10;&#10;            self.node_x_spin.blockSignals(False)&#10;            self.node_y_spin.blockSignals(False)&#10;            self.node_z_spin.blockSignals(False)&#10;&#10;            # Enable/disable panels based on mode&#10;            if self.current_mode == &quot;move&quot;:&#10;                self.node_group.setEnabled(True)&#10;            elif self.current_mode == &quot;delete_node&quot;:&#10;                self.delete_node(node_id)&#10;&#10;            self.member_group.setEnabled(False)&#10;            self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in node selection: {str(e)}&quot;)&#10;&#10;    def on_member_selected(self, member_id):&#10;        &quot;&quot;&quot;Handle member selection&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Member {member_id} selected&quot;)&#10;&#10;            if self.current_mode == &quot;delete_member&quot;:&#10;                self.delete_member(member_id)&#10;                return&#10;&#10;            # Find member data&#10;            member = next((m for m in self.members if m.get('id') == member_id), None)&#10;            if not member:&#10;                debug_print(f&quot;Member {member_id} not found in members list&quot;)&#10;                return&#10;&#10;            # Update member properties panel&#10;            self.member_id_label.setText(str(member_id))&#10;            i_node = member.get('i_node', '-')&#10;            j_node = member.get('j_node', '-')&#10;            self.member_nodes_label.setText(f&quot;{i_node} - {j_node}&quot;)&#10;&#10;            # Block signals&#10;            self.member_section_combo.blockSignals(True)&#10;            self.member_material_combo.blockSignals(True)&#10;&#10;            # Update combo box selections&#10;            section = member.get('section', 1)&#10;            material = member.get('material', 1)&#10;            self.member_section_combo.setCurrentIndex(section - 1)&#10;            self.member_material_combo.setCurrentIndex(material - 1)&#10;&#10;            self.member_section_combo.blockSignals(False)&#10;            self.member_material_combo.blockSignals(False)&#10;&#10;            # Enable/disable panels based on mode&#10;            self.node_group.setEnabled(False)&#10;            if self.current_mode == &quot;edit_member&quot;:&#10;                self.member_group.setEnabled(True)&#10;&#10;            self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in member selection: {str(e)}&quot;)&#10;&#10;    def update_node_position(self):&#10;        &quot;&quot;&quot;Update selected node position from spinboxes&quot;&quot;&quot;&#10;        try:&#10;            if not self.structure_view.selected_node:&#10;                return&#10;&#10;            node_id = self.structure_view.selected_node&#10;            x = self.node_x_spin.value()&#10;            y = self.node_y_spin.value()&#10;            z = self.node_z_spin.value()&#10;&#10;            # Update internal data&#10;            self.node_dict[node_id] = (x, y, z)&#10;&#10;            # Update node in list&#10;            for node in self.nodes:&#10;                if node.get('id') == node_id:&#10;                    node['x'] = f&quot;{x} ft&quot;&#10;                    node['y'] = f&quot;{y} ft&quot;&#10;                    node['z'] = f&quot;{z} ft&quot;&#10;                    break&#10;&#10;            # Update view&#10;            self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating node position: {str(e)}&quot;)&#10;&#10;    def update_member_properties(self):&#10;        &quot;&quot;&quot;Update selected member properties&quot;&quot;&quot;&#10;        try:&#10;            if not self.structure_view.selected_member:&#10;                return&#10;&#10;            member_id = self.structure_view.selected_member&#10;&#10;            # Find member&#10;            for member in self.members:&#10;                if member.get('id') == member_id:&#10;                    member['section'] = self.member_section_combo.currentIndex() + 1&#10;                    member['material'] = self.member_material_combo.currentIndex() + 1&#10;                    break&#10;&#10;            # Update view&#10;            self.structure_view.update_scene()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating member properties: {str(e)}&quot;)&#10;&#10;    def start_change_member_nodes(self):&#10;        &quot;&quot;&quot;Start process to change member's connected nodes&quot;&quot;&quot;&#10;        try:&#10;            if not self.structure_view.selected_member:&#10;                return&#10;&#10;            # Switch to special mode for changing member nodes&#10;            self.current_mode = &quot;change_member_nodes&quot;&#10;            self.member_creation_nodes = []&#10;&#10;            QMessageBox.information(self, &quot;Change Nodes&quot;,&#10;                                  &quot;Select two nodes to reconnect the member&quot;)&#10;            self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error starting member node change: {str(e)}&quot;)&#10;&#10;    def update_member_nodes(self, member_id, new_i_node, new_j_node):&#10;        &quot;&quot;&quot;Update a member's connected nodes&quot;&quot;&quot;&#10;        try:&#10;            member = next((m for m in self.members if m.get('id') == member_id), None)&#10;            if not member:&#10;                return&#10;&#10;            old_i_node = member.get('i_node')&#10;            old_j_node = member.get('j_node')&#10;&#10;            # Remove member from old node connections&#10;            if old_i_node in self.node_connections and member_id in self.node_connections[old_i_node]:&#10;                self.node_connections[old_i_node].remove(member_id)&#10;&#10;            if old_j_node in self.node_connections and member_id in self.node_connections[old_j_node]:&#10;                self.node_connections[old_j_node].remove(member_id)&#10;&#10;            # Update member endpoints&#10;            member['i_node'] = new_i_node&#10;            member['j_node'] = new_j_node&#10;&#10;            # Add to new node connections&#10;            if new_i_node not in self.node_connections:&#10;                self.node_connections[new_i_node] = []&#10;            self.node_connections[new_i_node].append(member_id)&#10;&#10;            if new_j_node not in self.node_connections:&#10;                self.node_connections[new_j_node] = []&#10;            self.node_connections[new_j_node].append(member_id)&#10;&#10;            # Update view&#10;            self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating member nodes: {str(e)}&quot;)&#10;&#10;    def create_member(self, node1, node2):&#10;        &quot;&quot;&quot;Create a new member between two nodes&quot;&quot;&quot;&#10;        try:&#10;            section = self.section_combo.currentIndex() + 1&#10;            material = self.material_combo.currentIndex() + 1&#10;&#10;            # Get next member ID&#10;            member_ids = [m.get('id', 0) for m in self.members]&#10;            next_id = max(member_ids, default=0) + 1&#10;&#10;            # Create new member&#10;            new_member = {&#10;                'id': next_id,&#10;                'i_node': node1,&#10;                'j_node': node2,&#10;                'section': section,&#10;                'material': material&#10;            }&#10;&#10;            debug_print(f&quot;Creating member {next_id} between nodes {node1}-{node2}&quot;)&#10;&#10;            # Add to data structures&#10;            self.members.append(new_member)&#10;&#10;            # Update connections&#10;            if node1 not in self.node_connections:&#10;                self.node_connections[node1] = []&#10;            self.node_connections[node1].append(next_id)&#10;&#10;            if node2 not in self.node_connections:&#10;                self.node_connections[node2] = []&#10;            self.node_connections[node2].append(next_id)&#10;&#10;            # Update view&#10;            self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;            self.populate_structure_tree()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error creating member: {str(e)}&quot;)&#10;&#10;    def delete_node(self, node_id):&#10;        &quot;&quot;&quot;Delete a node and its connected members&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Deleting node {node_id}&quot;)&#10;&#10;            # Get connected members&#10;            connected_members = self.node_connections.get(node_id, [])[:]&#10;&#10;            # Delete connected members&#10;            if connected_members:&#10;                for member_id in connected_members:&#10;                    self.delete_member(member_id, update_viz=False)&#10;&#10;            # Delete node&#10;            self.nodes = [n for n in self.nodes if n.get('id') != node_id]&#10;            if node_id in self.node_dict:&#10;                del self.node_dict[node_id]&#10;            if node_id in self.node_connections:&#10;                del self.node_connections[node_id]&#10;&#10;            # Update view&#10;            self.structure_view.selected_node = None&#10;            self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;            self.populate_structure_tree()&#10;            self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error deleting node: {str(e)}&quot;)&#10;&#10;    def delete_member(self, member_id, update_viz=True):&#10;        &quot;&quot;&quot;Delete a member&quot;&quot;&quot;&#10;        try:&#10;            debug_print(f&quot;Deleting member {member_id}&quot;)&#10;&#10;            # Find member&#10;            member = next((m for m in self.members if m.get('id') == member_id), None)&#10;            if not member:&#10;                return&#10;&#10;            # Remove from connections&#10;            i_node = member.get('i_node')&#10;            j_node = member.get('j_node')&#10;&#10;            if i_node in self.node_connections and member_id in self.node_connections[i_node]:&#10;                self.node_connections[i_node].remove(member_id)&#10;&#10;            if j_node in self.node_connections and member_id in self.node_connections[j_node]:&#10;                self.node_connections[j_node].remove(member_id)&#10;&#10;            # Remove from list&#10;            self.members = [m for m in self.members if m.get('id') != member_id]&#10;&#10;            # Update visualization if requested&#10;            if update_viz:&#10;                self.structure_view.selected_member = None&#10;                self.structure_view.setStructureData(self.node_dict, self.members, self.supports)&#10;                self.populate_structure_tree()&#10;                self.update_info_text()&#10;        except Exception as e:&#10;            debug_print(f&quot;Error deleting member: {str(e)}&quot;)&#10;&#10;    def update_info_text(self):&#10;        &quot;&quot;&quot;Update information text&quot;&quot;&quot;&#10;        try:&#10;            info = f&quot;Mode: {self.current_mode.replace('_', ' ').title()}\n\n&quot;&#10;&#10;            if self.current_mode == &quot;add_member&quot;:&#10;                info += f&quot;Select nodes to create a member.\n&quot;&#10;                info += f&quot;Selected nodes: {len(self.member_creation_nodes)}/2\n\n&quot;&#10;            elif self.current_mode == &quot;change_member_nodes&quot;:&#10;                info += f&quot;Select nodes to reconnect member {self.structure_view.selected_member}.\n&quot;&#10;                info += f&quot;Selected nodes: {len(self.member_creation_nodes)}/2\n\n&quot;&#10;&#10;            if self.structure_view.selected_node:&#10;                node_id = self.structure_view.selected_node&#10;                if node_id in self.node_dict:&#10;                    x, y, z = self.node_dict[node_id]&#10;                    info += f&quot;Selected Node: {node_id}\n&quot;&#10;                    info += f&quot;Position: ({x:.2f}, {y:.2f}, {z:.2f})\n&quot;&#10;                    info += f&quot;Connected Members: {len(self.node_connections.get(node_id, []))}\n&quot;&#10;&#10;            elif self.structure_view.selected_member:&#10;                member = next((m for m in self.members if m.get('id') == self.structure_view.selected_member), None)&#10;                if member:&#10;                    info += f&quot;Selected Member: {member.get('id')}\n&quot;&#10;                    info += f&quot;Nodes: {member.get('i_node')} - {member.get('j_node')}\n&quot;&#10;                    info += f&quot;Section: {member.get('section')}, Material: {member.get('material')}\n&quot;&#10;&#10;                    # Calculate length if both nodes exist&#10;                    i_node = member.get('i_node')&#10;                    j_node = member.get('j_node')&#10;                    if i_node in self.node_dict and j_node in self.node_dict:&#10;                        i_pos = self.node_dict[i_node]&#10;                        j_pos = self.node_dict[j_node]&#10;                        # Use math.sqrt instead of sp.sqrt&#10;                        length = math.sqrt(sum((j_pos[i] - i_pos[i])**2 for i in range(3)))&#10;                        info += f&quot;Length: {length:.2f} ft\n&quot;&#10;&#10;            self.info_text.setText(info)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error updating info text: {str(e)}&quot;)&#10;&#10;    def save_structure(self):&#10;        &quot;&quot;&quot;Save structure to JSON file&quot;&quot;&quot;&#10;        try:&#10;            # Update structure data&#10;            self.stairway_data['nodes'] = self.nodes&#10;            self.stairway_data['members'] = self.members&#10;&#10;            # Generate filename&#10;            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')&#10;            base_name = os.path.splitext(self.json_file)[0]&#10;            output_file = f&quot;{base_name}_edited_{timestamp}.json&quot;&#10;&#10;            try:&#10;                with open(output_file, 'w') as f:&#10;                    json.dump(self.stairway_data, f, indent=4)&#10;                QMessageBox.information(self, &quot;Success&quot;, f&quot;Structure saved to {output_file}&quot;)&#10;                debug_print(f&quot;Saved structure to {output_file}&quot;)&#10;            except Exception as e:&#10;                QMessageBox.critical(self, &quot;Error&quot;, f&quot;Failed to save: {str(e)}&quot;)&#10;                debug_print(f&quot;Error saving: {str(e)}&quot;)&#10;        except Exception as e:&#10;            debug_print(f&quot;Error in save_structure: {str(e)}&quot;)&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main entry point&quot;&quot;&quot;&#10;    try:&#10;        # Direct console output to stderr for debugging&#10;        sys.stdout.flush()&#10;&#10;        debug_print(f&quot;Starting application with Python {sys.version}&quot;)&#10;&#10;        # Create QApplication&#10;        app = QApplication(sys.argv)&#10;&#10;        # Get JSON file&#10;        if len(sys.argv) &gt; 1:&#10;            json_file = sys.argv[1]&#10;        else:&#10;            json_file = &quot;stairway_structure.json&quot;&#10;            if not os.path.exists(json_file):&#10;                # Try to find any JSON file&#10;                json_files = [f for f in os.listdir('.') if f.endswith('.json')]&#10;                if json_files:&#10;                    json_file = json_files[0]&#10;                else:&#10;                    debug_print(&quot;No JSON files found&quot;)&#10;                    QMessageBox.critical(None, &quot;Error&quot;, &quot;No JSON files found in the current directory&quot;)&#10;                    sys.exit(1)&#10;&#10;        # Create and show main window with exception handling&#10;        editor = StairwayInteractiveEditor(json_file)&#10;        editor.show()&#10;        debug_print(&quot;Application started successfully&quot;)&#10;&#10;        # Set up a timer to periodically flush stdout&#10;        flush_timer = QTimer()&#10;        flush_timer.timeout.connect(lambda: sys.stdout.flush())&#10;        flush_timer.start(1000)  # Flush every second&#10;&#10;        sys.exit(app.exec_())&#10;    except Exception as e:&#10;        debug_print(f&quot;Fatal error in main: {str(e)}&quot;)&#10;        traceback.print_exc()&#10;&#10;        # Try to show error message to user&#10;        try:&#10;            app = QApplication.instance() or QApplication(sys.argv)&#10;            error_msg = QMessageBox()&#10;            error_msg.setIcon(QMessageBox.Critical)&#10;            error_msg.setWindowTitle(&quot;Fatal Error&quot;)&#10;            error_msg.setText(&quot;The application has encountered a critical error and needs to close.&quot;)&#10;            error_msg.setDetailedText(f&quot;Error: {str(e)}\n\n{traceback.format_exc()}&quot;)&#10;            error_msg.exec_()&#10;        except:&#10;            pass&#10;&#10;        sys.exit(1)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/sections.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/sections.yml" />
              <option name="originalContent" value="# Standard W-shapes (Wide Flange)&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 1&#10;  name: &quot;W12x26&quot;&#10;  area: 7.65 in**2&#10;  Ixx: 204 in**4&#10;  Iyy: 54.1 in**4&#10;  Zx: 38.6 in**3&#10;  Zy: 11.8 in**3&#10;&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 2&#10;  name: &quot;W8x31&quot;&#10;  area: 9.13 in**2&#10;  Ixx: 110 in**4&#10;  Iyy: 37.1 in**4&#10;  Zx: 30.4 in**3&#10;  Zy: 11.5 in**3&#10;&#10;# HSS (Hollow Structural Sections)&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 3&#10;  name: &quot;HSS6x6x3/8&quot;&#10;  area: 7.58 in**2&#10;  Ixx: 37.4 in**4&#10;  Iyy: 37.4 in**4&#10;  Zx: 12.5 in**3&#10;  Zy: 12.5 in**3&#10;&#10;# Angle sections&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 4&#10;  name: &quot;L4x4x1/2&quot;&#10;  area: 3.75 in**2&#10;  Ixx: 5.56 in**4&#10;  Iyy: 5.56 in**4&#10;  Zx: 1.98 in**3&#10;  Zy: 1.98 in**3&#10;&#10;# Round HSS (pipe)&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 5&#10;  name: &quot;HSS5.563x0.258&quot;&#10;  area: 4.3 in**2&#10;  Ixx: 14.1 in**4&#10;  Iyy: 14.1 in**4&#10;  Zx: 5.08 in**3&#10;  Zy: 5.08 in**3&#10;&#10;# Channel sections&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 6&#10;  name: &quot;C10x15.3&quot;&#10;  area: 4.49 in**2&#10;  Ixx: 67.4 in**4&#10;  Iyy: 2.28 in**4&#10;  Zx: 13.5 in**3&#10;  Zy: 0.89 in**3" />
              <option name="updatedContent" value="# Standard W-shapes (Wide Flange)&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 1&#10;  name: &quot;W12x26&quot;&#10;  area: 7.65 in**2&#10;  Ixx: 204 in**4&#10;  Iyy: 54.1 in**4&#10;  Zx: 38.6 in**3&#10;  Zy: 11.8 in**3&#10;&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 2&#10;  name: &quot;W8x31&quot;&#10;  area: 9.13 in**2&#10;  Ixx: 110 in**4&#10;  Iyy: 37.1 in**4&#10;  Zx: 30.4 in**3&#10;  Zy: 11.5 in**3&#10;&#10;# HSS (Hollow Structural Sections)&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 3&#10;  name: &quot;HSS6x6x3/8&quot;&#10;  area: 7.58 in**2&#10;  Ixx: 37.4 in**4&#10;  Iyy: 37.4 in**4&#10;  Zx: 12.5 in**3&#10;  Zy: 12.5 in**3&#10;&#10;# Angle sections&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 4&#10;  name: &quot;L4x4x1/2&quot;&#10;  area: 3.75 in**2&#10;  Ixx: 5.56 in**4&#10;  Iyy: 5.56 in**4&#10;  Zx: 1.98 in**3&#10;  Zy: 1.98 in**3&#10;&#10;# Round HSS (pipe)&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 5&#10;  name: &quot;HSS5.563x0.258&quot;&#10;  area: 4.3 in**2&#10;  Ixx: 14.1 in**4&#10;  Iyy: 14.1 in**4&#10;  Zx: 5.08 in**3&#10;  Zy: 5.08 in**3&#10;&#10;# Channel sections&#10;- !!python/object:pyMAOS.pymaos_sections.Section&#10;  uid: 6&#10;  name: &quot;C10x15.3&quot;&#10;  area: 4.49 in**2&#10;  Ixx: 67.4 in**4&#10;  Iyy: 2.28 in**4&#10;  Zx: 13.5 in**3&#10;  Zy: 0.89 in**3" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ifc/JSON_to_IFC.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ifc/JSON_to_IFC.py" />
              <option name="originalContent" value="import json&#10;import uuid&#10;import sys&#10;import os&#10;import datetime&#10;import ifcopenshell&#10;import ifcopenshell.geom&#10;import ifcopenshell.api&#10;import scipy as sp&#10;import math&#10;import traceback&#10;from ifcopenshell.util import representation&#10;&#10;def debug_print(*args, **kwargs):&#10;    &quot;&quot;&quot;Helper function for debug printing&quot;&quot;&quot;&#10;    print(*args, **kwargs)&#10;    sys.stdout.flush()&#10;&#10;def create_guid():&#10;    &quot;&quot;&quot;Create a GUID for IFC entities&quot;&quot;&quot;&#10;    return ifcopenshell.guid.compress(uuid.uuid4().hex)&#10;&#10;def convert_json_to_ifc(json_file):&#10;    &quot;&quot;&quot;Convert JSON structure to IFC format&quot;&quot;&quot;&#10;    debug_print(f&quot;Converting {json_file} to IFC&quot;)&#10;&#10;    # Read the JSON file&#10;    with open(json_file, 'r') as f:&#10;        data = json.load(f)&#10;&#10;    # Extract model name&#10;    model_name = data.get(&quot;design_parameters&quot;, {}).get(&quot;name&quot;, &quot;Structural Model&quot;)&#10;    author = data.get(&quot;design_parameters&quot;, {}).get(&quot;author&quot;, &quot;Converter&quot;)&#10;    description = data.get(&quot;design_parameters&quot;, {}).get(&quot;description&quot;, &quot;&quot;)&#10;&#10;    # Create a new IFC file&#10;    timestamp = datetime.datetime.now().strftime(&quot;%Y%m%dT%H%M%S&quot;)&#10;    filename = os.path.splitext(os.path.basename(json_file))[0]&#10;    ifc_file = ifcopenshell.file()&#10;&#10;    # Set up the IFC file header&#10;    debug_print(&quot;Setting up IFC header&quot;)&#10;    ifc_file.wrapped_data.header.file_name.name = f&quot;{filename}.ifc&quot;&#10;    ifc_file.wrapped_data.header.file_description.description = (description,)&#10;    ifc_file.wrapped_data.header.file_name.time_stamp = timestamp&#10;    ifc_file.wrapped_data.header.file_name.author = (author,)&#10;    ifc_file.wrapped_data.header.file_name.organization = (&quot;&quot;,)&#10;&#10;    # Create IFC project structure&#10;    debug_print(&quot;Creating project structure&quot;)&#10;    project = ifcopenshell.api.run(&quot;root.create_entity&quot;, ifc_file, ifc_class=&quot;IfcProject&quot;, name=model_name)&#10;&#10;    # Define units&#10;    length_unit = data.get(&quot;units&quot;, {}).get(&quot;length&quot;, &quot;ft&quot;)&#10;    force_unit = data.get(&quot;units&quot;, {}).get(&quot;force&quot;, &quot;kip&quot;)&#10;    pressure_unit = data.get(&quot;units&quot;, {}).get(&quot;pressure&quot;, &quot;ksi&quot;)&#10;&#10;    # Create units&#10;    debug_print(&quot;Setting up units&quot;)&#10;    unit_assignments = ifcopenshell.api.run(&quot;unit.assign_unit&quot;, ifc_file)&#10;&#10;    # Length unit - handle imperial units correctly&#10;    if length_unit == &quot;ft&quot;:&#10;        # Create a conversion-based unit for feet (1 foot = 0.3048 meters)&#10;        length_si_unit = ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file,&#10;                                            unit_type=&quot;LENGTHUNIT&quot;)&#10;        ifcopenshell.api.run(&quot;unit.add_conversion_based_unit&quot;, ifc_file,&#10;                           name=&quot;foot&quot;, unit_type=&quot;LENGTHUNIT&quot;,&#10;                           conversion_factor=0.3048, converted_unit=length_si_unit)&#10;    elif length_unit == &quot;in&quot;:&#10;        # Create a conversion-based unit for inches (1 inch = 0.0254 meters)&#10;        length_si_unit = ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file,&#10;                                            unit_type=&quot;LENGTHUNIT&quot;)&#10;        ifcopenshell.api.run(&quot;unit.add_conversion_based_unit&quot;, ifc_file,&#10;                           name=&quot;inch&quot;, unit_type=&quot;LENGTHUNIT&quot;,&#10;                           conversion_factor=0.0254, converted_unit=length_si_unit)&#10;    else:&#10;        # Default to meters&#10;        ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file, unit_type=&quot;LENGTHUNIT&quot;)&#10;&#10;    # Force unit - create appropriate conversion&#10;    if force_unit == &quot;kip&quot;:&#10;        # 1 kip = 4448.2216 newtons&#10;        force_si_unit = ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file,&#10;                                           unit_type=&quot;FORCEUNIT&quot;)&#10;        ifcopenshell.api.run(&quot;unit.add_conversion_based_unit&quot;, ifc_file,&#10;                           name=&quot;kip&quot;, unit_type=&quot;FORCEUNIT&quot;,&#10;                           conversion_factor=4448.2216, converted_unit=force_si_unit)&#10;    else:&#10;        # Default to newtons&#10;        ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file, unit_type=&quot;FORCEUNIT&quot;)&#10;&#10;    # Pressure unit - create appropriate conversion&#10;    if pressure_unit == &quot;ksi&quot;:&#10;        # 1 ksi = 6894757.2932 pascals&#10;        pressure_si_unit = ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file,&#10;                                              unit_type=&quot;PRESSUREUNIT&quot;)&#10;        ifcopenshell.api.run(&quot;unit.add_conversion_based_unit&quot;, ifc_file,&#10;                           name=&quot;ksi&quot;, unit_type=&quot;PRESSUREUNIT&quot;,&#10;                           conversion_factor=6894757.2932, converted_unit=pressure_si_unit)&#10;    else:&#10;        # Default to pascals&#10;        ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file, unit_type=&quot;PRESSUREUNIT&quot;)&#10;&#10;    # Create a site, building, and building story&#10;    site = ifcopenshell.api.run(&quot;root.create_entity&quot;, ifc_file,&#10;                              ifc_class=&quot;IfcSite&quot;, name=&quot;Site&quot;)&#10;    ifcopenshell.api.run(&quot;aggregate.assign_object&quot;, ifc_file,&#10;                       products=[site], relating_object=project)&#10;&#10;    building = ifcopenshell.api.run(&quot;root.create_entity&quot;, ifc_file,&#10;                                  ifc_class=&quot;IfcBuilding&quot;, name=&quot;Building&quot;)&#10;    ifcopenshell.api.run(&quot;aggregate.assign_object&quot;, ifc_file,&#10;                       products=[building], relating_object=site)&#10;&#10;    story = ifcopenshell.api.run(&quot;root.create_entity&quot;, ifc_file,&#10;                               ifc_class=&quot;IfcBuildingStorey&quot;, name=&quot;Story&quot;)&#10;    ifcopenshell.api.run(&quot;aggregate.assign_object&quot;, ifc_file,&#10;                       products=[story], relating_object=building)&#10;&#10;    # Create context for geometry representation&#10;    debug_print(&quot;Creating geometry context&quot;)&#10;    context = ifcopenshell.api.run(&quot;context.add_context&quot;, ifc_file,&#10;                                 context_type=&quot;Model&quot;)&#10;    body_context = ifcopenshell.api.run(&quot;context.add_context&quot;, ifc_file,&#10;                                      context_type=&quot;Model&quot;,&#10;                                      context_identifier=&quot;Body&quot;,&#10;                                      target_view=&quot;MODEL_VIEW&quot;,&#10;                                      parent=context)&#10;&#10;    # Create materials dictionary&#10;    debug_print(&quot;Creating materials&quot;)&#10;    materials_dict = {}&#10;    for material_data in data.get(&quot;materials&quot;, []):&#10;        material_id = material_data[&quot;id&quot;]&#10;        material_name = f&quot;Material_{material_id}&quot;&#10;&#10;        material = ifcopenshell.api.run(&quot;material.add_material&quot;, ifc_file,&#10;                                      name=material_name)&#10;&#10;        # Set material properties if available&#10;        if &quot;type&quot; in material_data:&#10;            if material_data[&quot;type&quot;] == &quot;isotropic&quot;:&#10;                try:&#10;                    # Create property set manually&#10;                    pset_name = &quot;Pset_MaterialMechanical&quot;&#10;                    young_modulus = float(material_data.get(&quot;E&quot;, 0))&#10;                    shear_modulus = float(material_data.get(&quot;G&quot;, 0))&#10;                    poisson_ratio = float(material_data.get(&quot;nu&quot;, 0))&#10;&#10;                    props = {&#10;                        &quot;YoungModulus&quot;: young_modulus,&#10;                        &quot;ShearModulus&quot;: shear_modulus,&#10;                        &quot;PoissonRatio&quot;: poisson_ratio&#10;                    }&#10;&#10;                    if &quot;rho&quot; in material_data:&#10;                        props[&quot;MassDensity&quot;] = float(material_data[&quot;rho&quot;])&#10;&#10;                    # Create property set manually&#10;                    pset = ifc_file.create_entity(&#10;                        &quot;IfcPropertySet&quot;,&#10;                        GlobalId=create_guid(),&#10;                        Name=pset_name,&#10;                        Description=f&quot;Material properties for {material_name}&quot;,&#10;                        HasProperties=[]&#10;                    )&#10;&#10;                    # Create and add properties to the property set&#10;                    for prop_name, prop_value in props.items():&#10;                        # Ensure value is a proper float&#10;                        if prop_value is not None:&#10;                            single_prop = ifc_file.create_entity(&#10;                                &quot;IfcPropertySingleValue&quot;,&#10;                                Name=prop_name,&#10;                                NominalValue=ifc_file.create_entity(&quot;IfcReal&quot;, prop_value)&#10;                            )&#10;                            pset.HasProperties = list(pset.HasProperties) + [single_prop]&#10;&#10;                    # Create material property relationship&#10;                    rel = ifc_file.create_entity(&#10;                        &quot;IfcRelDefinesByProperties&quot;,&#10;                        GlobalId=create_guid(),&#10;                        RelatedObjects=[material],&#10;                        RelatingPropertyDefinition=pset&#10;                    )&#10;&#10;                    debug_print(f&quot;Created material properties for {material_name}&quot;)&#10;                except Exception as e:&#10;                    debug_print(f&quot;Warning: Could not set material properties: {e}&quot;)&#10;                    pass&#10;&#10;        materials_dict[material_id] = material&#10;&#10;    # Create section profiles&#10;    debug_print(&quot;Creating section profiles&quot;)&#10;    section_dict = {}&#10;    for section_data in data.get(&quot;sections&quot;, []):&#10;        section_id = section_data[&quot;id&quot;]&#10;        area = float(section_data.get(&quot;area&quot;, 0))&#10;        radius = float(section_data.get(&quot;r&quot;, 0))&#10;&#10;        # For simplicity, we'll create circular profiles for all sections&#10;        # In a full implementation, you would determine the actual profile shape&#10;        profile = ifc_file.create_entity(&#10;            &quot;IfcCircleProfileDef&quot;,&#10;            ProfileType=&quot;AREA&quot;,&#10;            ProfileName=f&quot;Section_{section_id}&quot;,&#10;            Radius=radius&#10;        )&#10;&#10;        section_dict[section_id] = profile&#10;&#10;    # Create nodes&#10;    debug_print(&quot;Creating nodes&quot;)&#10;    node_dict = {}&#10;    for node_data in data.get(&quot;nodes&quot;, []):&#10;        node_id = node_data[&quot;id&quot;]&#10;        x = float(node_data[&quot;x&quot;])&#10;        y = float(node_data[&quot;y&quot;])&#10;        z = float(node_data[&quot;z&quot;])&#10;&#10;        # Create a cartesian point for each node&#10;        point = ifc_file.create_entity(&#10;            &quot;IfcCartesianPoint&quot;,&#10;            Coordinates=(x, y, z)&#10;        )&#10;&#10;        node_dict[node_id] = point&#10;&#10;    # Create members&#10;    debug_print(&quot;Creating structural members&quot;)&#10;    member_dict = {}&#10;    for member_data in data.get(&quot;members&quot;, []):&#10;        member_id = member_data[&quot;id&quot;]&#10;        i_node_id = member_data[&quot;i_node&quot;]&#10;        j_node_id = member_data[&quot;j_node&quot;]&#10;        material_id = member_data.get(&quot;material&quot;, 1)&#10;        section_id = member_data.get(&quot;section&quot;, 1)&#10;&#10;        # Get the start and end points&#10;        start_point = node_dict[i_node_id]&#10;        end_point = node_dict[j_node_id]&#10;&#10;        # Extract raw coordinates&#10;        start_coords = start_point.Coordinates&#10;        end_coords = end_point.Coordinates&#10;&#10;        # Create a properly formatted coordinate list - must be a list of lists of floats&#10;        coord_list = [[float(start_coords[0]), float(start_coords[1]), float(start_coords[2])],&#10;                      [float(end_coords[0]), float(end_coords[1]), float(end_coords[2])]]&#10;&#10;        # Create point list properly&#10;        point_list = ifc_file.create_entity(&#10;            &quot;IfcCartesianPointList3D&quot;,&#10;            CoordList=coord_list&#10;        )&#10;&#10;        # Create a polyline from the points&#10;        polyline = ifc_file.create_entity(&#10;            &quot;IfcPolyline&quot;,&#10;            Points=[start_point, end_point]&#10;        )&#10;&#10;        # Create extrusion profile&#10;        profile = section_dict.get(section_id)&#10;        if not profile:&#10;            profile = section_dict.get(1, section_dict[list(section_dict.keys())[0]])&#10;&#10;        # Calculate member length for extrusion&#10;        p1 = start_point.Coordinates&#10;        p2 = end_point.Coordinates&#10;        dx = p2[0] - p1[0]&#10;        dy = p2[1] - p1[1]&#10;        dz = p2[2] - p1[2]&#10;        length = math.sqrt(dx*dx + dy*dy + dz*dz)&#10;&#10;        # Create direction for extrusion&#10;        if length &gt; 0:&#10;            direction = ifc_file.create_entity(&#10;                &quot;IfcDirection&quot;,&#10;                DirectionRatios=(dx/length, dy/length, dz/length)&#10;            )&#10;        else:&#10;            direction = ifc_file.create_entity(&#10;                &quot;IfcDirection&quot;,&#10;                DirectionRatios=(0, 0, 1)&#10;            )&#10;&#10;        # Create axis placement&#10;        axis_placement = ifc_file.create_entity(&#10;            &quot;IfcAxis2Placement3D&quot;,&#10;            Location=start_point,&#10;            Axis=direction,&#10;            RefDirection=None&#10;        )&#10;&#10;        # Create swept solid representation&#10;        swept_area = ifc_file.create_entity(&#10;            &quot;IfcExtrudedAreaSolid&quot;,&#10;            SweptArea=profile,&#10;            Position=axis_placement,&#10;            ExtrudedDirection=direction,&#10;            Depth=length&#10;        )&#10;&#10;        # Create the shape representation&#10;        shape_representation = ifc_file.create_entity(&#10;            &quot;IfcShapeRepresentation&quot;,&#10;            ContextOfItems=body_context,&#10;            RepresentationIdentifier=&quot;Body&quot;,&#10;            RepresentationType=&quot;SweptSolid&quot;,&#10;            Items=[swept_area]&#10;        )&#10;&#10;        product_shape = ifc_file.create_entity(&#10;            &quot;IfcProductDefinitionShape&quot;,&#10;            Representations=[shape_representation]&#10;        )&#10;&#10;        # Create the actual beam&#10;        beam = ifc_file.create_entity(&#10;            &quot;IfcBeamStandardCase&quot;,&#10;            GlobalId=create_guid(),&#10;            Name=f&quot;Member_{member_id}&quot;,&#10;            Description=f&quot;Structural member connecting nodes {i_node_id} and {j_node_id}&quot;,&#10;            ObjectPlacement=None,  # Will be set below&#10;            Representation=product_shape&#10;        )&#10;&#10;        # Assign material&#10;        material = materials_dict.get(material_id)&#10;        if material:&#10;            material_association = ifc_file.create_entity(&#10;                &quot;IfcMaterialProfileSetUsage&quot;,&#10;                ForProfileSet=ifc_file.create_entity(&#10;                    &quot;IfcMaterialProfileSet&quot;,&#10;                    MaterialProfiles=[&#10;                        ifc_file.create_entity(&#10;                            &quot;IfcMaterialProfile&quot;,&#10;                            Name=f&quot;MP_{member_id}&quot;,&#10;                            Material=material,&#10;                            Profile=profile&#10;                        )&#10;                    ]&#10;                )&#10;            )&#10;            ifcopenshell.api.run(&quot;material.assign_material&quot;, ifc_file,&#10;                               products=[beam],&#10;                               material=material_association)&#10;&#10;        # Add beam to building story - using direct entity creation instead of API&#10;        # This replaces the spatial.assign_object API call which is missing&#10;        if hasattr(story, &quot;ContainsElements&quot;) and story.ContainsElements:&#10;            # Get existing relationship if it exists&#10;            rel = story.ContainsElements[0]&#10;            # Add this beam to the related elements&#10;            related_elements = list(rel.RelatedElements)&#10;            if beam not in related_elements:&#10;                related_elements.append(beam)&#10;                rel.RelatedElements = related_elements&#10;        else:&#10;            # Create a new relationship&#10;            rel = ifc_file.create_entity(&#10;                &quot;IfcRelContainedInSpatialStructure&quot;,&#10;                GlobalId=create_guid(),&#10;                OwnerHistory=None,&#10;                Name=f&quot;Rel {story.Name} - {beam.Name}&quot;,&#10;                Description=&quot;Spatial containment relationship&quot;,&#10;                RelatedElements=[beam],&#10;                RelatingStructure=story&#10;            )&#10;&#10;        member_dict[member_id] = beam&#10;&#10;    # Create supports&#10;    debug_print(&quot;Creating supports&quot;)&#10;    for support_data in data.get(&quot;supports&quot;, []):&#10;        node_id = support_data[&quot;node&quot;]&#10;        ux = support_data.get(&quot;ux&quot;, 0)&#10;        uy = support_data.get(&quot;uy&quot;, 0)&#10;        uz = support_data.get(&quot;uz&quot;, 0)&#10;        rx = support_data.get(&quot;rx&quot;, 0)&#10;        ry = support_data.get(&quot;ry&quot;, 0)&#10;        rz = support_data.get(&quot;rz&quot;, 0)&#10;&#10;        # Get the support point&#10;        point = node_dict.get(node_id)&#10;        if not point:&#10;            debug_print(f&quot;Warning: Node {node_id} for support not found&quot;)&#10;            continue&#10;&#10;        # Create a support representation (simplified as a small cube)&#10;        box = ifc_file.create_entity(&#10;            &quot;IfcBoundingBox&quot;,&#10;            Corner=point,&#10;            XDim=0.2,&#10;            YDim=0.2,&#10;            ZDim=0.2&#10;        )&#10;&#10;        shape_representation = ifc_file.create_entity(&#10;            &quot;IfcShapeRepresentation&quot;,&#10;            ContextOfItems=body_context,&#10;            RepresentationIdentifier=&quot;Body&quot;,&#10;            RepresentationType=&quot;BoundingBox&quot;,&#10;            Items=[box]&#10;        )&#10;&#10;        product_shape = ifc_file.create_entity(&#10;            &quot;IfcProductDefinitionShape&quot;,&#10;            Representations=[shape_representation]&#10;        )&#10;&#10;        # For boundary conditions, use IfcBoolean wrapper for fixed/free conditions&#10;        # True = Fixed (restrained), False = Free (unrestrained)&#10;        # Create the support as a structural point connection&#10;        support = ifc_file.create_entity(&#10;            &quot;IfcStructuralPointConnection&quot;,&#10;            GlobalId=create_guid(),&#10;            Name=f&quot;Support_{node_id}&quot;,&#10;            Description=f&quot;Support at node {node_id}&quot;,&#10;            ObjectPlacement=None,&#10;            Representation=product_shape,&#10;            AppliedCondition=ifc_file.create_entity(&#10;                &quot;IfcBoundaryNodeCondition&quot;,&#10;                Name=f&quot;Constraints_{node_id}&quot;,&#10;                TranslationalStiffnessX=bool(ux) if ux else None,&#10;                TranslationalStiffnessY=bool(uy) if uy else None,&#10;                TranslationalStiffnessZ=bool(uz) if uz else None,&#10;                RotationalStiffnessX=bool(rx) if rx else None,&#10;                RotationalStiffnessY=bool(ry) if ry else None,&#10;                RotationalStiffnessZ=bool(rz) if rz else None&#10;            )&#10;        )&#10;&#10;        # Add support to building story - using direct entity creation instead of API&#10;        # This replaces the spatial.assign_object API call which is missing&#10;        if hasattr(story, &quot;ContainsElements&quot;) and story.ContainsElements:&#10;            # Get existing relationship if it exists&#10;            rel = story.ContainsElements[0]&#10;            # Add this support to the related elements&#10;            related_elements = list(rel.RelatedElements)&#10;            if support not in related_elements:&#10;                related_elements.append(support)&#10;                rel.RelatedElements = related_elements&#10;        else:&#10;            # Create a new relationship&#10;            rel = ifc_file.create_entity(&#10;                &quot;IfcRelContainedInSpatialStructure&quot;,&#10;                GlobalId=create_guid(),&#10;                OwnerHistory=None,&#10;                Name=f&quot;Rel {story.Name} - {support.Name}&quot;,&#10;                Description=&quot;Spatial containment relationship&quot;,&#10;                RelatedElements=[support],&#10;                RelatingStructure=story&#10;            )&#10;&#10;    # Write the IFC file&#10;    output_file = os.path.splitext(json_file)[0] + &quot;.ifc&quot;&#10;    ifc_file.write(output_file)&#10;    debug_print(f&quot;IFC file saved as {output_file}&quot;)&#10;&#10;    return output_file&#10;&#10;def main():&#10;    if len(sys.argv) &lt; 2:&#10;        print(&quot;Usage: python json_to_ifc.py &lt;json_file&gt;&quot;)&#10;        return&#10;&#10;    json_file = sys.argv[1]&#10;    if not os.path.exists(json_file):&#10;        print(f&quot;Error: File {json_file} not found&quot;)&#10;        return&#10;&#10;    try:&#10;        ifc_file = convert_json_to_ifc(json_file)&#10;        print(f&quot;Successfully converted {json_file} to {ifc_file}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error converting file: {e}&quot;)&#10;        traceback.print_exc()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
              <option name="updatedContent" value="import json&#10;import uuid&#10;import sys&#10;import os&#10;import datetime&#10;import ifcopenshell&#10;import ifcopenshell.geom&#10;import ifcopenshell.api&#10;import scipy as sp&#10;import math&#10;import traceback&#10;from ifcopenshell.util import representation&#10;&#10;def debug_print(*args, **kwargs):&#10;    &quot;&quot;&quot;Helper function for debug printing&quot;&quot;&quot;&#10;    print(*args, **kwargs)&#10;    sys.stdout.flush()&#10;&#10;def create_guid():&#10;    &quot;&quot;&quot;Create a GUID for IFC entities&quot;&quot;&quot;&#10;    return ifcopenshell.guid.compress(uuid.uuid4().hex)&#10;&#10;def convert_json_to_ifc(json_file):&#10;    &quot;&quot;&quot;Convert JSON structure to IFC format&quot;&quot;&quot;&#10;    debug_print(f&quot;Converting {json_file} to IFC&quot;)&#10;&#10;    # Read the JSON file&#10;    with open(json_file, 'r') as f:&#10;        data = json.load(f)&#10;&#10;    # Extract model name&#10;    model_name = data.get(&quot;design_parameters&quot;, {}).get(&quot;name&quot;, &quot;Structural Model&quot;)&#10;    author = data.get(&quot;design_parameters&quot;, {}).get(&quot;author&quot;, &quot;Converter&quot;)&#10;    description = data.get(&quot;design_parameters&quot;, {}).get(&quot;description&quot;, &quot;&quot;)&#10;&#10;    # Create a new IFC file&#10;    timestamp = datetime.datetime.now().strftime(&quot;%Y%m%dT%H%M%S&quot;)&#10;    filename = os.path.splitext(os.path.basename(json_file))[0]&#10;    ifc_file = ifcopenshell.file()&#10;&#10;    # Set up the IFC file header&#10;    debug_print(&quot;Setting up IFC header&quot;)&#10;    ifc_file.wrapped_data.header.file_name.name = f&quot;{filename}.ifc&quot;&#10;    ifc_file.wrapped_data.header.file_description.description = (description,)&#10;    ifc_file.wrapped_data.header.file_name.time_stamp = timestamp&#10;    ifc_file.wrapped_data.header.file_name.author = (author,)&#10;    ifc_file.wrapped_data.header.file_name.organization = (&quot;&quot;,)&#10;&#10;    # Create IFC project structure&#10;    debug_print(&quot;Creating project structure&quot;)&#10;    project = ifcopenshell.api.run(&quot;root.create_entity&quot;, ifc_file, ifc_class=&quot;IfcProject&quot;, name=model_name)&#10;&#10;    # Define units&#10;    length_unit = data.get(&quot;units&quot;, {}).get(&quot;length&quot;, &quot;ft&quot;)&#10;    force_unit = data.get(&quot;units&quot;, {}).get(&quot;force&quot;, &quot;kip&quot;)&#10;    pressure_unit = data.get(&quot;units&quot;, {}).get(&quot;pressure&quot;, &quot;ksi&quot;)&#10;&#10;    # Create units&#10;    debug_print(&quot;Setting up units&quot;)&#10;    unit_assignments = ifcopenshell.api.run(&quot;unit.assign_unit&quot;, ifc_file)&#10;&#10;    # Length unit - handle imperial units correctly&#10;    if length_unit == &quot;ft&quot;:&#10;        # Create a conversion-based unit for feet (1 foot = 0.3048 meters)&#10;        length_si_unit = ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file,&#10;                                            unit_type=&quot;LENGTHUNIT&quot;)&#10;        ifcopenshell.api.run(&quot;unit.add_conversion_based_unit&quot;, ifc_file,&#10;                           name=&quot;foot&quot;, unit_type=&quot;LENGTHUNIT&quot;,&#10;                           conversion_factor=0.3048, converted_unit=length_si_unit)&#10;    elif length_unit == &quot;in&quot;:&#10;        # Create a conversion-based unit for inches (1 inch = 0.0254 meters)&#10;        length_si_unit = ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file,&#10;                                            unit_type=&quot;LENGTHUNIT&quot;)&#10;        ifcopenshell.api.run(&quot;unit.add_conversion_based_unit&quot;, ifc_file,&#10;                           name=&quot;inch&quot;, unit_type=&quot;LENGTHUNIT&quot;,&#10;                           conversion_factor=0.0254, converted_unit=length_si_unit)&#10;    else:&#10;        # Default to meters&#10;        ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file, unit_type=&quot;LENGTHUNIT&quot;)&#10;&#10;    # Force unit - create appropriate conversion&#10;    if force_unit == &quot;kip&quot;:&#10;        # 1 kip = 4448.2216 newtons&#10;        force_si_unit = ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file,&#10;                                           unit_type=&quot;FORCEUNIT&quot;)&#10;        ifcopenshell.api.run(&quot;unit.add_conversion_based_unit&quot;, ifc_file,&#10;                           name=&quot;kip&quot;, unit_type=&quot;FORCEUNIT&quot;,&#10;                           conversion_factor=4448.2216, converted_unit=force_si_unit)&#10;    else:&#10;        # Default to newtons&#10;        ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file, unit_type=&quot;FORCEUNIT&quot;)&#10;&#10;    # Pressure unit - create appropriate conversion&#10;    if pressure_unit == &quot;ksi&quot;:&#10;        # 1 ksi = 6894757.2932 pascals&#10;        pressure_si_unit = ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file,&#10;                                              unit_type=&quot;PRESSUREUNIT&quot;)&#10;        ifcopenshell.api.run(&quot;unit.add_conversion_based_unit&quot;, ifc_file,&#10;                           name=&quot;ksi&quot;, unit_type=&quot;PRESSUREUNIT&quot;,&#10;                           conversion_factor=6894757.2932, converted_unit=pressure_si_unit)&#10;    else:&#10;        # Default to pascals&#10;        ifcopenshell.api.run(&quot;unit.add_si_unit&quot;, ifc_file, unit_type=&quot;PRESSUREUNIT&quot;)&#10;&#10;    # Create a site, building, and building story&#10;    site = ifcopenshell.api.run(&quot;root.create_entity&quot;, ifc_file,&#10;                              ifc_class=&quot;IfcSite&quot;, name=&quot;Site&quot;)&#10;    ifcopenshell.api.run(&quot;aggregate.assign_object&quot;, ifc_file,&#10;                       products=[site], relating_object=project)&#10;&#10;    building = ifcopenshell.api.run(&quot;root.create_entity&quot;, ifc_file,&#10;                                  ifc_class=&quot;IfcBuilding&quot;, name=&quot;Building&quot;)&#10;    ifcopenshell.api.run(&quot;aggregate.assign_object&quot;, ifc_file,&#10;                       products=[building], relating_object=site)&#10;&#10;    story = ifcopenshell.api.run(&quot;root.create_entity&quot;, ifc_file,&#10;                               ifc_class=&quot;IfcBuildingStorey&quot;, name=&quot;Story&quot;)&#10;    ifcopenshell.api.run(&quot;aggregate.assign_object&quot;, ifc_file,&#10;                       products=[story], relating_object=building)&#10;&#10;    # Create context for geometry representation&#10;    debug_print(&quot;Creating geometry context&quot;)&#10;    context = ifcopenshell.api.run(&quot;context.add_context&quot;, ifc_file,&#10;                                 context_type=&quot;Model&quot;)&#10;    body_context = ifcopenshell.api.run(&quot;context.add_context&quot;, ifc_file,&#10;                                      context_type=&quot;Model&quot;,&#10;                                      context_identifier=&quot;Body&quot;,&#10;                                      target_view=&quot;MODEL_VIEW&quot;,&#10;                                      parent=context)&#10;&#10;    # Create materials dictionary&#10;    debug_print(&quot;Creating materials&quot;)&#10;    materials_dict = {}&#10;    for material_data in data.get(&quot;materials&quot;, []):&#10;        material_id = material_data[&quot;id&quot;]&#10;        material_name = f&quot;Material_{material_id}&quot;&#10;&#10;        material = ifcopenshell.api.run(&quot;material.add_material&quot;, ifc_file,&#10;                                      name=material_name)&#10;&#10;        # Set material properties if available&#10;        if &quot;type&quot; in material_data:&#10;            if material_data[&quot;type&quot;] == &quot;isotropic&quot;:&#10;                try:&#10;                    # Create property set manually&#10;                    pset_name = &quot;Pset_MaterialMechanical&quot;&#10;                    young_modulus = float(material_data.get(&quot;E&quot;, 0))&#10;                    shear_modulus = float(material_data.get(&quot;G&quot;, 0))&#10;                    poisson_ratio = float(material_data.get(&quot;nu&quot;, 0))&#10;&#10;                    props = {&#10;                        &quot;YoungModulus&quot;: young_modulus,&#10;                        &quot;ShearModulus&quot;: shear_modulus,&#10;                        &quot;PoissonRatio&quot;: poisson_ratio&#10;                    }&#10;&#10;                    if &quot;rho&quot; in material_data:&#10;                        props[&quot;MassDensity&quot;] = float(material_data[&quot;rho&quot;])&#10;&#10;                    # Create property set manually&#10;                    pset = ifc_file.create_entity(&#10;                        &quot;IfcPropertySet&quot;,&#10;                        GlobalId=create_guid(),&#10;                        Name=pset_name,&#10;                        Description=f&quot;Material properties for {material_name}&quot;,&#10;                        HasProperties=[]&#10;                    )&#10;&#10;                    # Create and add properties to the property set&#10;                    for prop_name, prop_value in props.items():&#10;                        # Ensure value is a proper float&#10;                        if prop_value is not None:&#10;                            single_prop = ifc_file.create_entity(&#10;                                &quot;IfcPropertySingleValue&quot;,&#10;                                Name=prop_name,&#10;                                NominalValue=ifc_file.create_entity(&quot;IfcReal&quot;, prop_value)&#10;                            )&#10;                            pset.HasProperties = list(pset.HasProperties) + [single_prop]&#10;&#10;                    # Create material property relationship&#10;                    rel = ifc_file.create_entity(&#10;                        &quot;IfcRelDefinesByProperties&quot;,&#10;                        GlobalId=create_guid(),&#10;                        RelatedObjects=[material],&#10;                        RelatingPropertyDefinition=pset&#10;                    )&#10;&#10;                    debug_print(f&quot;Created material properties for {material_name}&quot;)&#10;                except Exception as e:&#10;                    debug_print(f&quot;Warning: Could not set material properties: {e}&quot;)&#10;                    pass&#10;&#10;        materials_dict[material_id] = material&#10;&#10;    # Create section profiles&#10;    debug_print(&quot;Creating section profiles&quot;)&#10;    section_dict = {}&#10;    for section_data in data.get(&quot;sections&quot;, []):&#10;        section_id = section_data[&quot;id&quot;]&#10;        area = float(section_data.get(&quot;area&quot;, 0))&#10;        radius = float(section_data.get(&quot;r&quot;, 0))&#10;&#10;        # For simplicity, we'll create circular profiles for all sections&#10;        # In a full implementation, you would determine the actual profile shape&#10;        profile = ifc_file.create_entity(&#10;            &quot;IfcCircleProfileDef&quot;,&#10;            ProfileType=&quot;AREA&quot;,&#10;            ProfileName=f&quot;Section_{section_id}&quot;,&#10;            Radius=radius&#10;        )&#10;&#10;        section_dict[section_id] = profile&#10;&#10;    # Create nodes&#10;    debug_print(&quot;Creating nodes&quot;)&#10;    node_dict = {}&#10;    for node_data in data.get(&quot;nodes&quot;, []):&#10;        node_id = node_data[&quot;id&quot;]&#10;        x = float(node_data[&quot;x&quot;])&#10;        y = float(node_data[&quot;y&quot;])&#10;        z = float(node_data[&quot;z&quot;])&#10;&#10;        # Create a cartesian point for each node&#10;        point = ifc_file.create_entity(&#10;            &quot;IfcCartesianPoint&quot;,&#10;            Coordinates=(x, y, z)&#10;        )&#10;&#10;        node_dict[node_id] = point&#10;&#10;    # Create members&#10;    debug_print(&quot;Creating structural members&quot;)&#10;    member_dict = {}&#10;    for member_data in data.get(&quot;members&quot;, []):&#10;        member_id = member_data[&quot;id&quot;]&#10;        i_node_id = member_data[&quot;i_node&quot;]&#10;        j_node_id = member_data[&quot;j_node&quot;]&#10;        material_id = member_data.get(&quot;material&quot;, 1)&#10;        section_id = member_data.get(&quot;section&quot;, 1)&#10;&#10;        # Get the start and end points&#10;        start_point = node_dict[i_node_id]&#10;        end_point = node_dict[j_node_id]&#10;&#10;        # Extract raw coordinates&#10;        start_coords = start_point.Coordinates&#10;        end_coords = end_point.Coordinates&#10;&#10;        # Create a properly formatted coordinate list - must be a list of lists of floats&#10;        coord_list = [[float(start_coords[0]), float(start_coords[1]), float(start_coords[2])],&#10;                      [float(end_coords[0]), float(end_coords[1]), float(end_coords[2])]]&#10;&#10;        # Create point list properly&#10;        point_list = ifc_file.create_entity(&#10;            &quot;IfcCartesianPointList3D&quot;,&#10;            CoordList=coord_list&#10;        )&#10;&#10;        # Create a polyline from the points&#10;        polyline = ifc_file.create_entity(&#10;            &quot;IfcPolyline&quot;,&#10;            Points=[start_point, end_point]&#10;        )&#10;&#10;        # Create extrusion profile&#10;        profile = section_dict.get(section_id)&#10;        if not profile:&#10;            profile = section_dict.get(1, section_dict[list(section_dict.keys())[0]])&#10;&#10;        # Calculate member length for extrusion&#10;        p1 = start_point.Coordinates&#10;        p2 = end_point.Coordinates&#10;        dx = p2[0] - p1[0]&#10;        dy = p2[1] - p1[1]&#10;        dz = p2[2] - p1[2]&#10;        length = math.sqrt(dx*dx + dy*dy + dz*dz)&#10;&#10;        # Create direction for extrusion&#10;        if length &gt; 0:&#10;            direction = ifc_file.create_entity(&#10;                &quot;IfcDirection&quot;,&#10;                DirectionRatios=(dx/length, dy/length, dz/length)&#10;            )&#10;        else:&#10;            direction = ifc_file.create_entity(&#10;                &quot;IfcDirection&quot;,&#10;                DirectionRatios=(0, 0, 1)&#10;            )&#10;&#10;        # Create axis placement&#10;        axis_placement = ifc_file.create_entity(&#10;            &quot;IfcAxis2Placement3D&quot;,&#10;            Location=start_point,&#10;            Axis=direction,&#10;            RefDirection=None&#10;        )&#10;&#10;        # Create swept solid representation&#10;        swept_area = ifc_file.create_entity(&#10;            &quot;IfcExtrudedAreaSolid&quot;,&#10;            SweptArea=profile,&#10;            Position=axis_placement,&#10;            ExtrudedDirection=direction,&#10;            Depth=length&#10;        )&#10;&#10;        # Create the shape representation&#10;        shape_representation = ifc_file.create_entity(&#10;            &quot;IfcShapeRepresentation&quot;,&#10;            ContextOfItems=body_context,&#10;            RepresentationIdentifier=&quot;Body&quot;,&#10;            RepresentationType=&quot;SweptSolid&quot;,&#10;            Items=[swept_area]&#10;        )&#10;&#10;        product_shape = ifc_file.create_entity(&#10;            &quot;IfcProductDefinitionShape&quot;,&#10;            Representations=[shape_representation]&#10;        )&#10;&#10;        # Create the actual beam&#10;        beam = ifc_file.create_entity(&#10;            &quot;IfcBeamStandardCase&quot;,&#10;            GlobalId=create_guid(),&#10;            Name=f&quot;Member_{member_id}&quot;,&#10;            Description=f&quot;Structural member connecting nodes {i_node_id} and {j_node_id}&quot;,&#10;            ObjectPlacement=None,  # Will be set below&#10;            Representation=product_shape&#10;        )&#10;&#10;        # Assign material&#10;        material = materials_dict.get(material_id)&#10;        if material:&#10;            material_association = ifc_file.create_entity(&#10;                &quot;IfcMaterialProfileSetUsage&quot;,&#10;                ForProfileSet=ifc_file.create_entity(&#10;                    &quot;IfcMaterialProfileSet&quot;,&#10;                    MaterialProfiles=[&#10;                        ifc_file.create_entity(&#10;                            &quot;IfcMaterialProfile&quot;,&#10;                            Name=f&quot;MP_{member_id}&quot;,&#10;                            Material=material,&#10;                            Profile=profile&#10;                        )&#10;                    ]&#10;                )&#10;            )&#10;            ifcopenshell.api.run(&quot;material.assign_material&quot;, ifc_file,&#10;                               products=[beam],&#10;                               material=material_association)&#10;&#10;        # Add beam to building story - using direct entity creation instead of API&#10;        # This replaces the spatial.assign_object API call which is missing&#10;        if hasattr(story, &quot;ContainsElements&quot;) and story.ContainsElements:&#10;            # Get existing relationship if it exists&#10;            rel = story.ContainsElements[0]&#10;            # Add this beam to the related elements&#10;            related_elements = list(rel.RelatedElements)&#10;            if beam not in related_elements:&#10;                related_elements.append(beam)&#10;                rel.RelatedElements = related_elements&#10;        else:&#10;            # Create a new relationship&#10;            rel = ifc_file.create_entity(&#10;                &quot;IfcRelContainedInSpatialStructure&quot;,&#10;                GlobalId=create_guid(),&#10;                OwnerHistory=None,&#10;                Name=f&quot;Rel {story.Name} - {beam.Name}&quot;,&#10;                Description=&quot;Spatial containment relationship&quot;,&#10;                RelatedElements=[beam],&#10;                RelatingStructure=story&#10;            )&#10;&#10;        member_dict[member_id] = beam&#10;&#10;    # Create supports&#10;    debug_print(&quot;Creating supports&quot;)&#10;    for support_data in data.get(&quot;supports&quot;, []):&#10;        node_id = support_data[&quot;node&quot;]&#10;        ux = support_data.get(&quot;ux&quot;, 0)&#10;        uy = support_data.get(&quot;uy&quot;, 0)&#10;        uz = support_data.get(&quot;uz&quot;, 0)&#10;        rx = support_data.get(&quot;rx&quot;, 0)&#10;        ry = support_data.get(&quot;ry&quot;, 0)&#10;        rz = support_data.get(&quot;rz&quot;, 0)&#10;&#10;        # Get the support point&#10;        point = node_dict.get(node_id)&#10;        if not point:&#10;            debug_print(f&quot;Warning: Node {node_id} for support not found&quot;)&#10;            continue&#10;&#10;        # Create a support representation (simplified as a small cube)&#10;        box = ifc_file.create_entity(&#10;            &quot;IfcBoundingBox&quot;,&#10;            Corner=point,&#10;            XDim=0.2,&#10;            YDim=0.2,&#10;            ZDim=0.2&#10;        )&#10;&#10;        shape_representation = ifc_file.create_entity(&#10;            &quot;IfcShapeRepresentation&quot;,&#10;            ContextOfItems=body_context,&#10;            RepresentationIdentifier=&quot;Body&quot;,&#10;            RepresentationType=&quot;BoundingBox&quot;,&#10;            Items=[box]&#10;        )&#10;&#10;        product_shape = ifc_file.create_entity(&#10;            &quot;IfcProductDefinitionShape&quot;,&#10;            Representations=[shape_representation]&#10;        )&#10;&#10;        # Create boundary condition values&#10;        # For IFC, we need to create IfcBoolean entities or use numeric stiffness values&#10;        # Using a very high stiffness value for fixed conditions, None for free&#10;        very_high_stiffness = 1e10  # Very high stiffness to simulate fixed condition&#10;        &#10;        # Helper function to create stiffness value&#10;        def create_stiffness_value(is_fixed):&#10;            if is_fixed:&#10;                # Return a very high stiffness value for fixed condition&#10;                return ifc_file.create_entity(&quot;IfcLinearStiffnessMeasure&quot;, very_high_stiffness)&#10;            else:&#10;                # Return None for free condition&#10;                return None&#10;&#10;        # Create the support as a structural point connection&#10;        support = ifc_file.create_entity(&#10;            &quot;IfcStructuralPointConnection&quot;,&#10;            GlobalId=create_guid(),&#10;            Name=f&quot;Support_{node_id}&quot;,&#10;            Description=f&quot;Support at node {node_id}&quot;,&#10;            ObjectPlacement=None,&#10;            Representation=product_shape,&#10;            AppliedCondition=ifc_file.create_entity(&#10;                &quot;IfcBoundaryNodeCondition&quot;,&#10;                Name=f&quot;Constraints_{node_id}&quot;,&#10;                TranslationalStiffnessX=create_stiffness_value(ux),&#10;                TranslationalStiffnessY=create_stiffness_value(uy),&#10;                TranslationalStiffnessZ=create_stiffness_value(uz),&#10;                RotationalStiffnessX=ifc_file.create_entity(&quot;IfcRotationalStiffnessMeasure&quot;, very_high_stiffness) if rx else None,&#10;                RotationalStiffnessY=ifc_file.create_entity(&quot;IfcRotationalStiffnessMeasure&quot;, very_high_stiffness) if ry else None,&#10;                RotationalStiffnessZ=ifc_file.create_entity(&quot;IfcRotationalStiffnessMeasure&quot;, very_high_stiffness) if rz else None&#10;            )&#10;        )&#10;&#10;        # Add support to building story - using direct entity creation instead of API&#10;        # This replaces the spatial.assign_object API call which is missing&#10;        if hasattr(story, &quot;ContainsElements&quot;) and story.ContainsElements:&#10;            # Get existing relationship if it exists&#10;            rel = story.ContainsElements[0]&#10;            # Add this support to the related elements&#10;            related_elements = list(rel.RelatedElements)&#10;            if support not in related_elements:&#10;                related_elements.append(support)&#10;                rel.RelatedElements = related_elements&#10;        else:&#10;            # Create a new relationship&#10;            rel = ifc_file.create_entity(&#10;                &quot;IfcRelContainedInSpatialStructure&quot;,&#10;                GlobalId=create_guid(),&#10;                OwnerHistory=None,&#10;                Name=f&quot;Rel {story.Name} - {support.Name}&quot;,&#10;                Description=&quot;Spatial containment relationship&quot;,&#10;                RelatedElements=[support],&#10;                RelatingStructure=story&#10;            )&#10;&#10;    # Write the IFC file&#10;    output_file = os.path.splitext(json_file)[0] + &quot;.ifc&quot;&#10;    ifc_file.write(output_file)&#10;    debug_print(f&quot;IFC file saved as {output_file}&quot;)&#10;&#10;    return output_file&#10;&#10;def main():&#10;    if len(sys.argv) &lt; 2:&#10;        print(&quot;Usage: python json_to_ifc.py &lt;json_file&gt;&quot;)&#10;        return&#10;&#10;    json_file = sys.argv[1]&#10;    if not os.path.exists(json_file):&#10;        print(f&quot;Error: File {json_file} not found&quot;)&#10;        return&#10;&#10;    try:&#10;        ifc_file = convert_json_to_ifc(json_file)&#10;        print(f&quot;Successfully converted {json_file} to {ifc_file}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error converting file: {e}&quot;)&#10;        traceback.print_exc()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/loading/point_loads.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/loading/point_loads.py" />
              <option name="originalContent" value="import pint&#10;from typing import TYPE_CHECKING, Any&#10;from pyMAOS.loading.piecewisePolinomial import PiecewisePolynomial&#10;from pprint import pprint&#10;from display_utils import print_quantity_nested_list&#10;import pyMAOS&#10;# Use TYPE_CHECKING to avoid runtime imports&#10;if TYPE_CHECKING:&#10;    from pyMAOS.frame2d import R2Frame&#10;&#10;class R2_Load_Base:&#10;    &quot;&quot;&quot;Base class for point loads and moments in R2 frames.&quot;&quot;&quot;&#10;&#10;    def __init__(self, a, member, loadcase=&quot;D&quot;):&#10;        &quot;&quot;&quot;Initialize common attributes for all loads.&quot;&quot;&quot;&#10;        self.a = a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.I = member.section.Ixx&#10;        self.EI = self.E * self.I&#10;&#10;        self.loadcase = loadcase&#10;&#10;        # These will be initialized in the child classes&#10;        self.Vy = None&#10;        self.Mz = None&#10;        self.Sz = None&#10;        self.Dy = None&#10;&#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Filter out NaN values before finding min/max&#10;        valid_indices = []&#10;        valid_y_values = []&#10;        for i, y in enumerate(y_values):&#10;            # Check if y is NaN (including Quantity objects with NaN magnitude)&#10;            is_nan = False&#10;            if hasattr(y, 'magnitude'):&#10;                is_nan = np.isnan(y.magnitude)&#10;            else:&#10;                is_nan = np.isnan(y) if isinstance(y, (int, float)) else False&#10;&#10;            if not is_nan:&#10;                valid_indices.append(i)&#10;                valid_y_values.append(y)&#10;&#10;        # If no valid values, skip plotting&#10;        if len(valid_y_values) == 0:&#10;            print(&quot;No valid data points to plot (all values are NaN)&quot;)&#10;            return&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(valid_y_values)&#10;        max_y = max(valid_y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;        range_y = max_y - min_y&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Skip NaN values&#10;            if hasattr(y, 'magnitude'):&#10;                if np.isnan(y.magnitude):&#10;                    continue&#10;            elif isinstance(y, (int, float)) and np.isnan(y):&#10;                continue&#10;&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart - avoid NaN issues&#10;            try:&#10;                y_normalized = (y - min_y) / range_y&#10;                y_pos = height - 1 - int(y_normalized * (height - 1))&#10;                y_pos = min(height - 1, max(0, y_pos))&#10;                chart[y_pos][x_pos] = '*'&#10;            except (ValueError, TypeError, ZeroDivisionError) as e:&#10;                print(f&quot;Warning: Could not plot point at x={x}, y={y}: {e}&quot;)&#10;                continue&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        print(f&quot;Region boundaries: [0, {self.a:.2f}, {self.L:.2f}]&quot;)&#10;&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of the load response with ASCII charts.&#10;        This should be implemented by each child class.&#10;        &quot;&quot;&quot;&#10;        raise NotImplementedError(&quot;Subclasses must implement print_detailed_analysis&quot;)&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;String representation should be implemented by each child class.&quot;&quot;&quot;&#10;        raise NotImplementedError(&quot;Subclasses must implement __str__&quot;)&#10;&#10;class R2_Point_Moment:&#10;    def __init__(self, M: pint.Quantity, a: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        &quot;&quot;&quot;&#10;        Parameters&#10;        ----------&#10;        M : FLOAT&#10;            Applied moment, counter-clockwise positive.&#10;        a : FLOAT&#10;            Point of application of moment as measured from the member left end.&#10;        member : Element Class&#10;            the member that the load is applied to.&#10;        loadcase : STRING, optional&#10;            String representation of the applied load type, this&#10;            data is used for load cases and combindations. The default is &quot;D&quot;.&#10;        &quot;&quot;&quot;&#10;        self.M = M&#10;        self.a = a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.I = member.section.Ixx&#10;&#10;        self.EI = self.E * self.I&#10;&#10;        self.kind = &quot;MOMENT&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Constants of Integration&#10;        self.integration_constants()&#10;&#10;        # Simple End Reactions&#10;        self.Riy = self.M / self.L&#10;        self.Rjy = -1 * self.Riy&#10;&#10;        # Piecewise Functions&#10;        # [co....cn x^n] [xa, xb]&#10;&#10;        Vy = [[[self.Riy], [0, self.a]], [[self.Riy], [self.a, self.L]]]&#10;        pprint(Vy)&#10;        Mz = [&#10;            [[0, self.Riy], [0, self.a]],&#10;            [[-1 * self.M, self.Riy], [self.a, self.L]],&#10;        ]&#10;        pprint(Mz)&#10;        Sz = [&#10;            [[self.c1 / self.EI, 0, self.Riy / (2 * self.EI)], [0, self.a]],&#10;            [&#10;                [&#10;                    self.c2 / self.EI,&#10;                    -1 * self.M / self.EI,&#10;                    self.Riy / (2 * self.EI),&#10;                ],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        pprint(Sz)&#10;        Dy = [&#10;            [&#10;                [&#10;                    self.c3 / self.EI,&#10;                    self.c1 / self.EI,&#10;                    0,&#10;                    self.Riy / (6 * self.EI),&#10;                ],&#10;                [0, self.a],&#10;            ],&#10;            [&#10;                [&#10;                    self.c4 / self.EI,&#10;                    self.c2 / self.EI,&#10;                    -1 * self.M / (2 * self.EI),&#10;                    self.Riy / (6 * self.EI),&#10;                ],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        pprint(Dy)&#10;        self.Wx = PiecewisePolynomial()  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        self.Ax = PiecewisePolynomial()&#10;        self.Dx = PiecewisePolynomial()&#10;        self.Vy = PiecewisePolynomial(Vy)&#10;        self.Mz = PiecewisePolynomial(Mz)&#10;        self.Sz = PiecewisePolynomial(Sz)&#10;        self.Dy = PiecewisePolynomial(Dy)&#10;&#10;    def integration_constants(self):&#10;        M = self.M&#10;        a = self.a&#10;        L = self.L&#10;&#10;        # Constants of Integration&#10;        self.c1 = ((3 * M * a * a) - (6 * L * M * a) + (2 * L * L * M)) / (6 * L)&#10;        self.c2 = ((3 * M * a * a) + (2 * L * L * M)) / (6 * L)&#10;        self.c3 = 0&#10;        self.c4 = -1 / 2 * M * a * a&#10;&#10;    def FEF(self):&#10;        &quot;&quot;&quot;&#10;        Compute and return the fixed and forces&#10;        &quot;&quot;&quot;&#10;        M = self.M&#10;        a = self.a&#10;        L = self.L&#10;&#10;        Miz = -1 * (M * (a - L) * ((3 * a) - L)) / (L * L)&#10;        Mjz = -1 * (M * a * (3 * a - 2 * L)) / (L * L)&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = 0 * unit_manager.ureg(Riy.units)&#10;&#10;        return [zero_force, Riy, Miz, zero_force, Rjy, Mjz]&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of the point moment response with ASCII charts.&#10;&#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;        from pyMAOS import unit_manager&#10;&#10;        print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        print(f&quot;Point moment of {self.M:.3f} at x={self.a:.3f}&quot;)&#10;        print(f&quot;Member length: {self.L:.3f}&quot;)&#10;        print(f&quot;Vertical reactions: Riy = {self.Riy:.3f}, Rjy = {self.Rjy:.3f}&quot;)&#10;&#10;        # Define regions for before and after the moment point&#10;        regions = [(0, self.a), (self.a, self.L)]&#10;        region_names = [&quot;Before Moment [0 to a]&quot;, &quot;After Moment [a to L]&quot;]&#10;&#10;        # Create sampling points for each region&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;&#10;        # Calculate function values&#10;        vy_values = [self.Vy.evaluate(x) for x in all_x]&#10;        mz_values = [self.Mz.evaluate(x) for x in all_x]&#10;        sz_values = [self.Sz.evaluate(x) for x in all_x]&#10;        dy_values = [self.Dy.evaluate(x) for x in all_x]&#10;&#10;        # Print ASCII charts&#10;        self._print_ascii_chart(&quot;Shear Force (Vy)&quot;, all_x, vy_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Bending Moment (Mz)&quot;, all_x, mz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Rotation (Sz)&quot;, all_x, sz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Deflection (Dy)&quot;, all_x, dy_values, regions, chart_width, chart_height)&#10;&#10;        # Print table of values at key points&#10;        print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;        print(f&quot;{'Position':15} {'Shear':15} {'Moment':15} {'Rotation':15} {'Deflection':15}&quot;)&#10;        print(&quot;-&quot; * 75)&#10;        for x in [0, self.a, self.L]:&#10;            print(f&quot;{x:15.3f} {self.Vy.evaluate(x):15.3f} {self.Mz.evaluate(x):15.3f} {self.Sz.evaluate(x):15.3e} {self.Dy.evaluate(x):15.3e}&quot;)&#10;&#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Filter out NaN values before finding min/max&#10;        valid_indices = []&#10;        valid_y_values = []&#10;        for i, y in enumerate(y_values):&#10;            # Check if y is NaN (including Quantity objects with NaN magnitude)&#10;            is_nan = False&#10;            if hasattr(y, 'magnitude'):&#10;                is_nan = np.isnan(y.magnitude)&#10;            else:&#10;                is_nan = np.isnan(y) if isinstance(y, (int, float)) else False&#10;&#10;            if not is_nan:&#10;                valid_indices.append(i)&#10;                valid_y_values.append(y)&#10;&#10;        # If no valid values, skip plotting&#10;        if len(valid_y_values) == 0:&#10;            print(&quot;No valid data points to plot (all values are NaN)&quot;)&#10;            return&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(valid_y_values)&#10;        max_y = max(valid_y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;        range_y = max_y - min_y&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Skip NaN values&#10;            if hasattr(y, 'magnitude'):&#10;                if np.isnan(y.magnitude):&#10;                    continue&#10;            elif isinstance(y, (int, float)) and np.isnan(y):&#10;                continue&#10;&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart - avoid NaN issues&#10;            try:&#10;                y_normalized = (y - min_y) / range_y&#10;                y_pos = height - 1 - int(y_normalized * (height - 1))&#10;                y_pos = min(height - 1, max(0, y_pos))&#10;                chart[y_pos][x_pos] = '*'&#10;            except (ValueError, TypeError, ZeroDivisionError) as e:&#10;                print(f&quot;Warning: Could not plot point at x={x}, y={y}: {e}&quot;)&#10;                continue&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        print(f&quot;Region boundaries: [0, {self.a:.2f}, {self.L:.2f}]&quot;)&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of a point moment.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Point Moment ({self.loadcase}): &quot;&#10;                f&quot;M={self.M:.3f} at x={self.a:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;&#10;class R2_Point_Load:&#10;    def __init__(self, p: pint.Quantity, a: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        self.p = p&#10;        self.a = a&#10;        self.L = member.length&#10;&#10;        self.E = member.material.E&#10;        self.I = member.section.Ixx&#10;&#10;        self.EI = self.E * self.I&#10;&#10;        self.kind = &quot;POINT&quot;&#10;        self.loadcase = loadcase&#10;&#10;        # Constants of Integration&#10;        # self.integration_constants()&#10;        # p = self.p&#10;        # a = self.a&#10;        L = self.L&#10;        import inspect;&#10;        print(f&quot;{inspect.getfile(inspect.currentframe())}:{inspect.currentframe().f_lineno}&quot;)&#10;&#10;        from pyMAOS import INTERNAL_LENGTH_UNIT,INTERNAL_FORCE_UNIT,INTERNAL_MOMENT_UNIT&#10;        self.c1 = pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;        self.c2 = -1 * p * a&#10;        self.c3 = (p * a * (a - (2 * L)) * (a - L)) / (6 * L)&#10;        self.c4 = (p * a * ((a * a) + (2 * L * L))) / (6 * L)&#10;        self.c5 = pyMAOS.unit_manager.ureg.Quantity(0, f&quot;{pyMAOS.unit_manager.INTERNAL_FORCE_UNIT} * {pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}**3&quot;)&#10;        self.c6 = (-1 * p * a * a * a) / 6&#10;&#10;        # Simple End Reactions&#10;        self.Riy = self.p * ((self.a - self.L) / self.L)&#10;        self.Rjy = -1 * self.p * self.a * (1 / self.L)&#10;        print(f&quot;Riy: {self.Riy:.3f}, Rjy: {self.Rjy:.3f}&quot;)&#10;        # Piecewise Functions&#10;        # [co....cn x^n] [xa, xb]&#10;        Vy = [&#10;            [[self.Riy], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.Riy + self.p], [self.a, self.L]],&#10;        ]&#10;        print(&quot;Vy:&quot;); print_quantity_nested_list(Vy)&#10;        Mz = [&#10;            [[self.c1, self.Riy], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.c2, self.Riy + self.p], [self.a, self.L]],&#10;        ]&#10;        print(&quot;Mz:&quot;); print_quantity_nested_list(Mz)&#10;        Sz = [&#10;            [[self.c3, self.c1, self.Riy / 2], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.c4, self.c2, (self.Riy + self.p) / 2], [self.a, self.L]],&#10;        ]&#10;        Sz[0][0] = [i / self.EI for i in Sz[0][0]]&#10;        Sz[1][0] = [i / self.EI for i in Sz[1][0]]&#10;        print(&quot;Sz:&quot;); print_quantity_nested_list(Sz)&#10;        Dy = [&#10;            [[self.c5, self.c3, self.c1 / 2, self.Riy / 6], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [&#10;                [self.c6, self.c4, self.c2 / 2, (self.Riy + self.p) / 6],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        Dy[0][0] = [i / self.EI for i in Dy[0][0]]&#10;        Dy[1][0] = [i / self.EI for i in Dy[1][0]]&#10;        #print(Dy)&#10;        print(&quot;Dy:&quot;); print_quantity_nested_list(Dy, precision=2, width=20, simplify_units=True)&#10;&#10;        self.Wx = PiecewisePolynomial()&#10;        # print(self.Wx) # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        # print(self.Wy)&#10;        self.Ax = PiecewisePolynomial()&#10;        # print(self.Ax)&#10;        self.Dx = PiecewisePolynomial()&#10;        #print(self.Dx)&#10;        from pprint import pprint; pprint(Vy); self.Vy = PiecewisePolynomial(Vy)&#10;        print(&quot;Vy:\n&quot;, self.Vy)&#10;&#10;&#10;        self.Mz = PiecewisePolynomial(Mz)&#10;        print(&quot;Mz:\n&quot;, self.Mz)&#10;        self.Sz = PiecewisePolynomial(Sz)&#10;        print(&quot;Sz:\n&quot;, self.Sz)&#10;        self.Dy = PiecewisePolynomial(Dy)&#10;        print(&quot;Dy:\n&quot;,self.Dy)&#10;&#10;        # Create PiecewisePolynomial2 instances alongside existing ones&#10;        from pyMAOS.loading.PiecewisePolynomial2 import PiecewisePolynomial2&#10;&#10;        self.Vy2 = PiecewisePolynomial2(Vy)&#10;        print(&quot;Vy2:&quot;, self.Vy2, sep=&quot;\n&quot;)&#10;&#10;        self.Mz2 = PiecewisePolynomial2(Mz)&#10;        print(&quot;Mz2:&quot;, self.Mz2, sep=&quot;\n&quot;)&#10;&#10;        self.Sz2 = PiecewisePolynomial2(Sz)&#10;        print(&quot;Sz2:&quot;, self.Sz2, sep=&quot;\n&quot;)&#10;&#10;        self.Dy2 = PiecewisePolynomial2(Dy)&#10;        print(&quot;Dy2:&quot;, self.Dy2, sep=&quot;\n&quot;)&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of a point load.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Point Load ({self.loadcase}): &quot;&#10;                f&quot;p={self.p:.3f} at x={self.a:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;&#10;    def FEF(self):&#10;        p = self.p&#10;        a = self.a&#10;        L = self.L&#10;&#10;        # Calculate fixed end moments&#10;        Miz = -1 * (p * a * (a - L) * (a - L)) / (L * L)&#10;        Mjz = -1 * (p * a * a * (a - L)) / (L * L)&#10;&#10;        # Calculate fixed end forces&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Import dimension constants&#10;        from pyMAOS import INTERNAL_MOMENT_UNIT, INTERNAL_FORCE_UNIT&#10;&#10;        # Define expected dimensionalities&#10;        FORCE_DIMENSIONALITY = pyMAOS.unit_manager.ureg.parse_units(pyMAOS.unit_manager.INTERNAL_FORCE_UNIT).dimensionality&#10;        MOMENT_DIMENSIONALITY = pyMAOS.unit_manager.ureg.parse_units(pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT).dimensionality&#10;&#10;        # Debug prints showing actual dimensionality&#10;        print(f&quot;DEBUG: Checking dimensions - Miz: {Miz.dimensionality}, Mjz: {Mjz.dimensionality}&quot;)&#10;        print(f&quot;DEBUG: Checking dimensions - Riy: {Riy.dimensionality}, Rjy: {Rjy.dimensionality}&quot;)&#10;&#10;        # Verify moment dimensions&#10;        try:&#10;            Miz.check(MOMENT_DIMENSIONALITY)&#10;            Mjz.check(MOMENT_DIMENSIONALITY)&#10;            print(&quot;DEBUG: Moment dimension check passed&quot;)&#10;        except pint.DimensionalityError as e:&#10;            print(f&quot;ERROR: Dimension error in moments: {e}&quot;)&#10;            # Create correctly dimensioned values as fallback&#10;            if not Miz.check(MOMENT_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Miz from {Miz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;                Miz = pyMAOS.unit_manager.ureg.Quantity(Miz.magnitude, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;            if not Mjz.check(MOMENT_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Mjz from {Mjz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;                Mjz = pyMAOS.unit_manager.ureg.Quantity(Mjz.magnitude, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;&#10;        # Verify force dimensions&#10;        try:&#10;            Riy.check(FORCE_DIMENSIONALITY)&#10;            Rjy.check(FORCE_DIMENSIONALITY)&#10;            print(&quot;DEBUG: Force dimension check passed&quot;)&#10;        except pint.DimensionalityError as e:&#10;            print(f&quot;ERROR: Dimension error in forces: {e}&quot;)&#10;            # Create correctly dimensioned values as fallback&#10;            if not Riy.check(FORCE_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Riy from {Riy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;                Riy = pyMAOS.unit_manager.ureg.Quantity(Riy.magnitude, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;            if not Rjy.check(FORCE_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Rjy from {Rjy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;                Rjy = pyMAOS.unit_manager.ureg.Quantity(Rjy.magnitude, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = pyMAOS.unit_manager.ureg.Quantity(0, Riy.units)&#10;&#10;        # Print forces and moments for debugging&#10;        print(f&quot;Point load FEF - Forces: Riy={Riy:.3f}, Rjy={Rjy:.3f}&quot;)&#10;        print(f&quot;Point load FEF - Moments: Miz={Miz:.3f}, Mjz={Mjz:.3f}&quot;)&#10;&#10;        ret_val = [zero_force, Riy, Miz, zero_force, Rjy, Mjz]&#10;&#10;        # Final dimension check for return values&#10;        for i, (val, expected_dim) in enumerate(zip(ret_val, [&#10;            FORCE_DIMENSIONALITY, FORCE_DIMENSIONALITY, MOMENT_DIMENSIONALITY,&#10;            FORCE_DIMENSIONALITY, FORCE_DIMENSIONALITY, MOMENT_DIMENSIONALITY&#10;        ])):&#10;            try:&#10;                val.check(expected_dim)&#10;            except pint.DimensionalityError as e:&#10;                print(f&quot;ERROR: Dimensionality error in ret_val[{i}]: {e}&quot;)&#10;                print(f&quot;  Actual: {val.dimensionality}, Expected: {expected_dim}&quot;)&#10;&#10;        return ret_val&#10;&#10;    def plot_all_ppoly_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all PiecewisePolynomial2 functions.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy2': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial2 objects&#10;        functions = []&#10;        if hasattr(self, 'Vy2') and self.Vy2.ppoly is not None:&#10;            functions.append(('Vy2', self.Vy2, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz2') and self.Mz2.ppoly is not None:&#10;            functions.append(('Mz2', self.Mz2, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz2') and self.Sz2.ppoly is not None:&#10;            functions.append(('Sz2', self.Sz2, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy2') and self.Dy2.ppoly is not None:&#10;            functions.append(('Dy2', self.Dy2, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No PiecewisePolynomial2 functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} PiecewisePolynomial2 functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key points&#10;            for x in [self.a, self.L]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title with sign-preserving formatting for load value&#10;        load_str = f&quot;{self.p:+.3g}&quot;  # Shows + for positive values&#10;        fig.suptitle(f&quot;Beam Analysis (PPoly) for Point Load {load_str} at x={self.a:.3g}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig&#10;    # def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;    #     &quot;&quot;&quot;&#10;    #     Prints detailed analysis of the point load response with ASCII charts.&#10;    #&#10;    #     Parameters&#10;    #     ----------&#10;    #     num_points : int&#10;    #         Number of points to sample in each region&#10;    #     chart_width : int&#10;    #         Width of ASCII charts in characters&#10;    #     chart_height : int&#10;    #         Height of ASCII charts in characters&#10;    #     &quot;&quot;&quot;&#10;    #     import numpy as np&#10;    #     from pyMAOS import unit_manager&#10;    #&#10;    #     print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;    #     print(f&quot;Point load of {self.p:.3f} at x={self.a:.3f}&quot;)&#10;    #     print(f&quot;Member length: {self.L:.3f}&quot;)&#10;    #     print(f&quot;Reactions: Rix = {self.Rix:.3f}, Rjx = {self.Rjx:.3f}&quot;)&#10;    #&#10;    #     # Define regions for before and after the load point&#10;    #     regions = [(0, self.a), (self.a, self.L)]&#10;    #     region_names = [&quot;Before Load [0 to a]&quot;, &quot;After Load [a to L]&quot;]&#10;    #&#10;    #     # Create sampling points for each region&#10;    #     all_x = []&#10;    #     for i, (start, end) in enumerate(regions):&#10;    #         if end &gt; start:  # Only if region has non-zero width&#10;    #             points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;    #             # Don't duplicate boundary points&#10;    #             if i &gt; 0 and len(all_x) &gt; 0:&#10;    #                 points = points[1:]&#10;    #             all_x.extend(points)&#10;    #&#10;    #     # Calculate function values&#10;    #     ax_values = [self.Ax.evaluate(x) for x in all_x]&#10;    #     dx_values = [self.Dx.evaluate(x) for x in all_x]&#10;    #&#10;    #     # Print ASCII charts&#10;    #     self._print_ascii_chart(&quot;Axial Force (Ax)&quot;, all_x, ax_values, regions, chart_width, chart_height)&#10;    #     self._print_ascii_chart(&quot;Axial Displacement (Dx)&quot;, all_x, dx_values, regions, chart_width, chart_height)&#10;    #&#10;    #     # Print table of values at key points&#10;    #     print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;    #     print(f&quot;{'Position':15} {'Axial Force':20} {'Axial Displacement':20}&quot;)&#10;    #     print(&quot;-&quot; * 60)&#10;    #     for x in [0, self.a, self.L]:&#10;    #         print(f&quot;{x:15.3f} {self.Ax.evaluate(x):20.3f} {self.Dx.evaluate(x):20.3e}&quot;)&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of the point load response with ASCII charts.&#10;&#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;        from pyMAOS import unit_manager&#10;&#10;        print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        print(f&quot;Point load of {self.p:.3f} at x={self.a:.3f}&quot;)&#10;        print(f&quot;Member length: {self.L:.3f}&quot;)&#10;        print(f&quot;Vertical reactions: Riy = {self.Riy:.3f}, Rjy = {self.Rjy:.3f}&quot;)&#10;&#10;        # Define regions for before and after the load point&#10;        regions = [(0, self.a), (self.a, self.L)]&#10;        region_names = [&quot;Before Load [0 to a]&quot;, &quot;After Load [a to L]&quot;]&#10;&#10;        # Create sampling points for each region&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;&#10;        # Calculate function values&#10;        vy_values = [self.Vy.evaluate(x) for x in all_x]&#10;        mz_values = [self.Mz.evaluate(x) for x in all_x]&#10;        sz_values = [self.Sz.evaluate(x) for x in all_x]&#10;        dy_values = [self.Dy.evaluate(x) for x in all_x]&#10;&#10;        # Print ASCII charts&#10;        self._print_ascii_chart(&quot;Shear Force (Vy)&quot;, all_x, vy_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Bending Moment (Mz)&quot;, all_x, mz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Rotation (Sz)&quot;, all_x, sz_values, regions, chart_width, chart_height)&#10;        self._print_ascii_chart(&quot;Deflection (Dy)&quot;, all_x, dy_values, regions, chart_width, chart_height)&#10;&#10;        # Print table of values at key points&#10;        print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;        print(f&quot;{'Position':15} {'Shear':15} {'Moment':15} {'Rotation':15} {'Deflection':15}&quot;)&#10;        print(&quot;-&quot; * 75)&#10;        for x in [0, self.a, self.L]:&#10;            print(f&quot;{x:15.3f} {self.Vy.evaluate(x):15.3f} {self.Mz.evaluate(x):15.3f} {self.Sz.evaluate(x):15.3e} {self.Dy.evaluate(x):15.3e}&quot;)&#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Filter out NaN values before finding min/max&#10;        valid_indices = []&#10;        valid_y_values = []&#10;        for i, y in enumerate(y_values):&#10;            # Check if y is NaN (including Quantity objects with NaN magnitude)&#10;            is_nan = False&#10;            if hasattr(y, 'magnitude'):&#10;                is_nan = np.isnan(y.magnitude)&#10;            else:&#10;                is_nan = np.isnan(y) if isinstance(y, (int, float)) else False&#10;&#10;            if not is_nan:&#10;                valid_indices.append(i)&#10;                valid_y_values.append(y)&#10;&#10;        # If no valid values, skip plotting&#10;        if len(valid_y_values) == 0:&#10;            print(&quot;No valid data points to plot (all values are NaN)&quot;)&#10;            return&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(valid_y_values)&#10;        max_y = max(valid_y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;        range_y = max_y - min_y&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Skip NaN values&#10;            if hasattr(y, 'magnitude'):&#10;                if np.isnan(y.magnitude):&#10;                    continue&#10;            elif isinstance(y, (int, float)) and np.isnan(y):&#10;                continue&#10;&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart - avoid NaN issues&#10;            try:&#10;                y_normalized = (y - min_y) / range_y&#10;                y_pos = height - 1 - int(y_normalized * (height - 1))&#10;                y_pos = min(height - 1, max(0, y_pos))&#10;                chart[y_pos][x_pos] = '*'&#10;            except (ValueError, TypeError, ZeroDivisionError) as e:&#10;                print(f&quot;Warning: Could not plot point at x={x}, y={y}: {e}&quot;)&#10;                continue&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        print(f&quot;Region boundaries: [0, {self.a:.2f}, {self.L:.2f}]&quot;)" />
              <option name="updatedContent" value="import pint&#10;from typing import TYPE_CHECKING, Any&#10;from pyMAOS.loading.piecewisePolinomial import PiecewisePolynomial&#10;from pprint import pprint&#10;from display_utils import print_quantity_nested_list&#10;import pyMAOS&#10;# Use TYPE_CHECKING to avoid runtime imports&#10;if TYPE_CHECKING:&#10;    from pyMAOS.frame2d import R2Frame&#10;&#10;class R2_Load_Base:&#10;    &quot;&quot;&quot;Base class for point loads and moments in R2 frames.&quot;&quot;&quot;&#10;    &#10;    def __init__(self, a, member, loadcase=&quot;D&quot;):&#10;        &quot;&quot;&quot;Initialize common attributes for all loads.&quot;&quot;&quot;&#10;        self.a = a&#10;        self.L = member.length&#10;        &#10;        self.E = member.material.E&#10;        self.I = member.section.Ixx&#10;        self.EI = self.E * self.I&#10;        &#10;        self.kind = &quot;LOAD_BASE&quot;  # Will be overridden by child classes&#10;        self.loadcase = loadcase&#10;        &#10;        # Initialize piecewise polynomials to None - will be set by child classes&#10;        self.Wx = PiecewisePolynomial()  # Axial Load Function&#10;        self.Wy = PiecewisePolynomial()  # Vertical Load Function&#10;        self.Ax = PiecewisePolynomial()  # Axial Force Function&#10;        self.Dx = PiecewisePolynomial()  # Axial Displacement Function&#10;        self.Vy = None  # Shear Function&#10;        self.Mz = None  # Moment Function&#10;        self.Sz = None  # Rotation Function&#10;        self.Dy = None  # Deflection Function&#10;    &#10;    def _print_ascii_chart(self, title, x_values, y_values, regions, width=60, height=15):&#10;        &quot;&quot;&quot;&#10;        Helper method to print an ASCII chart of data with proper unit handling.&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;&#10;        if len(y_values) == 0:&#10;            return&#10;&#10;        print(f&quot;\n--- {title} ---&quot;)&#10;&#10;        # Filter out NaN values before finding min/max&#10;        valid_indices = []&#10;        valid_y_values = []&#10;        for i, y in enumerate(y_values):&#10;            # Check if y is NaN (including Quantity objects with NaN magnitude)&#10;            is_nan = False&#10;            if hasattr(y, 'magnitude'):&#10;                is_nan = np.isnan(y.magnitude)&#10;            else:&#10;                is_nan = np.isnan(y) if isinstance(y, (int, float)) else False&#10;&#10;            if not is_nan:&#10;                valid_indices.append(i)&#10;                valid_y_values.append(y)&#10;&#10;        # If no valid values, skip plotting&#10;        if len(valid_y_values) == 0:&#10;            print(&quot;No valid data points to plot (all values are NaN)&quot;)&#10;            return&#10;&#10;        # Find min and max values while preserving units&#10;        min_y = min(valid_y_values)&#10;        max_y = max(valid_y_values)&#10;&#10;        # Debug print&#10;        print(f&quot;Value range: {min_y:.3f} to {max_y:.3f}&quot;)&#10;&#10;        # Avoid division by zero&#10;        if min_y == max_y:&#10;            if hasattr(min_y, 'magnitude') and min_y.magnitude == 0:&#10;                # Create non-zero range with proper units&#10;                if hasattr(min_y, 'units'):&#10;                    min_y -= 1 * min_y.units&#10;                    max_y += 1 * max_y.units&#10;                else:&#10;                    min_y -= 1&#10;                    max_y += 1&#10;            else:&#10;                # Just create some range around the value&#10;                min_y = 0.9 * min_y&#10;                max_y = 1.1 * max_y&#10;&#10;        # Get the maximum x value for scaling&#10;        max_x = max(x_values)&#10;        range_y = max_y - min_y&#10;&#10;        # Create the chart grid&#10;        chart = [[' ' for _ in range(width)] for _ in range(height)]&#10;&#10;        # Draw x-axis if zero is in the range&#10;        if min_y &lt;= 0 &lt;= max_y:&#10;            # Calculate position while preserving units&#10;            axis_pos = height - int(height * (0 - min_y) / range_y)&#10;            axis_pos = max(0, min(height - 1, axis_pos))&#10;            chart[axis_pos] = ['-' for _ in range(width)]&#10;&#10;        # Plot data points&#10;        for i, (x, y) in enumerate(zip(x_values, y_values)):&#10;            # Skip NaN values&#10;            if hasattr(y, 'magnitude'):&#10;                if np.isnan(y.magnitude):&#10;                    continue&#10;            elif isinstance(y, (int, float)) and np.isnan(y):&#10;                continue&#10;&#10;            # Map x and y to chart coordinates while preserving units&#10;            x_pos = int(width * x / max_x)&#10;            x_pos = min(width - 1, max(0, x_pos))&#10;&#10;            # Calculate y position in chart - avoid NaN issues&#10;            try:&#10;                y_normalized = (y - min_y) / range_y&#10;                y_pos = height - 1 - int(y_normalized * (height - 1))&#10;                y_pos = min(height - 1, max(0, y_pos))&#10;                chart[y_pos][x_pos] = '*'&#10;            except (ValueError, TypeError, ZeroDivisionError) as e:&#10;                print(f&quot;Warning: Could not plot point at x={x}, y={y}: {e}&quot;)&#10;                continue&#10;&#10;        # Draw vertical lines at region boundaries&#10;        for start, end in regions:&#10;            for boundary in [start, end]:&#10;                if boundary &gt; 0 and boundary &lt; max_x:&#10;                    x_pos = int(width * boundary / max_x)&#10;                    x_pos = min(width - 1, max(0, x_pos))&#10;                    for y_pos in range(height):&#10;                        if chart[y_pos][x_pos] != '*':  # Don't overwrite data points&#10;                            chart[y_pos][x_pos] = '|'&#10;&#10;        # Print the chart&#10;        for row in chart:&#10;            print(''.join(row))&#10;&#10;        # Print region information&#10;        print(f&quot;Region boundaries: [0, {self.a:.2f}, {self.L:.2f}]&quot;)&#10;    &#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Prints detailed analysis of the load response with ASCII charts.&#10;        &#10;        Parameters&#10;        ----------&#10;        num_points : int&#10;            Number of points to sample in each region&#10;        chart_width : int&#10;            Width of ASCII charts in characters&#10;        chart_height : int&#10;            Height of ASCII charts in characters&#10;        &quot;&quot;&quot;&#10;        import numpy as np&#10;        from pyMAOS import unit_manager&#10;    &#10;        print(f&quot;\n===== DETAILED ANALYSIS FOR {self.__str__()} =====&quot;)&#10;        &#10;        # Define regions for before and after the load point&#10;        regions = [(0, self.a), (self.a, self.L)]&#10;        region_names = [&quot;Before Load [0 to a]&quot;, &quot;After Load [a to L]&quot;]&#10;    &#10;        # Create sampling points for each region&#10;        all_x = []&#10;        for i, (start, end) in enumerate(regions):&#10;            if end &gt; start:  # Only if region has non-zero width&#10;                points = [start + j*(end-start)/num_points for j in range(num_points+1)]&#10;                # Don't duplicate boundary points&#10;                if i &gt; 0 and len(all_x) &gt; 0:&#10;                    points = points[1:]&#10;                all_x.extend(points)&#10;    &#10;        # Calculate function values for existing functions&#10;        if self.Vy is not None:&#10;            vy_values = [self.Vy.evaluate(x) for x in all_x]&#10;            self._print_ascii_chart(&quot;Shear Force (Vy)&quot;, all_x, vy_values, regions, chart_width, chart_height)&#10;        &#10;        if self.Mz is not None:&#10;            mz_values = [self.Mz.evaluate(x) for x in all_x]&#10;            self._print_ascii_chart(&quot;Bending Moment (Mz)&quot;, all_x, mz_values, regions, chart_width, chart_height)&#10;        &#10;        if self.Sz is not None:&#10;            sz_values = [self.Sz.evaluate(x) for x in all_x]&#10;            self._print_ascii_chart(&quot;Rotation (Sz)&quot;, all_x, sz_values, regions, chart_width, chart_height)&#10;        &#10;        if self.Dy is not None:&#10;            dy_values = [self.Dy.evaluate(x) for x in all_x]&#10;            self._print_ascii_chart(&quot;Deflection (Dy)&quot;, all_x, dy_values, regions, chart_width, chart_height)&#10;    &#10;        # Print table of values at key points if all functions exist&#10;        if all(f is not None for f in [self.Vy, self.Mz, self.Sz, self.Dy]):&#10;            print(&quot;\n===== VALUES AT KEY POINTS =====&quot;)&#10;            print(f&quot;{'Position':15} {'Shear':15} {'Moment':15} {'Rotation':15} {'Deflection':15}&quot;)&#10;            print(&quot;-&quot; * 75)&#10;            for x in [0, self.a, self.L]:&#10;                print(f&quot;{x:15.3f} {self.Vy.evaluate(x):15.3f} {self.Mz.evaluate(x):15.3f} {self.Sz.evaluate(x):15.3e} {self.Dy.evaluate(x):15.3e}&quot;)&#10;    &#10;    def plot_all_ppoly_functions(self, figsize=(10, 12), convert_x_to=None, convert_y_to=None):&#10;        &quot;&quot;&quot;&#10;        Create a figure with subplots for all PiecewisePolynomial2 functions.&#10;&#10;        Parameters&#10;        ----------&#10;        figsize : tuple&#10;            Figure size (width, height) in inches&#10;        convert_x_to : pint.Unit, optional&#10;            Convert x values to this unit for plotting&#10;        convert_y_to : dict, optional&#10;            Dictionary mapping function name to unit for conversion, e.g. {'Vy2': 'kN'}&#10;&#10;        Returns&#10;        -------&#10;        matplotlib.figure.Figure&#10;            The figure containing all plots&#10;        &quot;&quot;&quot;&#10;        import matplotlib.pyplot as plt&#10;&#10;        # Collect all non-empty PiecewisePolynomial2 objects&#10;        functions = []&#10;        if hasattr(self, 'Vy2') and self.Vy2.ppoly is not None:&#10;            functions.append(('Vy2', self.Vy2, 'red', 'Shear Force'))&#10;        if hasattr(self, 'Mz2') and self.Mz2.ppoly is not None:&#10;            functions.append(('Mz2', self.Mz2, 'green', 'Bending Moment'))&#10;        if hasattr(self, 'Sz2') and self.Sz2.ppoly is not None:&#10;            functions.append(('Sz2', self.Sz2, 'purple', 'Rotation'))&#10;        if hasattr(self, 'Dy2') and self.Dy2.ppoly is not None:&#10;            functions.append(('Dy2', self.Dy2, 'orange', 'Deflection'))&#10;&#10;        # Return early if no functions to plot&#10;        if not functions:&#10;            print(&quot;No PiecewisePolynomial2 functions to plot&quot;)&#10;            return None&#10;&#10;        # Create figure and subplots&#10;        fig, axes = plt.subplots(len(functions), 1, figsize=figsize, sharex=True)&#10;&#10;        # Handle single subplot case&#10;        if len(functions) == 1:&#10;            axes = [axes]&#10;&#10;        print(f&quot;Plotting {len(functions)} PiecewisePolynomial2 functions&quot;)&#10;&#10;        # Create each plot&#10;        for i, (name, func, color, title) in enumerate(functions):&#10;            # Convert y units if specified&#10;            y_unit = None&#10;            if convert_y_to and name in convert_y_to:&#10;                y_unit = convert_y_to[name]&#10;&#10;            # Plot the function on the appropriate subplot&#10;            func.plot(&#10;                ax=axes[i],&#10;                color=color,&#10;                title=f&quot;{title} ({name})&quot;,&#10;                convert_x_to=convert_x_to,&#10;                convert_y_to=y_unit,&#10;                show=False&#10;            )&#10;&#10;            # Add vertical lines at key points&#10;            for x in [self.a, self.L]:&#10;                if hasattr(x, 'magnitude'):&#10;                    x_val = x.to(convert_x_to).magnitude if convert_x_to else x.magnitude&#10;                else:&#10;                    x_val = x&#10;                axes[i].axvline(x=x_val, color='gray', linestyle='--', alpha=0.7)&#10;&#10;        # Add overall title&#10;        fig.suptitle(f&quot;Beam Analysis (PPoly) for {self.__str__()}&quot;, fontsize=16)&#10;&#10;        # Adjust spacing&#10;        plt.tight_layout()&#10;        fig.subplots_adjust(top=0.95)&#10;&#10;        # Show the grid on all plots&#10;        for ax in axes:&#10;            ax.grid(True, linestyle='--', alpha=0.7)&#10;&#10;        return fig&#10;    &#10;    def FEF(self):&#10;        &quot;&quot;&quot;&#10;        Compute and return the fixed end forces.&#10;        This method should be implemented by subclasses.&#10;        &quot;&quot;&quot;&#10;        raise NotImplementedError(&quot;Subclasses must implement FEF method&quot;)&#10;    &#10;    def __str__(self):&#10;        &quot;&quot;&quot;String representation should be implemented by each child class.&quot;&quot;&quot;&#10;        raise NotImplementedError(&quot;Subclasses must implement __str__&quot;)&#10;&#10;&#10;class R2_Point_Moment(R2_Load_Base):&#10;    def __init__(self, M: pint.Quantity, a: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        &quot;&quot;&quot;&#10;        Parameters&#10;        ----------&#10;        M : FLOAT&#10;            Applied moment, counter-clockwise positive.&#10;        a : FLOAT&#10;            Point of application of moment as measured from the member left end.&#10;        member : Element Class&#10;            the member that the load is applied to.&#10;        loadcase : STRING, optional&#10;            String representation of the applied load type, this&#10;            data is used for load cases and combindations. The default is &quot;D&quot;.&#10;        &quot;&quot;&quot;&#10;        # Call parent initializer&#10;        super().__init__(a, member, loadcase)&#10;        &#10;        self.M = M&#10;        self.kind = &quot;MOMENT&quot;&#10;&#10;        # Constants of Integration&#10;        self.integration_constants()&#10;&#10;        # Simple End Reactions&#10;        self.Riy = self.M / self.L&#10;        self.Rjy = -1 * self.Riy&#10;&#10;        # Piecewise Functions&#10;        # [co....cn x^n] [xa, xb]&#10;        Vy = [[[self.Riy], [0, self.a]], [[self.Riy], [self.a, self.L]]]&#10;        pprint(Vy)&#10;        &#10;        Mz = [&#10;            [[0, self.Riy], [0, self.a]],&#10;            [[-1 * self.M, self.Riy], [self.a, self.L]],&#10;        ]&#10;        pprint(Mz)&#10;        &#10;        Sz = [&#10;            [[self.c1 / self.EI, 0, self.Riy / (2 * self.EI)], [0, self.a]],&#10;            [&#10;                [&#10;                    self.c2 / self.EI,&#10;                    -1 * self.M / self.EI,&#10;                    self.Riy / (2 * self.EI),&#10;                ],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        pprint(Sz)&#10;        &#10;        Dy = [&#10;            [&#10;                [&#10;                    self.c3 / self.EI,&#10;                    self.c1 / self.EI,&#10;                    0,&#10;                    self.Riy / (6 * self.EI),&#10;                ],&#10;                [0, self.a],&#10;            ],&#10;            [&#10;                [&#10;                    self.c4 / self.EI,&#10;                    self.c2 / self.EI,&#10;                    -1 * self.M / (2 * self.EI),&#10;                    self.Riy / (6 * self.EI),&#10;                ],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        pprint(Dy)&#10;        &#10;        # Initialize piecewise polynomials&#10;        self.Vy = PiecewisePolynomial(Vy)&#10;        self.Mz = PiecewisePolynomial(Mz)&#10;        self.Sz = PiecewisePolynomial(Sz)&#10;        self.Dy = PiecewisePolynomial(Dy)&#10;&#10;        # Create PiecewisePolynomial2 instances if the class is available&#10;        try:&#10;            from pyMAOS.loading.PiecewisePolynomial2 import PiecewisePolynomial2&#10;            self.Vy2 = PiecewisePolynomial2(Vy)&#10;            self.Mz2 = PiecewisePolynomial2(Mz)&#10;            self.Sz2 = PiecewisePolynomial2(Sz)&#10;            self.Dy2 = PiecewisePolynomial2(Dy)&#10;        except ImportError:&#10;            pass&#10;&#10;    def integration_constants(self):&#10;        M = self.M&#10;        a = self.a&#10;        L = self.L&#10;&#10;        # Constants of Integration&#10;        self.c1 = ((3 * M * a * a) - (6 * L * M * a) + (2 * L * L * M)) / (6 * L)&#10;        self.c2 = ((3 * M * a * a) + (2 * L * L * M)) / (6 * L)&#10;        self.c3 = 0&#10;        self.c4 = -1 / 2 * M * a * a&#10;&#10;    def FEF(self):&#10;        &quot;&quot;&quot;&#10;        Compute and return the fixed and forces&#10;        &quot;&quot;&quot;&#10;        M = self.M&#10;        a = self.a&#10;        L = self.L&#10;&#10;        Miz = -1 * (M * (a - L) * ((3 * a) - L)) / (L * L)&#10;        Mjz = -1 * (M * a * (3 * a - 2 * L)) / (L * L)&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = 0 * pyMAOS.unit_manager.ureg(Riy.units)&#10;&#10;        return [zero_force, Riy, Miz, zero_force, Rjy, Mjz]&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of a point moment.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Point Moment ({self.loadcase}): &quot;&#10;                f&quot;M={self.M:.3f} at x={self.a:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Extended version of the base class method with moment-specific information.&#10;        &quot;&quot;&quot;&#10;        print(f&quot;Point moment of {self.M:.3f} at x={self.a:.3f}&quot;)&#10;        print(f&quot;Member length: {self.L:.3f}&quot;)&#10;        print(f&quot;Vertical reactions: Riy = {self.Riy:.3f}, Rjy = {self.Rjy:.3f}&quot;)&#10;        &#10;        # Call the parent class method to do the actual analysis&#10;        super().print_detailed_analysis(num_points, chart_width, chart_height)&#10;&#10;&#10;class R2_Point_Load(R2_Load_Base):&#10;    def __init__(self, p: pint.Quantity, a: pint.Quantity, member: &quot;Any&quot;, loadcase=&quot;D&quot;):&#10;        # Call parent initializer&#10;        super().__init__(a, member, loadcase)&#10;        &#10;        self.p = p&#10;        self.kind = &quot;POINT&quot;&#10;&#10;        # Calculate constants of integration&#10;        L = self.L&#10;        &#10;        from pyMAOS import INTERNAL_LENGTH_UNIT, INTERNAL_FORCE_UNIT, INTERNAL_MOMENT_UNIT&#10;        self.c1 = pyMAOS.unit_manager.ureg.Quantity(0, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;        self.c2 = -1 * p * a&#10;        self.c3 = (p * a * (a - (2 * L)) * (a - L)) / (6 * L)&#10;        self.c4 = (p * a * ((a * a) + (2 * L * L))) / (6 * L)&#10;        self.c5 = pyMAOS.unit_manager.ureg.Quantity(0, f&quot;{pyMAOS.unit_manager.INTERNAL_FORCE_UNIT} * {pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}**3&quot;)&#10;        self.c6 = (-1 * p * a * a * a) / 6&#10;&#10;        # Simple End Reactions&#10;        self.Riy = self.p * ((self.a - self.L) / self.L)&#10;        self.Rjy = -1 * self.p * self.a * (1 / self.L)&#10;        print(f&quot;Riy: {self.Riy:.3f}, Rjy: {self.Rjy:.3f}&quot;)&#10;        &#10;        # Piecewise Functions&#10;        # [co....cn x^n] [xa, xb]&#10;        Vy = [&#10;            [[self.Riy], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.Riy + self.p], [self.a, self.L]],&#10;        ]&#10;        print(&quot;Vy:&quot;); print_quantity_nested_list(Vy)&#10;        &#10;        Mz = [&#10;            [[self.c1, self.Riy], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.c2, self.Riy + self.p], [self.a, self.L]],&#10;        ]&#10;        print(&quot;Mz:&quot;); print_quantity_nested_list(Mz)&#10;        &#10;        Sz = [&#10;            [[self.c3, self.c1, self.Riy / 2], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [[self.c4, self.c2, (self.Riy + self.p) / 2], [self.a, self.L]],&#10;        ]&#10;        Sz[0][0] = [i / self.EI for i in Sz[0][0]]&#10;        Sz[1][0] = [i / self.EI for i in Sz[1][0]]&#10;        print(&quot;Sz:&quot;); print_quantity_nested_list(Sz)&#10;        &#10;        Dy = [&#10;            [[self.c5, self.c3, self.c1 / 2, self.Riy / 6], [pyMAOS.unit_manager.ureg.Quantity(0, self.a.units), self.a]],&#10;            [&#10;                [self.c6, self.c4, self.c2 / 2, (self.Riy + self.p) / 6],&#10;                [self.a, self.L],&#10;            ],&#10;        ]&#10;        Dy[0][0] = [i / self.EI for i in Dy[0][0]]&#10;        Dy[1][0] = [i / self.EI for i in Dy[1][0]]&#10;        print(&quot;Dy:&quot;); print_quantity_nested_list(Dy, precision=2, width=20, simplify_units=True)&#10;&#10;        # Initialize piecewise polynomials&#10;        self.Vy = PiecewisePolynomial(Vy)&#10;        print(&quot;Vy:\n&quot;, self.Vy)&#10;        &#10;        self.Mz = PiecewisePolynomial(Mz)&#10;        print(&quot;Mz:\n&quot;, self.Mz)&#10;        &#10;        self.Sz = PiecewisePolynomial(Sz)&#10;        print(&quot;Sz:\n&quot;, self.Sz)&#10;        &#10;        self.Dy = PiecewisePolynomial(Dy)&#10;        print(&quot;Dy:\n&quot;, self.Dy)&#10;&#10;        # Create PiecewisePolynomial2 instances if the class is available&#10;        try:&#10;            from pyMAOS.loading.PiecewisePolynomial2 import PiecewisePolynomial2&#10;&#10;            self.Vy2 = PiecewisePolynomial2(Vy)&#10;            print(&quot;Vy2:&quot;, self.Vy2, sep=&quot;\n&quot;)&#10;&#10;            self.Mz2 = PiecewisePolynomial2(Mz)&#10;            print(&quot;Mz2:&quot;, self.Mz2, sep=&quot;\n&quot;)&#10;&#10;            self.Sz2 = PiecewisePolynomial2(Sz)&#10;            print(&quot;Sz2:&quot;, self.Sz2, sep=&quot;\n&quot;)&#10;&#10;            self.Dy2 = PiecewisePolynomial2(Dy)&#10;            print(&quot;Dy2:&quot;, self.Dy2, sep=&quot;\n&quot;)&#10;        except ImportError:&#10;            pass&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;&#10;        String representation of a point load.&#10;        &quot;&quot;&quot;&#10;        return (f&quot;Point Load ({self.loadcase}): &quot;&#10;                f&quot;p={self.p:.3f} at x={self.a:.3f} &quot;&#10;                f&quot;(on member of length {self.L:.3f})&quot;)&#10;&#10;    def FEF(self):&#10;        p = self.p&#10;        a = self.a&#10;        L = self.L&#10;&#10;        # Calculate fixed end moments&#10;        Miz = -1 * (p * a * (a - L) * (a - L)) / (L * L)&#10;        Mjz = -1 * (p * a * a * (a - L)) / (L * L)&#10;&#10;        # Calculate fixed end forces&#10;        Riy = self.Riy + (Miz / L) + (Mjz / L)&#10;        Rjy = self.Rjy - (Miz / L) - (Mjz / L)&#10;&#10;        # Import dimension constants&#10;        from pyMAOS import INTERNAL_MOMENT_UNIT, INTERNAL_FORCE_UNIT&#10;&#10;        # Define expected dimensionalities&#10;        FORCE_DIMENSIONALITY = pyMAOS.unit_manager.ureg.parse_units(pyMAOS.unit_manager.INTERNAL_FORCE_UNIT).dimensionality&#10;        MOMENT_DIMENSIONALITY = pyMAOS.unit_manager.ureg.parse_units(pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT).dimensionality&#10;&#10;        # Debug prints showing actual dimensionality&#10;        print(f&quot;DEBUG: Checking dimensions - Miz: {Miz.dimensionality}, Mjz: {Mjz.dimensionality}&quot;)&#10;        print(f&quot;DEBUG: Checking dimensions - Riy: {Riy.dimensionality}, Rjy: {Rjy.dimensionality}&quot;)&#10;&#10;        # Verify moment dimensions&#10;        try:&#10;            Miz.check(MOMENT_DIMENSIONALITY)&#10;            Mjz.check(MOMENT_DIMENSIONALITY)&#10;            print(&quot;DEBUG: Moment dimension check passed&quot;)&#10;        except pint.DimensionalityError as e:&#10;            print(f&quot;ERROR: Dimension error in moments: {e}&quot;)&#10;            # Create correctly dimensioned values as fallback&#10;            if not Miz.check(MOMENT_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Miz from {Miz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;                Miz = pyMAOS.unit_manager.ureg.Quantity(Miz.magnitude, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;            if not Mjz.check(MOMENT_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Mjz from {Mjz.dimensionality} to {MOMENT_DIMENSIONALITY}&quot;)&#10;                Mjz = pyMAOS.unit_manager.ureg.Quantity(Mjz.magnitude, pyMAOS.unit_manager.INTERNAL_MOMENT_UNIT)&#10;&#10;        # Verify force dimensions&#10;        try:&#10;            Riy.check(FORCE_DIMENSIONALITY)&#10;            Rjy.check(FORCE_DIMENSIONALITY)&#10;            print(&quot;DEBUG: Force dimension check passed&quot;)&#10;        except pint.DimensionalityError as e:&#10;            print(f&quot;ERROR: Dimension error in forces: {e}&quot;)&#10;            # Create correctly dimensioned values as fallback&#10;            if not Riy.check(FORCE_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Riy from {Riy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;                Riy = pyMAOS.unit_manager.ureg.Quantity(Riy.magnitude, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;            if not Rjy.check(FORCE_DIMENSIONALITY):&#10;                print(f&quot;WARNING: Fixing dimensions of Rjy from {Rjy.dimensionality} to {FORCE_DIMENSIONALITY}&quot;)&#10;                Rjy = pyMAOS.unit_manager.ureg.Quantity(Rjy.magnitude, pyMAOS.unit_manager.INTERNAL_FORCE_UNIT)&#10;&#10;        # Create zeros with appropriate units&#10;        zero_force = pyMAOS.unit_manager.ureg.Quantity(0, Riy.units)&#10;&#10;        # Print forces and moments for debugging&#10;        print(f&quot;Point load FEF - Forces: Riy={Riy:.3f}, Rjy={Rjy:.3f}&quot;)&#10;        print(f&quot;Point load FEF - Moments: Miz={Miz:.3f}, Mjz={Mjz:.3f}&quot;)&#10;&#10;        ret_val = [zero_force, Riy, Miz, zero_force, Rjy, Mjz]&#10;&#10;        # Final dimension check for return values&#10;        for i, (val, expected_dim) in enumerate(zip(ret_val, [&#10;            FORCE_DIMENSIONALITY, FORCE_DIMENSIONALITY, MOMENT_DIMENSIONALITY,&#10;            FORCE_DIMENSIONALITY, FORCE_DIMENSIONALITY, MOMENT_DIMENSIONALITY&#10;        ])):&#10;            try:&#10;                val.check(expected_dim)&#10;            except pint.DimensionalityError as e:&#10;                print(f&quot;ERROR: Dimensionality error in ret_val[{i}]: {e}&quot;)&#10;                print(f&quot;  Actual: {val.dimensionality}, Expected: {expected_dim}&quot;)&#10;&#10;        return ret_val&#10;&#10;    def print_detailed_analysis(self, num_points=10, chart_width=60, chart_height=15):&#10;        &quot;&quot;&quot;&#10;        Extended version of the base class method with point load specific information.&#10;        &quot;&quot;&quot;&#10;        print(f&quot;Point load of {self.p:.3f} at x={self.a:.3f}&quot;)&#10;        print(f&quot;Member length: {self.L:.3f}&quot;)&#10;        print(f&quot;Vertical reactions: Riy = {self.Riy:.3f}, Rjy = {self.Rjy:.3f}&quot;)&#10;        &#10;        # Call the parent class method to do the actual analysis&#10;        super().print_detailed_analysis(num_points, chart_width, chart_height)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/material.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/material.py" />
              <option name="originalContent" value="from xarray.coding.times import resolve_time_unit_from_attrs_dtype&#10;&#10;import pyMAOS&#10;&#10;from typing import Union&#10;import pint&#10;from pyMAOS import unit_manager&#10;&#10;class LinearElasticMaterial():&#10;    def __init__(self, uid: int,&#10;                 density: Union[float, str, Quantity] = 7861.092937697687,&#10;                 E: Union[float, str,Quantity] = 199947961501.8826,&#10;                 nu: float = 0.3):&#10;        super().__init__()&#10;        self.uid = uid  # Unique Material Identifier&#10;        self.nu = nu  # Poisson's ratio (dimensionless)&#10;&#10;        import pint&#10;        if isinstance(E, pint.Quantity):&#10;            # If it's a pint Quantity, convert to SI units&#10;            self.E=E.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            self.E = self._parse_value_with_units(E, 'pressure')&#10;            if isinstance(self.E, pint.Quantity):&#10;                self.E = self.E.to_reduced_units()&#10;&#10;&#10;        if isinstance(density, pint.Quantity):&#10;            self.density=density.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            density = unit_manager.ureg(density).to_reduced_units()&#10;        print(&#10;            f&quot;LinearElasticMaterial uid {self.uid} initialized with density={self.density:.4g}, E={self.E:.3g}, nu={self.nu}&quot;)&#10;&#10;    def __setstate__(self, state):&#10;&#10;&#10;        # Initialize the object properly&#10;        self.__init__(state.get('uid'),&#10;                      unit_manager.ureg(state.get('density', &quot;0.284 lb/in^3&quot;)).to_reduced_units(),&#10;                      unit_manager.ureg(state.get('E', &quot;29000.0 ksi&quot;)).to_reduced_units(),&#10;                      state.get('nu', 0.3))&#10;&#10;    def _parse_value_with_units(self, value: Union[float, str], unit_type: str) -&gt; float:&#10;        &quot;&quot;&quot;&#10;        Parse a value that may be a float or string with units.&#10;        &#10;        Parameters&#10;        ----------&#10;        value : float or str&#10;            Value, either as a number or string with units (e.g., &quot;29000ksi&quot;, &quot;0.000284klb/in^3&quot;)&#10;        unit_type : str&#10;            Type of unit ('pressure', 'density')&#10;            &#10;        Returns&#10;        -------&#10;        float&#10;            Value in SI units&#10;        &quot;&quot;&quot;&#10;        # If it's already a number, return it as-is (assume SI units)&#10;        if isinstance(value, (int, float)):&#10;            return float(value)&#10;&#10;        # If it's a string, try to parse units&#10;        if isinstance(value, str):&#10;            try:&#10;                # Import the parse function from units_mod&#10;                from pyMAOS.pymaos_units import parse_value_with_units&#10;                import pint&#10;&#10;                # Parse the value string&#10;                parsed_value = parse_value_with_units(value)&#10;&#10;                # If it has units, convert to SI units&#10;                if isinstance(parsed_value, pint.Quantity):&#10;&#10;                    # Convert based on unit type&#10;                    if unit_type == 'pressure':&#10;                        # Young's modulus - convert to Pascals&#10;                        si_value = parsed_value.to('Pa')#.magnitude&#10;                    elif unit_type == 'density':&#10;                        # Density - convert to kg/m^3&#10;                        si_value = parsed_value.to('kg/m^3')#.magnitude&#10;                    else:&#10;                        # Fallback - just use the magnitude&#10;                        si_value = None&#10;                    return float(si_value)&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not convert '{value}' to SI units for {unit_type}: {e}&quot;)&#10;                # Fall back to magnitude if conversion fails&#10;                return&#10;&#10;    # If we get here, something unexpected happened&#10;        raise ValueError(f&quot;Unsupported material value type: {type(value)}&quot;)&#10;&#10;    def stress(self, strain):&#10;        return self.E * strain&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the material properties&quot;&quot;&quot;&#10;&#10;        units = pyMAOS.unit_manager.get_current_units()&#10;        e_display = self.E.to(units['pressure'])&#10;        density_display = self.density.to(units['density'])&#10;        # pressure_unit = units.get('pressure', 'Pa')&#10;        # density_unit = units.get('density', 'kg/m^3')&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={density_display:.4f}, E={e_display}, nu={self.nu}) in {units.get('name', 'default')} units&quot;&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return developer representation of the material&quot;&quot;&quot;&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={self.density:.4f}, E={self.E:.2f}, nu={self.nu})&quot;&#10;&#10;def get_materials_from_yaml(materials_yml, logger=None):&#10;    &quot;&quot;&quot;&#10;    Loads materials from a YAML file and converts properties to internal units&#10;&#10;    Parameters&#10;    ----------&#10;    materials_yml : str&#10;        Path to the materials YAML file&#10;    logger : logging.Logger, optional&#10;        Logger for output messages&#10;&#10;    Returns&#10;    -------&#10;    dict&#10;        Dictionary of materials with uid as key&#10;    &quot;&quot;&quot;&#10;    materials_dict = {}&#10;&#10;    # Use print or logger.info based on what's available&#10;    def log(message):&#10;        if logger:&#10;            logger.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    # Get internal units directly from unit_manager (force refresh)&#10;    import pyMAOS&#10;&#10;    # Debug the unit manager state&#10;    log(f&quot;Unit manager system: {pyMAOS.unit_manager.system_name}&quot;)&#10;    log(f&quot;Unit manager base units: Force={pyMAOS.unit_manager.INTERNAL_FORCE_UNIT}, Length={pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}&quot;)&#10;&#10;    # Force update derived units before accessing them&#10;    # pyMAOS.unit_manager._update_derived_units()&#10;&#10;    # Now get the updated internal units&#10;    internal_pressure_unit = pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT&#10;    internal_density_unit = pyMAOS.unit_manager.INTERNAL_DENSITY_UNIT&#10;    system_name = pyMAOS.unit_manager.system_name&#10;&#10;    log(f&quot;Loading materials from: {materials_yml}&quot;)&#10;    log(f&quot;Using internal unit system: {system_name}&quot;)&#10;    log(f&quot;Internal pressure unit: {internal_pressure_unit}&quot;)&#10;    log(f&quot;Internal pressure unit expanded: {pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT_EXPANDED}&quot;)&#10;    log(f&quot;Internal density unit: {internal_density_unit}&quot;)&#10;&#10;    # Rest of the function...&#10;&#10;    with open(materials_yml, 'r') as file:&#10;        import yaml&#10;        materials_list = yaml.unsafe_load(file)&#10;&#10;    # Process each material and convert units to internal units&#10;    for material in materials_list:&#10;        # If the material is already a LinearElasticMaterial instance, update its units&#10;        if hasattr(material, 'E') and hasattr(material, 'density'):&#10;            # Convert E to internal pressure units if it's a Quantity&#10;            import pint&#10;            if isinstance(material.E, pint.Quantity):&#10;                material.E = material.E.to(internal_pressure_unit)&#10;&#10;            # Convert density to internal density units if it's a Quantity&#10;            if isinstance(material.density, pint.Quantity):&#10;                material.density = material.density.to(internal_density_unit)&#10;&#10;            log(f&quot;Material {material.uid}: E={material.E}, density={material.density}&quot;)&#10;&#10;        # Add material to dictionary&#10;        materials_dict[material.uid] = material&#10;&#10;    log(f&quot;Loaded {len(materials_dict)} materials&quot;)&#10;    return materials_dict" />
              <option name="updatedContent" value="from xarray.coding.times import resolve_time_unit_from_attrs_dtype&#10;&#10;import pyMAOS&#10;&#10;from typing import Union&#10;import pint&#10;from pyMAOS import unit_manager&#10;&#10;class LinearElasticMaterial():&#10;    def __init__(self, uid: int,&#10;                 density: Union[float, str, Quantity] = 7861.092937697687,&#10;                 E: Union[float, str,Quantity] = 199947961501.8826,&#10;                 nu: float = 0.3):&#10;        super().__init__()&#10;        self.uid = uid  # Unique Material Identifier&#10;        self.nu = nu  # Poisson's ratio (dimensionless)&#10;&#10;        import pint&#10;        if isinstance(E, pint.Quantity):&#10;            # If it's a pint Quantity, convert to SI units&#10;            self.E=E.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            self.E = self._parse_value_with_units(E, 'pressure')&#10;            if isinstance(self.E, pint.Quantity):&#10;                self.E = self.E.to_reduced_units()&#10;&#10;&#10;        if isinstance(density, pint.Quantity):&#10;            self.density=density.to_reduced_units()  # .magnitude&#10;        else:&#10;            # If it's a float or string, parse it&#10;            density = unit_manager.ureg(density).to_reduced_units()&#10;        print(&#10;            f&quot;LinearElasticMaterial uid {self.uid} initialized with density={self.density:.4g}, E={self.E:.3g}, nu={self.nu}&quot;)&#10;&#10;    def __setstate__(self, state):&#10;&#10;&#10;        # Initialize the object properly&#10;        self.__init__(state.get('uid'),&#10;                      unit_manager.ureg(state.get('density', &quot;0.284 lb/in^3&quot;)).to_reduced_units(),&#10;                      unit_manager.ureg(state.get('E', &quot;29000.0 ksi&quot;)).to_reduced_units(),&#10;                      state.get('nu', 0.3))&#10;&#10;    def _parse_value_with_units(self, value: Union[float, str], unit_type: str) -&gt; float:&#10;        &quot;&quot;&quot;&#10;        Parse a value that may be a float or string with units.&#10;        &#10;        Parameters&#10;        ----------&#10;        value : float or str&#10;            Value, either as a number or string with units (e.g., &quot;29000ksi&quot;, &quot;0.000284klb/in^3&quot;)&#10;        unit_type : str&#10;            Type of unit ('pressure', 'density')&#10;            &#10;        Returns&#10;        -------&#10;        float&#10;            Value in SI units&#10;        &quot;&quot;&quot;&#10;        # If it's already a number, return it as-is (assume SI units)&#10;        if isinstance(value, (int, float)):&#10;            return float(value)&#10;&#10;        # If it's a string, try to parse units&#10;        if isinstance(value, str):&#10;            try:&#10;                # Import the parse function from units_mod&#10;                from pyMAOS.pymaos_units import parse_value_with_units&#10;                import pint&#10;&#10;                # Parse the value string&#10;                parsed_value = parse_value_with_units(value)&#10;&#10;                # If it has units, convert to SI units&#10;                if isinstance(parsed_value, pint.Quantity):&#10;&#10;                    # Convert based on unit type&#10;                    if unit_type == 'pressure':&#10;                        # Young's modulus - convert to Pascals&#10;                        si_value = parsed_value.to('Pa')#.magnitude&#10;                    elif unit_type == 'density':&#10;                        # Density - convert to kg/m^3&#10;                        si_value = parsed_value.to('kg/m^3')#.magnitude&#10;                    else:&#10;                        # Fallback - just use the magnitude&#10;                        si_value = None&#10;                    return float(si_value)&#10;            except Exception as e:&#10;                print(f&quot;Warning: Could not convert '{value}' to SI units for {unit_type}: {e}&quot;)&#10;                # Fall back to magnitude if conversion fails&#10;                return&#10;&#10;    # If we get here, something unexpected happened&#10;        raise ValueError(f&quot;Unsupported material value type: {type(value)}&quot;)&#10;&#10;    def stress(self, strain):&#10;        return self.E * strain&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the material properties&quot;&quot;&quot;&#10;&#10;        units = pyMAOS.unit_manager.get_current_units()&#10;        e_display = self.E.to(units['pressure'])&#10;        density_display = self.density.to(units['density'])&#10;        # pressure_unit = units.get('pressure', 'Pa')&#10;        # density_unit = units.get('density', 'kg/m^3')&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={density_display:.4f}, E={e_display}, nu={self.nu}) in {units.get('name', 'default')} units&quot;&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return developer representation of the material&quot;&quot;&quot;&#10;        return f&quot;LinearElasticMaterial(uid={self.uid}, density={self.density:.4f}, E={self.E:.2f}, nu={self.nu})&quot;&#10;&#10;def get_materials_from_yaml(materials_yml, logger=None):&#10;    &quot;&quot;&quot;&#10;    Loads materials from a YAML file and converts properties to internal units&#10;&#10;    Parameters&#10;    ----------&#10;    materials_yml : str&#10;        Path to the materials YAML file&#10;    logger : logging.Logger, optional&#10;        Logger for output messages&#10;&#10;    Returns&#10;    -------&#10;    dict&#10;        Dictionary of materials with uid as key&#10;    &quot;&quot;&quot;&#10;    materials_dict = {}&#10;&#10;    # Use print or logger.info based on what's available&#10;    def log(message):&#10;        if logger:&#10;            logger.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    # Get internal units directly from unit_manager (force refresh)&#10;    import pyMAOS&#10;&#10;    # Debug the unit manager state&#10;    log(f&quot;Unit manager system: {pyMAOS.unit_manager.system_name}&quot;)&#10;    log(f&quot;Unit manager base units: Force={pyMAOS.unit_manager.INTERNAL_FORCE_UNIT}, Length={pyMAOS.unit_manager.INTERNAL_LENGTH_UNIT}&quot;)&#10;&#10;    # Force update derived units before accessing them&#10;    # pyMAOS.unit_manager._update_derived_units()&#10;&#10;    # Now get the updated internal units&#10;    internal_pressure_unit = pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT&#10;    internal_density_unit = pyMAOS.unit_manager.INTERNAL_DENSITY_UNIT&#10;    system_name = pyMAOS.unit_manager.system_name&#10;&#10;    log(f&quot;Loading materials from: {materials_yml}&quot;)&#10;    log(f&quot;Using internal unit system: {system_name}&quot;)&#10;    log(f&quot;Internal pressure unit: {internal_pressure_unit}&quot;)&#10;    log(f&quot;Internal pressure unit expanded: {pyMAOS.unit_manager.INTERNAL_PRESSURE_UNIT_EXPANDED}&quot;)&#10;    log(f&quot;Internal density unit: {internal_density_unit}&quot;)&#10;&#10;    # Rest of the function...&#10;&#10;    with open(materials_yml, 'r') as file:&#10;        import yaml&#10;        materials_list = yaml.unsafe_load(file)&#10;&#10;    # Process each material and convert units to internal units&#10;    for material in materials_list:&#10;        # If the material is already a LinearElasticMaterial instance, update its units&#10;        if hasattr(material, 'E') and hasattr(material, 'density'):&#10;            # Convert E to internal pressure units if it's a Quantity&#10;            import pint&#10;            if isinstance(material.E, pint.Quantity):&#10;                material.E = material.E.to(internal_pressure_unit)&#10;&#10;            # Convert density to internal density units if it's a Quantity&#10;            if isinstance(material.density, pint.Quantity):&#10;                material.density = material.density.to(internal_density_unit)&#10;&#10;            log(f&quot;Material {material.uid}: E={material.E}, density={material.density}&quot;)&#10;&#10;        # Add material to dictionary&#10;        materials_dict[material.uid] = material&#10;&#10;    log(f&quot;Loaded {len(materials_dict)} materials&quot;)&#10;    return materials_dict" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyMAOS/pymaos_sections.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyMAOS/pymaos_sections.py" />
              <option name="originalContent" value="import numpy as np&#10;import pyMAOS&#10;from pyMAOS.unit_aware import UnitAwareMixin&#10;from quantity_utils import convert_registry&#10;&#10;from typing import Union&#10;import pint&#10;from pint import Quantity&#10;from math import isnan&#10;&#10;class Section():&#10;    def __init__(self, uid: int,&#10;                 Area: Union[str, Quantity],&#10;                 Ixx: Union[str, Quantity] = &quot;1.0 in^4&quot;,&#10;                 Iyy: Union[str, Quantity] = &quot;1.0 in^4&quot;,&#10;                 name: str = None):&#10;        &quot;&quot;&quot;&#10;        Initialize a section with proper unit validation.&#10;&#10;        Parameters&#10;        ----------&#10;        uid : int&#10;            Unique Section Identifier&#10;        Area : Union[str, Quantity]&#10;            Cross-sectional area with units (e.g. &quot;10 in^2&quot;)&#10;        Ixx : Union[str, Quantity], optional&#10;            Moment of inertia about x-axis with units (e.g. &quot;100 in^4&quot;)&#10;        Iyy : Union[str, Quantity], optional&#10;            Moment of inertia about y-axis with units (e.g. &quot;50 in^4&quot;)&#10;        name : str, optional&#10;            Name identifier for the section&#10;        &quot;&quot;&quot;&#10;        super().__init__()&#10;        self.uid = uid&#10;        self.name = name if name else f&quot;Section_{uid}&quot;&#10;&#10;        # Get internal units from unit manager&#10;        internal_area_unit = pyMAOS.unit_manager.INTERNAL_AREA_UNIT&#10;        internal_inertia_unit = pyMAOS.unit_manager.INTERNAL_MOMENT_OF_INERTIA_UNIT&#10;        system_name = pyMAOS.unit_manager.system_name&#10;&#10;        print(f&quot;Creating section {uid} using internal unit system: {system_name}&quot;)&#10;        print(f&quot;Internal area unit: {internal_area_unit}&quot;)&#10;        print(f&quot;Internal inertia unit: {internal_inertia_unit}&quot;)&#10;&#10;        # Handle Area - must be a string with units or a Quantity&#10;        if isinstance(Area, (int, float)):&#10;            raise TypeError(&quot;Area must be provided as a string with units or a Quantity object&quot;)&#10;&#10;        # Convert string to Quantity if needed&#10;        if not isinstance(Area, pint.Quantity):&#10;            Area = pyMAOS.unit_manager.ureg(Area)&#10;&#10;        # Validate dimensions for Area&#10;        if not Area.check({'[length]': 2}):&#10;            raise ValueError(f&quot;Area has incorrect dimensions: {Area.dimensionality}. &quot;&#10;                            f&quot;Expected dimensions: [length]^2&quot;)&#10;&#10;        # Store validated value in internal units&#10;        self.Area = Area.to(pyMAOS.unit_manager.INTERNAL_AREA_UNIT)&#10;&#10;        # Process Ixx - must be a string with units or a Quantity&#10;        if isinstance(Ixx, (int, float)):&#10;            raise ValueError(&quot;Ixx must be provided as a string with units or a Quantity object&quot;)&#10;&#10;        # Convert string to Quantity if needed&#10;        if not isinstance(Ixx, pint.Quantity):&#10;            try:&#10;                Ixx = pyMAOS.unit_manager.ureg(Ixx)&#10;            except Exception as e:&#10;                raise ValueError(f&quot;Invalid Ixx value: {Ixx}. Error: {e}&quot;)&#10;&#10;        # Validate dimensions for Ixx&#10;        if not Ixx.check({'[length]': 4}):&#10;            raise ValueError(f&quot;Ixx has incorrect dimensions: {Ixx.dimensionality}. &quot;&#10;                           f&quot;Expected dimensions: [length]^4&quot;)&#10;&#10;        # Convert to internal units&#10;        Ixx_internal = Ixx.to(internal_inertia_unit)&#10;&#10;        # Check for zero or negative values&#10;        if Ixx_internal.magnitude &lt;= 0:&#10;            raise ValueError(f&quot;Ixx must be greater than zero. Got: {Ixx}&quot;)&#10;&#10;        self.Ixx = Ixx_internal&#10;        print(f&quot;Processed Ixx = {self.Ixx}&quot;)&#10;&#10;        # Process Iyy - must be a string with units or a Quantity&#10;        if isinstance(Iyy, (int, float)):&#10;            raise ValueError(&quot;Iyy must be provided as a string with units or a Quantity object&quot;)&#10;&#10;        # Convert string to Quantity if needed&#10;        if not isinstance(Iyy, pint.Quantity):&#10;            try:&#10;                Iyy = pyMAOS.unit_manager.ureg(Iyy)&#10;            except Exception as e:&#10;                raise ValueError(f&quot;Invalid Iyy value: {Iyy}. Error: {e}&quot;)&#10;&#10;        # Validate dimensions for Iyy&#10;        if not Iyy.check({'[length]': 4}):&#10;            raise ValueError(f&quot;Iyy has incorrect dimensions: {Iyy.dimensionality}. &quot;&#10;                           f&quot;Expected dimensions: [length]^4&quot;)&#10;&#10;        # Convert to internal units&#10;        Iyy_internal = Iyy.to(internal_inertia_unit)&#10;&#10;        # Check for zero or negative values&#10;        if Iyy_internal.magnitude &lt;= 0:&#10;            raise ValueError(f&quot;Iyy must be greater than zero. Got: {Iyy}&quot;)&#10;&#10;        self.Iyy = Iyy_internal&#10;        print(f&quot;Processed Iyy = {self.Iyy}&quot;)&#10;&#10;    def __setstate__(self, state):&#10;        &quot;&quot;&quot;&#10;        Restore the object state during unpickling.&#10;        &quot;&quot;&quot;&#10;        print(state)&#10;        uid = state.get('uid', 1)&#10;&#10;        # Get Area - this is required&#10;        area = state.get('Area', &quot;1.0 m^2&quot;)  # Use a non-zero default with units&#10;&#10;        # For moments of inertia, use valid default values with units&#10;        ixx = state.get('Ixx', &quot;1.0 in^4&quot;)&#10;        if isinstance(ixx, float) and (np.isnan(ixx) or ixx &lt;= 0):&#10;            ixx = &quot;1.0 in^4&quot;  # Use a non-zero default&#10;&#10;        iyy = state.get('Iyy', &quot;1.0 in^4&quot;)&#10;        if isinstance(iyy, float) and (np.isnan(iyy) or iyy &lt;= 0):&#10;            iyy = &quot;1.0 in^4&quot;  # Use a non-zero default&#10;&#10;        # Get name if it exists&#10;        name = state.get('name', None)&#10;&#10;        # Let __init__ handle the validation&#10;        self.__init__(uid=uid, Area=area, Ixx=ixx, Iyy=iyy, name=name)&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the section properties&quot;&quot;&quot;&#10;        units = pyMAOS.unit_manager.get_current_units()&#10;        area_display = self.Area.to(units['area'])&#10;&#10;        # Handle possible NaN values for moments of inertia&#10;        if isinstance(self.Ixx, (int, float)) and np.isnan(self.Ixx):&#10;            ixx_display = &quot;NaN&quot;&#10;        else:&#10;            ixx_display = self.Ixx.to(units['moment_of_inertia'])&#10;&#10;        if isinstance(self.Iyy, (int, float)) and np.isnan(self.Iyy):&#10;            iyy_display = &quot;NaN&quot;&#10;        else:&#10;            iyy_display = self.Iyy.to(units['moment_of_inertia'])&#10;&#10;        return f&quot;Section {self.name} (ID: {self.uid}): A={area_display:.2f}, Ixx={ixx_display:.2f}, Iyy={iyy_display}&quot;&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return developer representation of the section&quot;&quot;&quot;&#10;        return f&quot;Section(uid={self.uid}, name='{self.name}', Area={self.Area}, Ixx={self.Ixx}, Iyy={self.Iyy})&quot;&#10;&#10;def get_sections_from_yaml(sections_yml, logger=None):&#10;    &quot;&quot;&quot;&#10;    Loads sections from a YAML file and returns them as a dictionary.&#10;&#10;    Parameters&#10;    ----------&#10;    sections_yml : str&#10;        Path to the sections YAML file&#10;    logger : logging.Logger, optional&#10;        Logger for output messages&#10;&#10;    Returns&#10;    -------&#10;    dict&#10;        Dictionary of sections with uid as key&#10;    &quot;&quot;&quot;&#10;    def log(message):&#10;        if logger:&#10;            pyMAOS.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    pyMAOS.info(f&quot;Loading sections from: {sections_yml}&quot;)&#10;&#10;    try:&#10;        import yaml&#10;        with open(sections_yml, 'r') as file:&#10;            sections_list = yaml.unsafe_load(file)&#10;&#10;        # Convert list to dictionary with uid as key&#10;        sections_dict = {section.uid: section for section in sections_list}&#10;&#10;        pyMAOS.info(f&quot;Loaded {len(sections_dict)} sections&quot;)&#10;        return sections_dict&#10;    except Exception as e:&#10;        pyMAOS.info(f&quot;Error loading sections from {sections_yml}: {e}&quot;)&#10;        return {}&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;import pyMAOS&#10;from pyMAOS.unit_aware import UnitAwareMixin&#10;from quantity_utils import convert_registry&#10;&#10;from typing import Union&#10;import pint&#10;from pint import Quantity&#10;from math import isnan&#10;&#10;class Section():&#10;    def __init__(self, uid: int,&#10;                 Area: Union[str, Quantity],&#10;                 Ixx: Union[str, Quantity] = &quot;1.0 in^4&quot;,&#10;                 Iyy: Union[str, Quantity] = &quot;1.0 in^4&quot;,&#10;                 name: str = None):&#10;        &quot;&quot;&quot;&#10;        Initialize a section with proper unit validation.&#10;&#10;        Parameters&#10;        ----------&#10;        uid : int&#10;            Unique Section Identifier&#10;        Area : Union[str, Quantity]&#10;            Cross-sectional area with units (e.g. &quot;10 in^2&quot;)&#10;        Ixx : Union[str, Quantity], optional&#10;            Moment of inertia about x-axis with units (e.g. &quot;100 in^4&quot;)&#10;        Iyy : Union[str, Quantity], optional&#10;            Moment of inertia about y-axis with units (e.g. &quot;50 in^4&quot;)&#10;        name : str, optional&#10;            Name identifier for the section&#10;        &quot;&quot;&quot;&#10;        super().__init__()&#10;        self.uid = uid&#10;        self.name = name if name else f&quot;Section_{uid}&quot;&#10;&#10;        # Get internal units from unit manager&#10;        internal_area_unit = pyMAOS.unit_manager.INTERNAL_AREA_UNIT&#10;        internal_inertia_unit = pyMAOS.unit_manager.INTERNAL_MOMENT_OF_INERTIA_UNIT&#10;        system_name = pyMAOS.unit_manager.system_name&#10;&#10;        print(f&quot;Creating section {uid} using internal unit system: {system_name}&quot;)&#10;        print(f&quot;Internal area unit: {internal_area_unit}&quot;)&#10;        print(f&quot;Internal inertia unit: {internal_inertia_unit}&quot;)&#10;&#10;        # Handle Area - must be a string with units or a Quantity&#10;        if isinstance(Area, (int, float)):&#10;            raise TypeError(&quot;Area must be provided as a string with units or a Quantity object&quot;)&#10;&#10;        # Convert string to Quantity if needed&#10;        if not isinstance(Area, pint.Quantity):&#10;            Area = pyMAOS.unit_manager.ureg(Area)&#10;&#10;        # Validate dimensions for Area&#10;        if not Area.check({'[length]': 2}):&#10;            raise ValueError(f&quot;Area has incorrect dimensions: {Area.dimensionality}. &quot;&#10;                            f&quot;Expected dimensions: [length]^2&quot;)&#10;&#10;        # Store validated value in internal units&#10;        self.Area = Area.to(pyMAOS.unit_manager.INTERNAL_AREA_UNIT)&#10;&#10;        # Process Ixx - must be a string with units or a Quantity&#10;        if isinstance(Ixx, (int, float)):&#10;            raise ValueError(&quot;Ixx must be provided as a string with units or a Quantity object&quot;)&#10;&#10;        # Convert string to Quantity if needed&#10;        if not isinstance(Ixx, pint.Quantity):&#10;            try:&#10;                Ixx = pyMAOS.unit_manager.ureg(Ixx)&#10;            except Exception as e:&#10;                raise ValueError(f&quot;Invalid Ixx value: {Ixx}. Error: {e}&quot;)&#10;&#10;        # Validate dimensions for Ixx&#10;        if not Ixx.check({'[length]': 4}):&#10;            raise ValueError(f&quot;Ixx has incorrect dimensions: {Ixx.dimensionality}. &quot;&#10;                           f&quot;Expected dimensions: [length]^4&quot;)&#10;&#10;        # Convert to internal units&#10;        Ixx_internal = Ixx.to(internal_inertia_unit)&#10;&#10;        # Check for zero or negative values&#10;        if Ixx_internal.magnitude &lt;= 0:&#10;            raise ValueError(f&quot;Ixx must be greater than zero. Got: {Ixx}&quot;)&#10;&#10;        self.Ixx = Ixx_internal&#10;        print(f&quot;Processed Ixx = {self.Ixx}&quot;)&#10;&#10;        # Process Iyy - must be a string with units or a Quantity&#10;        if isinstance(Iyy, (int, float)):&#10;            raise ValueError(&quot;Iyy must be provided as a string with units or a Quantity object&quot;)&#10;&#10;        # Convert string to Quantity if needed&#10;        if not isinstance(Iyy, pint.Quantity):&#10;            try:&#10;                Iyy = pyMAOS.unit_manager.ureg(Iyy)&#10;            except Exception as e:&#10;                raise ValueError(f&quot;Invalid Iyy value: {Iyy}. Error: {e}&quot;)&#10;&#10;        # Validate dimensions for Iyy&#10;        if not Iyy.check({'[length]': 4}):&#10;            raise ValueError(f&quot;Iyy has incorrect dimensions: {Iyy.dimensionality}. &quot;&#10;                           f&quot;Expected dimensions: [length]^4&quot;)&#10;&#10;        # Convert to internal units&#10;        Iyy_internal = Iyy.to(internal_inertia_unit)&#10;&#10;        # Check for zero or negative values&#10;        if Iyy_internal.magnitude &lt;= 0:&#10;            raise ValueError(f&quot;Iyy must be greater than zero. Got: {Iyy}&quot;)&#10;&#10;        self.Iyy = Iyy_internal&#10;        print(f&quot;Processed Iyy = {self.Iyy}&quot;)&#10;&#10;    def __setstate__(self, state):&#10;        &quot;&quot;&quot;&#10;        Restore the object state during unpickling.&#10;&#10;        Parameters&#10;        ----------&#10;        state : dict&#10;            Dictionary containing the object state&#10;        &quot;&quot;&quot;&#10;        # Handle Area value properly based on its type&#10;        area_value = state.get('Area', &quot;1.0 in^2&quot;)&#10;        if isinstance(area_value, (int, float)):&#10;            pyMAOS.warning(f&quot;assuming Area {area_value} is in {pyMAOS.unit_manager.INTERNAL_AREA_UNIT}&quot;)&#10;            area_quantity = pyMAOS.unit_manager.ureg.Quantity(area_value, pyMAOS.unit_manager.INTERNAL_AREA_UNIT)&#10;        elif isinstance(area_value, pint.Quantity):&#10;            # If it's already a Quantity object, use it directly&#10;            area_quantity = convert_registry(area_value, pyMAOS.unit_manager.ureg)&#10;        else:&#10;            # If it's a string, parse it with ureg&#10;            area_quantity = pyMAOS.unit_manager.ureg(area_value)&#10;        &#10;        # Handle Ixx value properly based on its type&#10;        ixx_value = state.get('Ixx', &quot;1.0 in^4&quot;)&#10;        if isinstance(ixx_value, (int, float)):&#10;            if np.isnan(ixx_value) or ixx_value &lt;= 0:&#10;                ixx_value = &quot;1.0 in^4&quot;  # Use a non-zero default with units&#10;                pyMAOS.warning(f&quot;Invalid Ixx value detected, using default: {ixx_value}&quot;)&#10;            else:&#10;                pyMAOS.warning(f&quot;assuming Ixx {ixx_value} is in {pyMAOS.unit_manager.INTERNAL_MOMENT_OF_INERTIA_UNIT}&quot;)&#10;                ixx_quantity = pyMAOS.unit_manager.ureg.Quantity(ixx_value, pyMAOS.unit_manager.INTERNAL_MOMENT_OF_INERTIA_UNIT)&#10;        elif isinstance(ixx_value, pint.Quantity):&#10;            # If it's already a Quantity object, use it directly&#10;            ixx_quantity = convert_registry(ixx_value, pyMAOS.unit_manager.ureg)&#10;        else:&#10;            # If it's a string, parse it with ureg&#10;            ixx_quantity = pyMAOS.unit_manager.ureg(ixx_value)&#10;        &#10;        # Handle Iyy value properly based on its type&#10;        iyy_value = state.get('Iyy', &quot;1.0 in^4&quot;)&#10;        if isinstance(iyy_value, (int, float)):&#10;            if np.isnan(iyy_value) or iyy_value &lt;= 0:&#10;                iyy_value = &quot;1.0 in^4&quot;  # Use a non-zero default with units&#10;                pyMAOS.warning(f&quot;Invalid Iyy value detected, using default: {iyy_value}&quot;)&#10;            else:&#10;                pyMAOS.warning(f&quot;assuming Iyy {iyy_value} is in {pyMAOS.unit_manager.INTERNAL_MOMENT_OF_INERTIA_UNIT}&quot;)&#10;                iyy_quantity = pyMAOS.unit_manager.ureg.Quantity(iyy_value, pyMAOS.unit_manager.INTERNAL_MOMENT_OF_INERTIA_UNIT)&#10;        elif isinstance(iyy_value, pint.Quantity):&#10;            # If it's already a Quantity object, use it directly&#10;            iyy_quantity = convert_registry(iyy_value, pyMAOS.unit_manager.ureg)&#10;        else:&#10;            # If it's a string, parse it with ureg&#10;            iyy_quantity = pyMAOS.unit_manager.ureg(iyy_value)&#10;        &#10;        # Get name if it exists&#10;        name = state.get('name', None)&#10;        &#10;        # Pass the values directly to __init__ for validation and processing&#10;        self.__init__(&#10;            uid=state.get('uid', 0),&#10;            Area=area_quantity,&#10;            Ixx=ixx_quantity,&#10;            Iyy=iyy_quantity,&#10;            name=name&#10;        )&#10;&#10;    def __str__(self):&#10;        &quot;&quot;&quot;Return string representation of the section properties&quot;&quot;&quot;&#10;        units = pyMAOS.unit_manager.get_current_units()&#10;        area_display = self.Area.to(units['area'])&#10;&#10;        # Handle possible NaN values for moments of inertia&#10;        if isinstance(self.Ixx, (int, float)) and np.isnan(self.Ixx):&#10;            ixx_display = &quot;NaN&quot;&#10;        else:&#10;            ixx_display = self.Ixx.to(units['moment_of_inertia'])&#10;&#10;        if isinstance(self.Iyy, (int, float)) and np.isnan(self.Iyy):&#10;            iyy_display = &quot;NaN&quot;&#10;        else:&#10;            iyy_display = self.Iyy.to(units['moment_of_inertia'])&#10;&#10;        return f&quot;Section {self.name} (ID: {self.uid}): A={area_display:.2f}, Ixx={ixx_display:.2f}, Iyy={iyy_display}&quot;&#10;&#10;    def __repr__(self):&#10;        &quot;&quot;&quot;Return developer representation of the section&quot;&quot;&quot;&#10;        return f&quot;Section(uid={self.uid}, name='{self.name}', Area={self.Area}, Ixx={self.Ixx}, Iyy={self.Iyy})&quot;&#10;&#10;def get_sections_from_yaml(sections_yml, logger=None):&#10;    &quot;&quot;&quot;&#10;    Loads sections from a YAML file and returns them as a dictionary.&#10;&#10;    Parameters&#10;    ----------&#10;    sections_yml : str&#10;        Path to the sections YAML file&#10;    logger : logging.Logger, optional&#10;        Logger for output messages&#10;&#10;    Returns&#10;    -------&#10;    dict&#10;        Dictionary of sections with uid as key&#10;    &quot;&quot;&quot;&#10;    def log(message):&#10;        if logger:&#10;            pyMAOS.info(message)&#10;        else:&#10;            print(message)&#10;&#10;    pyMAOS.info(f&quot;Loading sections from: {sections_yml}&quot;)&#10;&#10;    try:&#10;        import yaml&#10;        with open(sections_yml, 'r') as file:&#10;            sections_list = yaml.unsafe_load(file)&#10;&#10;        # Convert list to dictionary with uid as key&#10;        sections_dict = {section.uid: section for section in sections_list}&#10;&#10;        pyMAOS.info(f&quot;Loaded {len(sections_dict)} sections&quot;)&#10;        return sections_dict&#10;    except Exception as e:&#10;        pyMAOS.info(f&quot;Error loading sections from {sections_yml}: {e}&quot;)&#10;        return {}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Baltimore_Space_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Baltimore_Space_Truss.YAML" />
              <option name="updatedContent" value="# Baltimore space truss bridge example with units&#10;# This structure consists of two parallel Baltimore trusses connected with transverse members&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # First truss - Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Intermediate nodes for sub-diagonals&#10;  - id: 13&#10;    x: 10 ft&#10;    y: 10 ft&#10;    z: 0 ft&#10;  - id: 14&#10;    x: 30 ft&#10;    y: 10 ft&#10;    z: 0 ft&#10;  - id: 15&#10;    x: 50 ft&#10;    y: 10 ft&#10;    z: 0 ft&#10;  - id: 16&#10;    x: 70 ft&#10;    y: 10 ft&#10;    z: 0 ft&#10;  - id: 17&#10;    x: 90 ft&#10;    y: 10 ft&#10;    z: 0 ft&#10;&#10;  # Second truss - Bottom chord nodes&#10;  - id: 18&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 19&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 20&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 21&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 22&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 23&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Top chord nodes&#10;  - id: 24&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 25&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 26&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 27&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 28&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 29&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Intermediate nodes for sub-diagonals&#10;  - id: 30&#10;    x: 10 ft&#10;    y: 10 ft&#10;    z: 20 ft&#10;  - id: 31&#10;    x: 30 ft&#10;    y: 10 ft&#10;    z: 20 ft&#10;  - id: 32&#10;    x: 50 ft&#10;    y: 10 ft&#10;    z: 20 ft&#10;  - id: 33&#10;    x: 70 ft&#10;    y: 10 ft&#10;    z: 20 ft&#10;  - id: 34&#10;    x: 90 ft&#10;    y: 10 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # First truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Fixed support at left end of first truss&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of first truss&#10;  &#10;  # Second truss supports&#10;  - node: 18&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at left end of second truss&#10;  - node: 23&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of second truss&#10;&#10;members:&#10;  # First truss - Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # First truss - Diagonal members&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # First truss - Sub-diagonal members&#10;  - id: 22&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 24&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Bottom chord members&#10;  - id: 26&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 27&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 22&#10;    j_node: 23&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Top chord members&#10;  - id: 31&#10;    i_node: 24&#10;    j_node: 25&#10;    material: 1&#10;    section: 1&#10;  - id: 32&#10;    i_node: 25&#10;    j_node: 26&#10;    material: 1&#10;    section: 1&#10;  - id: 33&#10;    i_node: 26&#10;    j_node: 27&#10;    material: 1&#10;    section: 1&#10;  - id: 34&#10;    i_node: 27&#10;    j_node: 28&#10;    material: 1&#10;    section: 1&#10;  - id: 35&#10;    i_node: 28&#10;    j_node: 29&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Vertical members&#10;  - id: 36&#10;    i_node: 18&#10;    j_node: 24&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 19&#10;    j_node: 25&#10;    material: 1&#10;    section: 2&#10;  - id: 38&#10;    i_node: 20&#10;    j_node: 26&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 21&#10;    j_node: 27&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 22&#10;    j_node: 28&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 23&#10;    j_node: 29&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Diagonal members&#10;  - id: 42&#10;    i_node: 24&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 43&#10;    i_node: 25&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 44&#10;    i_node: 26&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 45&#10;    i_node: 27&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  - id: 46&#10;    i_node: 28&#10;    j_node: 23&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Sub-diagonal members&#10;  - id: 47&#10;    i_node: 19&#10;    j_node: 30&#10;    material: 1&#10;    section: 2&#10;  - id: 48&#10;    i_node: 30&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 49&#10;    i_node: 21&#10;    j_node: 32&#10;    material: 1&#10;    section: 2&#10;  - id: 50&#10;    i_node: 32&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;&#10;  # Transverse members connecting bottom chords&#10;  - id: 51&#10;    i_node: 1&#10;    j_node: 18&#10;    material: 1&#10;    section: 3  # HSS6x6x3/8 for transverse members&#10;  - id: 52&#10;    i_node: 2&#10;    j_node: 19&#10;    material: 1&#10;    section: 3&#10;  - id: 53&#10;    i_node: 3&#10;    j_node: 20&#10;    material: 1&#10;    section: 3&#10;  - id: 54&#10;    i_node: 4&#10;    j_node: 21&#10;    material: 1&#10;    section: 3&#10;  - id: 55&#10;    i_node: 5&#10;    j_node: 22&#10;    material: 1&#10;    section: 3&#10;  - id: 56&#10;    i_node: 6&#10;    j_node: 23&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting top chords&#10;  - id: 57&#10;    i_node: 7&#10;    j_node: 24&#10;    material: 1&#10;    section: 3&#10;  - id: 58&#10;    i_node: 8&#10;    j_node: 25&#10;    material: 1&#10;    section: 3&#10;  - id: 59&#10;    i_node: 9&#10;    j_node: 26&#10;    material: 1&#10;    section: 3&#10;  - id: 60&#10;    i_node: 10&#10;    j_node: 27&#10;    material: 1&#10;    section: 3&#10;  - id: 61&#10;    i_node: 11&#10;    j_node: 28&#10;    material: 1&#10;    section: 3&#10;  - id: 62&#10;    i_node: 12&#10;    j_node: 29&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting intermediate nodes&#10;  - id: 63&#10;    i_node: 13&#10;    j_node: 30&#10;    material: 1&#10;    section: 3&#10;  - id: 64&#10;    i_node: 14&#10;    j_node: 31&#10;    material: 1&#10;    section: 3&#10;  - id: 65&#10;    i_node: 15&#10;    j_node: 32&#10;    material: 1&#10;    section: 3&#10;  - id: 66&#10;    i_node: 16&#10;    j_node: 33&#10;    material: 1&#10;    section: 3&#10;  - id: 67&#10;    i_node: 17&#10;    j_node: 34&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing for lateral stability - Bottom plane&#10;  - id: 68&#10;    i_node: 1&#10;    j_node: 19&#10;    material: 1&#10;    section: 4  # L4x4x1/2 angle for bracing&#10;  - id: 69&#10;    i_node: 2&#10;    j_node: 20&#10;    material: 1&#10;    section: 4&#10;  - id: 70&#10;    i_node: 3&#10;    j_node: 21&#10;    material: 1&#10;    section: 4&#10;  - id: 71&#10;    i_node: 4&#10;    j_node: 22&#10;    material: 1&#10;    section: 4&#10;  - id: 72&#10;    i_node: 5&#10;    j_node: 23&#10;    material: 1&#10;    section: 4&#10;&#10;  # Diagonal bracing for lateral stability - Top plane&#10;  - id: 73&#10;    i_node: 7&#10;    j_node: 25&#10;    material: 1&#10;    section: 4&#10;  - id: 74&#10;    i_node: 8&#10;    j_node: 26&#10;    material: 1&#10;    section: 4&#10;  - id: 75&#10;    i_node: 9&#10;    j_node: 27&#10;    material: 1&#10;    section: 4&#10;  - id: 76&#10;    i_node: 10&#10;    j_node: 28&#10;    material: 1&#10;    section: 4&#10;  - id: 77&#10;    i_node: 11&#10;    j_node: 29&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord of first truss&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord of second truss&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 27&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 28&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 29&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 30&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse member loads&#10;  - member_uid: 51&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 52&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 53&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 54&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 55&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 56&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Baltimore_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Baltimore_Truss.YAML" />
              <option name="originalContent" value="# Baltimore truss bridge example with units&#10;# This truss is a variation of the Pratt truss with additional bracing for longer spans.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;  # Intermediate nodes for sub-diagonals&#10;  - id: 13&#10;    x: 10 ft&#10;    y: 10 ft&#10;  - id: 14&#10;    x: 30 ft&#10;    y: 10 ft&#10;  - id: 15&#10;    x: 50 ft&#10;    y: 10 ft&#10;  - id: 16&#10;    x: 70 ft&#10;    y: 10 ft&#10;  - id: 17&#10;    x: 90 ft&#10;    y: 10 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # Sub-diagonal members&#10;  - id: 22&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 24&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
              <option name="updatedContent" value="# Baltimore truss bridge example with units&#10;# This truss is a variation of the Pratt truss with additional bracing for longer spans.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;  # Intermediate nodes for sub-diagonals&#10;  - id: 13&#10;    x: 10 ft&#10;    y: 10 ft&#10;  - id: 14&#10;    x: 30 ft&#10;    y: 10 ft&#10;  - id: 15&#10;    x: 50 ft&#10;    y: 10 ft&#10;  - id: 16&#10;    x: 70 ft&#10;    y: 10 ft&#10;  - id: 17&#10;    x: 90 ft&#10;    y: 10 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel (29000 ksi)&#10;    section: 1   # W12x26 (7.65 in^2, Ixx=204 in^4)&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31 (9.13 in^2, Ixx=110 in^4)&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # Sub-diagonal members&#10;  - id: 22&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 24&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Howe_Space_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Howe_Space_Truss.YAML" />
              <option name="updatedContent" value="# Howe space truss bridge example with units&#10;# This structure consists of two parallel Howe trusses connected with transverse members&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # First truss - Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # Second truss - Bottom chord nodes&#10;  - id: 13&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 14&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 15&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 16&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 17&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 18&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Top chord nodes&#10;  - id: 19&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 20&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 21&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 22&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 23&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 24&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # First truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Fixed support at left end of first truss&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of first truss&#10;  &#10;  # Second truss supports&#10;  - node: 13&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at left end of second truss&#10;  - node: 18&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of second truss&#10;&#10;members:&#10;  # First truss - Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # First truss - Diagonal members (sloping up toward center - Howe pattern)&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 6&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Bottom chord members&#10;  - id: 22&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 17&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Top chord members&#10;  - id: 27&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 22&#10;    j_node: 23&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 23&#10;    j_node: 24&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Vertical members&#10;  - id: 32&#10;    i_node: 13&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 14&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 15&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 16&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 17&#10;    j_node: 23&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 18&#10;    j_node: 24&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Diagonal members (sloping up toward center - Howe pattern)&#10;  - id: 38&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 17&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 18&#10;    j_node: 23&#10;    material: 1&#10;    section: 2&#10;&#10;  # Transverse members connecting bottom chords&#10;  - id: 43&#10;    i_node: 1&#10;    j_node: 13&#10;    material: 1&#10;    section: 3  # HSS6x6x3/8 for transverse members&#10;  - id: 44&#10;    i_node: 2&#10;    j_node: 14&#10;    material: 1&#10;    section: 3&#10;  - id: 45&#10;    i_node: 3&#10;    j_node: 15&#10;    material: 1&#10;    section: 3&#10;  - id: 46&#10;    i_node: 4&#10;    j_node: 16&#10;    material: 1&#10;    section: 3&#10;  - id: 47&#10;    i_node: 5&#10;    j_node: 17&#10;    material: 1&#10;    section: 3&#10;  - id: 48&#10;    i_node: 6&#10;    j_node: 18&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting top chords&#10;  - id: 49&#10;    i_node: 7&#10;    j_node: 19&#10;    material: 1&#10;    section: 3&#10;  - id: 50&#10;    i_node: 8&#10;    j_node: 20&#10;    material: 1&#10;    section: 3&#10;  - id: 51&#10;    i_node: 9&#10;    j_node: 21&#10;    material: 1&#10;    section: 3&#10;  - id: 52&#10;    i_node: 10&#10;    j_node: 22&#10;    material: 1&#10;    section: 3&#10;  - id: 53&#10;    i_node: 11&#10;    j_node: 23&#10;    material: 1&#10;    section: 3&#10;  - id: 54&#10;    i_node: 12&#10;    j_node: 24&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing for lateral stability - Bottom plane&#10;  - id: 55&#10;    i_node: 1&#10;    j_node: 14&#10;    material: 1&#10;    section: 4  # L4x4x1/2 angle for bracing&#10;  - id: 56&#10;    i_node: 2&#10;    j_node: 15&#10;    material: 1&#10;    section: 4&#10;  - id: 57&#10;    i_node: 3&#10;    j_node: 16&#10;    material: 1&#10;    section: 4&#10;  - id: 58&#10;    i_node: 4&#10;    j_node: 17&#10;    material: 1&#10;    section: 4&#10;  - id: 59&#10;    i_node: 5&#10;    j_node: 18&#10;    material: 1&#10;    section: 4&#10;&#10;  # Diagonal bracing for lateral stability - Top plane&#10;  - id: 60&#10;    i_node: 7&#10;    j_node: 20&#10;    material: 1&#10;    section: 4&#10;  - id: 61&#10;    i_node: 8&#10;    j_node: 21&#10;    material: 1&#10;    section: 4&#10;  - id: 62&#10;    i_node: 9&#10;    j_node: 22&#10;    material: 1&#10;    section: 4&#10;  - id: 63&#10;    i_node: 10&#10;    j_node: 23&#10;    material: 1&#10;    section: 4&#10;  - id: 64&#10;    i_node: 11&#10;    j_node: 24&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord of first truss&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord of second truss&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse member loads&#10;  - member_uid: 43&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 44&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 45&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 46&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 47&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 48&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Howe_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Howe_Truss.YAML" />
              <option name="originalContent" value="# Howe truss bridge example with units&#10;# This truss has diagonal members that slope upward toward the center, typically placing diagonals in compression under vertical loads.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (sloping up toward center - Howe pattern)&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 6&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
              <option name="updatedContent" value="# Howe truss bridge example with units&#10;# This truss has diagonal members that slope upward toward the center, typically placing diagonals in compression under vertical loads.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel (29000 ksi)&#10;    section: 1   # W12x26 (7.65 in^2, Ixx=204 in^4)&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31 (9.13 in^2, Ixx=110 in^4)&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (sloping up toward center - Howe pattern)&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 6&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/K_Space_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/K_Space_Truss.YAML" />
              <option name="updatedContent" value="# K-Space-Truss bridge example with units&#10;# This structure consists of two parallel K-trusses connected with transverse members&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # First truss - Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # Second truss - Bottom chord nodes&#10;  - id: 12&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 13&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 14&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 15&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 16&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 17&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Top chord nodes&#10;  - id: 18&#10;    x: 10 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 19&#10;    x: 30 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 20&#10;    x: 50 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 21&#10;    x: 70 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 22&#10;    x: 90 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # First truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  &#10;  # Second truss supports&#10;  - node: 12&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;&#10;members:&#10;  # First truss - Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Vertical members&#10;  - id: 10&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 11&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;  # First truss - Diagonal members (K-pattern)&#10;  - id: 14&#10;    i_node: 7&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 8&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 9&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Bottom chord members&#10;  - id: 20&#10;    i_node: 12&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 21&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 22&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Top chord members&#10;  - id: 25&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 27&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Vertical members&#10;  - id: 29&#10;    i_node: 13&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 30&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 31&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 32&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Diagonal members (K-pattern)&#10;  - id: 33&#10;    i_node: 18&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 19&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 20&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 13&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 14&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 38&#10;    i_node: 15&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;&#10;  # Transverse members connecting bottom chords&#10;  - id: 39&#10;    i_node: 1&#10;    j_node: 12&#10;    material: 1&#10;    section: 3  # HSS6x6x3/8 for transverse members&#10;  - id: 40&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 3&#10;  - id: 41&#10;    i_node: 3&#10;    j_node: 14&#10;    material: 1&#10;    section: 3&#10;  - id: 42&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 3&#10;  - id: 43&#10;    i_node: 5&#10;    j_node: 16&#10;    material: 1&#10;    section: 3&#10;  - id: 44&#10;    i_node: 6&#10;    j_node: 17&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting top chords&#10;  - id: 45&#10;    i_node: 7&#10;    j_node: 18&#10;    material: 1&#10;    section: 3&#10;  - id: 46&#10;    i_node: 8&#10;    j_node: 19&#10;    material: 1&#10;    section: 3&#10;  - id: 47&#10;    i_node: 9&#10;    j_node: 20&#10;    material: 1&#10;    section: 3&#10;  - id: 48&#10;    i_node: 10&#10;    j_node: 21&#10;    material: 1&#10;    section: 3&#10;  - id: 49&#10;    i_node: 11&#10;    j_node: 22&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing for lateral stability - Bottom plane&#10;  - id: 50&#10;    i_node: 1&#10;    j_node: 13&#10;    material: 1&#10;    section: 4  # L4x4x1/2 angle for bracing&#10;  - id: 51&#10;    i_node: 2&#10;    j_node: 14&#10;    material: 1&#10;    section: 4&#10;  - id: 52&#10;    i_node: 3&#10;    j_node: 15&#10;    material: 1&#10;    section: 4&#10;  - id: 53&#10;    i_node: 4&#10;    j_node: 16&#10;    material: 1&#10;    section: 4&#10;  - id: 54&#10;    i_node: 5&#10;    j_node: 17&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord of first truss&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord of second truss&#10;  - member_uid: 20&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 21&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -1.5 kip/ft&#10;    wj: -1.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse member loads&#10;  - member_uid: 39&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 40&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 41&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 42&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 43&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 44&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/K_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/K_Truss.YAML" />
              <option name="originalContent" value="# K-Truss bridge example with units&#10;# This truss has diagonal members forming a &quot;K&quot; shape, which helps distribute loads efficiently.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 10&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 11&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (K-pattern)&#10;  - id: 14&#10;    i_node: 7&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 8&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 9&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
              <option name="updatedContent" value="# K-Truss bridge example with units&#10;# This truss has diagonal members forming a &quot;K&quot; shape, which helps distribute loads efficiently.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel (29000 ksi)&#10;    section: 1   # W12x26 (7.65 in^2, Ixx=204 in^4)&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 10&#10;    i_node: 2&#10;    j_node: 7&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31 (9.13 in^2, Ixx=110 in^4)&#10;  - id: 11&#10;    i_node: 3&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 4&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 5&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (K-pattern)&#10;  - id: 14&#10;    i_node: 7&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 8&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 9&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 17&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Pratt_Bridge.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Pratt_Bridge.YAML" />
              <option name="originalContent" value="# Pratt bridge example with two spans and units&#10;# Both spans have diagonals sloping toward the center (which places diagonals in tension under vertical loads)&#10;# Key design features:&#10;#&#10;#&#10;# The bridge has two 100 ft spans (200 ft total length)&#10;# Central node 6 serves as the pier connection point for both spans&#10;# Diagonals in the left span slope down toward the center (right)&#10;# Diagonals in the right span slope down toward the center (left)&#10;# Supports are at node 1 (pinned), node 6 (pinned pier), and node 17 (roller)&#10;# Both spans use the same materials, sections, and loading&#10;# This arrangement ensures that diagonals in both spans will primarily experience tension under vertical loads, which is the main characteristic of a Pratt truss design.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # LEFT SPAN&#10;  # Bottom chord nodes (left span)&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;  # Top chord nodes (left span)&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;  # RIGHT SPAN&#10;  # Bottom chord nodes (right span)&#10;  - id: 13&#10;    x: 120 ft&#10;    y: 0 ft&#10;  - id: 14&#10;    x: 140 ft&#10;    y: 0 ft&#10;  - id: 15&#10;    x: 160 ft&#10;    y: 0 ft&#10;  - id: 16&#10;    x: 180 ft&#10;    y: 0 ft&#10;  - id: 17&#10;    x: 200 ft&#10;    y: 0 ft&#10;  # Top chord nodes (right span) - renumbered to be sequential&#10;  - id: 18&#10;    x: 120 ft&#10;    y: 20 ft&#10;  - id: 19&#10;    x: 140 ft&#10;    y: 20 ft&#10;  - id: 20&#10;    x: 160 ft&#10;    y: 20 ft&#10;  - id: 21&#10;    x: 180 ft&#10;    y: 20 ft&#10;  - id: 22&#10;    x: 200 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pier support at center (bottom chord)&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # LEFT SPAN&#10;  # Bottom chord members (left span)&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members (left span)&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members (left span)&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (left span - sloping down toward center)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # RIGHT SPAN&#10;  # Bottom chord members (right span)&#10;  - id: 22&#10;    i_node: 6&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members (right span) - updated node references&#10;  - id: 27&#10;    i_node: 12&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members (right span)&#10;  - id: 32&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 13&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 17&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (right span - sloping down toward center/left)&#10;  - id: 38&#10;    i_node: 18&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 19&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 20&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 21&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 22&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord (left span)&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span)&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
              <option name="updatedContent" value="# Pratt bridge example with two spans and units&#10;# Both spans have diagonals sloping toward the center (which places diagonals in tension under vertical loads)&#10;# Key design features:&#10;#&#10;#&#10;# The bridge has two 100 ft spans (200 ft total length)&#10;# Central node 6 serves as the pier connection point for both spans&#10;# Diagonals in the left span slope down toward the center (right)&#10;# Diagonals in the right span slope down toward the center (left)&#10;# Supports are at node 1 (pinned), node 6 (pinned pier), and node 17 (roller)&#10;# Both spans use the same materials, sections, and loading&#10;# This arrangement ensures that diagonals in both spans will primarily experience tension under vertical loads, which is the main characteristic of a Pratt truss design.&#10;&#10;# DESIGN PARAMETERS&#10;design_parameters:&#10;  min_safety_factor: 1.2&#10;  deck_load: 0.5 kip/ft  # Reduced from 2.0 to achieve reasonable safety factors&#10;&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # LEFT SPAN&#10;  # Bottom chord nodes (left span)&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;  # Top chord nodes (left span)&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;  # RIGHT SPAN&#10;  # Bottom chord nodes (right span)&#10;  - id: 13&#10;    x: 120 ft&#10;    y: 0 ft&#10;  - id: 14&#10;    x: 140 ft&#10;    y: 0 ft&#10;  - id: 15&#10;    x: 160 ft&#10;    y: 0 ft&#10;  - id: 16&#10;    x: 180 ft&#10;    y: 0 ft&#10;  - id: 17&#10;    x: 200 ft&#10;    y: 0 ft&#10;  # Top chord nodes (right span) - renumbered to be sequential&#10;  - id: 18&#10;    x: 120 ft&#10;    y: 20 ft&#10;  - id: 19&#10;    x: 140 ft&#10;    y: 20 ft&#10;  - id: 20&#10;    x: 160 ft&#10;    y: 20 ft&#10;  - id: 21&#10;    x: 180 ft&#10;    y: 20 ft&#10;  - id: 22&#10;    x: 200 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pier support at center (bottom chord)&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # LEFT SPAN&#10;  # Bottom chord members (left span)&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members (left span)&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members (left span)&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (left span - sloping down toward center)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # RIGHT SPAN&#10;  # Bottom chord members (right span)&#10;  - id: 22&#10;    i_node: 6&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members (right span) - updated node references&#10;  - id: 27&#10;    i_node: 12&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members (right span)&#10;  - id: 32&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 13&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 17&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (right span - sloping down toward center/left)&#10;  - id: 38&#10;    i_node: 18&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 19&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 20&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 21&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 22&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord (left span) - reduced loading&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span) - reduced loading&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;sections:&#10;  - id: 1&#10;    area: 15.3 in^2     # W14x51 - doubled from W12x26 for chord members&#10;    r: 5.02 in&#10;  - id: 2  &#10;    area: 13.3 in^2     # W10x45 - increased from W8x31 for verticals/diagonals&#10;    r: 3.93 in" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Pratt_Bridge_3D.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Pratt_Bridge_3D.YAML" />
              <option name="originalContent" value="# 3D Pratt bridge with parallel trusses and transverse members&#10;# Both spans have diagonals sloping toward the center&#10;&#10;design_parameters:&#10;  min_safety_factor: 1.2&#10;  deck_load: 0.5 kip/ft&#10;&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # LEFT TRUSS (front truss, z=0)&#10;  # Bottom chord nodes (left span, front)&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Top chord nodes (left span, front)&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  # Intermediate bottom chord node (front)&#10;  - id: 13&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Bottom chord nodes (right span, front)&#10;  - id: 14&#10;    x: 140 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 15&#10;    x: 160 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 16&#10;    x: 180 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 17&#10;    x: 200 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Top chord nodes (right span, front)&#10;  - id: 18&#10;    x: 120 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 19&#10;    x: 140 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 20&#10;    x: 160 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 21&#10;    x: 180 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 22&#10;    x: 200 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # RIGHT TRUSS (back truss, z=20)&#10;  # Bottom chord nodes (left span, back)&#10;  - id: 101&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 102&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 103&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 104&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 105&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 106&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Top chord nodes (left span, back)&#10;  - id: 107&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 108&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 109&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 110&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 111&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 112&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  # Intermediate bottom chord node (back)&#10;  - id: 113&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Bottom chord nodes (right span, back)&#10;  - id: 114&#10;    x: 140 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 115&#10;    x: 160 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 116&#10;    x: 180 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 117&#10;    x: 200 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Top chord nodes (right span, back)&#10;  - id: 118&#10;    x: 120 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 119&#10;    x: 140 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 120&#10;    x: 160 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 121&#10;    x: 180 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 122&#10;    x: 200 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;# Add intermediate bottom chord nodes at 120ft for proper connectivity&#10;  - id: 13&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 113&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # Front truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 6&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  # Back truss supports&#10;  - node: 101&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 106&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 117&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;&#10;members:&#10;  # FRONT TRUSS (original)&#10;  # Bottom chord members (left span)&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (left span)&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (left span)&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (left span)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  # Bottom chord members (right span) - updated to use merged nodes&#10;  - id: 22&#10;    i_node: 6&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (right span)&#10;  - id: 27&#10;    i_node: 12&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (right span) - updated&#10;  - id: 32&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 13&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 17&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (right span) - updated&#10;  - id: 38&#10;    i_node: 18&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 19&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 20&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 21&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 22&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;&#10;  # BACK TRUSS (parallel truss)&#10;  # Bottom chord members (left span)&#10;  - id: 101&#10;    i_node: 101&#10;    j_node: 102&#10;    material: 1&#10;    section: 1&#10;  - id: 102&#10;    i_node: 102&#10;    j_node: 103&#10;    material: 1&#10;    section: 1&#10;  - id: 103&#10;    i_node: 103&#10;    j_node: 104&#10;    material: 1&#10;    section: 1&#10;  - id: 104&#10;    i_node: 104&#10;    j_node: 105&#10;    material: 1&#10;    section: 1&#10;  - id: 105&#10;    i_node: 105&#10;    j_node: 106&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (left span)&#10;  - id: 106&#10;    i_node: 107&#10;    j_node: 108&#10;    material: 1&#10;    section: 1&#10;  - id: 107&#10;    i_node: 108&#10;    j_node: 109&#10;    material: 1&#10;    section: 1&#10;  - id: 108&#10;    i_node: 109&#10;    j_node: 110&#10;    material: 1&#10;    section: 1&#10;  - id: 109&#10;    i_node: 110&#10;    j_node: 111&#10;    material: 1&#10;    section: 1&#10;  - id: 110&#10;    i_node: 111&#10;    j_node: 112&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (left span)&#10;  - id: 111&#10;    i_node: 101&#10;    j_node: 107&#10;    material: 1&#10;    section: 2&#10;  - id: 112&#10;    i_node: 102&#10;    j_node: 108&#10;    material: 1&#10;    section: 2&#10;  - id: 113&#10;    i_node: 103&#10;    j_node: 109&#10;    material: 1&#10;    section: 2&#10;  - id: 114&#10;    i_node: 104&#10;    j_node: 110&#10;    material: 1&#10;    section: 2&#10;  - id: 115&#10;    i_node: 105&#10;    j_node: 111&#10;    material: 1&#10;    section: 2&#10;  - id: 116&#10;    i_node: 106&#10;    j_node: 112&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (left span)&#10;  - id: 117&#10;    i_node: 107&#10;    j_node: 102&#10;    material: 1&#10;    section: 2&#10;  - id: 118&#10;    i_node: 108&#10;    j_node: 103&#10;    material: 1&#10;    section: 2&#10;  - id: 119&#10;    i_node: 109&#10;    j_node: 104&#10;    material: 1&#10;    section: 2&#10;  - id: 120&#10;    i_node: 110&#10;    j_node: 105&#10;    material: 1&#10;    section: 2&#10;  - id: 121&#10;    i_node: 111&#10;    j_node: 106&#10;    material: 1&#10;    section: 2&#10;  # Bottom chord members (right span) - updated to use merged nodes&#10;  - id: 122&#10;    i_node: 106&#10;    j_node: 113&#10;    material: 1&#10;    section: 1&#10;  - id: 123&#10;    i_node: 113&#10;    j_node: 114&#10;    material: 1&#10;    section: 1&#10;  - id: 124&#10;    i_node: 114&#10;    j_node: 115&#10;    material: 1&#10;    section: 1&#10;  - id: 125&#10;    i_node: 115&#10;    j_node: 116&#10;    material: 1&#10;    section: 1&#10;  - id: 126&#10;    i_node: 116&#10;    j_node: 117&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (right span)&#10;  - id: 127&#10;    i_node: 112&#10;    j_node: 118&#10;    material: 1&#10;    section: 1&#10;  - id: 128&#10;    i_node: 118&#10;    j_node: 119&#10;    material: 1&#10;    section: 1&#10;  - id: 129&#10;    i_node: 119&#10;    j_node: 120&#10;    material: 1&#10;    section: 1&#10;  - id: 130&#10;    i_node: 120&#10;    j_node: 121&#10;    material: 1&#10;    section: 1&#10;  - id: 131&#10;    i_node: 121&#10;    j_node: 122&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (right span) - updated&#10;  - id: 132&#10;    i_node: 106&#10;    j_node: 112&#10;    material: 1&#10;    section: 2&#10;  - id: 133&#10;    i_node: 113&#10;    j_node: 118&#10;    material: 1&#10;    section: 2&#10;  - id: 134&#10;    i_node: 114&#10;    j_node: 119&#10;    material: 1&#10;    section: 2&#10;  - id: 135&#10;    i_node: 115&#10;    j_node: 120&#10;    material: 1&#10;    section: 2&#10;  - id: 136&#10;    i_node: 116&#10;    j_node: 121&#10;    material: 1&#10;    section: 2&#10;  - id: 137&#10;    i_node: 117&#10;    j_node: 122&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (right span) - updated&#10;  - id: 138&#10;    i_node: 118&#10;    j_node: 106&#10;    material: 1&#10;    section: 2&#10;  - id: 139&#10;    i_node: 119&#10;    j_node: 113&#10;    material: 1&#10;    section: 2&#10;  - id: 140&#10;    i_node: 120&#10;    j_node: 114&#10;    material: 1&#10;    section: 2&#10;  - id: 141&#10;    i_node: 121&#10;    j_node: 115&#10;    material: 1&#10;    section: 2&#10;  - id: 142&#10;    i_node: 122&#10;    j_node: 116&#10;    material: 1&#10;    section: 2&#10;&#10;  # TRANSVERSE MEMBERS (connecting front and back trusses)&#10;  # Bottom chord transverse members&#10;  - id: 201&#10;    i_node: 1&#10;    j_node: 101&#10;    material: 1&#10;    section: 3&#10;  - id: 202&#10;    i_node: 2&#10;    j_node: 102&#10;    material: 1&#10;    section: 3&#10;  - id: 203&#10;    i_node: 3&#10;    j_node: 103&#10;    material: 1&#10;    section: 3&#10;  - id: 204&#10;    i_node: 4&#10;    j_node: 104&#10;    material: 1&#10;    section: 3&#10;  - id: 205&#10;    i_node: 5&#10;    j_node: 105&#10;    material: 1&#10;    section: 3&#10;  - id: 206&#10;    i_node: 6&#10;    j_node: 106&#10;    material: 1&#10;    section: 3&#10;  - id: 207&#10;    i_node: 13&#10;    j_node: 113&#10;    material: 1&#10;    section: 3&#10;  - id: 208&#10;    i_node: 14&#10;    j_node: 114&#10;    material: 1&#10;    section: 3&#10;  - id: 209&#10;    i_node: 15&#10;    j_node: 115&#10;    material: 1&#10;    section: 3&#10;  - id: 210&#10;    i_node: 16&#10;    j_node: 116&#10;    material: 1&#10;    section: 3&#10;  - id: 211&#10;    i_node: 17&#10;    j_node: 117&#10;    material: 1&#10;    section: 3&#10;&#10;  # Top chord transverse members&#10;  - id: 212&#10;    i_node: 7&#10;    j_node: 107&#10;    material: 1&#10;    section: 3&#10;  - id: 213&#10;    i_node: 8&#10;    j_node: 108&#10;    material: 1&#10;    section: 3&#10;  - id: 214&#10;    i_node: 9&#10;    j_node: 109&#10;    material: 1&#10;    section: 3&#10;  - id: 215&#10;    i_node: 10&#10;    j_node: 110&#10;    material: 1&#10;    section: 3&#10;  - id: 216&#10;    i_node: 11&#10;    j_node: 111&#10;    material: 1&#10;    section: 3&#10;  - id: 217&#10;    i_node: 12&#10;    j_node: 112&#10;    material: 1&#10;    section: 3&#10;  - id: 218&#10;    i_node: 18&#10;    j_node: 118&#10;    material: 1&#10;    section: 3&#10;  - id: 219&#10;    i_node: 19&#10;    j_node: 119&#10;    material: 1&#10;    section: 3&#10;  - id: 220&#10;    i_node: 20&#10;    j_node: 120&#10;    material: 1&#10;    section: 3&#10;  - id: 221&#10;    i_node: 21&#10;    j_node: 121&#10;    material: 1&#10;    section: 3&#10;  - id: 222&#10;    i_node: 22&#10;    j_node: 122&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing in transverse planes (X-bracing for lateral stability)&#10;  # Left span&#10;  - id: 223&#10;    i_node: 1&#10;    j_node: 107&#10;    material: 1&#10;    section: 4&#10;  - id: 224&#10;    i_node: 101&#10;    j_node: 7&#10;    material: 1&#10;    section: 4&#10;  - id: 225&#10;    i_node: 2&#10;    j_node: 108&#10;    material: 1&#10;    section: 4&#10;  - id: 226&#10;    i_node: 102&#10;    j_node: 8&#10;    material: 1&#10;    section: 4&#10;  - id: 227&#10;    i_node: 3&#10;    j_node: 109&#10;    material: 1&#10;    section: 4&#10;  - id: 228&#10;    i_node: 103&#10;    j_node: 9&#10;    material: 1&#10;    section: 4&#10;  - id: 229&#10;    i_node: 4&#10;    j_node: 110&#10;    material: 1&#10;    section: 4&#10;  - id: 230&#10;    i_node: 104&#10;    j_node: 10&#10;    material: 1&#10;    section: 4&#10;  - id: 231&#10;    i_node: 5&#10;    j_node: 111&#10;    material: 1&#10;    section: 4&#10;  - id: 232&#10;    i_node: 105&#10;    j_node: 11&#10;    material: 1&#10;    section: 4&#10;  - id: 233&#10;    i_node: 6&#10;    j_node: 112&#10;    material: 1&#10;    section: 4&#10;&#10;  # Right span&#10;  - id: 235&#10;    i_node: 13&#10;    j_node: 118&#10;    material: 1&#10;    section: 4&#10;  - id: 236&#10;    i_node: 113&#10;    j_node: 18&#10;    material: 1&#10;    section: 4&#10;  - id: 237&#10;    i_node: 14&#10;    j_node: 119&#10;    material: 1&#10;    section: 4&#10;  - id: 238&#10;    i_node: 114&#10;    j_node: 19&#10;    material: 1&#10;    section: 4&#10;  - id: 239&#10;    i_node: 15&#10;    j_node: 120&#10;    material: 1&#10;    section: 4&#10;  - id: 240&#10;    i_node: 115&#10;    j_node: 20&#10;    material: 1&#10;    section: 4&#10;  - id: 241&#10;    i_node: 16&#10;    j_node: 121&#10;    material: 1&#10;    section: 4&#10;  - id: 242&#10;    i_node: 116&#10;    j_node: 21&#10;    material: 1&#10;    section: 4&#10;  - id: 243&#10;    i_node: 17&#10;    j_node: 122&#10;    material: 1&#10;    section: 4&#10;  - id: 244&#10;    i_node: 117&#10;    j_node: 22&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord (left span, front truss)&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span, front truss)&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (left span, back truss)&#10;  - member_uid: 101&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 102&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 103&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 104&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 105&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span, back truss)&#10;  - member_uid: 122&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 123&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 124&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 125&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 126&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse loads&#10;  - member_uid: 201&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 206&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 211&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;sections:&#10;  - id: 1&#10;    area: 15.3 in^2     # W14x51 - Chord members&#10;    r: 5.02 in&#10;  - id: 2&#10;    area: 13.3 in^2     # W10x45 - Verticals/diagonals&#10;    r: 3.93 in&#10;  - id: 3&#10;    area: 14.4 in^2     # W12x48 - Transverse beams&#10;    r: 4.85 in&#10;  - id: 4&#10;    area: 9.13 in^2     # W8x31 - Transverse bracing&#10;    r: 3.47 in" />
              <option name="updatedContent" value="# 3D Pratt bridge with parallel trusses and transverse members&#10;# Both spans have diagonals sloping toward the center&#10;&#10;design_parameters:&#10;  min_safety_factor: 1.2&#10;  deck_load: 0.5 kip/ft&#10;&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # LEFT TRUSS (front truss, z=0)&#10;  # Bottom chord nodes (left span, front)&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Top chord nodes (left span, front)&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  # Intermediate bottom chord node (front)&#10;  - id: 13&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Bottom chord nodes (right span, front)&#10;  - id: 14&#10;    x: 140 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 15&#10;    x: 160 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 16&#10;    x: 180 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 17&#10;    x: 200 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  # Top chord nodes (right span, front)&#10;  - id: 18&#10;    x: 120 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 19&#10;    x: 140 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 20&#10;    x: 160 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 21&#10;    x: 180 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 22&#10;    x: 200 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # RIGHT TRUSS (back truss, z=20)&#10;  # Bottom chord nodes (left span, back)&#10;  - id: 101&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 102&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 103&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 104&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 105&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 106&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Top chord nodes (left span, back)&#10;  - id: 107&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 108&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 109&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 110&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 111&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 112&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  # Intermediate bottom chord node (back)&#10;  - id: 113&#10;    x: 120 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Bottom chord nodes (right span, back)&#10;  - id: 114&#10;    x: 140 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 115&#10;    x: 160 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 116&#10;    x: 180 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 117&#10;    x: 200 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  # Top chord nodes (right span, back)&#10;  - id: 118&#10;    x: 120 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 119&#10;    x: 140 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 120&#10;    x: 160 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 121&#10;    x: 180 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 122&#10;    x: 200 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # Front truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 6&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  # Back truss supports&#10;  - node: 101&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 106&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;  - node: 117&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;&#10;members:&#10;  # FRONT TRUSS (original)&#10;  # Bottom chord members (left span)&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (left span)&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (left span)&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (left span)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  # Bottom chord members (right span) - updated to use merged nodes&#10;  - id: 22&#10;    i_node: 6&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (right span)&#10;  - id: 27&#10;    i_node: 12&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (right span) - updated&#10;  - id: 32&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 13&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 14&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 15&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 16&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 17&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (right span) - updated&#10;  - id: 38&#10;    i_node: 18&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 19&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 20&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 21&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 22&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;&#10;  # BACK TRUSS (parallel truss)&#10;  # Bottom chord members (left span)&#10;  - id: 101&#10;    i_node: 101&#10;    j_node: 102&#10;    material: 1&#10;    section: 1&#10;  - id: 102&#10;    i_node: 102&#10;    j_node: 103&#10;    material: 1&#10;    section: 1&#10;  - id: 103&#10;    i_node: 103&#10;    j_node: 104&#10;    material: 1&#10;    section: 1&#10;  - id: 104&#10;    i_node: 104&#10;    j_node: 105&#10;    material: 1&#10;    section: 1&#10;  - id: 105&#10;    i_node: 105&#10;    j_node: 106&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (left span)&#10;  - id: 106&#10;    i_node: 107&#10;    j_node: 108&#10;    material: 1&#10;    section: 1&#10;  - id: 107&#10;    i_node: 108&#10;    j_node: 109&#10;    material: 1&#10;    section: 1&#10;  - id: 108&#10;    i_node: 109&#10;    j_node: 110&#10;    material: 1&#10;    section: 1&#10;  - id: 109&#10;    i_node: 110&#10;    j_node: 111&#10;    material: 1&#10;    section: 1&#10;  - id: 110&#10;    i_node: 111&#10;    j_node: 112&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (left span)&#10;  - id: 111&#10;    i_node: 101&#10;    j_node: 107&#10;    material: 1&#10;    section: 2&#10;  - id: 112&#10;    i_node: 102&#10;    j_node: 108&#10;    material: 1&#10;    section: 2&#10;  - id: 113&#10;    i_node: 103&#10;    j_node: 109&#10;    material: 1&#10;    section: 2&#10;  - id: 114&#10;    i_node: 104&#10;    j_node: 110&#10;    material: 1&#10;    section: 2&#10;  - id: 115&#10;    i_node: 105&#10;    j_node: 111&#10;    material: 1&#10;    section: 2&#10;  - id: 116&#10;    i_node: 106&#10;    j_node: 112&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (left span)&#10;  - id: 117&#10;    i_node: 107&#10;    j_node: 102&#10;    material: 1&#10;    section: 2&#10;  - id: 118&#10;    i_node: 108&#10;    j_node: 103&#10;    material: 1&#10;    section: 2&#10;  - id: 119&#10;    i_node: 109&#10;    j_node: 104&#10;    material: 1&#10;    section: 2&#10;  - id: 120&#10;    i_node: 110&#10;    j_node: 105&#10;    material: 1&#10;    section: 2&#10;  - id: 121&#10;    i_node: 111&#10;    j_node: 106&#10;    material: 1&#10;    section: 2&#10;  # Bottom chord members (right span) - updated to use merged nodes&#10;  - id: 122&#10;    i_node: 106&#10;    j_node: 113&#10;    material: 1&#10;    section: 1&#10;  - id: 123&#10;    i_node: 113&#10;    j_node: 114&#10;    material: 1&#10;    section: 1&#10;  - id: 124&#10;    i_node: 114&#10;    j_node: 115&#10;    material: 1&#10;    section: 1&#10;  - id: 125&#10;    i_node: 115&#10;    j_node: 116&#10;    material: 1&#10;    section: 1&#10;  - id: 126&#10;    i_node: 116&#10;    j_node: 117&#10;    material: 1&#10;    section: 1&#10;  # Top chord members (right span)&#10;  - id: 127&#10;    i_node: 112&#10;    j_node: 118&#10;    material: 1&#10;    section: 1&#10;  - id: 128&#10;    i_node: 118&#10;    j_node: 119&#10;    material: 1&#10;    section: 1&#10;  - id: 129&#10;    i_node: 119&#10;    j_node: 120&#10;    material: 1&#10;    section: 1&#10;  - id: 130&#10;    i_node: 120&#10;    j_node: 121&#10;    material: 1&#10;    section: 1&#10;  - id: 131&#10;    i_node: 121&#10;    j_node: 122&#10;    material: 1&#10;    section: 1&#10;  # Vertical members (right span) - updated&#10;  - id: 132&#10;    i_node: 106&#10;    j_node: 112&#10;    material: 1&#10;    section: 2&#10;  - id: 133&#10;    i_node: 113&#10;    j_node: 118&#10;    material: 1&#10;    section: 2&#10;  - id: 134&#10;    i_node: 114&#10;    j_node: 119&#10;    material: 1&#10;    section: 2&#10;  - id: 135&#10;    i_node: 115&#10;    j_node: 120&#10;    material: 1&#10;    section: 2&#10;  - id: 136&#10;    i_node: 116&#10;    j_node: 121&#10;    material: 1&#10;    section: 2&#10;  - id: 137&#10;    i_node: 117&#10;    j_node: 122&#10;    material: 1&#10;    section: 2&#10;  # Diagonal members (right span) - updated&#10;  - id: 138&#10;    i_node: 118&#10;    j_node: 106&#10;    material: 1&#10;    section: 2&#10;  - id: 139&#10;    i_node: 119&#10;    j_node: 113&#10;    material: 1&#10;    section: 2&#10;  - id: 140&#10;    i_node: 120&#10;    j_node: 114&#10;    material: 1&#10;    section: 2&#10;  - id: 141&#10;    i_node: 121&#10;    j_node: 115&#10;    material: 1&#10;    section: 2&#10;  - id: 142&#10;    i_node: 122&#10;    j_node: 116&#10;    material: 1&#10;    section: 2&#10;&#10;  # TRANSVERSE MEMBERS (connecting front and back trusses)&#10;  # Bottom chord transverse members&#10;  - id: 201&#10;    i_node: 1&#10;    j_node: 101&#10;    material: 1&#10;    section: 3&#10;  - id: 202&#10;    i_node: 2&#10;    j_node: 102&#10;    material: 1&#10;    section: 3&#10;  - id: 203&#10;    i_node: 3&#10;    j_node: 103&#10;    material: 1&#10;    section: 3&#10;  - id: 204&#10;    i_node: 4&#10;    j_node: 104&#10;    material: 1&#10;    section: 3&#10;  - id: 205&#10;    i_node: 5&#10;    j_node: 105&#10;    material: 1&#10;    section: 3&#10;  - id: 206&#10;    i_node: 6&#10;    j_node: 106&#10;    material: 1&#10;    section: 3&#10;  - id: 207&#10;    i_node: 13&#10;    j_node: 113&#10;    material: 1&#10;    section: 3&#10;  - id: 208&#10;    i_node: 14&#10;    j_node: 114&#10;    material: 1&#10;    section: 3&#10;  - id: 209&#10;    i_node: 15&#10;    j_node: 115&#10;    material: 1&#10;    section: 3&#10;  - id: 210&#10;    i_node: 16&#10;    j_node: 116&#10;    material: 1&#10;    section: 3&#10;  - id: 211&#10;    i_node: 17&#10;    j_node: 117&#10;    material: 1&#10;    section: 3&#10;&#10;  # Top chord transverse members&#10;  - id: 212&#10;    i_node: 7&#10;    j_node: 107&#10;    material: 1&#10;    section: 3&#10;  - id: 213&#10;    i_node: 8&#10;    j_node: 108&#10;    material: 1&#10;    section: 3&#10;  - id: 214&#10;    i_node: 9&#10;    j_node: 109&#10;    material: 1&#10;    section: 3&#10;  - id: 215&#10;    i_node: 10&#10;    j_node: 110&#10;    material: 1&#10;    section: 3&#10;  - id: 216&#10;    i_node: 11&#10;    j_node: 111&#10;    material: 1&#10;    section: 3&#10;  - id: 217&#10;    i_node: 12&#10;    j_node: 112&#10;    material: 1&#10;    section: 3&#10;  - id: 218&#10;    i_node: 18&#10;    j_node: 118&#10;    material: 1&#10;    section: 3&#10;  - id: 219&#10;    i_node: 19&#10;    j_node: 119&#10;    material: 1&#10;    section: 3&#10;  - id: 220&#10;    i_node: 20&#10;    j_node: 120&#10;    material: 1&#10;    section: 3&#10;  - id: 221&#10;    i_node: 21&#10;    j_node: 121&#10;    material: 1&#10;    section: 3&#10;  - id: 222&#10;    i_node: 22&#10;    j_node: 122&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing in transverse planes (X-bracing for lateral stability)&#10;  # Left span&#10;  - id: 223&#10;    i_node: 1&#10;    j_node: 107&#10;    material: 1&#10;    section: 4&#10;  - id: 224&#10;    i_node: 101&#10;    j_node: 7&#10;    material: 1&#10;    section: 4&#10;  - id: 225&#10;    i_node: 2&#10;    j_node: 108&#10;    material: 1&#10;    section: 4&#10;  - id: 226&#10;    i_node: 102&#10;    j_node: 8&#10;    material: 1&#10;    section: 4&#10;  - id: 227&#10;    i_node: 3&#10;    j_node: 109&#10;    material: 1&#10;    section: 4&#10;  - id: 228&#10;    i_node: 103&#10;    j_node: 9&#10;    material: 1&#10;    section: 4&#10;  - id: 229&#10;    i_node: 4&#10;    j_node: 110&#10;    material: 1&#10;    section: 4&#10;  - id: 230&#10;    i_node: 104&#10;    j_node: 10&#10;    material: 1&#10;    section: 4&#10;  - id: 231&#10;    i_node: 5&#10;    j_node: 111&#10;    material: 1&#10;    section: 4&#10;  - id: 232&#10;    i_node: 105&#10;    j_node: 11&#10;    material: 1&#10;    section: 4&#10;  - id: 233&#10;    i_node: 6&#10;    j_node: 112&#10;    material: 1&#10;    section: 4&#10;  - id: 234&#10;    i_node: 106&#10;    j_node: 12&#10;    material: 1&#10;    section: 4&#10;&#10;  # Right span&#10;  - id: 235&#10;    i_node: 13&#10;    j_node: 118&#10;    material: 1&#10;    section: 4&#10;  - id: 236&#10;    i_node: 113&#10;    j_node: 18&#10;    material: 1&#10;    section: 4&#10;  - id: 237&#10;    i_node: 14&#10;    j_node: 119&#10;    material: 1&#10;    section: 4&#10;  - id: 238&#10;    i_node: 114&#10;    j_node: 19&#10;    material: 1&#10;    section: 4&#10;  - id: 239&#10;    i_node: 15&#10;    j_node: 120&#10;    material: 1&#10;    section: 4&#10;  - id: 240&#10;    i_node: 115&#10;    j_node: 20&#10;    material: 1&#10;    section: 4&#10;  - id: 241&#10;    i_node: 16&#10;    j_node: 121&#10;    material: 1&#10;    section: 4&#10;  - id: 242&#10;    i_node: 116&#10;    j_node: 21&#10;    material: 1&#10;    section: 4&#10;  - id: 243&#10;    i_node: 17&#10;    j_node: 122&#10;    material: 1&#10;    section: 4&#10;  - id: 244&#10;    i_node: 117&#10;    j_node: 22&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord (left span, front truss)&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span, front truss)&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (left span, back truss)&#10;  - member_uid: 101&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 102&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 103&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 104&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 105&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord (right span, back truss)&#10;  - member_uid: 122&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 123&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 124&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 125&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 126&#10;    load_type: 3&#10;    wi: -0.25 kip/ft&#10;    wj: -0.25 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse loads&#10;  - member_uid: 201&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 206&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 211&#10;    load_type: 3&#10;    wi: -0.2 kip/ft&#10;    wj: -0.2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;sections:&#10;  - id: 1&#10;    area: 15.3 in^2     # W14x51 - Chord members&#10;    r: 5.02 in&#10;  - id: 2&#10;    area: 13.3 in^2     # W10x45 - Verticals/diagonals&#10;    r: 3.93 in&#10;  - id: 3&#10;    area: 14.4 in^2     # W12x48 - Transverse beams&#10;    r: 4.85 in&#10;  - id: 4&#10;    area: 9.13 in^2     # W8x31 - Transverse bracing&#10;    r: 3.47 in" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Pratt_Space_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Pratt_Space_Truss.YAML" />
              <option name="updatedContent" value="# Pratt space truss bridge example with units&#10;# This structure consists of two parallel Pratt trusses connected with transverse members&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # First truss - Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 0 ft&#10;&#10;  # Second truss - Bottom chord nodes&#10;  - id: 13&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 14&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 15&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 16&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 17&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 18&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Top chord nodes&#10;  - id: 19&#10;    x: 0 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 20&#10;    x: 20 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 21&#10;    x: 40 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 22&#10;    x: 60 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 23&#10;    x: 80 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;  - id: 24&#10;    x: 100 ft&#10;    y: 20 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # First truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1  # Restrain Z direction&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Fixed support at left end of first truss&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0  # Allow Z translation&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of first truss&#10;  &#10;  # Second truss supports&#10;  - node: 13&#10;    ux: 0  # Allow X translation&#10;    uy: 1&#10;    uz: 1  # Restrain Z direction&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at left end of second truss&#10;  - node: 18&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0  # Allow Z translation&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of second truss&#10;&#10;members:&#10;  # First truss - Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # First truss - Diagonal members (sloping down toward center)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Bottom chord members&#10;  - id: 22&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 25&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 17&#10;    j_node: 18&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Top chord members&#10;  - id: 27&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 29&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;  - id: 30&#10;    i_node: 22&#10;    j_node: 23&#10;    material: 1&#10;    section: 1&#10;  - id: 31&#10;    i_node: 23&#10;    j_node: 24&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Vertical members&#10;  - id: 32&#10;    i_node: 13&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 14&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 15&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 16&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 17&#10;    j_node: 23&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 18&#10;    j_node: 24&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Diagonal members (sloping down toward center)&#10;  - id: 38&#10;    i_node: 19&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 39&#10;    i_node: 20&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 40&#10;    i_node: 21&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;  - id: 41&#10;    i_node: 22&#10;    j_node: 17&#10;    material: 1&#10;    section: 2&#10;  - id: 42&#10;    i_node: 23&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;&#10;  # Transverse members connecting bottom chords&#10;  - id: 43&#10;    i_node: 1&#10;    j_node: 13&#10;    material: 1&#10;    section: 3  # HSS6x6x3/8 for transverse members&#10;  - id: 44&#10;    i_node: 2&#10;    j_node: 14&#10;    material: 1&#10;    section: 3&#10;  - id: 45&#10;    i_node: 3&#10;    j_node: 15&#10;    material: 1&#10;    section: 3&#10;  - id: 46&#10;    i_node: 4&#10;    j_node: 16&#10;    material: 1&#10;    section: 3&#10;  - id: 47&#10;    i_node: 5&#10;    j_node: 17&#10;    material: 1&#10;    section: 3&#10;  - id: 48&#10;    i_node: 6&#10;    j_node: 18&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting top chords&#10;  - id: 49&#10;    i_node: 7&#10;    j_node: 19&#10;    material: 1&#10;    section: 3&#10;  - id: 50&#10;    i_node: 8&#10;    j_node: 20&#10;    material: 1&#10;    section: 3&#10;  - id: 51&#10;    i_node: 9&#10;    j_node: 21&#10;    material: 1&#10;    section: 3&#10;  - id: 52&#10;    i_node: 10&#10;    j_node: 22&#10;    material: 1&#10;    section: 3&#10;  - id: 53&#10;    i_node: 11&#10;    j_node: 23&#10;    material: 1&#10;    section: 3&#10;  - id: 54&#10;    i_node: 12&#10;    j_node: 24&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing for lateral stability - Bottom&#10;  - id: 55&#10;    i_node: 1&#10;    j_node: 14&#10;    material: 1&#10;    section: 4  # L4x4x1/2 angle for bracing&#10;  - id: 56&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 4&#10;  - id: 57&#10;    i_node: 3&#10;    j_node: 16&#10;    material: 1&#10;    section: 4&#10;  - id: 58&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 4&#10;  - id: 59&#10;    i_node: 5&#10;    j_node: 18&#10;    material: 1&#10;    section: 4&#10;  - id: 60&#10;    i_node: 6&#10;    j_node: 17&#10;    material: 1&#10;    section: 4&#10;&#10;  # Diagonal bracing for lateral stability - Top&#10;  - id: 61&#10;    i_node: 7&#10;    j_node: 20&#10;    material: 1&#10;    section: 4&#10;  - id: 62&#10;    i_node: 8&#10;    j_node: 19&#10;    material: 1&#10;    section: 4&#10;  - id: 63&#10;    i_node: 9&#10;    j_node: 22&#10;    material: 1&#10;    section: 4&#10;  - id: 64&#10;    i_node: 10&#10;    j_node: 21&#10;    material: 1&#10;    section: 4&#10;  - id: 65&#10;    i_node: 11&#10;    j_node: 24&#10;    material: 1&#10;    section: 4&#10;  - id: 66&#10;    i_node: 12&#10;    j_node: 23&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord of first truss&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord of second truss&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 25&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 26&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse member loads&#10;  - member_uid: 43&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 44&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 45&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 46&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 47&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 48&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Pratt_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Pratt_Truss.YAML" />
              <option name="originalContent" value="# Pratt truss bridge example with units&#10;# This truss has diagonal members that slope downward toward the center, typically placing diagonals in tension under vertical loads&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (sloping down toward center)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
              <option name="updatedContent" value="# Pratt truss bridge example with units&#10;# This truss has diagonal members that slope downward toward the center, typically placing diagonals in tension under vertical loads&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 0 ft&#10;    y: 20 ft&#10;  - id: 8&#10;    x: 20 ft&#10;    y: 20 ft&#10;  - id: 9&#10;    x: 40 ft&#10;    y: 20 ft&#10;  - id: 10&#10;    x: 60 ft&#10;    y: 20 ft&#10;  - id: 11&#10;    x: 80 ft&#10;    y: 20 ft&#10;  - id: 12&#10;    x: 100 ft&#10;    y: 20 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel (29000 ksi)&#10;    section: 1   # W12x26 (7.65 in^2, Ixx=204 in^4)&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;  - id: 10&#10;    i_node: 11&#10;    j_node: 12&#10;    material: 1&#10;    section: 1&#10;&#10;  # Vertical members&#10;  - id: 11&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31 (9.13 in^2, Ixx=110 in^4)&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 6&#10;    j_node: 12&#10;    material: 1&#10;    section: 2&#10;&#10;  # Diagonal members (sloping down toward center)&#10;  - id: 17&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 20&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 21&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Warren_Space_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Warren_Space_Truss.YAML" />
              <option name="updatedContent" value="# Warren space truss bridge example with units&#10;# This structure consists of two Warren trusses connected with transverse members&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # First truss - Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 0 ft&#10;&#10;  # First truss - Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 17.32 ft&#10;    z: 0 ft&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 17.32 ft&#10;    z: 0 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 17.32 ft&#10;    z: 0 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 17.32 ft&#10;    z: 0 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 17.32 ft&#10;    z: 0 ft&#10;&#10;  # Second truss - Bottom chord nodes&#10;  - id: 12&#10;    x: 0 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 13&#10;    x: 20 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 14&#10;    x: 40 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 15&#10;    x: 60 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 16&#10;    x: 80 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;  - id: 17&#10;    x: 100 ft&#10;    y: 0 ft&#10;    z: 20 ft&#10;&#10;  # Second truss - Top chord nodes&#10;  - id: 18&#10;    x: 10 ft&#10;    y: 17.32 ft&#10;    z: 20 ft&#10;  - id: 19&#10;    x: 30 ft&#10;    y: 17.32 ft&#10;    z: 20 ft&#10;  - id: 20&#10;    x: 50 ft&#10;    y: 17.32 ft&#10;    z: 20 ft&#10;  - id: 21&#10;    x: 70 ft&#10;    y: 17.32 ft&#10;    z: 20 ft&#10;  - id: 22&#10;    x: 90 ft&#10;    y: 17.32 ft&#10;    z: 20 ft&#10;&#10;supports:&#10;  # First truss supports&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Fixed support at left end of first truss&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of first truss&#10;  &#10;  # Second truss supports&#10;  - node: 12&#10;    ux: 0&#10;    uy: 1&#10;    uz: 1&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at left end of second truss&#10;  - node: 17&#10;    ux: 0&#10;    uy: 1&#10;    uz: 0&#10;    rx: 0&#10;    ry: 0&#10;    rz: 0&#10;    # Roller support at right end of second truss&#10;&#10;members:&#10;  # First truss - Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;&#10;  # First truss - Diagonal members (Warren pattern)&#10;  - id: 10&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 11&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 17&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;  # Second truss - Bottom chord members&#10;  - id: 20&#10;    i_node: 12&#10;    j_node: 13&#10;    material: 1&#10;    section: 1&#10;  - id: 21&#10;    i_node: 13&#10;    j_node: 14&#10;    material: 1&#10;    section: 1&#10;  - id: 22&#10;    i_node: 14&#10;    j_node: 15&#10;    material: 1&#10;    section: 1&#10;  - id: 23&#10;    i_node: 15&#10;    j_node: 16&#10;    material: 1&#10;    section: 1&#10;  - id: 24&#10;    i_node: 16&#10;    j_node: 17&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Top chord members&#10;  - id: 25&#10;    i_node: 18&#10;    j_node: 19&#10;    material: 1&#10;    section: 1&#10;  - id: 26&#10;    i_node: 19&#10;    j_node: 20&#10;    material: 1&#10;    section: 1&#10;  - id: 27&#10;    i_node: 20&#10;    j_node: 21&#10;    material: 1&#10;    section: 1&#10;  - id: 28&#10;    i_node: 21&#10;    j_node: 22&#10;    material: 1&#10;    section: 1&#10;&#10;  # Second truss - Diagonal members (Warren pattern)&#10;  - id: 29&#10;    i_node: 12&#10;    j_node: 18&#10;    material: 1&#10;    section: 2&#10;  - id: 30&#10;    i_node: 18&#10;    j_node: 13&#10;    material: 1&#10;    section: 2&#10;  - id: 31&#10;    i_node: 13&#10;    j_node: 19&#10;    material: 1&#10;    section: 2&#10;  - id: 32&#10;    i_node: 19&#10;    j_node: 14&#10;    material: 1&#10;    section: 2&#10;  - id: 33&#10;    i_node: 14&#10;    j_node: 20&#10;    material: 1&#10;    section: 2&#10;  - id: 34&#10;    i_node: 20&#10;    j_node: 15&#10;    material: 1&#10;    section: 2&#10;  - id: 35&#10;    i_node: 15&#10;    j_node: 21&#10;    material: 1&#10;    section: 2&#10;  - id: 36&#10;    i_node: 21&#10;    j_node: 16&#10;    material: 1&#10;    section: 2&#10;  - id: 37&#10;    i_node: 16&#10;    j_node: 22&#10;    material: 1&#10;    section: 2&#10;  - id: 38&#10;    i_node: 22&#10;    j_node: 17&#10;    material: 1&#10;    section: 2&#10;&#10;  # Transverse members connecting bottom chords&#10;  - id: 39&#10;    i_node: 1&#10;    j_node: 12&#10;    material: 1&#10;    section: 3  # HSS6x6x3/8 for transverse members&#10;  - id: 40&#10;    i_node: 2&#10;    j_node: 13&#10;    material: 1&#10;    section: 3&#10;  - id: 41&#10;    i_node: 3&#10;    j_node: 14&#10;    material: 1&#10;    section: 3&#10;  - id: 42&#10;    i_node: 4&#10;    j_node: 15&#10;    material: 1&#10;    section: 3&#10;  - id: 43&#10;    i_node: 5&#10;    j_node: 16&#10;    material: 1&#10;    section: 3&#10;  - id: 44&#10;    i_node: 6&#10;    j_node: 17&#10;    material: 1&#10;    section: 3&#10;&#10;  # Transverse members connecting top chords&#10;  - id: 45&#10;    i_node: 7&#10;    j_node: 18&#10;    material: 1&#10;    section: 3&#10;  - id: 46&#10;    i_node: 8&#10;    j_node: 19&#10;    material: 1&#10;    section: 3&#10;  - id: 47&#10;    i_node: 9&#10;    j_node: 20&#10;    material: 1&#10;    section: 3&#10;  - id: 48&#10;    i_node: 10&#10;    j_node: 21&#10;    material: 1&#10;    section: 3&#10;  - id: 49&#10;    i_node: 11&#10;    j_node: 22&#10;    material: 1&#10;    section: 3&#10;&#10;  # Diagonal bracing for lateral stability&#10;  - id: 50&#10;    i_node: 1&#10;    j_node: 13&#10;    material: 1&#10;    section: 4  # L4x4x1/2 angle for bracing&#10;  - id: 51&#10;    i_node: 2&#10;    j_node: 12&#10;    material: 1&#10;    section: 4&#10;  - id: 52&#10;    i_node: 3&#10;    j_node: 15&#10;    material: 1&#10;    section: 4&#10;  - id: 53&#10;    i_node: 4&#10;    j_node: 14&#10;    material: 1&#10;    section: 4&#10;  - id: 54&#10;    i_node: 5&#10;    j_node: 17&#10;    material: 1&#10;    section: 4&#10;  - id: 55&#10;    i_node: 6&#10;    j_node: 16&#10;    material: 1&#10;    section: 4&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord of first truss&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Deck loads on bottom chord of second truss&#10;  - member_uid: 20&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 21&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 22&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 23&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 24&#10;    load_type: 3&#10;    wi: -1 kip/ft&#10;    wj: -1 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;&#10;  # Transverse member loads&#10;  - member_uid: 39&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 40&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 41&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 42&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 43&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 44&#10;    load_type: 3&#10;    wi: -0.5 kip/ft&#10;    wj: -0.5 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/Warren_Truss.YAML">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/Warren_Truss.YAML" />
              <option name="originalContent" value="# Warren truss bridge example with units&#10;# This truss uses equilateral triangles with diagonal members that alternate between compression and tension.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 17.32 ft  # Height based on equilateral triangle&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 17.32 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 17.32 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 17.32 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 17.32 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1&#10;    section: 1&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1&#10;    section: 1&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1&#10;    section: 1&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1&#10;    section: 1&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1&#10;    section: 1&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1&#10;    section: 1&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1&#10;    section: 1&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1&#10;    section: 1&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1&#10;    section: 1&#10;&#10;  # Diagonal members (Warren pattern)&#10;  - id: 10&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1&#10;    section: 2&#10;  - id: 11&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1&#10;    section: 2&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1&#10;    section: 2&#10;  - id: 13&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1&#10;    section: 2&#10;  - id: 14&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1&#10;    section: 2&#10;  - id: 15&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1&#10;    section: 2&#10;  - id: 16&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1&#10;    section: 2&#10;  - id: 17&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1&#10;    section: 2&#10;  - id: 18&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1&#10;    section: 2&#10;  - id: 19&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1&#10;    section: 2&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
              <option name="updatedContent" value="# Warren truss bridge example with units&#10;# This truss uses equilateral triangles with diagonal members that alternate between compression and tension.&#10;units:&#10;  force: kip&#10;  length: ft&#10;  pressure: ksi&#10;&#10;nodes:&#10;  # Bottom chord nodes&#10;  - id: 1&#10;    x: 0 ft&#10;    y: 0 ft&#10;  - id: 2&#10;    x: 20 ft&#10;    y: 0 ft&#10;  - id: 3&#10;    x: 40 ft&#10;    y: 0 ft&#10;  - id: 4&#10;    x: 60 ft&#10;    y: 0 ft&#10;  - id: 5&#10;    x: 80 ft&#10;    y: 0 ft&#10;  - id: 6&#10;    x: 100 ft&#10;    y: 0 ft&#10;&#10;  # Top chord nodes&#10;  - id: 7&#10;    x: 10 ft&#10;    y: 17.32 ft  # Height based on equilateral triangle&#10;  - id: 8&#10;    x: 30 ft&#10;    y: 17.32 ft&#10;  - id: 9&#10;    x: 50 ft&#10;    y: 17.32 ft&#10;  - id: 10&#10;    x: 70 ft&#10;    y: 17.32 ft&#10;  - id: 11&#10;    x: 90 ft&#10;    y: 17.32 ft&#10;&#10;supports:&#10;  - node: 1&#10;    ux: 1&#10;    uy: 1&#10;    rz: 0&#10;    # Pinned support at left end&#10;  - node: 6&#10;    ux: 0&#10;    uy: 1&#10;    rz: 0&#10;    # Roller support at right end&#10;&#10;members:&#10;  # Bottom chord members&#10;  - id: 1&#10;    i_node: 1&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel (29000 ksi)&#10;    section: 1   # W12x26 (7.65 in^2, Ixx=204 in^4)&#10;  - id: 2&#10;    i_node: 2&#10;    j_node: 3&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 3&#10;    i_node: 3&#10;    j_node: 4&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 4&#10;    i_node: 4&#10;    j_node: 5&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 5&#10;    i_node: 5&#10;    j_node: 6&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;&#10;  # Top chord members&#10;  - id: 6&#10;    i_node: 7&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 7&#10;    i_node: 8&#10;    j_node: 9&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 8&#10;    i_node: 9&#10;    j_node: 10&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;  - id: 9&#10;    i_node: 10&#10;    j_node: 11&#10;    material: 1  # A36 Structural Steel&#10;    section: 1   # W12x26&#10;&#10;  # Diagonal members (Warren pattern)&#10;  - id: 10&#10;    i_node: 1&#10;    j_node: 7&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31 (9.13 in^2, Ixx=110 in^4)&#10;  - id: 11&#10;    i_node: 7&#10;    j_node: 2&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 12&#10;    i_node: 2&#10;    j_node: 8&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 13&#10;    i_node: 8&#10;    j_node: 3&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 14&#10;    i_node: 3&#10;    j_node: 9&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 15&#10;    i_node: 9&#10;    j_node: 4&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 16&#10;    i_node: 4&#10;    j_node: 10&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 17&#10;    i_node: 10&#10;    j_node: 5&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 18&#10;    i_node: 5&#10;    j_node: 11&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;  - id: 19&#10;    i_node: 11&#10;    j_node: 6&#10;    material: 1  # A36 Structural Steel&#10;    section: 2   # W8x31&#10;&#10;member_loads:&#10;  # Deck loads on bottom chord&#10;  - member_uid: 1&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 2&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 3&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 4&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D&#10;  - member_uid: 5&#10;    load_type: 3&#10;    wi: -2 kip/ft&#10;    wj: -2 kip/ft&#10;    a: 0 ft&#10;    b: 20 ft&#10;    case: D" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/run_Pratt_bridge.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/run_Pratt_bridge.py" />
              <option name="originalContent" value="import sys&#10;import yaml&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;import os&#10;from matplotlib.backends.backend_pdf import PdfPages&#10;import datetime&#10;import matplotlib.gridspec as gridspec&#10;import matplotlib.cm as cm&#10;&#10;# Load the bridge definition&#10;bridge_file = 'Pratt_Bridge.YAML'&#10;print(f&quot;Loading bridge from {bridge_file}&quot;)&#10;with open(os.path.join(os.path.dirname(__file__), bridge_file), 'r') as file:&#10;    bridge = yaml.safe_load(file)&#10;&#10;# Extract design parameters if present&#10;design_params = bridge.get('design_parameters', {})&#10;min_safety_factor = design_params.get('min_safety_factor', 1.0)&#10;print(f&quot;\nDesign minimum safety factor: {min_safety_factor}&quot;)&#10;&#10;# Extract nodes and members&#10;nodes = bridge['nodes']&#10;members = bridge['members']&#10;supports = bridge['supports']&#10;&#10;# Create a dictionary for easier node lookup&#10;node_dict = {}&#10;for node in nodes:&#10;    node_id = node['id']&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;    z = float(str(node.get('z', '0 ft')).split()[0])  # Default to 0 if z not present&#10;    node_dict[node_id] = (x, y, z)&#10;&#10;# Check for duplicate nodes&#10;print(&quot;\nChecking for duplicate nodes...&quot;)&#10;node_positions = {}&#10;for node_id, pos in node_dict.items():&#10;    pos_key = (pos[0], pos[1])  # Use only x,y for 2D&#10;    if pos_key in node_positions:&#10;        raise ValueError(f&quot;WARNING: Nodes {node_positions[pos_key]} and {node_id} are at the same position {pos_key}&quot;+&quot;This will cause numerical instability!&quot;)&#10;    else:&#10;        node_positions[pos_key] = node_id&#10;&#10;# Define function to get DOF indices for a node&#10;def get_dof(node_id):&#10;    return 2 * (node_id - 1), 2 * (node_id - 1) + 1&#10;&#10;# Initialize global stiffness matrix and force vector&#10;num_nodes = len(nodes)&#10;dof = 2 * num_nodes  # Degrees of freedom (x and y for each node)&#10;K_global = np.zeros((dof, dof))&#10;F_global = np.zeros(dof)&#10;&#10;# Material properties (A36 steel)&#10;E = 29000.0  # ksi - Young's modulus&#10;&#10;# Define section properties - now load from YAML if available&#10;if 'sections' in bridge:&#10;    sections = {}&#10;    for section in bridge['sections']:&#10;        sec_id = section['id']&#10;        area_str = str(section['area']).split()[0]  # Extract numeric part&#10;        r_str = str(section['r']).split()[0]        # Extract numeric part&#10;        sections[sec_id] = {&#10;            &quot;area&quot;: float(area_str),&#10;            &quot;r&quot;: float(r_str)&#10;        }&#10;    print(&quot;\nLoaded section properties from YAML:&quot;)&#10;    for sec_id, props in sections.items():&#10;        print(f&quot;  Section {sec_id}: Area = {props['area']} in^2, r = {props['r']} in&quot;)&#10;else:&#10;    # Default section properties if not in YAML&#10;    sections = {&#10;        1: {&quot;area&quot;: 7.65, &quot;r&quot;: 4.32},  # W12x26 - area in in^2, r is radius of gyration in inches&#10;        2: {&quot;area&quot;: 9.13, &quot;r&quot;: 3.47}   # W8x31 - area in in^2, r is radius of gyration in inches&#10;    }&#10;    print(&quot;\nUsing default section properties&quot;)&#10;&#10;# Store member data for later reference&#10;member_data = {}&#10;&#10;# Calculate axial stiffness for each member&#10;print(&quot;\nAssembling stiffness matrix...&quot;)&#10;for member in members:&#10;    member_id = member['id']&#10;    start = member['i_node']&#10;    end = member['j_node']&#10;    section_id = member['section']&#10;&#10;    # Get section properties&#10;    section_area = sections[section_id][&quot;area&quot;]  # in&#10;&#10;    # Calculate EA in kip-in (E in ksi, A in in =&gt; EA in kip)&#10;    EA = E * section_area&#10;&#10;    # Get coordinates&#10;    x1, y1, _ = node_dict[start]&#10;    x2, y2, _ = node_dict[end]&#10;&#10;    # Calculate length in ft&#10;    dx = x2 - x1&#10;    dy = y2 - y1&#10;    length_ft = np.sqrt(dx**2 + dy**2)&#10;&#10;    # Check for zero-length members&#10;    if length_ft &lt; 1e-6:&#10;        print(f&quot;ERROR: Member {member_id} has zero length (nodes {start} to {end})&quot;)&#10;        print(f&quot;  Node {start}: ({x1}, {y1})&quot;)&#10;        print(f&quot;  Node {end}: ({x2}, {y2})&quot;)&#10;        sys.exit(1)&#10;&#10;    length_in = length_ft * 12.0  # Convert to inches&#10;&#10;    # Calculate direction cosines&#10;    cos = dx / length_ft&#10;    sin = dy / length_ft&#10;&#10;    # Store member properties&#10;    member_data[member_id] = {&#10;        &quot;start&quot;: start,&#10;        &quot;end&quot;: end,&#10;        &quot;length_ft&quot;: length_ft,&#10;        &quot;length_in&quot;: length_in,&#10;        &quot;EA&quot;: EA,&#10;        &quot;cos&quot;: cos,&#10;        &quot;sin&quot;: sin,&#10;        &quot;section_id&quot;: section_id,&#10;        &quot;section_area&quot;: section_area&#10;    }&#10;&#10;    # Debug info for first few members&#10;    if member_id &lt;= 3:&#10;        print(f&quot;Member {member_id}: Length = {length_ft:.2f} ft ({length_in:.2f} in), EA = {EA:.2f} kip&quot;)&#10;        print(f&quot;  Direction: cos = {cos:.4f}, sin = {sin:.4f}&quot;)&#10;&#10;    # Local to global transformation matrix&#10;    T = np.array([&#10;        [ cos, sin, 0,   0],&#10;        [-sin, cos, 0,   0],&#10;        [0,   0,   cos, sin],&#10;        [0,   0,  -sin, cos]&#10;    ])&#10;&#10;    # Element stiffness matrix in local coordinates (for a truss element)&#10;    # k = EA/L in kip/in&#10;    k_axial = EA / length_in&#10;&#10;    k_local = np.array([&#10;        [ k_axial, 0, -k_axial, 0],&#10;        [0, 0,  0, 0],&#10;        [-k_axial, 0, k_axial, 0],&#10;        [0, 0,  0, 0]&#10;    ])&#10;&#10;    # Transform to global coordinates&#10;    k_global = T.T @ k_local @ T&#10;    print(f&quot;member id: {member_id}&quot;, k_global, sep=&quot;\n&quot;)&#10;    # Map local DOFs to global DOFs&#10;    dof_start = get_dof(start)&#10;    dof_end = get_dof(end)&#10;    dof_indices = [*dof_start, *dof_end]; print(f&quot;dof_indices: {dof_indices}&quot;)&#10;&#10;    # Assemble into global stiffness matrix&#10;    for i in range(4):&#10;        for j in range(4):&#10;            K_global[dof_indices[i], dof_indices[j]] += k_global[i, j]&#10;&#10;# Apply external forces from member loads&#10;print(&quot;\nApplying loads...&quot;)&#10;if 'member_loads' in bridge:&#10;    for load in bridge['member_loads']:&#10;        member_id = load['member_uid']&#10;        if member_id not in member_data:&#10;            print(f&quot;WARNING: Load references non-existent member {member_id}&quot;)&#10;            continue&#10;&#10;        member = next(m for m in members if m['id'] == member_id)&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        # Convert distributed load to equivalent nodal loads&#10;        wi = float(str(load['wi']).split()[0])  # kips/ft&#10;        wj = float(str(load['wj']).split()[0])  # kips/ft&#10;        length = member_data[member_id][&quot;length_ft&quot;]  # ft&#10;&#10;        # For uniform load, apply half to each node in y-direction&#10;        if abs(wi - wj) &lt; 1e-6:  # Uniform load&#10;            force = abs(wi) * length / 2  # kips (make positive)&#10;            _, dof_yi = get_dof(i_node)&#10;            _, dof_yj = get_dof(j_node)&#10;&#10;            # Debug info for first few loads&#10;            if member_id &lt;= 3:&#10;                print(f&quot;Load on member {member_id}: w = {wi} kips/ft, L = {length:.2f} ft&quot;)&#10;                print(f&quot;  Equivalent nodal forces: {force:.2f} kips (downward) at nodes {i_node} and {j_node}&quot;)&#10;&#10;            # Apply downward forces (negative in typical structural convention)&#10;            F_global[dof_yi] -= force  # Negative for downward&#10;            F_global[dof_yj] -= force  # Negative for downward&#10;        else:&#10;            # For non-uniform load (simplified approach)&#10;            force_i = abs(wi) * length / 3  # kips&#10;            force_j = abs(wj) * length / 3  # kips&#10;            _, dof_yi = get_dof(i_node)&#10;            _, dof_yj = get_dof(j_node)&#10;            F_global[dof_yi] -= force_i  # Negative for downward&#10;            F_global[dof_yj] -= force_j  # Negative for downward&#10;&#10;# Apply support constraints&#10;print(&quot;\nApplying support constraints:&quot;)&#10;constrained_dofs = []&#10;for support in supports:&#10;    node_id = support['node']&#10;    dof_x, dof_y = get_dof(node_id)&#10;&#10;    print(f&quot;Support at node {node_id}: ux={support['ux']}, uy={support['uy']}&quot;)&#10;&#10;    if support['ux'] == 1:  # Fixed in x-direction&#10;        constrained_dofs.append(dof_x)&#10;        K_global[dof_x, :] = 0&#10;        K_global[:, dof_x] = 0&#10;        K_global[dof_x, dof_x] = 1&#10;        F_global[dof_x] = 0&#10;&#10;    if support['uy'] == 1:  # Fixed in y-direction&#10;        constrained_dofs.append(dof_y)&#10;        K_global[dof_y, :] = 0&#10;        K_global[:, dof_y] = 0&#10;        K_global[dof_y, dof_y] = 1&#10;        F_global[dof_y] = 0&#10;&#10;print(f&quot;Total constrained DOFs: {len(constrained_dofs)}&quot;)&#10;print(f&quot;Free DOFs: {dof - len(constrained_dofs)}&quot;)&#10;&#10;# Check for zero diagonal elements (indicates singularity)&#10;diag_zeros = np.where(np.abs(np.diag(K_global)) &lt; 1e-10)[0]&#10;if len(diag_zeros) &gt; 0:&#10;    print(f&quot;\nWARNING: Zero diagonal elements detected at DOFs: {diag_zeros}&quot;)&#10;    for dof_idx in diag_zeros:&#10;        node_id = dof_idx // 2 + 1&#10;        dof_type = &quot;x&quot; if dof_idx % 2 == 0 else &quot;y&quot;&#10;        print(f&quot;  Node {node_id}, direction {dof_type}&quot;)&#10;&#10;        # Check if this DOF is connected to any members&#10;        connected_members = []&#10;        for mem_id, mem_data in member_data.items():&#10;            if mem_data[&quot;start&quot;] == node_id or mem_data[&quot;end&quot;] == node_id:&#10;                connected_members.append(mem_id)&#10;        print(f&quot;    Connected to members: {connected_members}&quot;)&#10;&#10;# Check if the stiffness matrix is symmetric (it should be)&#10;is_symmetric = np.allclose(K_global, K_global.T, rtol=1e-5, atol=1e-8)&#10;print(f&quot;\nStiffness matrix is symmetric: {is_symmetric}&quot;)&#10;&#10;# Analyze the condition of the matrix&#10;try:&#10;    # Compute the condition number&#10;    cond = np.linalg.cond(K_global)&#10;    print(f&quot;Condition number of stiffness matrix: {cond:.2e}&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        print(&quot;\nWARNING: Very high condition number detected!&quot;)&#10;        print(&quot;The structure may have:&quot;)&#10;        print(&quot;1. Duplicate nodes at the same location&quot;)&#10;        print(&quot;2. Insufficient supports (mechanism)&quot;)&#10;        print(&quot;3. Disconnected parts&quot;)&#10;        print(&quot;4. Numerical scaling issues&quot;)&#10;&#10;        # Find the ratio between max and min non-zero diagonal elements&#10;        diag = np.abs(np.diag(K_global))&#10;        nonzero_diag = diag[diag &gt; 1e-10]&#10;        if len(nonzero_diag) &gt; 0:&#10;            diag_ratio = np.max(nonzero_diag) / np.min(nonzero_diag)&#10;            print(f&quot;\nDiagonal scaling ratio: {diag_ratio:.2e}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;Could not compute condition number: {e}&quot;)&#10;    cond = float('inf')&#10;&#10;# Apply scaling to improve conditioning&#10;print(&quot;\nAttempting to solve the system...&quot;)&#10;try:&#10;    # Use a more robust solver from scipy&#10;    from scipy import linalg&#10;&#10;    # For very ill-conditioned systems, try regularization&#10;    if cond &gt; 1e14:&#10;        print(&quot;System is extremely ill-conditioned. Applying regularization...&quot;)&#10;        # Add small diagonal perturbation to improve conditioning&#10;        reg_factor = 1e-8 * np.max(np.abs(np.diag(K_global)))&#10;        K_regularized = K_global + reg_factor * np.eye(dof)&#10;&#10;        try:&#10;            displacements = linalg.solve(K_regularized, F_global, assume_a='sym')&#10;            print(&quot;Regularized solution successful&quot;)&#10;        except:&#10;            # Fall back to least squares&#10;            displacements, residuals, rank, s = linalg.lstsq(K_global, F_global)&#10;            print(f&quot;Least squares solution: rank={rank}/{dof}&quot;)&#10;    else:&#10;        # Try direct solution&#10;        displacements = linalg.solve(K_global, F_global, assume_a='sym')&#10;        print(&quot;Direct solution successful&quot;)&#10;&#10;    # Convert displacements from inches to feet for consistency&#10;    # Actually, the displacements are already in feet since we used consistent units&#10;&#10;    # Print first few displacement values for debugging&#10;    print(&quot;\nNodal displacements:&quot;)&#10;    print(&quot;Node | dx (in) | dy (in)&quot;)&#10;    print(&quot;-&quot; * 30)&#10;    for i in range(1, min(11, num_nodes + 1)):&#10;        dof_x, dof_y = get_dof(i)&#10;        # Convert to inches for display&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        print(f&quot;{i:4} | {dx_in:7.4f} | {dy_in:7.4f}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;All solution methods failed: {e}&quot;)&#10;    print(&quot;Using zero displacements as fallback&quot;)&#10;    displacements = np.zeros(dof)&#10;&#10;# Find maximum vertical displacement&#10;max_vert_disp = 0&#10;max_disp_node = None&#10;for node_id in node_dict:&#10;    _, dof_y = get_dof(node_id)&#10;    # Skip nodes that are supported&#10;    is_supported = any(s['node'] == node_id and s['uy'] == 1 for s in supports)&#10;    if not is_supported:&#10;        disp = abs(displacements[dof_y])&#10;        if disp &gt; max_vert_disp:&#10;            max_vert_disp = disp&#10;            max_disp_node = node_id&#10;&#10;# Convert to inches for display&#10;max_vert_disp_in = max_vert_disp * 12&#10;print(f&quot;\nMaximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}&quot;)&#10;&#10;# Calculate member forces&#10;member_forces = {}&#10;member_stresses = {}&#10;&#10;# Material properties (A36 steel)&#10;Fy = 36.0    # ksi - Yield strength&#10;Fu = 58.0    # ksi - Ultimate strength&#10;safety_factor_tension = 1.67&#10;safety_factor_compression = 1.67&#10;allowable_tension_stress = Fy / safety_factor_tension      # ksi&#10;allowable_compression_stress_max = Fy / safety_factor_compression  # ksi&#10;&#10;# Calculate forces and stresses for each member&#10;for member in members:&#10;    member_id = member['id']&#10;    if member_id not in member_data:&#10;        continue  # Skip members with zero length&#10;&#10;    mem_data = member_data[member_id]&#10;    start = mem_data[&quot;start&quot;]&#10;    end = mem_data[&quot;end&quot;]&#10;    area = mem_data[&quot;section_area&quot;]  # in&#10;    cos = mem_data[&quot;cos&quot;]&#10;    sin = mem_data[&quot;sin&quot;]&#10;&#10;    # Get displacements at both nodes (in feet)&#10;    dof_x1, dof_y1 = get_dof(start)&#10;    dof_x2, dof_y2 = get_dof(end)&#10;&#10;    # Calculate relative displacement in the axial direction (in feet)&#10;    delta_u1 = displacements[dof_x1] * cos + displacements[dof_y1] * sin&#10;    delta_u2 = displacements[dof_x2] * cos + displacements[dof_y2] * sin&#10;    delta_axial = delta_u2 - delta_u1&#10;&#10;    # Convert to inches for force calculation&#10;    delta_axial_in = delta_axial * 12&#10;&#10;    # Calculate axial force (F = EA/L * delta)&#10;    EA = mem_data[&quot;EA&quot;]  # kip&#10;    force = (EA / mem_data[&quot;length_in&quot;]) * delta_axial_in  # kips&#10;    member_forces[member_id] = force&#10;&#10;    # Calculate axial stress&#10;    stress = force / area  # kips/in = ksi&#10;    member_stresses[member_id] = stress&#10;&#10;    # Debug output for the first few members&#10;    if member_id &lt;= 3 or member_id == 32:&#10;        print(f&quot;\nMember {member_id} analysis:&quot;)&#10;        print(f&quot;  Length = {mem_data['length_ft']:.2f} ft&quot;)&#10;        print(f&quot;  Node {start}: dx = {displacements[dof_x1]*12:.4f} in, dy = {displacements[dof_y1]*12:.4f} in&quot;)&#10;        print(f&quot;  Node {end}: dx = {displacements[dof_x2]*12:.4f} in, dy = {displacements[dof_y2]*12:.4f} in&quot;)&#10;        print(f&quot;  Delta axial = {delta_axial_in:.4f} in&quot;)&#10;        print(f&quot;  Force = {force:.2f} kips&quot;)&#10;        print(f&quot;  Stress = {stress:.2f} ksi&quot;)&#10;&#10;# Calculate safety factors for all members&#10;member_safety_factors = {}&#10;member_status = {}&#10;&#10;# Define zero force threshold&#10;ZERO_FORCE_THRESHOLD = 0.1  # Consider forces below this threshold as &quot;zero&quot;&#10;&#10;# Replace the problematic part in the safety factors calculation&#10;for member_id, stress in member_stresses.items():&#10;    section_id = member_data[member_id][&quot;section_id&quot;]&#10;    section = sections[section_id]&#10;&#10;    if abs(stress) &lt; ZERO_FORCE_THRESHOLD / section[&quot;area&quot;]:&#10;        # Zero/near-zero stress&#10;        safety_factor = float('inf')&#10;        limit = allowable_tension_stress  # Arbitrary for zero-force members&#10;        status = &quot;OK&quot;&#10;    elif stress &gt;= 0:  # Tension&#10;        safety_factor = allowable_tension_stress / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_tension_stress&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;    else:  # Compression&#10;        # Calculate allowable compression stress based on slenderness&#10;        length_inches = member_data[member_id][&quot;length_in&quot;]&#10;        slenderness = length_inches / section[&quot;r&quot;]&#10;&#10;        if slenderness &gt; 100:  # For slender members&#10;            critical_stress = (np.pi**2 * E) / (slenderness**2)&#10;            allowable_compression = min(allowable_compression_stress_max, critical_stress/safety_factor_compression)&#10;        else:  # For stocky members&#10;            allowable_compression = allowable_compression_stress_max&#10;&#10;        safety_factor = allowable_compression / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_compression&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;&#10;    member_safety_factors[member_id] = safety_factor&#10;    member_status[member_id] = {&#10;        &quot;stress&quot;: stress,&#10;        &quot;allowable&quot;: limit,&#10;        &quot;safety_factor&quot;: safety_factor,&#10;        &quot;status&quot;: status&#10;    }&#10;&#10;# After calculating safety factors, add a summary of members below minimum&#10;members_below_min_sf = []&#10;for member_id, status_info in member_status.items():&#10;    if status_info[&quot;safety_factor&quot;] &lt; min_safety_factor and status_info[&quot;safety_factor&quot;] &lt; 100:&#10;        members_below_min_sf.append({&#10;            'id': member_id,&#10;            'sf': status_info[&quot;safety_factor&quot;],&#10;            'stress': status_info[&quot;stress&quot;],&#10;            'allowable': status_info[&quot;allowable&quot;]&#10;        })&#10;&#10;if members_below_min_sf:&#10;    print(f&quot;\n{len(members_below_min_sf)} members have safety factor below {min_safety_factor}:&quot;)&#10;    for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:10]:  # Show worst 10&#10;        print(f&quot;  Member {mem['id']}: SF = {mem['sf']:.2f}, Stress = {abs(mem['stress']):.1f} ksi&quot;)&#10;&#10;# Create figure for the PDF - add timestamp to filenames&#10;timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M%S')&#10;pdf_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_Analysis_{timestamp}.pdf&quot;)&#10;text_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_Analysis_{timestamp}.txt&quot;)&#10;&#10;# Open the text file for writing the report&#10;with open(text_filename, 'w') as txt_report:&#10;    # Write header information&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(&quot;PRATT BRIDGE STRUCTURAL ANALYSIS REPORT\n&quot;)&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(f&quot;Analysis Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}\n&quot;)&#10;    txt_report.write(f&quot;Input File: {bridge_file}\n&quot;)&#10;    txt_report.write(f&quot;Design Minimum Safety Factor: {min_safety_factor}\n\n&quot;)&#10;&#10;    # Write model statistics&#10;    txt_report.write(&quot;MODEL STATISTICS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Number of nodes: {num_nodes}\n&quot;)&#10;    txt_report.write(f&quot;Number of members: {len(members)}\n&quot;)&#10;    txt_report.write(f&quot;Number of supports: {len(supports)}\n&quot;)&#10;    txt_report.write(f&quot;Degrees of freedom: {dof}\n&quot;)&#10;    txt_report.write(f&quot;Constrained DOFs: {len(constrained_dofs)}\n&quot;)&#10;    txt_report.write(f&quot;Free DOFs: {dof - len(constrained_dofs)}\n\n&quot;)&#10;&#10;    # Write material properties&#10;    txt_report.write(&quot;MATERIAL PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Material: A36 Steel\n&quot;)&#10;    txt_report.write(f&quot;Young's modulus: {E} ksi\n&quot;)&#10;    txt_report.write(f&quot;Yield strength: {Fy} ksi\n&quot;)&#10;    txt_report.write(f&quot;Ultimate strength: {Fu} ksi\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (tension): {safety_factor_tension}\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (compression): {safety_factor_compression}\n\n&quot;)&#10;&#10;    # Write section properties&#10;    txt_report.write(&quot;SECTION PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    for sec_id, props in sections.items():&#10;        txt_report.write(f&quot;Section {sec_id}: Area = {props['area']} in, r = {props['r']} in\n&quot;)&#10;    txt_report.write(&quot;\n&quot;)&#10;&#10;    # Write analysis results summary&#10;    txt_report.write(&quot;ANALYSIS RESULTS SUMMARY\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Maximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}\n&quot;)&#10;&#10;    # Calculate critical values&#10;    critical_sf = float('inf')&#10;    critical_member = None&#10;    overstressed_count = 0&#10;    for member_id, status_info in member_status.items():&#10;        sf = status_info[&quot;safety_factor&quot;]&#10;        if sf &lt; critical_sf and sf &lt; 100:&#10;            critical_sf = sf&#10;            critical_member = member_id&#10;        if status_info[&quot;status&quot;] == &quot;OVERSTRESSED&quot;:&#10;            overstressed_count += 1&#10;&#10;    txt_report.write(f&quot;Number of tension members: {sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of compression members: {sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of zero-force members: {sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Overstressed members: {overstressed_count}\n&quot;)&#10;    txt_report.write(f&quot;Maximum member force: {max(abs(f) for f in member_forces.values()):.2f} kips\n&quot;)&#10;    txt_report.write(f&quot;Maximum member stress: {max(abs(s) for s in member_stresses.values()):.2f} ksi\n&quot;)&#10;    txt_report.write(f&quot;Minimum safety factor: {critical_sf:.2f} (Member #{critical_member})\n\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;WARNING: High condition number indicates numerical instability.\n&quot;)&#10;        txt_report.write(&quot;The structure may have:\n&quot;)&#10;        txt_report.write(&quot;1. Duplicate nodes at the same location\n&quot;)&#10;        txt_report.write(&quot;2. Insufficient supports (mechanism)\n&quot;)&#10;        txt_report.write(&quot;3. Disconnected parts\n&quot;)&#10;        txt_report.write(&quot;4. Numerical scaling issues\n\n&quot;)&#10;&#10;    # Write detailed member results&#10;    txt_report.write(&quot;DETAILED MEMBER RESULTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Member | Nodes (i-j) | Force (kips) | Stress (ksi) | Type | S.F. | Status\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 80 + &quot;\n&quot;)&#10;&#10;    for member in sorted(members, key=lambda m: m['id']):&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;        stress = member_stresses[member_id]&#10;        sf = member_safety_factors[member_id]&#10;        status = member_status[member_id][&quot;status&quot;]&#10;&#10;        # Fix the text report formatting to use only ASCII&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            force_type = &quot;ZERO&quot;&#10;            sf_text = &quot;inf&quot;&#10;        elif force &gt; 0:&#10;            force_type = &quot;TENSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;        else:&#10;            force_type = &quot;COMPRESSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;&#10;        txt_report.write(&#10;            f&quot;{member_id:6} | {i_node:2}-{j_node:&lt;2} | {abs(force):11.2f} | {abs(stress):10.2f} | {force_type:10} | {sf_text:&gt;5} | {status}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;&#10;    # Write nodal displacements&#10;    txt_report.write(&quot;NODAL DISPLACEMENTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Node | dx (inches) | dy (inches)\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 35 + &quot;\n&quot;)&#10;&#10;    for node_id in sorted(node_dict.keys()):&#10;        dof_x, dof_y = get_dof(node_id)&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        txt_report.write(f&quot;{node_id:4} | {dx_in:11.4f} | {dy_in:11.4f}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;    txt_report.write(&quot;RECOMMENDATIONS FOR STRUCTURE REFINEMENT\n&quot;)&#10;    txt_report.write(&quot;----------------------------------------\n&quot;)&#10;&#10;    if members_below_min_sf:&#10;        txt_report.write(f&quot;1. {len(members_below_min_sf)} members have safety factor below the design minimum of {min_safety_factor}:\n&quot;)&#10;        for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:20]:  # Show worst 20&#10;            member = next(m for m in members if m['id'] == mem['id'])&#10;            txt_report.write(f&quot;   - Member {mem['id']} (nodes {member['i_node']}-{member['j_node']}): SF = {mem['sf']:.2f}\n&quot;)&#10;&#10;        # Calculate required section increase&#10;        worst_sf = min(mem['sf'] for mem in members_below_min_sf)&#10;        required_increase = min_safety_factor / worst_sf&#10;        txt_report.write(f&quot;\n   Worst member requires approximately {required_increase:.1f}x increase in capacity.\n&quot;)&#10;        txt_report.write(f&quot;   Consider using larger sections or reducing the loading.\n&quot;)&#10;    else:&#10;        txt_report.write(&quot;1. All members meet the minimum safety factor requirement.\n&quot;)&#10;        txt_report.write(&quot;   Consider optimizing the structure by reducing sections for members with high safety factors.\n&quot;)&#10;&#10;    if max_vert_disp_in &gt; 2.0:  # Assuming 2 inches as a reasonable deflection limit&#10;        txt_report.write(f&quot;2. Consider stiffening the structure to reduce the maximum deflection (currently {max_vert_disp_in:.4f} inches).\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;3. Fix numerical stability issues by reviewing structure connectivity and supports.\n&quot;)&#10;&#10;    txt_report.write(&quot;\nReport generated by pyMAOS Truss Analysis Tool\n&quot;)&#10;&#10;print(f&quot;Text report saved to: {text_filename}&quot;)&#10;&#10;with PdfPages(pdf_filename) as pdf:&#10;    # 1. BRIDGE ANALYSIS SUMMARY page&#10;    fig = plt.figure(figsize=(8.5, 11))&#10;    plt.axis('off')&#10;&#10;    # Add overall bridge status text - avoid using unicode characters&#10;    if overstressed_count == 0:&#10;        status_text = &quot;BRIDGE IS STRUCTURALLY ADEQUATE&quot;&#10;        status_color = 'green'&#10;    else:&#10;        status_text = f&quot;WARNING: BRIDGE HAS {overstressed_count} OVERSTRESSED MEMBERS&quot;&#10;        status_color = 'red'&#10;&#10;    plt.figtext(0.5, 0.9, &quot;BRIDGE ANALYSIS SUMMARY&quot;, ha='center', fontsize=16, weight='bold')&#10;    plt.figtext(0.5, 0.85, status_text, ha='center', fontsize=14, weight='bold', color=status_color)&#10;&#10;    # Add displacement information&#10;    plt.figtext(0.5, 0.78, f&quot;Maximum Vertical Displacement: {max_vert_disp_in:.4f} inches at Node {max_disp_node}&quot;,&#10;                ha='center', fontsize=12)&#10;&#10;    # Add summary statistics&#10;    critical_text = f&quot;Most critical member: #{critical_member} (Safety Factor: {critical_sf:.2f})&quot;&#10;    plt.figtext(0.5, 0.73, critical_text, ha='center', fontsize=12)&#10;&#10;    # Add a summary table of key statistics&#10;    summary_data = [&#10;        [&quot;Total Members&quot;, f&quot;{len(members)}&quot;],&#10;        [&quot;Tension Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Compression Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Zero-Force Members&quot;, f&quot;{sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Overstressed Members&quot;, f&quot;{overstressed_count}&quot;],&#10;        [&quot;Maximum Member Force&quot;, f&quot;{max(abs(f) for f in member_forces.values()):.2f} kips&quot;],&#10;        [&quot;Maximum Member Stress&quot;, f&quot;{max(abs(s) for s in member_stresses.values()):.2f} ksi&quot;],&#10;        [&quot;Minimum Safety Factor&quot;, f&quot;{critical_sf:.2f}&quot;],&#10;        [&quot;Maximum Displacement&quot;, f&quot;{max_vert_disp_in:.4f} inches&quot;],&#10;    ]&#10;&#10;    # Create a table in the middle of the page&#10;    ax = plt.subplot(111)&#10;    ax.axis('off')&#10;    tbl = plt.table(cellText=summary_data, colLabels=[&quot;Metric&quot;, &quot;Value&quot;],&#10;                    loc='center', cellLoc='left')&#10;    tbl.auto_set_font_size(False)&#10;    tbl.set_fontsize(10)&#10;    tbl.scale(1, 1.5)&#10;&#10;    # Add design criteria info&#10;    criteria = (&#10;        f&quot;Design Criteria:\n&quot;&#10;        f&quot;- Material: A36 Steel (Fy = 36 ksi)\n&quot;&#10;        f&quot;- Allowable tension stress: {allowable_tension_stress:.1f} ksi\n&quot;&#10;        f&quot;- Allowable compression stress: Based on member slenderness\n&quot;&#10;        f&quot;- Safety factor: {safety_factor_tension:.2f}&quot;&#10;    )&#10;    plt.figtext(0.5, 0.2, criteria, ha='center', fontsize=10,&#10;                bbox=dict(facecolor='#eeeeee', alpha=0.7, boxstyle='round,pad=0.5'))&#10;&#10;    # Add timestamp&#10;    plt.figtext(0.5, 0.1, f&quot;Analysis completed on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    # Save the summary page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 2. Reliability Analysis - Safety Factors plot&#10;    fig, ax = plt.subplots(figsize=(11, 8.5))  # Changed to landscape orientation&#10;&#10;    # Use plt.colormaps instead of cm.get_cmap to avoid deprecation warning&#10;    cmap = plt.colormaps['RdYlGn']  # Red-Yellow-Green colormap&#10;    norm = plt.Normalize(0.5, 2.0)&#10;&#10;    # Plot members with color based on safety factors&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        safety_factor = member_safety_factors[member_id]&#10;        safety_factor_capped = min(safety_factor, 5.0)  # Cap extremely high values for visualization&#10;&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        x = [x1, x2]&#10;        y = [y1, y2]&#10;&#10;        color = cmap(norm(safety_factor_capped))&#10;        linewidth = 3  # Consistent line width&#10;&#10;        ax.plot(x, y, color=color, linewidth=linewidth)&#10;&#10;        # Add safety factor label at midpoint&#10;        mid_x = (x1 + x2) / 2&#10;        mid_y = (y1 + y2) / 2&#10;&#10;        # Format infinity as &quot;&quot;&#10;        sf_text = &quot;&quot; if safety_factor &gt; 100 else f&quot;{safety_factor:.1f}&quot;&#10;&#10;        ax.text(mid_x, mid_y, sf_text,&#10;                fontsize=6, ha='center', va='center',&#10;                bbox=dict(facecolor='white', alpha=0.7, pad=1))&#10;&#10;    # Plot nodes and supports&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        ax.plot(x, y, 'ko', markersize=5)&#10;        ax.text(x+1, y+1, f&quot;{node_id}&quot;, fontsize=7)&#10;&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, _ = node_dict[node_id]&#10;        if support['ux'] == 1 and support['uy'] == 1:&#10;            ax.plot(x, y-2, 'ks', markersize=8)&#10;        elif support['ux'] == 0 and support['uy'] == 1:&#10;            ax.plot(x, y-2, 'ko', markersize=8)&#10;&#10;    # Add a colorbar&#10;    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)&#10;    sm.set_array([])&#10;    cbar = plt.colorbar(sm, ax=ax, label='Safety Factor', shrink=0.8)&#10;    cbar.set_ticks([0.5, 1.0, 1.5, 2.0])&#10;    cbar.set_ticklabels(['0.5', '1.0 (Limit)', '1.5', ' 2.0'])&#10;&#10;    # Set plot limits and labels&#10;    max_x = max(node_dict[n][0] for n in node_dict)&#10;    max_y = max(node_dict[n][1] for n in node_dict)&#10;    ax.set_xlim(-5, max_x + 15)&#10;    ax.set_ylim(-5, max_y + 5)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;    ax.set_title('Pratt Truss Bridge Reliability Analysis - Safety Factors', fontsize=12)&#10;    ax.grid(True)&#10;    plt.tight_layout(pad=2.0, rect=[0, 0, 1, 0.95])&#10;&#10;    # Save the safety factor visualization to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 3. Member Forces Summary Tables (split across pages) with node IDs&#10;    rows_per_page = 20  # Adjust as needed&#10;    all_members = sorted(members, key=lambda m: m['id'])&#10;    member_chunks = [all_members[i:i+rows_per_page] for i in range(0, len(all_members), rows_per_page)]&#10;&#10;    for page_idx, member_chunk in enumerate(member_chunks):&#10;        fig = plt.figure(figsize=(8.5, 11))&#10;        gs = gridspec.GridSpec(1, 1)&#10;        ax = plt.subplot(gs[0])&#10;        ax.axis('tight')&#10;        ax.axis('off')&#10;&#10;        # Create summary data for this chunk&#10;        table_data = []&#10;        table_data.append(['Member', 'Nodes (i-j)', 'Force (kips)', 'Type'])&#10;&#10;        for member in member_chunk:&#10;            member_id = member['id']&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;            force = member_forces[member_id]&#10;&#10;            if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;                force_type = &quot;ZERO&quot;&#10;            elif force &gt; 0:&#10;                force_type = &quot;TENSION&quot;&#10;            else:&#10;                force_type = &quot;COMPRESSION&quot;&#10;&#10;            table_data.append([str(member_id), f&quot;{i_node}-{j_node}&quot;, f&quot;{abs(force):.2f}&quot;, force_type])&#10;&#10;        # Create table with smaller font&#10;        table = ax.table(cellText=table_data, loc='center', cellLoc='center')&#10;        table.auto_set_font_size(False)&#10;        table.set_fontsize(8)&#10;        table.scale(1, 1.4)&#10;&#10;        # Add title with page number but more space at the top&#10;        plt.title(f&quot;Member Forces Summary (Page {page_idx+1} of {len(member_chunks)})&quot;,&#10;                  fontsize=14, y=0.98, pad=20)&#10;&#10;        # Add metadata&#10;        plt.figtext(0.5, 0.03,&#10;                    f&quot;Pratt Bridge Analysis - Generated on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                    ha='center', fontsize=6)&#10;&#10;        # Save the page to PDF&#10;        pdf.savefig(fig)&#10;        plt.close(fig)&#10;&#10;    # 4. Member Forces plot&#10;    fig, ax = plt.subplots(figsize=(11, 8.5))  # Changed to landscape orientation&#10;&#10;    # Plot members with color based on tension/compression/zero&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;&#10;        # Find the coordinates for both nodes&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        x = [x1, x2]&#10;        y = [y1, y2]&#10;&#10;        # Color: red for tension, blue for compression, black for zero/near-zero&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            color = 'black'  # Zero force&#10;            linestyle = '-'&#10;            linewidth = 1.5&#10;        elif force &gt; 0:&#10;            color = 'red'  # Tension&#10;            linestyle = '-'&#10;            linewidth = 2 + min(5, abs(force)/100)  # Scale width with force magnitude&#10;        else:&#10;            color = 'blue'  # Compression&#10;            linestyle = '-'&#10;            linewidth = 2 + min(5, abs(force)/100)  # Scale width with force magnitude&#10;&#10;        # Plot the member&#10;        ax.plot(x, y, color=color, linestyle=linestyle, linewidth=linewidth)&#10;&#10;        # Add force label at midpoint - reduced font size&#10;        mid_x = (x1 + x2) / 2&#10;        mid_y = (y1 + y2) / 2&#10;        ax.text(mid_x, mid_y, f&quot;{abs(force):.1f}&quot;,&#10;                fontsize=6, ha='center', va='center',&#10;                bbox=dict(facecolor='white', alpha=0.7, pad=1))&#10;&#10;    # Plot nodes&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        ax.plot(x, y, 'ko', markersize=6)&#10;        ax.text(x+1, y+1, f&quot;{node_id}&quot;, fontsize=7)&#10;&#10;    # Plot supports&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, _ = node_dict[node_id]&#10;&#10;        # Different markers for different support types&#10;        if support['ux'] == 1 and support['uy'] == 1:&#10;            # Pinned support - triangle&#10;            ax.plot(x, y-2, 'ks', markersize=10)&#10;        elif support['ux'] == 0 and support['uy'] == 1:&#10;            # Roller support - circle&#10;            ax.plot(x, y-2, 'ko', markersize=10)&#10;&#10;    # Add legend&#10;    red_line = plt.Line2D([0], [0], color='red', linewidth=3, label='Tension')&#10;    blue_line = plt.Line2D([0], [0], color='blue', linewidth=3, label='Compression')&#10;    black_line = plt.Line2D([0], [0], color='black', linewidth=2, label='Zero Force')&#10;    ax.legend(handles=[red_line, blue_line, black_line], loc='upper right', fontsize=8)&#10;&#10;    # Set plot limits and labels&#10;    ax.set_xlim(-5, max_x + 15)  # Extra space on right for labels&#10;    ax.set_ylim(-5, max_y + 5)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;    ax.set_title('Pratt Truss Bridge Analysis - Member Forces', fontsize=12)&#10;    ax.grid(True)&#10;&#10;    # Use tight_layout with adjusted parameters&#10;    plt.tight_layout(pad=2.0, rect=[0, 0, 1, 0.95])&#10;&#10;    # Save the member forces plot to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 5. Displacement visualization&#10;    fig, ax = plt.subplots(figsize=(12, 9))  # Increased figure size for better visibility&#10;&#10;    # Draw original structure in light gray&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        ax.plot([x1, x2], [y1, y2], color='lightgray', linestyle='-', linewidth=1, alpha=0.5)&#10;&#10;    # Calculate max displacement for proper scaling&#10;    max_disp_magnitude = 0&#10;    for node_id in node_dict:&#10;        dof_x, dof_y = get_dof(node_id)&#10;        disp_magnitude = np.sqrt(displacements[dof_x]**2 + displacements[dof_y]**2)&#10;        max_disp_magnitude = max(max_disp_magnitude, disp_magnitude)&#10;&#10;    # More reasonable scale factor - aim for approximately 5-10% of bridge span&#10;    max_span = max(node_dict[n][0] for n in node_dict) - min(node_dict[n][0] for n in node_dict)&#10;    bridge_height = max(node_dict[n][1] for n in node_dict) - min(node_dict[n][1] for n in node_dict)&#10;    target_max_disp = min(max_span, bridge_height) * 0.05  # More conservative scaling&#10;&#10;    # Calculate scale factor (with protection against division by zero)&#10;    if max_disp_magnitude &gt; 1e-10:&#10;        scale_factor = target_max_disp / max_disp_magnitude&#10;        # Ensure scale factor is rounded to a clean number for display&#10;        scale_magnitude = 10 ** int(np.log10(scale_factor))&#10;        scale_factor = round(scale_factor / scale_magnitude) * scale_magnitude&#10;    else:&#10;        scale_factor = 50.0  # Default if displacements are effectively zero&#10;&#10;    # Print debug info for node 12 (central top chord)&#10;    if 12 in node_dict:&#10;        dof_x12, dof_y12 = get_dof(12)&#10;        print(f&quot;\nDebug - Node 12 displacement:&quot;)&#10;        print(f&quot;  Original position: ({node_dict[12][0]}, {node_dict[12][1]})&quot;)&#10;        print(f&quot;  Displacement: dx={displacements[dof_x12]*12:.6f} in, dy={displacements[dof_y12]*12:.6f} in&quot;)&#10;        print(f&quot;  Scaled displacement: dx={displacements[dof_x12]*scale_factor:.4f} ft, dy={displacements[dof_y12]*scale_factor:.4f} ft&quot;)&#10;&#10;    # Precalculate the max and min coordinates after displacement to ensure proper plot limits&#10;    min_x_disp = float('inf')&#10;    min_y_disp = float('inf')&#10;    max_x_disp = float('-inf')&#10;    max_y_disp = float('-inf')&#10;&#10;    # First pass - calculate extents of displaced structure&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        dof_x, dof_y = get_dof(node_id)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;&#10;        min_x_disp = min(min_x_disp, x_new)&#10;        min_y_disp = min(min_y_disp, y_new)&#10;        max_x_disp = max(max_x_disp, x_new)&#10;        max_y_disp = max(max_y_disp, y_new)&#10;&#10;    # Draw displaced structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;&#10;        # Get displacements&#10;        dof_x1, dof_y1 = get_dof(i_node)&#10;        dof_x2, dof_y2 = get_dof(j_node)&#10;&#10;        # Apply displacements&#10;        x1_new = x1 + displacements[dof_x1] * scale_factor&#10;        y1_new = y1 + displacements[dof_y1] * scale_factor&#10;        x2_new = x2 + displacements[dof_x2] * scale_factor&#10;        y2_new = y2 + displacements[dof_y2] * scale_factor&#10;&#10;        # Draw displaced member&#10;        ax.plot([x1_new, x2_new], [y1_new, y2_new], color='blue', linestyle='-', linewidth=1.5)&#10;&#10;        # Add small markers at displaced node positions for clarity&#10;        ax.plot(x1_new, y1_new, 'b.', markersize=4)&#10;        ax.plot(x2_new, y2_new, 'b.', markersize=4)&#10;&#10;    # Highlight the node with maximum displacement - directly on the plot without a box&#10;    if max_disp_node:&#10;        x, y, _ = node_dict[max_disp_node]&#10;        dof_x, dof_y = get_dof(max_disp_node)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;&#10;        # Use a more visible marker directly on the plot&#10;        ax.plot(x_new, y_new, 'ro', markersize=8)&#10;&#10;        # Add the label directly at the node with smaller text and no box&#10;        label_x = x_new + 0.03 * max_span&#10;        label_y = y_new + 0.02 * max_span&#10;        ax.text(label_x, label_y, f&quot;Node {max_disp_node}: {max_vert_disp_in:.2f} in&quot;,&#10;                fontsize=8, color='red', ha='left', va='bottom',&#10;                path_effects=[plt.matplotlib.patheffects.withStroke(linewidth=3, foreground='white')])&#10;&#10;    # Add legend&#10;    orig = plt.Line2D([0], [0], color='lightgray', linestyle='-', linewidth=1, alpha=0.5, label='Original Structure')&#10;    disp = plt.Line2D([0], [0], color='blue', linestyle='-', linewidth=1.5, label='Displaced Structure')&#10;    ax.legend(handles=[orig, disp], loc='upper right', fontsize=8)&#10;&#10;    # Set plot limits to ensure complete structure visibility, with additional padding&#10;    min_x = min(node_dict[n][0] for n in node_dict)&#10;    min_y = min(node_dict[n][1] for n in node_dict)&#10;    max_x = max(node_dict[n][0] for n in node_dict)&#10;    max_y = max(node_dict[n][1] for n in node_dict)&#10;&#10;    # Ensure we include both original and displaced structures with padding&#10;    plot_min_x = min(min_x, min_x_disp) - 0.1 * max_span&#10;    plot_min_y = min(min_y, min_y_disp) - 0.15 * bridge_height&#10;    plot_max_x = max(max_x, max_x_disp) + 0.1 * max_span&#10;    plot_max_y = max(max_y, max_y_disp) + 0.1 * bridge_height&#10;&#10;    ax.set_xlim(plot_min_x, plot_max_x)&#10;    ax.set_ylim(plot_min_y, plot_max_y)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;&#10;    # Format scale factor nicely&#10;    if scale_factor &gt;= 1000:&#10;        scale_factor_text = f&quot;{scale_factor/1000:.1f}k&quot;&#10;    elif scale_factor &gt;= 100:&#10;        scale_factor_text = f&quot;{int(scale_factor)}&quot;&#10;    else:&#10;        scale_factor_text = f&quot;{scale_factor:.1f}&quot;&#10;&#10;    ax.set_title(f'Pratt Truss Bridge - Displacement Analysis (Scale Factor: {scale_factor_text})', fontsize=12)&#10;&#10;    # Add note about displacement scale&#10;    plt.figtext(0.5, 0.01,&#10;                f&quot;Note: Displacements are scaled by a factor of {scale_factor_text} for visibility. &quot;&#10;                f&quot;Actual maximum displacement: {max_vert_disp_in:.4f} inches.&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    ax.grid(True)&#10;    plt.tight_layout(pad=2.0, rect=[0, 0.02, 1, 0.98])&#10;&#10;    # Save the displacement page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # Add PDF metadata&#10;    d = pdf.infodict()&#10;    d['Title'] = 'Pratt Bridge Structural Analysis'&#10;    d['Author'] = 'pyMAOS Truss Analysis Tool'&#10;    d['Subject'] = 'Structural analysis and reliability assessment'&#10;    d['Keywords'] = 'truss, structural analysis, bridge, reliability'&#10;    d['CreationDate'] = datetime.datetime.now()&#10;    d['ModDate'] = datetime.datetime.now()&#10;&#10;# Print summary of results to console&#10;print(&quot;\nMember Forces Summary:&quot;)&#10;print(&quot;----------------------&quot;)&#10;print(&quot;Member | Force (kips) | Type&quot;)&#10;print(&quot;----------------------&quot;)&#10;for member in sorted(members, key=lambda m: m['id']):&#10;    member_id = member['id']&#10;    force = member_forces[member_id]&#10;    if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;        force_type = &quot;ZERO&quot;&#10;    elif force &gt; 0:&#10;        force_type = &quot;TENSION&quot;&#10;    else:&#10;        force_type = &quot;COMPRESSION&quot;&#10;    print(f&quot;{member_id:6} | {abs(force):11.2f} | {force_type}&quot;)&#10;&#10;# Print numerical stability information&#10;print(&quot;\nNumerical Stability Info:&quot;)&#10;print(&quot;-----------------------&quot;)&#10;print(f&quot;Matrix size: {dof}{dof}&quot;)&#10;print(f&quot;Condition number: {cond:.2e}&quot;)&#10;print(f&quot;Number of members: {len(member_data)}&quot;)&#10;print(f&quot;Maximum force magnitude: {max(abs(f) for f in member_forces.values()):.2f} kips&quot;)&#10;print(f&quot;Maximum displacement: {max_vert_disp_in:.4f} inches&quot;)&#10;&#10;if cond &gt; 1e12:&#10;    print(&quot;\nWARNING: High condition number indicates numerical instability.&quot;)&#10;    print(&quot;\nRECOMMENDATIONS:&quot;)&#10;    print(&quot;1. The duplicate nodes 6 and 13 at (100, 0) should be merged into a single node&quot;)&#10;    print(&quot;2. Update member connectivity to reference the merged node&quot;)&#10;    print(&quot;3. Ensure all supports are properly defined&quot;)&#10;    print(&quot;4. Check for any disconnected parts of the structure&quot;)&#10;&#10;# Display the plot on screen&#10;plt.show()&#10;" />
              <option name="updatedContent" value="import sys&#10;import yaml&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;import os&#10;from matplotlib.backends.backend_pdf import PdfPages&#10;import datetime&#10;import matplotlib.gridspec as gridspec&#10;import matplotlib.cm as cm&#10;&#10;# Load the bridge definition&#10;bridge_file = 'Pratt_Bridge.YAML'&#10;print(f&quot;Loading bridge from {bridge_file}&quot;)&#10;with open(os.path.join(os.path.dirname(__file__), bridge_file), 'r') as file:&#10;    bridge = yaml.safe_load(file)&#10;&#10;# Extract design parameters if present&#10;design_params = bridge.get('design_parameters', {})&#10;min_safety_factor = design_params.get('min_safety_factor', 1.0)&#10;print(f&quot;\nDesign minimum safety factor: {min_safety_factor}&quot;)&#10;&#10;# Extract nodes and members&#10;nodes = bridge['nodes']&#10;members = bridge['members']&#10;supports = bridge['supports']&#10;&#10;# Create a dictionary for easier node lookup&#10;node_dict = {}&#10;for node in nodes:&#10;    node_id = node['id']&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;    z = float(str(node.get('z', '0 ft')).split()[0])  # Default to 0 if z not present&#10;    node_dict[node_id] = (x, y, z)&#10;&#10;# Check for duplicate nodes&#10;print(&quot;\nChecking for duplicate nodes...&quot;)&#10;node_positions = {}&#10;for node_id, pos in node_dict.items():&#10;    pos_key = (pos[0], pos[1])  # Use only x,y for 2D&#10;    if pos_key in node_positions:&#10;        raise ValueError(f&quot;WARNING: Nodes {node_positions[pos_key]} and {node_id} are at the same position {pos_key}&quot;+&quot;This will cause numerical instability!&quot;)&#10;    else:&#10;        node_positions[pos_key] = node_id&#10;&#10;# Define function to get DOF indices for a node&#10;def get_dof(node_id):&#10;    return 2 * (node_id - 1), 2 * (node_id - 1) + 1&#10;&#10;# Initialize global stiffness matrix and force vector&#10;num_nodes = len(nodes)&#10;dof = 2 * num_nodes  # Degrees of freedom (x and y for each node)&#10;K_global = np.zeros((dof, dof))&#10;F_global = np.zeros(dof)&#10;&#10;# Material properties (A36 steel)&#10;E = 29000.0  # ksi - Young's modulus&#10;&#10;# Define section properties - now load from YAML if available&#10;if 'sections' in bridge:&#10;    sections = {}&#10;    for section in bridge['sections']:&#10;        sec_id = section['id']&#10;        area_str = str(section['area']).split()[0]  # Extract numeric part&#10;        r_str = str(section['r']).split()[0]        # Extract numeric part&#10;        sections[sec_id] = {&#10;            &quot;area&quot;: float(area_str),&#10;            &quot;r&quot;: float(r_str)&#10;        }&#10;    print(&quot;\nLoaded section properties from YAML:&quot;)&#10;    for sec_id, props in sections.items():&#10;        print(f&quot;  Section {sec_id}: Area = {props['area']} in^2, r = {props['r']} in&quot;)&#10;else:&#10;    # Default section properties if not in YAML&#10;    sections = {&#10;        1: {&quot;area&quot;: 7.65, &quot;r&quot;: 4.32},  # W12x26 - area in in^2, r is radius of gyration in inches&#10;        2: {&quot;area&quot;: 9.13, &quot;r&quot;: 3.47}   # W8x31 - area in in^2, r is radius of gyration in inches&#10;    }&#10;    print(&quot;\nUsing default section properties&quot;)&#10;&#10;# Store member data for later reference&#10;member_data = {}&#10;&#10;# Calculate axial stiffness for each member&#10;print(&quot;\nAssembling stiffness matrix...&quot;)&#10;for member in members:&#10;    member_id = member['id']&#10;    start = member['i_node']&#10;    end = member['j_node']&#10;    section_id = member['section']&#10;&#10;    # Get section properties&#10;    section_area = sections[section_id][&quot;area&quot;]  # in&#10;&#10;    # Calculate EA in kip-in (E in ksi, A in in =&gt; EA in kip)&#10;    EA = E * section_area&#10;&#10;    # Get coordinates&#10;    x1, y1, _ = node_dict[start]&#10;    x2, y2, _ = node_dict[end]&#10;&#10;    # Calculate length in ft&#10;    dx = x2 - x1&#10;    dy = y2 - y1&#10;    length_ft = np.sqrt(dx**2 + dy**2)&#10;&#10;    # Check for zero-length members&#10;    if length_ft &lt; 1e-6:&#10;        print(f&quot;ERROR: Member {member_id} has zero length (nodes {start} to {end})&quot;)&#10;        print(f&quot;  Node {start}: ({x1}, {y1})&quot;)&#10;        print(f&quot;  Node {end}: ({x2}, {y2})&quot;)&#10;        sys.exit(1)&#10;&#10;    length_in = length_ft * 12.0  # Convert to inches&#10;&#10;    # Calculate direction cosines&#10;    cos = dx / length_ft&#10;    sin = dy / length_ft&#10;&#10;    # Store member properties&#10;    member_data[member_id] = {&#10;        &quot;start&quot;: start,&#10;        &quot;end&quot;: end,&#10;        &quot;length_ft&quot;: length_ft,&#10;        &quot;length_in&quot;: length_in,&#10;        &quot;EA&quot;: EA,&#10;        &quot;cos&quot;: cos,&#10;        &quot;sin&quot;: sin,&#10;        &quot;section_id&quot;: section_id,&#10;        &quot;section_area&quot;: section_area&#10;    }&#10;&#10;    # Debug info for first few members&#10;    if member_id &lt;= 3:&#10;        print(f&quot;Member {member_id}: Length = {length_ft:.2f} ft ({length_in:.2f} in), EA = {EA:.2f} kip&quot;)&#10;        print(f&quot;  Direction: cos = {cos:.4f}, sin = {sin:.4f}&quot;)&#10;&#10;    # Local to global transformation matrix&#10;    T = np.array([&#10;        [ cos, sin, 0,   0],&#10;        [-sin, cos, 0,   0],&#10;        [0,   0,   cos, sin],&#10;        [0,   0,  -sin, cos]&#10;    ])&#10;&#10;    # Element stiffness matrix in local coordinates (for a truss element)&#10;    # k = EA/L in kip/in&#10;    k_axial = EA / length_in&#10;&#10;    k_local = np.array([&#10;        [ k_axial, 0, -k_axial, 0],&#10;        [0, 0,  0, 0],&#10;        [-k_axial, 0, k_axial, 0],&#10;        [0, 0,  0, 0]&#10;    ])&#10;&#10;    # Transform to global coordinates&#10;    k_global = T.T @ k_local @ T&#10;    print(f&quot;member id: {member_id}&quot;, k_global, sep=&quot;\n&quot;)&#10;    # Map local DOFs to global DOFs&#10;    dof_start = get_dof(start)&#10;    dof_end = get_dof(end)&#10;    dof_indices = [*dof_start, *dof_end]; print(f&quot;dof_indices: {dof_indices}&quot;)&#10;&#10;    # Assemble into global stiffness matrix&#10;    for i in range(4):&#10;        for j in range(4):&#10;            K_global[dof_indices[i], dof_indices[j]] += k_global[i, j]&#10;&#10;# Apply external forces from member loads&#10;print(&quot;\nApplying loads...&quot;)&#10;if 'member_loads' in bridge:&#10;    for load in bridge['member_loads']:&#10;        member_id = load['member_uid']&#10;        if member_id not in member_data:&#10;            print(f&quot;WARNING: Load references non-existent member {member_id}&quot;)&#10;            continue&#10;&#10;        member = next(m for m in members if m['id'] == member_id)&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        # Convert distributed load to equivalent nodal loads&#10;        wi = float(str(load['wi']).split()[0])  # kips/ft&#10;        wj = float(str(load['wj']).split()[0])  # kips/ft&#10;        length = member_data[member_id][&quot;length_ft&quot;]  # ft&#10;&#10;        # For uniform load, apply half to each node in y-direction&#10;        if abs(wi - wj) &lt; 1e-6:  # Uniform load&#10;            force = abs(wi) * length / 2  # kips (make positive)&#10;            _, dof_yi = get_dof(i_node)&#10;            _, dof_yj = get_dof(j_node)&#10;&#10;            # Debug info for first few loads&#10;            if member_id &lt;= 3:&#10;                print(f&quot;Load on member {member_id}: w = {wi} kips/ft, L = {length:.2f} ft&quot;)&#10;                print(f&quot;  Equivalent nodal forces: {force:.2f} kips (downward) at nodes {i_node} and {j_node}&quot;)&#10;&#10;            # Apply downward forces (negative in typical structural convention)&#10;            F_global[dof_yi] -= force  # Negative for downward&#10;            F_global[dof_yj] -= force  # Negative for downward&#10;        else:&#10;            # For non-uniform load (simplified approach)&#10;            force_i = abs(wi) * length / 3  # kips&#10;            force_j = abs(wj) * length / 3  # kips&#10;            _, dof_yi = get_dof(i_node)&#10;            _, dof_yj = get_dof(j_node)&#10;            F_global[dof_yi] -= force_i  # Negative for downward&#10;            F_global[dof_yj] -= force_j  # Negative for downward&#10;&#10;# Apply support constraints&#10;print(&quot;\nApplying support constraints:&quot;)&#10;constrained_dofs = []&#10;for support in supports:&#10;    node_id = support['node']&#10;    dof_x, dof_y = get_dof(node_id)&#10;&#10;    print(f&quot;Support at node {node_id}: ux={support['ux']}, uy={support['uy']}&quot;)&#10;&#10;    if support['ux'] == 1:  # Fixed in x-direction&#10;        constrained_dofs.append(dof_x)&#10;        K_global[dof_x, :] = 0&#10;        K_global[:, dof_x] = 0&#10;        K_global[dof_x, dof_x] = 1&#10;        F_global[dof_x] = 0&#10;&#10;    if support['uy'] == 1:  # Fixed in y-direction&#10;        constrained_dofs.append(dof_y)&#10;        K_global[dof_y, :] = 0&#10;        K_global[:, dof_y] = 0&#10;        K_global[dof_y, dof_y] = 1&#10;        F_global[dof_y] = 0&#10;&#10;print(f&quot;Total constrained DOFs: {len(constrained_dofs)}&quot;)&#10;print(f&quot;Free DOFs: {dof - len(constrained_dofs)}&quot;)&#10;&#10;# Check for zero diagonal elements (indicates singularity)&#10;diag_zeros = np.where(np.abs(np.diag(K_global)) &lt; 1e-10)[0]&#10;if len(diag_zeros) &gt; 0:&#10;    print(f&quot;\nWARNING: Zero diagonal elements detected at DOFs: {diag_zeros}&quot;)&#10;    for dof_idx in diag_zeros:&#10;        node_id = dof_idx // 2 + 1&#10;        dof_type = &quot;x&quot; if dof_idx % 2 == 0 else &quot;y&quot;&#10;        print(f&quot;  Node {node_id}, direction {dof_type}&quot;)&#10;&#10;        # Check if this DOF is connected to any members&#10;        connected_members = []&#10;        for mem_id, mem_data in member_data.items():&#10;            if mem_data[&quot;start&quot;] == node_id or mem_data[&quot;end&quot;] == node_id:&#10;                connected_members.append(mem_id)&#10;        print(f&quot;    Connected to members: {connected_members}&quot;)&#10;&#10;# Check if the stiffness matrix is symmetric (it should be)&#10;is_symmetric = np.allclose(K_global, K_global.T, rtol=1e-5, atol=1e-8)&#10;print(f&quot;\nStiffness matrix is symmetric: {is_symmetric}&quot;)&#10;&#10;# Analyze the condition of the matrix&#10;try:&#10;    # Compute the condition number&#10;    cond = np.linalg.cond(K_global)&#10;    print(f&quot;Condition number of stiffness matrix: {cond:.2e}&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        print(&quot;\nWARNING: Very high condition number detected!&quot;)&#10;        print(&quot;The structure may have:&quot;)&#10;        print(&quot;1. Duplicate nodes at the same location&quot;)&#10;        print(&quot;2. Insufficient supports (mechanism)&quot;)&#10;        print(&quot;3. Disconnected parts&quot;)&#10;        print(&quot;4. Numerical scaling issues&quot;)&#10;&#10;        # Find the ratio between max and min non-zero diagonal elements&#10;        diag = np.abs(np.diag(K_global))&#10;        nonzero_diag = diag[diag &gt; 1e-10]&#10;        if len(nonzero_diag) &gt; 0:&#10;            diag_ratio = np.max(nonzero_diag) / np.min(nonzero_diag)&#10;            print(f&quot;\nDiagonal scaling ratio: {diag_ratio:.2e}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;Could not compute condition number: {e}&quot;)&#10;    cond = float('inf')&#10;&#10;# Apply scaling to improve conditioning&#10;print(&quot;\nAttempting to solve the system...&quot;)&#10;try:&#10;    # Use a more robust solver from scipy&#10;    from scipy import linalg&#10;&#10;    # For very ill-conditioned systems, try regularization&#10;    if cond &gt; 1e14:&#10;        print(&quot;System is extremely ill-conditioned. Applying regularization...&quot;)&#10;        # Add small diagonal perturbation to improve conditioning&#10;        reg_factor = 1e-8 * np.max(np.abs(np.diag(K_global)))&#10;        K_regularized = K_global + reg_factor * np.eye(dof)&#10;&#10;        try:&#10;            displacements = linalg.solve(K_regularized, F_global, assume_a='sym')&#10;            print(&quot;Regularized solution successful&quot;)&#10;        except:&#10;            # Fall back to least squares&#10;            displacements, residuals, rank, s = linalg.lstsq(K_global, F_global)&#10;            print(f&quot;Least squares solution: rank={rank}/{dof}&quot;)&#10;    else:&#10;        # Try direct solution&#10;        displacements = linalg.solve(K_global, F_global, assume_a='sym')&#10;        print(&quot;Direct solution successful&quot;)&#10;&#10;    # Convert displacements from inches to feet for consistency&#10;    # Actually, the displacements are already in feet since we used consistent units&#10;&#10;    # Print first few displacement values for debugging&#10;    print(&quot;\nNodal displacements:&quot;)&#10;    print(&quot;Node | dx (in) | dy (in)&quot;)&#10;    print(&quot;-&quot; * 30)&#10;    for i in range(1, min(11, num_nodes + 1)):&#10;        dof_x, dof_y = get_dof(i)&#10;        # Convert to inches for display&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        print(f&quot;{i:4} | {dx_in:7.4f} | {dy_in:7.4f}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;All solution methods failed: {e}&quot;)&#10;    print(&quot;Using zero displacements as fallback&quot;)&#10;    displacements = np.zeros(dof)&#10;&#10;# Find maximum vertical displacement&#10;max_vert_disp = 0&#10;max_disp_node = None&#10;for node_id in node_dict:&#10;    _, dof_y = get_dof(node_id)&#10;    # Skip nodes that are supported&#10;    is_supported = any(s['node'] == node_id and s['uy'] == 1 for s in supports)&#10;    if not is_supported:&#10;        disp = abs(displacements[dof_y])&#10;        if disp &gt; max_vert_disp:&#10;            max_vert_disp = disp&#10;            max_disp_node = node_id&#10;&#10;# Convert to inches for display&#10;max_vert_disp_in = max_vert_disp * 12&#10;print(f&quot;\nMaximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}&quot;)&#10;&#10;# Calculate member forces&#10;member_forces = {}&#10;member_stresses = {}&#10;&#10;# Material properties (A36 steel)&#10;Fy = 36.0    # ksi - Yield strength&#10;Fu = 58.0    # ksi - Ultimate strength&#10;safety_factor_tension = 1.67&#10;safety_factor_compression = 1.67&#10;allowable_tension_stress = Fy / safety_factor_tension      # ksi&#10;allowable_compression_stress_max = Fy / safety_factor_compression  # ksi&#10;&#10;# Calculate forces and stresses for each member&#10;for member in members:&#10;    member_id = member['id']&#10;    if member_id not in member_data:&#10;        continue  # Skip members with zero length&#10;&#10;    mem_data = member_data[member_id]&#10;    start = mem_data[&quot;start&quot;]&#10;    end = mem_data[&quot;end&quot;]&#10;    area = mem_data[&quot;section_area&quot;]  # in&#10;    cos = mem_data[&quot;cos&quot;]&#10;    sin = mem_data[&quot;sin&quot;]&#10;&#10;    # Get displacements at both nodes (in feet)&#10;    dof_x1, dof_y1 = get_dof(start)&#10;    dof_x2, dof_y2 = get_dof(end)&#10;&#10;    # Calculate relative displacement in the axial direction (in feet)&#10;    delta_u1 = displacements[dof_x1] * cos + displacements[dof_y1] * sin&#10;    delta_u2 = displacements[dof_x2] * cos + displacements[dof_y2] * sin&#10;    delta_axial = delta_u2 - delta_u1&#10;&#10;    # Convert to inches for force calculation&#10;    delta_axial_in = delta_axial * 12&#10;&#10;    # Calculate axial force (F = EA/L * delta)&#10;    EA = mem_data[&quot;EA&quot;]  # kip&#10;    force = (EA / mem_data[&quot;length_in&quot;]) * delta_axial_in  # kips&#10;    member_forces[member_id] = force&#10;&#10;    # Calculate axial stress&#10;    stress = force / area  # kips/in = ksi&#10;    member_stresses[member_id] = stress&#10;&#10;    # Debug output for the first few members&#10;    if member_id &lt;= 3 or member_id == 32:&#10;        print(f&quot;\nMember {member_id} analysis:&quot;)&#10;        print(f&quot;  Length = {mem_data['length_ft']:.2f} ft&quot;)&#10;        print(f&quot;  Node {start}: dx = {displacements[dof_x1]*12:.4f} in, dy = {displacements[dof_y1]*12:.4f} in&quot;)&#10;        print(f&quot;  Node {end}: dx = {displacements[dof_x2]*12:.4f} in, dy = {displacements[dof_y2]*12:.4f} in&quot;)&#10;        print(f&quot;  Delta axial = {delta_axial_in:.4f} in&quot;)&#10;        print(f&quot;  Force = {force:.2f} kips&quot;)&#10;        print(f&quot;  Stress = {stress:.2f} ksi&quot;)&#10;&#10;# Calculate safety factors for all members&#10;member_safety_factors = {}&#10;member_status = {}&#10;&#10;# Define zero force threshold&#10;ZERO_FORCE_THRESHOLD = 0.1  # Consider forces below this threshold as &quot;zero&quot;&#10;&#10;# Replace the problematic part in the safety factors calculation&#10;for member_id, stress in member_stresses.items():&#10;    section_id = member_data[member_id][&quot;section_id&quot;]&#10;    section = sections[section_id]&#10;&#10;    if abs(stress) &lt; ZERO_FORCE_THRESHOLD / section[&quot;area&quot;]:&#10;        # Zero/near-zero stress&#10;        safety_factor = float('inf')&#10;        limit = allowable_tension_stress  # Arbitrary for zero-force members&#10;        status = &quot;OK&quot;&#10;    elif stress &gt;= 0:  # Tension&#10;        safety_factor = allowable_tension_stress / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_tension_stress&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;    else:  # Compression&#10;        # Calculate allowable compression stress based on slenderness&#10;        length_inches = member_data[member_id][&quot;length_in&quot;]&#10;        slenderness = length_inches / section[&quot;r&quot;]&#10;&#10;        if slenderness &gt; 100:  # For slender members&#10;            critical_stress = (np.pi**2 * E) / (slenderness**2)&#10;            allowable_compression = min(allowable_compression_stress_max, critical_stress/safety_factor_compression)&#10;        else:  # For stocky members&#10;            allowable_compression = allowable_compression_stress_max&#10;&#10;        safety_factor = allowable_compression / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_compression&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;&#10;    member_safety_factors[member_id] = safety_factor&#10;    member_status[member_id] = {&#10;        &quot;stress&quot;: stress,&#10;        &quot;allowable&quot;: limit,&#10;        &quot;safety_factor&quot;: safety_factor,&#10;        &quot;status&quot;: status&#10;    }&#10;&#10;# After calculating safety factors, add a summary of members below minimum&#10;members_below_min_sf = []&#10;for member_id, status_info in member_status.items():&#10;    if status_info[&quot;safety_factor&quot;] &lt; min_safety_factor and status_info[&quot;safety_factor&quot;] &lt; 100:&#10;        members_below_min_sf.append({&#10;            'id': member_id,&#10;            'sf': status_info[&quot;safety_factor&quot;],&#10;            'stress': status_info[&quot;stress&quot;],&#10;            'allowable': status_info[&quot;allowable&quot;]&#10;        })&#10;&#10;if members_below_min_sf:&#10;    print(f&quot;\n{len(members_below_min_sf)} members have safety factor below {min_safety_factor}:&quot;)&#10;    for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:10]:  # Show worst 10&#10;        print(f&quot;  Member {mem['id']}: SF = {mem['sf']:.2f}, Stress = {abs(mem['stress']):.1f} ksi&quot;)&#10;&#10;# Create figure for the PDF - add timestamp to filenames&#10;timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M%S')&#10;pdf_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_Analysis_{timestamp}.pdf&quot;)&#10;text_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_Analysis_{timestamp}.txt&quot;)&#10;&#10;# Open the text file for writing the report&#10;with open(text_filename, 'w') as txt_report:&#10;    # Write header information&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(&quot;PRATT BRIDGE STRUCTURAL ANALYSIS REPORT\n&quot;)&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(f&quot;Analysis Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}\n&quot;)&#10;    txt_report.write(f&quot;Input File: {bridge_file}\n&quot;)&#10;    txt_report.write(f&quot;Design Minimum Safety Factor: {min_safety_factor}\n\n&quot;)&#10;&#10;    # Write model statistics&#10;    txt_report.write(&quot;MODEL STATISTICS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Number of nodes: {num_nodes}\n&quot;)&#10;    txt_report.write(f&quot;Number of members: {len(members)}\n&quot;)&#10;    txt_report.write(f&quot;Number of supports: {len(supports)}\n&quot;)&#10;    txt_report.write(f&quot;Degrees of freedom: {dof}\n&quot;)&#10;    txt_report.write(f&quot;Constrained DOFs: {len(constrained_dofs)}\n&quot;)&#10;    txt_report.write(f&quot;Free DOFs: {dof - len(constrained_dofs)}\n\n&quot;)&#10;&#10;    # Write material properties&#10;    txt_report.write(&quot;MATERIAL PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Material: A36 Steel\n&quot;)&#10;    txt_report.write(f&quot;Young's modulus: {E} ksi\n&quot;)&#10;    txt_report.write(f&quot;Yield strength: {Fy} ksi\n&quot;)&#10;    txt_report.write(f&quot;Ultimate strength: {Fu} ksi\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (tension): {safety_factor_tension}\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (compression): {safety_factor_compression}\n\n&quot;)&#10;&#10;    # Write section properties&#10;    txt_report.write(&quot;SECTION PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    for sec_id, props in sections.items():&#10;        txt_report.write(f&quot;Section {sec_id}: Area = {props['area']} in, r = {props['r']} in\n&quot;)&#10;    txt_report.write(&quot;\n&quot;)&#10;&#10;    # Write analysis results summary&#10;    txt_report.write(&quot;ANALYSIS RESULTS SUMMARY\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Maximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}\n&quot;)&#10;&#10;    # Calculate critical values&#10;    critical_sf = float('inf')&#10;    critical_member = None&#10;    overstressed_count = 0&#10;    for member_id, status_info in member_status.items():&#10;        sf = status_info[&quot;safety_factor&quot;]&#10;        if sf &lt; critical_sf and sf &lt; 100:&#10;            critical_sf = sf&#10;            critical_member = member_id&#10;        if status_info[&quot;status&quot;] == &quot;OVERSTRESSED&quot;:&#10;            overstressed_count += 1&#10;&#10;    txt_report.write(f&quot;Number of tension members: {sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of compression members: {sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of zero-force members: {sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Overstressed members: {overstressed_count}\n&quot;)&#10;    txt_report.write(f&quot;Maximum member force: {max(abs(f) for f in member_forces.values()):.2f} kips\n&quot;)&#10;    txt_report.write(f&quot;Maximum member stress: {max(abs(s) for s in member_stresses.values()):.2f} ksi\n&quot;)&#10;    txt_report.write(f&quot;Minimum safety factor: {critical_sf:.2f} (Member #{critical_member})\n\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;WARNING: High condition number indicates numerical instability.\n&quot;)&#10;        txt_report.write(&quot;The structure may have:\n&quot;)&#10;        txt_report.write(&quot;1. Duplicate nodes at the same location\n&quot;)&#10;        txt_report.write(&quot;2. Insufficient supports (mechanism)\n&quot;)&#10;        txt_report.write(&quot;3. Disconnected parts\n&quot;)&#10;        txt_report.write(&quot;4. Numerical scaling issues\n\n&quot;)&#10;&#10;    # Write detailed member results&#10;    txt_report.write(&quot;DETAILED MEMBER RESULTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Member | Nodes (i-j) | Force (kips) | Stress (ksi) | Type | S.F. | Status\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 80 + &quot;\n&quot;)&#10;&#10;    for member in sorted(members, key=lambda m: m['id']):&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;        stress = member_stresses[member_id]&#10;        sf = member_safety_factors[member_id]&#10;        status = member_status[member_id][&quot;status&quot;]&#10;&#10;        # Fix the text report formatting to use only ASCII&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            force_type = &quot;ZERO&quot;&#10;            sf_text = &quot;inf&quot;&#10;        elif force &gt; 0:&#10;            force_type = &quot;TENSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;        else:&#10;            force_type = &quot;COMPRESSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;&#10;        txt_report.write(&#10;            f&quot;{member_id:6} | {i_node:2}-{j_node:&lt;2} | {abs(force):11.2f} | {abs(stress):10.2f} | {force_type:10} | {sf_text:&gt;5} | {status}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;&#10;    # Write nodal displacements&#10;    txt_report.write(&quot;NODAL DISPLACEMENTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Node | dx (inches) | dy (inches)\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 35 + &quot;\n&quot;)&#10;&#10;    for node_id in sorted(node_dict.keys()):&#10;        dof_x, dof_y = get_dof(node_id)&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        txt_report.write(f&quot;{node_id:4} | {dx_in:11.4f} | {dy_in:11.4f}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;    txt_report.write(&quot;RECOMMENDATIONS FOR STRUCTURE REFINEMENT\n&quot;)&#10;    txt_report.write(&quot;----------------------------------------\n&quot;)&#10;&#10;    if members_below_min_sf:&#10;        txt_report.write(f&quot;1. {len(members_below_min_sf)} members have safety factor below the design minimum of {min_safety_factor}:\n&quot;)&#10;        for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:20]:  # Show worst 20&#10;            member = next(m for m in members if m['id'] == mem['id'])&#10;            txt_report.write(f&quot;   - Member {mem['id']} (nodes {member['i_node']}-{member['j_node']}): SF = {mem['sf']:.2f}\n&quot;)&#10;&#10;        # Calculate required section increase&#10;        worst_sf = min(mem['sf'] for mem in members_below_min_sf)&#10;        required_increase = min_safety_factor / worst_sf&#10;        txt_report.write(f&quot;\n   Worst member requires approximately {required_increase:.1f}x increase in capacity.\n&quot;)&#10;        txt_report.write(f&quot;   Consider using larger sections or reducing the loading.\n&quot;)&#10;    else:&#10;        txt_report.write(&quot;1. All members meet the minimum safety factor requirement.\n&quot;)&#10;        txt_report.write(&quot;   Consider optimizing the structure by reducing sections for members with high safety factors.\n&quot;)&#10;&#10;    if max_vert_disp_in &gt; 2.0:  # Assuming 2 inches as a reasonable deflection limit&#10;        txt_report.write(f&quot;2. Consider stiffening the structure to reduce the maximum deflection (currently {max_vert_disp_in:.4f} inches).\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;3. Fix numerical stability issues by reviewing structure connectivity and supports.\n&quot;)&#10;&#10;    txt_report.write(&quot;\nReport generated by pyMAOS Truss Analysis Tool\n&quot;)&#10;&#10;print(f&quot;Text report saved to: {text_filename}&quot;)&#10;&#10;with PdfPages(pdf_filename) as pdf:&#10;    # 1. BRIDGE ANALYSIS SUMMARY page&#10;    fig = plt.figure(figsize=(8.5, 11))&#10;    plt.axis('off')&#10;&#10;    # Add overall bridge status text - avoid using unicode characters&#10;    if overstressed_count == 0:&#10;        status_text = &quot;BRIDGE IS STRUCTURALLY ADEQUATE&quot;&#10;        status_color = 'green'&#10;    else:&#10;        status_text = f&quot;WARNING: BRIDGE HAS {overstressed_count} OVERSTRESSED MEMBERS&quot;&#10;        status_color = 'red'&#10;&#10;    plt.figtext(0.5, 0.9, &quot;BRIDGE ANALYSIS SUMMARY&quot;, ha='center', fontsize=16, weight='bold')&#10;    plt.figtext(0.5, 0.85, status_text, ha='center', fontsize=14, weight='bold', color=status_color)&#10;&#10;    # Add displacement information&#10;    plt.figtext(0.5, 0.78, f&quot;Maximum Vertical Displacement: {max_vert_disp_in:.4f} inches at Node {max_disp_node}&quot;,&#10;                ha='center', fontsize=12)&#10;&#10;    # Add summary statistics&#10;    critical_text = f&quot;Most critical member: #{critical_member} (Safety Factor: {critical_sf:.2f})&quot;&#10;    plt.figtext(0.5, 0.73, critical_text, ha='center', fontsize=12)&#10;&#10;    # Add a summary table of key statistics&#10;    summary_data = [&#10;        [&quot;Total Members&quot;, f&quot;{len(members)}&quot;],&#10;        [&quot;Tension Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Compression Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Zero-Force Members&quot;, f&quot;{sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Overstressed Members&quot;, f&quot;{overstressed_count}&quot;],&#10;        [&quot;Maximum Member Force&quot;, f&quot;{max(abs(f) for f in member_forces.values()):.2f} kips&quot;],&#10;        [&quot;Maximum Member Stress&quot;, f&quot;{max(abs(s) for s in member_stresses.values()):.2f} ksi&quot;],&#10;        [&quot;Minimum Safety Factor&quot;, f&quot;{critical_sf:.2f}&quot;],&#10;        [&quot;Maximum Displacement&quot;, f&quot;{max_vert_disp_in:.4f} inches&quot;],&#10;    ]&#10;&#10;    # Create a table in the middle of the page&#10;    ax = plt.subplot(111)&#10;    ax.axis('off')&#10;    tbl = plt.table(cellText=summary_data, colLabels=[&quot;Metric&quot;, &quot;Value&quot;],&#10;                    loc='center', cellLoc='left')&#10;    tbl.auto_set_font_size(False)&#10;    tbl.set_fontsize(10)&#10;    tbl.scale(1, 1.5)&#10;&#10;    # Add design criteria info&#10;    criteria = (&#10;        f&quot;Design Criteria:\n&quot;&#10;        f&quot;- Material: A36 Steel (Fy = 36 ksi)\n&quot;&#10;        f&quot;- Allowable tension stress: {allowable_tension_stress:.1f} ksi\n&quot;&#10;        f&quot;- Allowable compression stress: Based on member slenderness\n&quot;&#10;        f&quot;- Safety factor: {safety_factor_tension:.2f}&quot;&#10;    )&#10;    plt.figtext(0.5, 0.2, criteria, ha='center', fontsize=10,&#10;                bbox=dict(facecolor='#eeeeee', alpha=0.7, boxstyle='round,pad=0.5'))&#10;&#10;    # Add timestamp&#10;    plt.figtext(0.5, 0.1, f&quot;Analysis completed on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    # Save the summary page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 2. Reliability Analysis - Safety Factors plot&#10;    fig, ax = plt.subplots(figsize=(11, 8.5))  # Changed to landscape orientation&#10;&#10;    # Use plt.colormaps instead of cm.get_cmap to avoid deprecation warning&#10;    cmap = plt.colormaps['RdYlGn']  # Red-Yellow-Green colormap&#10;    norm = plt.Normalize(0.5, 2.0)&#10;&#10;    # Plot members with color based on safety factors&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        safety_factor = member_safety_factors[member_id]&#10;        safety_factor_capped = min(safety_factor, 5.0)  # Cap extremely high values for visualization&#10;&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        x = [x1, x2]&#10;        y = [y1, y2]&#10;&#10;        color = cmap(norm(safety_factor_capped))&#10;        linewidth = 3  # Consistent line width&#10;&#10;        ax.plot(x, y, color=color, linewidth=linewidth)&#10;&#10;        # Add safety factor label at midpoint&#10;        mid_x = (x1 + x2) / 2&#10;        mid_y = (y1 + y2) / 2&#10;&#10;        # Format infinity as &quot;&quot;&#10;        sf_text = &quot;&quot; if safety_factor &gt; 100 else f&quot;{safety_factor:.1f}&quot;&#10;&#10;        ax.text(mid_x, mid_y, sf_text,&#10;                fontsize=6, ha='center', va='center',&#10;                bbox=dict(facecolor='white', alpha=0.7, pad=1))&#10;&#10;    # Plot nodes and supports&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        ax.plot(x, y, 'ko', markersize=5)&#10;        ax.text(x+1, y+1, f&quot;{node_id}&quot;, fontsize=7)&#10;&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, _ = node_dict[node_id]&#10;        if support['ux'] == 1 and support['uy'] == 1:&#10;            ax.plot(x, y-2, 'ks', markersize=8)&#10;        elif support['ux'] == 0 and support['uy'] == 1:&#10;            ax.plot(x, y-2, 'ko', markersize=8)&#10;&#10;    # Add a colorbar&#10;    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)&#10;    sm.set_array([])&#10;    cbar = plt.colorbar(sm, ax=ax, label='Safety Factor', shrink=0.8)&#10;    cbar.set_ticks([0.5, 1.0, 1.5, 2.0])&#10;    cbar.set_ticklabels(['0.5', '1.0 (Limit)', '1.5', ' 2.0'])&#10;&#10;    # Set plot limits and labels&#10;    max_x = max(node_dict[n][0] for n in node_dict)&#10;    max_y = max(node_dict[n][1] for n in node_dict)&#10;    ax.set_xlim(-5, max_x + 15)&#10;    ax.set_ylim(-5, max_y + 5)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;    ax.set_title('Pratt Truss Bridge Reliability Analysis - Safety Factors', fontsize=12)&#10;    ax.grid(True)&#10;    plt.tight_layout(pad=2.0, rect=[0, 0, 1, 0.95])&#10;&#10;    # Save the safety factor visualization to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 3. Member Forces Summary Tables (split across pages) with node IDs&#10;    rows_per_page = 20  # Adjust as needed&#10;    all_members = sorted(members, key=lambda m: m['id'])&#10;    member_chunks = [all_members[i:i+rows_per_page] for i in range(0, len(all_members), rows_per_page)]&#10;&#10;    for page_idx, member_chunk in enumerate(member_chunks):&#10;        fig = plt.figure(figsize=(8.5, 11))&#10;        gs = gridspec.GridSpec(1, 1)&#10;        ax = plt.subplot(gs[0])&#10;        ax.axis('tight')&#10;        ax.axis('off')&#10;&#10;        # Create summary data for this chunk&#10;        table_data = []&#10;        table_data.append(['Member', 'Nodes (i-j)', 'Force (kips)', 'Type'])&#10;&#10;        for member in member_chunk:&#10;            member_id = member['id']&#10;            i_node = member['i_node']&#10;            j_node = member['j_node']&#10;            force = member_forces[member_id]&#10;&#10;            if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;                force_type = &quot;ZERO&quot;&#10;            elif force &gt; 0:&#10;                force_type = &quot;TENSION&quot;&#10;            else:&#10;                force_type = &quot;COMPRESSION&quot;&#10;&#10;            table_data.append([str(member_id), f&quot;{i_node}-{j_node}&quot;, f&quot;{abs(force):.2f}&quot;, force_type])&#10;&#10;        # Create table with smaller font&#10;        table = ax.table(cellText=table_data, loc='center', cellLoc='center')&#10;        table.auto_set_font_size(False)&#10;        table.set_fontsize(8)&#10;        table.scale(1, 1.4)&#10;&#10;        # Add title with page number but more space at the top&#10;        plt.title(f&quot;Member Forces Summary (Page {page_idx+1} of {len(member_chunks)})&quot;,&#10;                  fontsize=14, y=0.98, pad=20)&#10;&#10;        # Add metadata&#10;        plt.figtext(0.5, 0.03,&#10;                    f&quot;Pratt Bridge Analysis - Generated on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                    ha='center', fontsize=6)&#10;&#10;        # Save the page to PDF&#10;        pdf.savefig(fig)&#10;        plt.close(fig)&#10;&#10;    # 4. Member Forces plot&#10;    fig, ax = plt.subplots(figsize=(11, 8.5))  # Changed to landscape orientation&#10;&#10;    # Plot members with color based on tension/compression/zero&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;&#10;        # Find the coordinates for both nodes&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        x = [x1, x2]&#10;        y = [y1, y2]&#10;&#10;        # Color: red for tension, blue for compression, black for zero/near-zero&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            color = 'black'  # Zero force&#10;            linestyle = '-'&#10;            linewidth = 1.5&#10;        elif force &gt; 0:&#10;            color = 'red'  # Tension&#10;            linestyle = '-'&#10;            linewidth = 2 + min(5, abs(force)/100)  # Scale width with force magnitude&#10;        else:&#10;            color = 'blue'  # Compression&#10;            linestyle = '-'&#10;            linewidth = 2 + min(5, abs(force)/100)  # Scale width with force magnitude&#10;&#10;        # Plot the member&#10;        ax.plot(x, y, color=color, linestyle=linestyle, linewidth=linewidth)&#10;&#10;        # Add force label at midpoint - reduced font size&#10;        mid_x = (x1 + x2) / 2&#10;        mid_y = (y1 + y2) / 2&#10;        ax.text(mid_x, mid_y, f&quot;{abs(force):.1f}&quot;,&#10;                fontsize=6, ha='center', va='center',&#10;                bbox=dict(facecolor='white', alpha=0.7, pad=1))&#10;&#10;    # Plot nodes&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        ax.plot(x, y, 'ko', markersize=6)&#10;        ax.text(x+1, y+1, f&quot;{node_id}&quot;, fontsize=7)&#10;&#10;    # Plot supports&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, _ = node_dict[node_id]&#10;&#10;        # Different markers for different support types&#10;        if support['ux'] == 1 and support['uy'] == 1:&#10;            # Pinned support - triangle&#10;            ax.plot(x, y-2, 'ks', markersize=10)&#10;        elif support['ux'] == 0 and support['uy'] == 1:&#10;            # Roller support - circle&#10;            ax.plot(x, y-2, 'ko', markersize=10)&#10;&#10;    # Add legend&#10;    red_line = plt.Line2D([0], [0], color='red', linewidth=3, label='Tension')&#10;    blue_line = plt.Line2D([0], [0], color='blue', linewidth=3, label='Compression')&#10;    black_line = plt.Line2D([0], [0], color='black', linewidth=2, label='Zero Force')&#10;    ax.legend(handles=[red_line, blue_line, black_line], loc='upper right', fontsize=8)&#10;&#10;    # Set plot limits and labels&#10;    ax.set_xlim(-5, max_x + 15)  # Extra space on right for labels&#10;    ax.set_ylim(-5, max_y + 5)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;    ax.set_title('Pratt Truss Bridge Analysis - Member Forces', fontsize=12)&#10;    ax.grid(True)&#10;&#10;    # Use tight_layout with adjusted parameters&#10;    plt.tight_layout(pad=2.0, rect=[0, 0, 1, 0.95])&#10;&#10;    # Save the member forces plot to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 5. Displacement visualization&#10;    fig, ax = plt.subplots(figsize=(12, 9))  # Increased figure size for better visibility&#10;&#10;    # Draw original structure in light gray&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;        ax.plot([x1, x2], [y1, y2], color='lightgray', linestyle='-', linewidth=1, alpha=0.5)&#10;&#10;    # Calculate max displacement for proper scaling&#10;    max_disp_magnitude = 0&#10;    for node_id in node_dict:&#10;        dof_x, dof_y = get_dof(node_id)&#10;        disp_magnitude = np.sqrt(displacements[dof_x]**2 + displacements[dof_y]**2)&#10;        max_disp_magnitude = max(max_disp_magnitude, disp_magnitude)&#10;&#10;    # More reasonable scale factor - aim for approximately 5-10% of bridge span&#10;    max_span = max(node_dict[n][0] for n in node_dict) - min(node_dict[n][0] for n in node_dict)&#10;    bridge_height = max(node_dict[n][1] for n in node_dict) - min(node_dict[n][1] for n in node_dict)&#10;    target_max_disp = min(max_span, bridge_height) * 0.05  # More conservative scaling&#10;&#10;    # Calculate scale factor (with protection against division by zero)&#10;    if max_disp_magnitude &gt; 1e-10:&#10;        scale_factor = target_max_disp / max_disp_magnitude&#10;        # Ensure scale factor is rounded to a clean number for display&#10;        scale_magnitude = 10 ** int(np.log10(scale_factor))&#10;        scale_factor = round(scale_factor / scale_magnitude) * scale_magnitude&#10;    else:&#10;        scale_factor = 50.0  # Default if displacements are effectively zero&#10;&#10;    # Print debug info for node 12 (central top chord)&#10;    if 12 in node_dict:&#10;        dof_x12, dof_y12 = get_dof(12)&#10;        print(f&quot;\nDebug - Node 12 displacement:&quot;)&#10;        print(f&quot;  Original position: ({node_dict[12][0]}, {node_dict[12][1]})&quot;)&#10;        print(f&quot;  Displacement: dx={displacements[dof_x12]*12:.6f} in, dy={displacements[dof_y12]*12:.6f} in&quot;)&#10;        print(f&quot;  Scaled displacement: dx={displacements[dof_x12]*scale_factor:.4f} ft, dy={displacements[dof_y12]*scale_factor:.4f} ft&quot;)&#10;&#10;    # Precalculate the max and min coordinates after displacement to ensure proper plot limits&#10;    min_x_disp = float('inf')&#10;    min_y_disp = float('inf')&#10;    max_x_disp = float('-inf')&#10;    max_y_disp = float('-inf')&#10;&#10;    # First pass - calculate extents of displaced structure&#10;    for node_id, (x, y, _) in node_dict.items():&#10;        dof_x, dof_y = get_dof(node_id)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;&#10;        min_x_disp = min(min_x_disp, x_new)&#10;        min_y_disp = min(min_y_disp, y_new)&#10;        max_x_disp = max(max_x_disp, x_new)&#10;        max_y_disp = max(max_y_disp, y_new)&#10;&#10;    # Draw displaced structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, _ = node_dict[i_node]&#10;        x2, y2, _ = node_dict[j_node]&#10;&#10;        # Get displacements&#10;        dof_x1, dof_y1 = get_dof(i_node)&#10;        dof_x2, dof_y2 = get_dof(j_node)&#10;&#10;        # Apply displacements&#10;        x1_new = x1 + displacements[dof_x1] * scale_factor&#10;        y1_new = y1 + displacements[dof_y1] * scale_factor&#10;        x2_new = x2 + displacements[dof_x2] * scale_factor&#10;        y2_new = y2 + displacements[dof_y2] * scale_factor&#10;&#10;        # Draw displaced member&#10;        ax.plot([x1_new, x2_new], [y1_new, y2_new], color='blue', linestyle='-', linewidth=1.5)&#10;&#10;        # Add small markers at displaced node positions for clarity&#10;        ax.plot(x1_new, y1_new, 'b.', markersize=4)&#10;        ax.plot(x2_new, y2_new, 'b.', markersize=4)&#10;&#10;    # Highlight the node with maximum displacement - directly on the plot without a box&#10;    if max_disp_node:&#10;        x, y, _ = node_dict[max_disp_node]&#10;        dof_x, dof_y = get_dof(max_disp_node)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;&#10;        # Use a more visible marker directly on the plot&#10;        ax.plot(x_new, y_new, 'ro', markersize=8)&#10;&#10;        # Add the label directly at the node with smaller text and no box&#10;        label_x = x_new + 0.03 * max_span&#10;        label_y = y_new + 0.02 * max_span&#10;        ax.text(label_x, label_y, f&quot;Node {max_disp_node}: {max_vert_disp_in:.2f} in&quot;,&#10;                fontsize=8, color='red', ha='left', va='bottom',&#10;                path_effects=[plt.matplotlib.patheffects.withStroke(linewidth=3, foreground='white')])&#10;&#10;    # Add legend&#10;    orig = plt.Line2D([0], [0], color='lightgray', linestyle='-', linewidth=1, alpha=0.5, label='Original Structure')&#10;    disp = plt.Line2D([0], [0], color='blue', linestyle='-', linewidth=1.5, label='Displaced Structure')&#10;    ax.legend(handles=[orig, disp], loc='upper right', fontsize=8)&#10;&#10;    # Set plot limits to ensure complete structure visibility, with additional padding&#10;    min_x = min(node_dict[n][0] for n in node_dict)&#10;    min_y = min(node_dict[n][1] for n in node_dict)&#10;    max_x = max(node_dict[n][0] for n in node_dict)&#10;    max_y = max(node_dict[n][1] for n in node_dict)&#10;&#10;    # Ensure we include both original and displaced structures with padding&#10;    plot_min_x = min(min_x, min_x_disp) - 0.1 * max_span&#10;    plot_min_y = min(min_y, min_y_disp) - 0.15 * bridge_height&#10;    plot_max_x = max(max_x, max_x_disp) + 0.1 * max_span&#10;    plot_max_y = max(max_y, max_y_disp) + 0.1 * bridge_height&#10;&#10;    ax.set_xlim(plot_min_x, plot_max_x)&#10;    ax.set_ylim(plot_min_y, plot_max_y)&#10;    ax.set_xlabel('Length (ft)')&#10;    ax.set_ylabel('Height (ft)')&#10;&#10;    # Format scale factor nicely&#10;    if scale_factor &gt;= 1000:&#10;        scale_factor_text = f&quot;{scale_factor/1000:.1f}k&quot;&#10;    elif scale_factor &gt;= 100:&#10;        scale_factor_text = f&quot;{int(scale_factor)}&quot;&#10;    else:&#10;        scale_factor_text = f&quot;{scale_factor:.1f}&quot;&#10;&#10;    ax.set_title(f'Pratt Truss Bridge - Displacement Analysis (Scale Factor: {scale_factor_text})', fontsize=12)&#10;&#10;    # Add note about displacement scale&#10;    plt.figtext(0.5, 0.01,&#10;                f&quot;Note: Displacements are scaled by a factor of {scale_factor_text} for visibility. &quot;&#10;                f&quot;Actual maximum displacement: {max_vert_disp_in:.4f} inches.&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    ax.grid(True)&#10;    plt.tight_layout(pad=2.0, rect=[0, 0.02, 1, 0.98])&#10;&#10;    # Save the displacement page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # Add PDF metadata&#10;    d = pdf.infodict()&#10;    d['Title'] = 'Pratt Bridge Structural Analysis'&#10;    d['Author'] = 'pyMAOS Truss Analysis Tool'&#10;    d['Subject'] = 'Structural analysis and reliability assessment'&#10;    d['Keywords'] = 'truss, structural analysis, bridge, reliability'&#10;    d['CreationDate'] = datetime.datetime.now()&#10;    d['ModDate'] = datetime.datetime.now()&#10;&#10;# Print summary of results to console&#10;print(&quot;\nMember Forces Summary:&quot;)&#10;print(&quot;----------------------&quot;)&#10;print(&quot;Member | Force (kips) | Type&quot;)&#10;print(&quot;----------------------&quot;)&#10;for member in sorted(members, key=lambda m: m['id']):&#10;    member_id = member['id']&#10;    force = member_forces[member_id]&#10;    if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;        force_type = &quot;ZERO&quot;&#10;    elif force &gt; 0:&#10;        force_type = &quot;TENSION&quot;&#10;    else:&#10;        force_type = &quot;COMPRESSION&quot;&#10;    print(f&quot;{member_id:6} | {abs(force):11.2f} | {force_type}&quot;)&#10;&#10;# Print numerical stability information&#10;print(&quot;\nNumerical Stability Info:&quot;)&#10;print(&quot;-----------------------&quot;)&#10;print(f&quot;Matrix size: {dof}{dof}&quot;)&#10;print(f&quot;Condition number: {cond:.2e}&quot;)&#10;print(f&quot;Number of members: {len(member_data)}&quot;)&#10;print(f&quot;Maximum force magnitude: {max(abs(f) for f in member_forces.values()):.2f} kips&quot;)&#10;print(f&quot;Maximum displacement: {max_vert_disp_in:.4f} inches&quot;)&#10;&#10;if cond &gt; 1e12:&#10;    print(&quot;\nWARNING: High condition number indicates numerical instability.&quot;)&#10;    print(&quot;\nRECOMMENDATIONS:&quot;)&#10;    print(&quot;1. The duplicate nodes 6 and 13 at (100, 0) should be merged into a single node&quot;)&#10;    print(&quot;2. Update member connectivity to reference the merged node&quot;)&#10;    print(&quot;3. Ensure all supports are properly defined&quot;)&#10;    print(&quot;4. Check for any disconnected parts of the structure&quot;)&#10;&#10;# Display the plot on screen&#10;plt.show()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/run_Pratt_bridge_3d.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/run_Pratt_bridge_3d.py" />
              <option name="originalContent" value="import sys&#10;import yaml&#10;import matplotlib.pyplot as plt&#10;from mpl_toolkits.mplot3d import Axes3D&#10;import numpy as np&#10;import os&#10;from matplotlib.backends.backend_pdf import PdfPages&#10;import datetime&#10;import matplotlib.gridspec as gridspec&#10;import matplotlib.cm as cm&#10;from scipy import linalg&#10;&#10;# Load the bridge definition&#10;bridge_file = 'Pratt_Bridge_3D.YAML'&#10;print(f&quot;Loading 3D bridge from {bridge_file}&quot;)&#10;with open(os.path.join(os.path.dirname(__file__), bridge_file), 'r') as file:&#10;    bridge = yaml.safe_load(file)&#10;&#10;# Extract design parameters if present&#10;design_params = bridge.get('design_parameters', {})&#10;min_safety_factor = design_params.get('min_safety_factor', 1.0)&#10;print(f&quot;\nDesign minimum safety factor: {min_safety_factor}&quot;)&#10;&#10;# Extract nodes and members&#10;nodes = bridge['nodes']&#10;members = bridge['members']&#10;supports = bridge['supports']&#10;&#10;# Create a dictionary for easier node lookup and a node_id to index mapping&#10;node_dict = {}&#10;node_to_index = {}  # Maps node_id to its position index (0-based)&#10;for i, node in enumerate(nodes):&#10;    node_id = node['id']&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;    z = float(str(node.get('z', '0 ft')).split()[0])  # Default to 0 if z not present&#10;    node_dict[node_id] = (x, y, z)&#10;    node_to_index[node_id] = i  # Store 0-based index for each node&#10;&#10;print(f&quot;Created node index mapping for {len(node_to_index)} nodes&quot;)&#10;print(f&quot;First few mappings: {list(node_to_index.items())[:5]}&quot;)&#10;print(f&quot;Highest node ID: {max(node_to_index.keys())}&quot;)&#10;&#10;# Check for duplicate nodes with higher precision&#10;print(&quot;\nChecking for duplicate nodes (high precision check)...&quot;)&#10;node_positions = {}&#10;duplicate_nodes = []&#10;duplicate_tolerance = 1e-6  # Tolerance for considering nodes as duplicates (in feet)&#10;&#10;for node_id, pos in node_dict.items():&#10;    # Round to handle potential floating point precision issues&#10;    pos_key = (round(pos[0]/duplicate_tolerance)*duplicate_tolerance,&#10;               round(pos[1]/duplicate_tolerance)*duplicate_tolerance,&#10;               round(pos[2]/duplicate_tolerance)*duplicate_tolerance)&#10;&#10;    if pos_key in node_positions:&#10;        other_node = node_positions[pos_key]&#10;        print(f&quot;WARNING: Nodes {other_node} and {node_id} are at the same position {pos}&quot;)&#10;        print(f&quot;  Node {other_node}: ({node_dict[other_node][0]}, {node_dict[other_node][1]}, {node_dict[other_node][2]})&quot;)&#10;        print(f&quot;  Node {node_id}: ({pos[0]}, {pos[1]}, {pos[2]})&quot;)&#10;        print(&quot;This will cause numerical instability!&quot;)&#10;        duplicate_nodes.append((other_node, node_id))&#10;    else:&#10;        node_positions[pos_key] = node_id&#10;&#10;# Report structural connectivity&#10;print(&quot;\nStructural connectivity check:&quot;)&#10;print(f&quot;Total nodes: {len(node_dict)}&quot;)&#10;print(f&quot;Unique positions: {len(node_positions)}&quot;)&#10;if duplicate_nodes:&#10;    print(f&quot;Found {len(duplicate_nodes)} duplicate node pairs:&quot;)&#10;    for node1, node2 in duplicate_nodes:&#10;        pos = node_dict[node1]&#10;        print(f&quot;  Nodes {node1} and {node2} at position ({pos[0]}, {pos[1]}, {pos[2]})&quot;)&#10;    print(&quot;Duplicate nodes should be merged for numerical stability&quot;)&#10;else:&#10;    print(&quot;No duplicate nodes found - good!&quot;)&#10;&#10;# Check for disconnected parts&#10;print(&quot;\nChecking for member connectivity...&quot;)&#10;node_connections = {node_id: set() for node_id in node_dict}&#10;for member in members:&#10;    if member['i_node'] in node_dict and member['j_node'] in node_dict:&#10;        node_connections[member['i_node']].add(member['j_node'])&#10;        node_connections[member['j_node']].add(member['i_node'])&#10;&#10;# Find isolated nodes&#10;isolated_nodes = [node_id for node_id, connections in node_connections.items() if len(connections) == 0]&#10;if isolated_nodes:&#10;    print(f&quot;WARNING: Found {len(isolated_nodes)} isolated nodes: {isolated_nodes}&quot;)&#10;&#10;# Check connectivity between the two spans&#10;# Nodes at x=100 ft should connect the left and right spans&#10;nodes_at_pier = [node_id for node_id, pos in node_dict.items() if abs(pos[0] - 100) &lt; 0.1]&#10;print(f&quot;\nNodes at center pier (x=100 ft): {sorted(nodes_at_pier)}&quot;)&#10;&#10;# Check for members that should exist but don't&#10;print(&quot;\nVerifying critical connections:&quot;)&#10;critical_connections = [&#10;    (6, 12, &quot;Central vertical at x=100ft, front&quot;),&#10;    (106, 112, &quot;Central vertical at x=100ft, back&quot;),&#10;    (106, 12, &quot;Diagonal bracing at center pier&quot;)&#10;]&#10;&#10;for i_node, j_node, description in critical_connections:&#10;    found = any((m['i_node'] == i_node and m['j_node'] == j_node) or&#10;                (m['i_node'] == j_node and m['j_node'] == i_node)&#10;                for m in members)&#10;    if not found:&#10;        print(f&quot;  WARNING: Missing critical member {description} between nodes {i_node} and {j_node}&quot;)&#10;    else:&#10;        print(f&quot;  OK: Found {description}&quot;)&#10;&#10;# Define function to get DOF indices for a node (3D: 3 DOFs per node)&#10;def get_dof(node_id):&#10;    if node_id not in node_to_index:&#10;        raise ValueError(f&quot;Node ID {node_id} not found in node index mapping&quot;)&#10;    base = 3 * node_to_index[node_id]  # Use the node index, not the ID&#10;    return base, base + 1, base + 2  # x, y, z DOFs&#10;&#10;# Initialize global stiffness matrix and force vector&#10;num_nodes = len(nodes)&#10;dof = 3 * num_nodes  # Degrees of freedom (x, y, z for each node)&#10;K_global = np.zeros((dof, dof))&#10;F_global = np.zeros(dof)&#10;&#10;print(f&quot;\n3D Analysis: {num_nodes} nodes, {dof} DOFs&quot;)&#10;&#10;# Material properties (A36 steel)&#10;E = 29000.0  # ksi - Young's modulus&#10;&#10;# Define section properties - now load from YAML if available&#10;if 'sections' in bridge:&#10;    sections = {}&#10;    for section in bridge['sections']:&#10;        sec_id = section['id']&#10;        area_str = str(section['area']).split()[0]  # Extract numeric part&#10;        r_str = str(section['r']).split()[0]        # Extract numeric part&#10;        sections[sec_id] = {&#10;            &quot;area&quot;: float(area_str),&#10;            &quot;r&quot;: float(r_str)&#10;        }&#10;    print(&quot;\nLoaded section properties from YAML:&quot;)&#10;    for sec_id, props in sections.items():&#10;        print(f&quot;  Section {sec_id}: Area = {props['area']} in^2, r = {props['r']} in&quot;)&#10;else:&#10;    # Default section properties if not in YAML&#10;    sections = {&#10;        1: {&quot;area&quot;: 7.65, &quot;r&quot;: 4.32},  # W12x26 - area in in^2, r is radius of gyration in inches&#10;        2: {&quot;area&quot;: 9.13, &quot;r&quot;: 3.47}   # W8x31 - area in in^2, r is radius of gyration in inches&#10;    }&#10;    print(&quot;\nUsing default section properties&quot;)&#10;&#10;# Store member data for later reference&#10;member_data = {}&#10;&#10;# Calculate axial stiffness for each member&#10;print(&quot;\nAssembling 3D stiffness matrix...&quot;)&#10;for member in members:&#10;    member_id = member['id']&#10;    start = member['i_node']&#10;    end = member['j_node']&#10;&#10;    # Verify nodes exist in our mapping&#10;    if start not in node_to_index:&#10;        print(f&quot;ERROR: Member {member_id} references non-existent node {start}&quot;)&#10;        continue&#10;    if end not in node_to_index:&#10;        print(f&quot;ERROR: Member {member_id} references non-existent node {end}&quot;)&#10;        continue&#10;&#10;    section_id = member['section']&#10;&#10;    # Get section properties&#10;    section_area = sections[section_id][&quot;area&quot;]  # in&#10;&#10;    # Calculate EA in kip-in (E in ksi, A in in =&gt; EA in kip)&#10;    EA = E * section_area&#10;&#10;    # Get coordinates&#10;    x1, y1, z1 = node_dict[start]&#10;    x2, y2, z2 = node_dict[end]&#10;&#10;    # Calculate length in ft&#10;    dx = x2 - x1&#10;    dy = y2 - y1&#10;    dz = z2 - z1&#10;    length_ft = np.sqrt(dx**2 + dy**2 + dz**2)&#10;&#10;    # Check for zero-length members&#10;    if length_ft &lt; 1e-6:&#10;        print(f&quot;ERROR: Member {member_id} has zero length (nodes {start} to {end})&quot;)&#10;        print(f&quot;  Node {start}: ({x1}, {y1}, {z1})&quot;)&#10;        print(f&quot;  Node {end}: ({x2}, {y2}, {z2})&quot;)&#10;        continue  # Skip this member instead of exiting&#10;&#10;    length_in = length_ft * 12.0  # Convert to inches&#10;&#10;    # Calculate direction cosines for 3D&#10;    cx = dx / length_ft&#10;    cy = dy / length_ft&#10;    cz = dz / length_ft&#10;&#10;    # Store member properties&#10;    member_data[member_id] = {&#10;        &quot;start&quot;: start,&#10;        &quot;end&quot;: end,&#10;        &quot;length_ft&quot;: length_ft,&#10;        &quot;length_in&quot;: length_in,&#10;        &quot;EA&quot;: EA,&#10;        &quot;cx&quot;: cx,&#10;        &quot;cy&quot;: cy,&#10;        &quot;cz&quot;: cz,&#10;        &quot;section_id&quot;: section_id,&#10;        &quot;section_area&quot;: section_area&#10;    }&#10;&#10;    # Debug info for first few members&#10;    if member_id &lt;= 3:&#10;        print(f&quot;Member {member_id}: Length = {length_ft:.2f} ft ({length_in:.2f} in), EA = {EA:.2f} kip&quot;)&#10;        print(f&quot;  Direction cosines: cx = {cx:.4f}, cy = {cy:.4f}, cz = {cz:.4f}&quot;)&#10;&#10;    # Local to global transformation matrix for 3D truss element&#10;    # The transformation matrix is 6x6 for 3D (3 DOFs per node)&#10;    T = np.array([&#10;        [cx, cy, cz, 0,  0,  0],&#10;        [0,  0,  0, cx, cy, cz]&#10;    ])&#10;&#10;    # Element stiffness matrix in local coordinates (for a 3D truss element)&#10;    # k = EA/L in kip/in&#10;    k_axial = EA / length_in&#10;&#10;    k_local = k_axial * np.array([&#10;        [ 1, -1],&#10;        [-1,  1]&#10;    ])&#10;&#10;    # Transform to global coordinates: k_global = T^T * k_local * T&#10;    k_global = T.T @ k_local @ T&#10;&#10;    # Map local DOFs to global DOFs using node indices, not IDs&#10;    dof_start = get_dof(start)&#10;    dof_end = get_dof(end)&#10;    dof_indices = [*dof_start, *dof_end]&#10;&#10;    if member_id &lt;= 3:&#10;        print(f&quot;  DOF indices: {dof_indices}&quot;)&#10;&#10;    # Assemble into global stiffness matrix&#10;    for i in range(6):&#10;        for j in range(6):&#10;            K_global[dof_indices[i], dof_indices[j]] += k_global[i, j]&#10;&#10;# Apply external forces from member loads&#10;print(&quot;\nApplying loads...&quot;)&#10;if 'member_loads' in bridge:&#10;    for load in bridge['member_loads']:&#10;        member_id = load['member_uid']&#10;        if member_id not in member_data:&#10;            print(f&quot;WARNING: Load references non-existent member {member_id}&quot;)&#10;            continue&#10;&#10;        member = next(m for m in members if m['id'] == member_id)&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        # Convert distributed load to equivalent nodal loads&#10;        wi = float(str(load['wi']).split()[0])  # kips/ft&#10;        wj = float(str(load['wj']).split()[0])  # kips/ft&#10;        length = member_data[member_id][&quot;length_ft&quot;]  # ft&#10;&#10;        # For uniform load, apply half to each node in y-direction&#10;        if abs(wi - wj) &lt; 1e-6:  # Uniform load&#10;            force = abs(wi) * length / 2  # kips (make positive)&#10;            _, dof_yi, _ = get_dof(i_node)&#10;            _, dof_yj, _ = get_dof(j_node)&#10;&#10;            # Debug info for first few loads&#10;            if member_id &lt;= 3:&#10;                print(f&quot;Load on member {member_id}: w = {wi} kips/ft, L = {length:.2f} ft&quot;)&#10;                print(f&quot;  Equivalent nodal forces: {force:.2f} kips (downward) at nodes {i_node} and {j_node}&quot;)&#10;&#10;            # Apply downward forces (negative in typical structural convention)&#10;            F_global[dof_yi] -= force  # Negative for downward&#10;            F_global[dof_yj] -= force  # Negative for downward&#10;        else:&#10;            # For non-uniform load (simplified approach)&#10;            force_i = abs(wi) * length / 3  # kips&#10;            force_j = abs(wj) * length / 3  # kips&#10;            _, dof_yi, _ = get_dof(i_node)&#10;            _, dof_yj, _ = get_dof(j_node)&#10;            F_global[dof_yi] -= force_i  # Negative for downward&#10;            F_global[dof_yj] -= force_j  # Negative for downward&#10;&#10;# Apply support constraints&#10;print(&quot;\nApplying support constraints:&quot;)&#10;constrained_dofs = []&#10;for support in supports:&#10;    node_id = support['node']&#10;&#10;    if node_id not in node_to_index:&#10;        print(f&quot;WARNING: Support references non-existent node {node_id}&quot;)&#10;        continue&#10;&#10;    dof_x, dof_y, dof_z = get_dof(node_id)&#10;&#10;    print(f&quot;Support at node {node_id}: ux={support['ux']}, uy={support['uy']}, uz={support.get('uz', 0)}&quot;)&#10;&#10;    if support['ux'] == 1:  # Fixed in x-direction&#10;        constrained_dofs.append(dof_x)&#10;        K_global[dof_x, :] = 0&#10;        K_global[:, dof_x] = 0&#10;        K_global[dof_x, dof_x] = 1&#10;        F_global[dof_x] = 0&#10;&#10;    if support['uy'] == 1:  # Fixed in y-direction&#10;        constrained_dofs.append(dof_y)&#10;        K_global[dof_y, :] = 0&#10;        K_global[:, dof_y] = 0&#10;        K_global[dof_y, dof_y] = 1&#10;        F_global[dof_y] = 0&#10;&#10;    if support.get('uz', 0) == 1:  # Fixed in z-direction&#10;        constrained_dofs.append(dof_z)&#10;        K_global[dof_z, :] = 0&#10;        K_global[:, dof_z] = 0&#10;        K_global[dof_z, dof_z] = 1&#10;        F_global[dof_z] = 0&#10;&#10;print(f&quot;Total constrained DOFs: {len(constrained_dofs)}&quot;)&#10;print(f&quot;Free DOFs: {dof - len(constrained_dofs)}&quot;)&#10;&#10;# Check for zero diagonal elements (indicates singularity)&#10;diag_zeros = np.where(np.abs(np.diag(K_global)) &lt; 1e-10)[0]&#10;if len(diag_zeros) &gt; 0:&#10;    print(f&quot;\nWARNING: Zero diagonal elements detected at DOFs: {diag_zeros}&quot;)&#10;    for dof_idx in diag_zeros:&#10;        # Find which node this DOF belongs to&#10;        node_idx = dof_idx // 3&#10;        # Find the node_id from the index&#10;        node_id = None&#10;        for nid, idx in node_to_index.items():&#10;            if idx == node_idx:&#10;                node_id = nid&#10;                break&#10;        dof_type = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;][dof_idx % 3]&#10;        print(f&quot;  DOF {dof_idx} (Node {node_id}, {dof_type}-direction)&quot;)&#10;&#10;# Check if the stiffness matrix is symmetric (it should be)&#10;is_symmetric = np.allclose(K_global, K_global.T, rtol=1e-5, atol=1e-8)&#10;print(f&quot;\nStiffness matrix is symmetric: {is_symmetric}&quot;)&#10;&#10;# Check for rows/columns that are all zeros (except diagonal)&#10;print(&quot;\nChecking for zero rows/columns in stiffness matrix...&quot;)&#10;zero_rows = []&#10;for i in range(dof):&#10;    row = K_global[i, :]&#10;    if np.sum(np.abs(row)) - np.abs(row[i]) &lt; 1e-10:  # Row has only diagonal element&#10;        zero_rows.append(i)&#10;        # Find which node this DOF belongs to&#10;        node_idx = i // 3&#10;        # Find the node_id from the index&#10;        node_id = None&#10;        for nid, idx in node_to_index.items():&#10;            if idx == node_idx:&#10;                node_id = nid&#10;                break&#10;        dof_type = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;][i % 3]&#10;        print(f&quot;  DOF {i} (Node {node_id}, {dof_type}-direction) has no off-diagonal connections&quot;)&#10;&#10;# Analyze the condition of the matrix&#10;try:&#10;    # Compute the condition number&#10;    cond = np.linalg.cond(K_global)&#10;    print(f&quot;Condition number of stiffness matrix: {cond:.2e}&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        print(&quot;\nWARNING: Very high condition number detected!&quot;)&#10;        print(&quot;The structure may have:&quot;)&#10;        print(&quot;1. Insufficient supports (mechanism)&quot;)&#10;        print(&quot;2. Disconnected parts&quot;)&#10;        print(&quot;3. Numerical scaling issues&quot;)&#10;        print(&quot;4. Duplicate nodes at the same location&quot;)&#10;&#10;        # Additional diagnostics&#10;        print(&quot;\nDiagnostic information:&quot;)&#10;        print(f&quot;- Number of duplicate node positions: {len(duplicate_nodes)}&quot;)&#10;        print(f&quot;- Number of isolated nodes: {len(isolated_nodes)}&quot;)&#10;        print(f&quot;- Number of zero rows/columns: {len(zero_rows)}&quot;)&#10;&#10;        # Check for specific problematic DOFs&#10;        if len(zero_rows) &gt; 0:&#10;            print(&quot;\nNodes with unconnected DOFs:&quot;)&#10;            problematic_nodes = set()&#10;            for dof_idx in zero_rows:&#10;                node_idx = dof_idx // 3&#10;                for nid, idx in node_to_index.items():&#10;                    if idx == node_idx:&#10;                        problematic_nodes.add(nid)&#10;                        break&#10;            print(f&quot;  Nodes with issues: {sorted(problematic_nodes)}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;Could not compute condition number: {e}&quot;)&#10;    cond = float('inf')&#10;&#10;# Apply scaling to improve conditioning&#10;print(&quot;\nAttempting to solve the system...&quot;)&#10;try:&#10;    # For very ill-conditioned systems, try regularization&#10;    if cond &gt; 1e14:&#10;        print(&quot;System is extremely ill-conditioned. Applying regularization...&quot;)&#10;        # Add small diagonal perturbation to improve conditioning&#10;        reg_factor = 1e-8 * np.max(np.abs(np.diag(K_global)))&#10;        K_regularized = K_global + reg_factor * np.eye(dof)&#10;&#10;        try:&#10;            displacements = linalg.solve(K_regularized, F_global, assume_a='sym')&#10;            print(&quot;Regularized solution successful&quot;)&#10;        except:&#10;            # Fall back to least squares&#10;            displacements, residuals, rank, s = linalg.lstsq(K_global, F_global)&#10;            print(f&quot;Least squares solution: rank={rank}/{dof}&quot;)&#10;    else:&#10;        # Try direct solution&#10;        displacements = linalg.solve(K_global, F_global, assume_a='sym')&#10;        print(&quot;Direct solution successful&quot;)&#10;&#10;    # Print first few displacement values for debugging&#10;    print(&quot;\nNodal displacements:&quot;)&#10;    print(&quot;Node | dx (in) | dy (in) | dz (in)&quot;)&#10;    print(&quot;-&quot; * 40)&#10;    for node_id in sorted(list(node_dict.keys()))[:10]:  # First 10 nodes&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        # Convert to inches for display&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        dz_in = displacements[dof_z] * 12&#10;        print(f&quot;{node_id:4} | {dx_in:7.4f} | {dy_in:7.4f} | {dz_in:7.4f}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;All solution methods failed: {e}&quot;)&#10;    print(&quot;Using zero displacements as fallback&quot;)&#10;    displacements = np.zeros(dof)&#10;&#10;# Find maximum vertical displacement&#10;max_vert_disp = 0&#10;max_disp_node = None&#10;for node_id in node_dict:&#10;    _, dof_y, _ = get_dof(node_id)&#10;    # Skip nodes that are supported&#10;    is_supported = any(s['node'] == node_id and s['uy'] == 1 for s in supports)&#10;    if not is_supported:&#10;        disp = abs(displacements[dof_y])&#10;        if disp &gt; max_vert_disp:&#10;            max_vert_disp = disp&#10;            max_disp_node = node_id&#10;&#10;# Convert to inches for display&#10;max_vert_disp_in = max_vert_disp * 12&#10;print(f&quot;\nMaximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}&quot;)&#10;&#10;# Calculate member forces&#10;member_forces = {}&#10;member_stresses = {}&#10;&#10;# Material properties (A36 steel)&#10;Fy = 36.0    # ksi - Yield strength&#10;Fu = 58.0    # ksi - Ultimate strength&#10;safety_factor_tension = 1.67&#10;safety_factor_compression = 1.67&#10;allowable_tension_stress = Fy / safety_factor_tension      # ksi&#10;allowable_compression_stress_max = Fy / safety_factor_compression  # ksi&#10;&#10;# Calculate forces and stresses for each member&#10;for member in members:&#10;    member_id = member['id']&#10;    if member_id not in member_data:&#10;        continue  # Skip members with zero length or missing data&#10;&#10;    mem_data = member_data[member_id]&#10;    start = mem_data[&quot;start&quot;]&#10;    end = mem_data[&quot;end&quot;]&#10;    area = mem_data[&quot;section_area&quot;]  # in&#10;    cx = mem_data[&quot;cx&quot;]&#10;    cy = mem_data[&quot;cy&quot;]&#10;    cz = mem_data[&quot;cz&quot;]&#10;&#10;    # Get displacements at both nodes (in feet)&#10;    dof_x1, dof_y1, dof_z1 = get_dof(start)&#10;    dof_x2, dof_y2, dof_z2 = get_dof(end)&#10;&#10;    # Calculate relative displacement in the axial direction (in feet)&#10;    delta_u1 = displacements[dof_x1] * cx + displacements[dof_y1] * cy + displacements[dof_z1] * cz&#10;    delta_u2 = displacements[dof_x2] * cx + displacements[dof_y2] * cy + displacements[dof_z2] * cz&#10;    delta_axial = delta_u2 - delta_u1&#10;&#10;    # Convert to inches for force calculation&#10;    delta_axial_in = delta_axial * 12&#10;&#10;    # Calculate axial force (F = EA/L * delta)&#10;    EA = mem_data[&quot;EA&quot;]  # kip&#10;    force = (EA / mem_data[&quot;length_in&quot;]) * delta_axial_in  # kips&#10;    member_forces[member_id] = force&#10;&#10;    # Calculate axial stress&#10;    stress = force / area  # kips/in = ksi&#10;    member_stresses[member_id] = stress&#10;&#10;    # Debug output for selected members&#10;    if member_id &lt;= 3 or member_id == 32:&#10;        print(f&quot;\nMember {member_id} analysis:&quot;)&#10;        print(f&quot;  Length = {mem_data['length_ft']:.2f} ft&quot;)&#10;        print(f&quot;  Node {start}: dx = {displacements[dof_x1]*12:.4f} in, dy = {displacements[dof_y1]*12:.4f} in, dz = {displacements[dof_z1]*12:.4f} in&quot;)&#10;        print(f&quot;  Node {end}: dx = {displacements[dof_x2]*12:.4f} in, dy = {displacements[dof_y2]*12:.4f} in, dz = {displacements[dof_z2]*12:.4f} in&quot;)&#10;        print(f&quot;  Delta axial = {delta_axial_in:.4f} in&quot;)&#10;        print(f&quot;  Force = {force:.2f} kips&quot;)&#10;        print(f&quot;  Stress = {stress:.2f} ksi&quot;)&#10;&#10;# Calculate safety factors for all members&#10;member_safety_factors = {}&#10;member_status = {}&#10;&#10;# Define zero force threshold&#10;ZERO_FORCE_THRESHOLD = 0.1  # Consider forces below this threshold as &quot;zero&quot;&#10;&#10;# Replace the problematic part in the safety factors calculation&#10;for member_id, stress in member_stresses.items():&#10;    section_id = member_data[member_id][&quot;section_id&quot;]&#10;    section = sections[section_id]&#10;&#10;    if abs(stress) &lt; ZERO_FORCE_THRESHOLD / section[&quot;area&quot;]:&#10;        # Zero/near-zero stress&#10;        safety_factor = float('inf')&#10;        limit = allowable_tension_stress  # Arbitrary for zero-force members&#10;        status = &quot;OK&quot;&#10;    elif stress &gt;= 0:  # Tension&#10;        safety_factor = allowable_tension_stress / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_tension_stress&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;    else:  # Compression&#10;        # Calculate allowable compression stress based on slenderness&#10;        length_inches = member_data[member_id][&quot;length_in&quot;]&#10;        slenderness = length_inches / section[&quot;r&quot;]&#10;&#10;        if slenderness &gt; 100:  # For slender members&#10;            critical_stress = (np.pi**2 * E) / (slenderness**2)&#10;            allowable_compression = min(allowable_compression_stress_max, critical_stress/safety_factor_compression)&#10;        else:  # For stocky members&#10;            allowable_compression = allowable_compression_stress_max&#10;&#10;        safety_factor = allowable_compression / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_compression&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;&#10;    member_safety_factors[member_id] = safety_factor&#10;    member_status[member_id] = {&#10;        &quot;stress&quot;: stress,&#10;        &quot;allowable&quot;: limit,&#10;        &quot;safety_factor&quot;: safety_factor,&#10;        &quot;status&quot;: status&#10;    }&#10;&#10;# After calculating safety factors, add a summary of members below minimum&#10;members_below_min_sf = []&#10;zero_force_members = []&#10;for member_id, status_info in member_status.items():&#10;    if status_info[&quot;safety_factor&quot;] &lt; min_safety_factor and status_info[&quot;safety_factor&quot;] &lt; 100:&#10;        members_below_min_sf.append({&#10;            'id': member_id,&#10;            'sf': status_info[&quot;safety_factor&quot;],&#10;            'stress': status_info[&quot;stress&quot;],&#10;            'allowable': status_info[&quot;allowable&quot;]&#10;        })&#10;    if abs(member_forces[member_id]) &lt; ZERO_FORCE_THRESHOLD:&#10;        zero_force_members.append(member_id)&#10;&#10;if members_below_min_sf:&#10;    print(f&quot;\n{len(members_below_min_sf)} members have safety factor below {min_safety_factor}:&quot;)&#10;    for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:10]:  # Show worst 10&#10;        print(f&quot;  Member {mem['id']}: SF = {mem['sf']:.2f}, Stress = {abs(mem['stress']):.1f} ksi&quot;)&#10;&#10;if zero_force_members:&#10;    print(f&quot;\n{len(zero_force_members)} zero-force members detected:&quot;)&#10;    print(f&quot;  Members: {sorted(zero_force_members)[:20]}&quot;)  # Show first 20&#10;&#10;# Create figure for the PDF - add timestamp to filenames&#10;timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M%S')&#10;pdf_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_3D_Analysis_{timestamp}.pdf&quot;)&#10;text_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_3D_Analysis_{timestamp}.txt&quot;)&#10;&#10;# Open the text file for writing the report&#10;with open(text_filename, 'w') as txt_report:&#10;    # Write header information&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(&quot;PRATT BRIDGE STRUCTURAL ANALYSIS REPORT\n&quot;)&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(f&quot;Analysis Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}\n&quot;)&#10;    txt_report.write(f&quot;Input File: {bridge_file}\n&quot;)&#10;    txt_report.write(f&quot;Design Minimum Safety Factor: {min_safety_factor}\n\n&quot;)&#10;&#10;    # Write model statistics&#10;    txt_report.write(&quot;MODEL STATISTICS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Number of nodes: {num_nodes}\n&quot;)&#10;    txt_report.write(f&quot;Number of members: {len(members)}\n&quot;)&#10;    txt_report.write(f&quot;Number of supports: {len(supports)}\n&quot;)&#10;    txt_report.write(f&quot;Degrees of freedom: {dof}\n&quot;)&#10;    txt_report.write(f&quot;Constrained DOFs: {len(constrained_dofs)}\n&quot;)&#10;    txt_report.write(f&quot;Free DOFs: {dof - len(constrained_dofs)}\n\n&quot;)&#10;&#10;    # Write material properties&#10;    txt_report.write(&quot;MATERIAL PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Material: A36 Steel\n&quot;)&#10;    txt_report.write(f&quot;Young's modulus: {E} ksi\n&quot;)&#10;    txt_report.write(f&quot;Yield strength: {Fy} ksi\n&quot;)&#10;    txt_report.write(f&quot;Ultimate strength: {Fu} ksi\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (tension): {safety_factor_tension}\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (compression): {safety_factor_compression}\n\n&quot;)&#10;&#10;    # Write section properties&#10;    txt_report.write(&quot;SECTION PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    for sec_id, props in sections.items():&#10;        txt_report.write(f&quot;Section {sec_id}: Area = {props['area']} in, r = {props['r']} in\n&quot;)&#10;    txt_report.write(&quot;\n&quot;)&#10;&#10;    # Write analysis results summary&#10;    txt_report.write(&quot;ANALYSIS RESULTS SUMMARY\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Maximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}\n&quot;)&#10;    txt_report.write(f&quot;Stiffness matrix condition number: {cond:.2e}\n&quot;)&#10;&#10;    # Calculate critical values&#10;    critical_sf = float('inf')&#10;    critical_member = None&#10;    overstressed_count = 0&#10;    for member_id, status_info in member_status.items():&#10;        sf = status_info[&quot;safety_factor&quot;]&#10;        if sf &lt; critical_sf and sf &lt; 100:&#10;            critical_sf = sf&#10;            critical_member = member_id&#10;        if status_info[&quot;status&quot;] == &quot;OVERSTRESSED&quot;:&#10;            overstressed_count += 1&#10;&#10;    txt_report.write(f&quot;Number of tension members: {sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of compression members: {sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of zero-force members: {sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Overstressed members: {overstressed_count}\n&quot;)&#10;    txt_report.write(f&quot;Maximum member force: {max(abs(f) for f in member_forces.values()):.2f} kips\n&quot;)&#10;    txt_report.write(f&quot;Maximum member stress: {max(abs(s) for s in member_stresses.values()):.2f} ksi\n&quot;)&#10;    txt_report.write(f&quot;Minimum safety factor: {critical_sf:.2f} (Member #{critical_member})\n\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;\nNUMERICAL STABILITY WARNING:\n&quot;)&#10;        txt_report.write(&quot;--------------------------------\n&quot;)&#10;        txt_report.write(f&quot;Condition number ({cond:.2e}) indicates severe numerical instability.\n&quot;)&#10;        txt_report.write(&quot;\nPossible causes:\n&quot;)&#10;        if duplicate_nodes:&#10;            txt_report.write(f&quot;1. Found {len(duplicate_nodes)} duplicate node pairs:\n&quot;)&#10;            for node1, node2 in duplicate_nodes[:5]:  # Show first 5&#10;                txt_report.write(f&quot;   - Nodes {node1} and {node2} at position {node_dict[node1]}\n&quot;)&#10;        if isolated_nodes:&#10;            txt_report.write(f&quot;2. Found {len(isolated_nodes)} isolated nodes\n&quot;)&#10;        if zero_rows:&#10;            txt_report.write(f&quot;3. Found {len(zero_rows)} DOFs with no off-diagonal connections\n&quot;)&#10;        txt_report.write(&quot;\nRecommended fixes:\n&quot;)&#10;        txt_report.write(&quot;- Merge duplicate nodes into single nodes\n&quot;)&#10;        txt_report.write(&quot;- Ensure proper connectivity between structural parts\n&quot;)&#10;        txt_report.write(&quot;- Verify all supports are correctly defined\n&quot;)&#10;        txt_report.write(&quot;- Check member connectivity references\n\n&quot;)&#10;&#10;    # Write detailed member results&#10;    txt_report.write(&quot;DETAILED MEMBER RESULTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Member | Nodes (i-j) | Force (kips) | Stress (ksi) | Type | S.F. | Status\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 80 + &quot;\n&quot;)&#10;&#10;    for member in sorted(members, key=lambda m: m['id']):&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;        stress = member_stresses[member_id]&#10;        sf = member_safety_factors[member_id]&#10;        status = member_status[member_id][&quot;status&quot;]&#10;&#10;        # Fix the text report formatting to use only ASCII&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            force_type = &quot;ZERO&quot;&#10;            sf_text = &quot;inf&quot;&#10;        elif force &gt; 0:&#10;            force_type = &quot;TENSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;        else:&#10;            force_type = &quot;COMPRESSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;&#10;        txt_report.write(&#10;            f&quot;{member_id:6} | {i_node:2}-{j_node:&lt;2} | {abs(force):11.2f} | {abs(stress):10.2f} | {force_type:10} | {sf_text:&gt;5} | {status}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;&#10;    # Write nodal displacements&#10;    txt_report.write(&quot;NODAL DISPLACEMENTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Node | dx (inches) | dy (inches) | dz (inches)\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 40 + &quot;\n&quot;)&#10;&#10;    for node_id in sorted(node_dict.keys()):&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        dz_in = displacements[dof_z] * 12&#10;        txt_report.write(f&quot;{node_id:4} | {dx_in:11.4f} | {dy_in:11.4f} | {dz_in:11.4f}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;    txt_report.write(&quot;RECOMMENDATIONS FOR STRUCTURE REFINEMENT\n&quot;)&#10;    txt_report.write(&quot;----------------------------------------\n&quot;)&#10;&#10;    if members_below_min_sf:&#10;        txt_report.write(f&quot;1. {len(members_below_min_sf)} members have safety factor below the design minimum of {min_safety_factor}:\n&quot;)&#10;        for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:20]:  # Show worst 20&#10;            member = next(m for m in members if m['id'] == mem['id'])&#10;            txt_report.write(f&quot;   - Member {mem['id']} (nodes {member['i_node']}-{member['j_node']}): SF = {mem['sf']:.2f}\n&quot;)&#10;&#10;        # Calculate required section increase&#10;        worst_sf = min(mem['sf'] for mem in members_below_min_sf)&#10;        required_increase = min_safety_factor / worst_sf&#10;        txt_report.write(f&quot;\n   Worst member requires approximately {required_increase:.1f}x increase in capacity.\n&quot;)&#10;        txt_report.write(f&quot;   Consider using larger sections or reducing the loading.\n&quot;)&#10;    else:&#10;        txt_report.write(&quot;1. All members meet the minimum safety factor requirement.\n&quot;)&#10;        txt_report.write(&quot;   Consider optimizing the structure by reducing sections for members with high safety factors.\n&quot;)&#10;&#10;    if max_vert_disp_in &gt; 2.0:  # Assuming 2 inches as a reasonable deflection limit&#10;        txt_report.write(f&quot;2. Consider stiffening the structure to reduce the maximum deflection (currently {max_vert_disp_in:.4f} inches).\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;3. Fix numerical stability issues by reviewing structure connectivity and supports.\n&quot;)&#10;&#10;    txt_report.write(&quot;\nReport generated by pyMAOS Truss Analysis Tool\n&quot;)&#10;&#10;print(f&quot;Text report saved to: {text_filename}&quot;)&#10;&#10;with PdfPages(pdf_filename) as pdf:&#10;    # 1. BRIDGE ANALYSIS SUMMARY page&#10;    fig = plt.figure(figsize=(8.5, 11))&#10;    plt.axis('off')&#10;&#10;    # Add overall bridge status text - avoid using unicode characters&#10;    if overstressed_count == 0:&#10;        status_text = &quot;BRIDGE IS STRUCTURALLY ADEQUATE&quot;&#10;        status_color = 'green'&#10;    else:&#10;        status_text = f&quot;WARNING: BRIDGE HAS {overstressed_count} OVERSTRESSED MEMBERS&quot;&#10;        status_color = 'red'&#10;&#10;    plt.figtext(0.5, 0.9, &quot;BRIDGE ANALYSIS SUMMARY&quot;, ha='center', fontsize=16, weight='bold')&#10;    plt.figtext(0.5, 0.85, status_text, ha='center', fontsize=14, weight='bold', color=status_color)&#10;&#10;    # Add displacement information&#10;    plt.figtext(0.5, 0.78, f&quot;Maximum Vertical Displacement: {max_vert_disp_in:.4f} inches at Node {max_disp_node}&quot;,&#10;                ha='center', fontsize=12)&#10;&#10;    # Add summary statistics&#10;    critical_text = f&quot;Most critical member: #{critical_member} (Safety Factor: {critical_sf:.2f})&quot;&#10;    plt.figtext(0.5, 0.73, critical_text, ha='center', fontsize=12)&#10;&#10;    # Add a summary table of key statistics&#10;    summary_data = [&#10;        [&quot;Total Members&quot;, f&quot;{len(members)}&quot;],&#10;        [&quot;Tension Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Compression Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Zero-Force Members&quot;, f&quot;{sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Overstressed Members&quot;, f&quot;{overstressed_count}&quot;],&#10;        [&quot;Maximum Member Force&quot;, f&quot;{max(abs(f) for f in member_forces.values()):.2f} kips&quot;],&#10;        [&quot;Maximum Member Stress&quot;, f&quot;{max(abs(s) for s in member_stresses.values()):.2f} ksi&quot;],&#10;        [&quot;Minimum Safety Factor&quot;, f&quot;{critical_sf:.2f}&quot;],&#10;        [&quot;Maximum Displacement&quot;, f&quot;{max_vert_disp_in:.4f} inches&quot;],&#10;    ]&#10;&#10;    # Create a table in the middle of the page&#10;    ax = plt.subplot(111)&#10;    ax.axis('off')&#10;    tbl = plt.table(cellText=summary_data, colLabels=[&quot;Metric&quot;, &quot;Value&quot;],&#10;                    loc='center', cellLoc='left')&#10;    tbl.auto_set_font_size(False)&#10;    tbl.set_fontsize(10)&#10;    tbl.scale(1, 1.5)&#10;&#10;    # Add design criteria info&#10;    criteria = (&#10;        f&quot;Design Criteria:\n&quot;&#10;        f&quot;- Material: A36 Steel (Fy = 36 ksi)\n&quot;&#10;        f&quot;- Allowable tension stress: {allowable_tension_stress:.1f} ksi\n&quot;&#10;        f&quot;- Allowable compression stress: Based on member slenderness\n&quot;&#10;        f&quot;- Safety factor: {safety_factor_tension:.2f}&quot;&#10;    )&#10;    plt.figtext(0.5, 0.2, criteria, ha='center', fontsize=10,&#10;                bbox=dict(facecolor='#eeeeee', alpha=0.7, boxstyle='round,pad=0.5'))&#10;&#10;    # Add timestamp&#10;    plt.figtext(0.5, 0.1, f&quot;Analysis completed on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    # Save the summary page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 2. 3D Structure Visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Plot members with color based on safety factors&#10;    cmap = plt.colormaps['RdYlGn']  # Red-Yellow-Green colormap&#10;    norm = plt.Normalize(0.5, 2.0)&#10;&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        safety_factor = member_safety_factors[member_id]&#10;        safety_factor_capped = min(safety_factor, 5.0)  # Cap extremely high values&#10;&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        color = cmap(norm(safety_factor_capped))&#10;&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color=color, linewidth=2)&#10;&#10;    # Plot nodes&#10;    for node_id, (x, y, z) in node_dict.items():&#10;        ax.scatter(x, y, z, c='black', s=20)&#10;&#10;    # Plot supports with different markers&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, z = node_dict[node_id]&#10;        if support['ux'] == 1 and support['uy'] == 1 and support.get('uz', 0) == 1:&#10;            ax.scatter(x, y-5, z, c='red', s=100, marker='s')  # Fixed support&#10;        else:&#10;            ax.scatter(x, y-5, z, c='blue', s=100, marker='o')  # Roller support&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title('3D Pratt Truss Bridge - Safety Factor Visualization')&#10;&#10;    # Add colorbar&#10;    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)&#10;    sm.set_array([])&#10;    cbar = plt.colorbar(sm, ax=ax, label='Safety Factor', shrink=0.6)&#10;&#10;    # Set aspect ratio&#10;    ax.set_box_aspect([2, 0.5, 0.5])  # Adjust based on bridge proportions&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 3. Member Forces - 3D visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Plot members with color based on tension/compression&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        # Color based on force type&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            color = 'black'&#10;            linewidth = 1&#10;        elif force &gt; 0:&#10;            color = 'red'  # Tension&#10;            linewidth = 2 + min(3, abs(force)/50)&#10;        else:&#10;            color = 'blue'  # Compression&#10;            linewidth = 2 + min(3, abs(force)/50)&#10;&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color=color, linewidth=linewidth)&#10;&#10;    # Add legend&#10;    from matplotlib.lines import Line2D&#10;    red_line = Line2D([0], [0], color='red', linewidth=3, label='Tension')&#10;    blue_line = Line2D([0], [0], color='blue', linewidth=3, label='Compression')&#10;    black_line = Line2D([0], [0], color='black', linewidth=1, label='Zero Force')&#10;    ax.legend(handles=[red_line, blue_line, black_line], loc='upper right')&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title('3D Pratt Truss Bridge - Member Forces')&#10;    ax.set_box_aspect([2, 0.5, 0.5])&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 4. 3D Displacement visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Calculate max displacement for scaling&#10;    max_disp_magnitude = 0&#10;    for node_id in node_dict:&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        disp_magnitude = np.sqrt(displacements[dof_x]**2 + displacements[dof_y]**2 + displacements[dof_z]**2)&#10;        max_disp_magnitude = max(max_disp_magnitude, disp_magnitude)&#10;&#10;    # Calculate scale factor&#10;    max_span = max(node_dict[n][0] for n in node_dict) - min(node_dict[n][0] for n in node_dict)&#10;    target_max_disp = max_span * 0.05&#10;&#10;    if max_disp_magnitude &gt; 1e-10:&#10;        scale_factor = target_max_disp / max_disp_magnitude&#10;        scale_magnitude = 10 ** int(np.log10(scale_factor))&#10;        scale_factor = round(scale_factor / scale_magnitude) * scale_magnitude&#10;    else:&#10;        scale_factor = 50.0&#10;&#10;    # Draw original structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color='lightgray', linewidth=1, alpha=0.5)&#10;&#10;    # Draw displaced structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        # Get displacements&#10;        dof_x1, dof_y1, dof_z1 = get_dof(i_node)&#10;        dof_x2, dof_y2, dof_z2 = get_dof(j_node)&#10;&#10;        # Apply scaled displacements&#10;        x1_new = x1 + displacements[dof_x1] * scale_factor&#10;        y1_new = y1 + displacements[dof_y1] * scale_factor&#10;        z1_new = z1 + displacements[dof_z1] * scale_factor&#10;        x2_new = x2 + displacements[dof_x2] * scale_factor&#10;        y2_new = y2 + displacements[dof_y2] * scale_factor&#10;        z2_new = z2 + displacements[dof_z2] * scale_factor&#10;&#10;        ax.plot([x1_new, x2_new], [y1_new, y2_new], [z1_new, z2_new], color='blue', linewidth=1.5)&#10;&#10;    # Highlight max displacement node&#10;    if max_disp_node:&#10;        x, y, z = node_dict[max_disp_node]&#10;        dof_x, dof_y, dof_z = get_dof(max_disp_node)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;        z_new = z + displacements[dof_z] * scale_factor&#10;        ax.scatter(x_new, y_new, z_new, c='red', s=100)&#10;&#10;    # Format scale factor&#10;    if scale_factor &gt;= 1000:&#10;        scale_factor_text = f&quot;{scale_factor/1000:.1f}k&quot;&#10;    elif scale_factor &gt;= 100:&#10;        scale_factor_text = f&quot;{int(scale_factor)}&quot;&#10;    else:&#10;        scale_factor_text = f&quot;{scale_factor:.1f}&quot;&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title(f'3D Pratt Truss Bridge - Displacement (Scale Factor: {scale_factor_text}x)')&#10;    ax.set_box_aspect([2, 0.5, 0.5])&#10;&#10;    # Add legend&#10;    gray_line = Line2D([0], [0], color='lightgray', linewidth=1, alpha=0.5, label='Original')&#10;    blue_line = Line2D([0], [0], color='blue', linewidth=1.5, label='Displaced')&#10;    ax.legend(handles=[gray_line, blue_line], loc='upper right')&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # Add PDF metadata&#10;    d = pdf.infodict()&#10;    d['Title'] = 'Pratt Bridge Structural Analysis'&#10;    d['Author'] = 'pyMAOS Truss Analysis Tool'&#10;    d['Subject'] = 'Structural analysis and reliability assessment'&#10;    d['Keywords'] = 'truss, structural analysis, bridge, reliability'&#10;    d['CreationDate'] = datetime.datetime.now()&#10;    d['ModDate'] = datetime.datetime.now()&#10;&#10;# Print summary of results to console&#10;print(&quot;\nMember Forces Summary:&quot;)&#10;print(&quot;----------------------&quot;)&#10;print(&quot;Member | Force (kips) | Type&quot;)&#10;print(&quot;----------------------&quot;)&#10;for member in sorted(members, key=lambda m: m['id']):&#10;    member_id = member['id']&#10;    force = member_forces[member_id]&#10;    if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;        force_type = &quot;ZERO&quot;&#10;    elif force &gt; 0:&#10;        force_type = &quot;TENSION&quot;&#10;    else:&#10;        force_type = &quot;COMPRESSION&quot;&#10;    print(f&quot;{member_id:6} | {abs(force):11.2f} | {force_type}&quot;)&#10;&#10;# Print numerical stability information&#10;print(&quot;\nNumerical Stability Info:&quot;)&#10;print(&quot;-----------------------&quot;)&#10;print(f&quot;Matrix size: {dof}{dof}&quot;)&#10;print(f&quot;Condition number: {cond:.2e}&quot;)&#10;print(f&quot;Number of members: {len(member_data)}&quot;)&#10;print(f&quot;Maximum force magnitude: {max(abs(f) for f in member_forces.values()):.2f} kips&quot;)&#10;print(f&quot;Maximum displacement: {max_vert_disp_in:.4f} inches&quot;)&#10;&#10;if cond &gt; 1e12:&#10;    print(&quot;\nWARNING: High condition number indicates numerical instability.&quot;)&#10;    print(&quot;\nRECOMMENDATIONS:&quot;)&#10;    if duplicate_nodes:&#10;        for node1, node2 in duplicate_nodes[:3]:  # Show first 3 duplicates&#10;            pos = node_dict[node1]&#10;            print(f&quot;1. The duplicate nodes {node1} and {node2} at ({pos[0]}, {pos[1]}, {pos[2]}) should be merged&quot;)&#10;        print(&quot;2. Update member connectivity to reference the merged nodes&quot;)&#10;    else:&#10;        print(&quot;1. Check for nearly-coincident nodes that might be causing instability&quot;)&#10;        print(&quot;2. Verify member connectivity for proper structural integrity&quot;)&#10;    print(&quot;3. Ensure all supports are properly defined&quot;)&#10;    print(&quot;4. Check for any disconnected parts of the structure&quot;)&#10;&#10;# Display the plot on screen&#10;plt.show()&#10;" />
              <option name="updatedContent" value="import sys&#10;import yaml&#10;import matplotlib.pyplot as plt&#10;from mpl_toolkits.mplot3d import Axes3D&#10;import numpy as np&#10;import os&#10;from matplotlib.backends.backend_pdf import PdfPages&#10;import datetime&#10;import matplotlib.gridspec as gridspec&#10;import matplotlib.cm as cm&#10;from scipy import linalg&#10;&#10;# Load the bridge definition&#10;bridge_file = 'Pratt_Bridge_3D.YAML'&#10;print(f&quot;Loading 3D bridge from {bridge_file}&quot;)&#10;with open(os.path.join(os.path.dirname(__file__), bridge_file), 'r') as file:&#10;    bridge = yaml.safe_load(file)&#10;&#10;# Extract design parameters if present&#10;design_params = bridge.get('design_parameters', {})&#10;min_safety_factor = design_params.get('min_safety_factor', 1.0)&#10;print(f&quot;\nDesign minimum safety factor: {min_safety_factor}&quot;)&#10;&#10;# Extract nodes and members&#10;nodes = bridge['nodes']&#10;members = bridge['members']&#10;supports = bridge['supports']&#10;&#10;# Create a dictionary for easier node lookup and a node_id to index mapping&#10;node_dict = {}&#10;node_to_index = {}  # Maps node_id to its position index (0-based)&#10;for i, node in enumerate(nodes):&#10;    node_id = node['id']&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;    z = float(str(node.get('z', '0 ft')).split()[0])  # Default to 0 if z not present&#10;    node_dict[node_id] = (x, y, z)&#10;    node_to_index[node_id] = i  # Store 0-based index for each node&#10;&#10;print(f&quot;Created node index mapping for {len(node_to_index)} nodes&quot;)&#10;print(f&quot;First few mappings: {list(node_to_index.items())[:5]}&quot;)&#10;print(f&quot;Highest node ID: {max(node_to_index.keys())}&quot;)&#10;&#10;# Check for duplicate nodes with higher precision&#10;print(&quot;\nChecking for duplicate nodes (high precision check)...&quot;)&#10;node_positions = {}&#10;duplicate_nodes = []&#10;duplicate_tolerance = 1e-6  # Tolerance for considering nodes as duplicates (in feet)&#10;&#10;for node_id, pos in node_dict.items():&#10;    # Round to handle potential floating point precision issues&#10;    pos_key = (round(pos[0]/duplicate_tolerance)*duplicate_tolerance,&#10;               round(pos[1]/duplicate_tolerance)*duplicate_tolerance,&#10;               round(pos[2]/duplicate_tolerance)*duplicate_tolerance)&#10;&#10;    if pos_key in node_positions:&#10;        other_node = node_positions[pos_key]&#10;        print(f&quot;WARNING: Nodes {other_node} and {node_id} are at the same position {pos}&quot;)&#10;        print(f&quot;  Node {other_node}: ({node_dict[other_node][0]}, {node_dict[other_node][1]}, {node_dict[other_node][2]})&quot;)&#10;        print(f&quot;  Node {node_id}: ({pos[0]}, {pos[1]}, {pos[2]})&quot;)&#10;        print(&quot;This will cause numerical instability!&quot;)&#10;        duplicate_nodes.append((other_node, node_id))&#10;    else:&#10;        node_positions[pos_key] = node_id&#10;&#10;# Report structural connectivity&#10;print(&quot;\nStructural connectivity check:&quot;)&#10;print(f&quot;Total nodes: {len(node_dict)}&quot;)&#10;print(f&quot;Unique positions: {len(node_positions)}&quot;)&#10;if duplicate_nodes:&#10;    print(f&quot;Found {len(duplicate_nodes)} duplicate node pairs:&quot;)&#10;    for node1, node2 in duplicate_nodes:&#10;        pos = node_dict[node1]&#10;        print(f&quot;  Nodes {node1} and {node2} at position ({pos[0]}, {pos[1]}, {pos[2]})&quot;)&#10;    print(&quot;Duplicate nodes should be merged for numerical stability&quot;)&#10;else:&#10;    print(&quot;No duplicate nodes found - good!&quot;)&#10;&#10;# Check for disconnected parts&#10;print(&quot;\nChecking for member connectivity...&quot;)&#10;node_connections = {node_id: set() for node_id in node_dict}&#10;for member in members:&#10;    if member['i_node'] in node_dict and member['j_node'] in node_dict:&#10;        node_connections[member['i_node']].add(member['j_node'])&#10;        node_connections[member['j_node']].add(member['i_node'])&#10;&#10;# Find isolated nodes&#10;isolated_nodes = [node_id for node_id, connections in node_connections.items() if len(connections) == 0]&#10;if isolated_nodes:&#10;    print(f&quot;WARNING: Found {len(isolated_nodes)} isolated nodes: {isolated_nodes}&quot;)&#10;&#10;# Check connectivity between the two spans&#10;# Nodes at x=100 ft should connect the left and right spans&#10;nodes_at_pier = [node_id for node_id, pos in node_dict.items() if abs(pos[0] - 100) &lt; 0.1]&#10;print(f&quot;\nNodes at center pier (x=100 ft): {sorted(nodes_at_pier)}&quot;)&#10;&#10;# Add function to calculate distances between node pairs&#10;def calculate_distance(point1, point2):&#10;    &quot;&quot;&quot;Calculate Euclidean distance between two 3D points&quot;&quot;&quot;&#10;    dx = point2[0] - point1[0]&#10;    dy = point2[1] - point1[1]&#10;    dz = point2[2] - point1[2]&#10;    return np.sqrt(dx**2 + dy**2 + dz**2)&#10;&#10;def print_all_node_distances(node_dict, output_file=None):&#10;    &quot;&quot;&quot;Calculate and print distances between all node pairs&quot;&quot;&quot;&#10;    # Generate all pairs of nodes&#10;    node_pairs = []&#10;    node_ids = sorted(node_dict.keys())&#10;    &#10;    print(&quot;\nCalculating distances between all node pairs...&quot;)&#10;    total_pairs = len(node_ids) * (len(node_ids) - 1) // 2&#10;    print(f&quot;Total {total_pairs} unique node pairs&quot;)&#10;    &#10;    for i, node1 in enumerate(node_ids):&#10;        for node2 in node_ids[i+1:]:  # Start from i+1 to avoid duplicates&#10;            point1 = node_dict[node1]&#10;            point2 = node_dict[node2]&#10;            distance = calculate_distance(point1, point2)&#10;            node_pairs.append((node1, node2, distance))&#10;    &#10;    # Sort by distance (ascending)&#10;    node_pairs.sort(key=lambda x: x[2])&#10;    &#10;    # Print results (show only first 20 pairs to avoid flooding console)&#10;    print(f&quot;\nNode pair distances (sorted by distance, showing first 20):&quot;)&#10;    print(f&quot;{'Node 1':&lt;6} {'Node 2':&lt;6} {'Distance (ft)':&lt;12}&quot;)&#10;    print(&quot;-&quot; * 30)&#10;    &#10;    for node1, node2, dist in node_pairs[:20]:&#10;        print(f&quot;{node1:&lt;6} {node2:&lt;6} {dist:&lt;12.3f}&quot;)&#10;    &#10;    # Save all results to file if requested&#10;    if output_file:&#10;        with open(output_file, 'w') as f:&#10;            f.write(f&quot;{'Node 1':&lt;6} {'Node 2':&lt;6} {'Distance (ft)':&lt;12}\n&quot;)&#10;            f.write(&quot;-&quot; * 30 + &quot;\n&quot;)&#10;            for node1, node2, dist in node_pairs:&#10;                f.write(f&quot;{node1:&lt;6} {node2:&lt;6} {dist:&lt;12.3f}\n&quot;)&#10;        print(f&quot;\nAll node distances saved to {output_file}&quot;)&#10;    &#10;    return node_pairs&#10;&#10;# Calculate and save distances between all node pairs&#10;timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M%S')&#10;node_distances_file = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_3D_Node_Distances_{timestamp}.txt&quot;)&#10;node_pairs = print_all_node_distances(node_dict, node_distances_file)&#10;&#10;# Check for members that should exist but don't&#10;print(&quot;\nVerifying critical connections:&quot;)&#10;critical_connections = [&#10;    (6, 12, &quot;Central vertical at x=100ft, front&quot;),&#10;    (106, 112, &quot;Central vertical at x=100ft, back&quot;),&#10;    (106, 12, &quot;Diagonal bracing at center pier&quot;)&#10;]&#10;&#10;for i_node, j_node, description in critical_connections:&#10;    found = any((m['i_node'] == i_node and m['j_node'] == j_node) or&#10;                (m['i_node'] == j_node and m['j_node'] == i_node)&#10;                for m in members)&#10;    if not found:&#10;        print(f&quot;  WARNING: Missing critical member {description} between nodes {i_node} and {j_node}&quot;)&#10;    else:&#10;        print(f&quot;  OK: Found {description}&quot;)&#10;&#10;# Define function to get DOF indices for a node (3D: 3 DOFs per node)&#10;def get_dof(node_id):&#10;    if node_id not in node_to_index:&#10;        raise ValueError(f&quot;Node ID {node_id} not found in node index mapping&quot;)&#10;    base = 3 * node_to_index[node_id]  # Use the node index, not the ID&#10;    return base, base + 1, base + 2  # x, y, z DOFs&#10;&#10;# Initialize global stiffness matrix and force vector&#10;num_nodes = len(nodes)&#10;dof = 3 * num_nodes  # Degrees of freedom (x, y, z for each node)&#10;K_global = np.zeros((dof, dof))&#10;F_global = np.zeros(dof)&#10;&#10;print(f&quot;\n3D Analysis: {num_nodes} nodes, {dof} DOFs&quot;)&#10;&#10;# Material properties (A36 steel)&#10;E = 29000.0  # ksi - Young's modulus&#10;&#10;# Define section properties - now load from YAML if available&#10;if 'sections' in bridge:&#10;    sections = {}&#10;    for section in bridge['sections']:&#10;        sec_id = section['id']&#10;        area_str = str(section['area']).split()[0]  # Extract numeric part&#10;        r_str = str(section['r']).split()[0]        # Extract numeric part&#10;        sections[sec_id] = {&#10;            &quot;area&quot;: float(area_str),&#10;            &quot;r&quot;: float(r_str)&#10;        }&#10;    print(&quot;\nLoaded section properties from YAML:&quot;)&#10;    for sec_id, props in sections.items():&#10;        print(f&quot;  Section {sec_id}: Area = {props['area']} in^2, r = {props['r']} in&quot;)&#10;else:&#10;    # Default section properties if not in YAML&#10;    sections = {&#10;        1: {&quot;area&quot;: 7.65, &quot;r&quot;: 4.32},  # W12x26 - area in in^2, r is radius of gyration in inches&#10;        2: {&quot;area&quot;: 9.13, &quot;r&quot;: 3.47}   # W8x31 - area in in^2, r is radius of gyration in inches&#10;    }&#10;    print(&quot;\nUsing default section properties&quot;)&#10;&#10;# Store member data for later reference&#10;member_data = {}&#10;&#10;# Calculate axial stiffness for each member&#10;print(&quot;\nAssembling 3D stiffness matrix...&quot;)&#10;for member in members:&#10;    member_id = member['id']&#10;    start = member['i_node']&#10;    end = member['j_node']&#10;&#10;    # Verify nodes exist in our mapping&#10;    if start not in node_to_index:&#10;        print(f&quot;ERROR: Member {member_id} references non-existent node {start}&quot;)&#10;        continue&#10;    if end not in node_to_index:&#10;        print(f&quot;ERROR: Member {member_id} references non-existent node {end}&quot;)&#10;        continue&#10;&#10;    section_id = member['section']&#10;&#10;    # Get section properties&#10;    section_area = sections[section_id][&quot;area&quot;]  # in&#10;&#10;    # Calculate EA in kip-in (E in ksi, A in in =&gt; EA in kip)&#10;    EA = E * section_area&#10;&#10;    # Get coordinates&#10;    x1, y1, z1 = node_dict[start]&#10;    x2, y2, z2 = node_dict[end]&#10;&#10;    # Calculate length in ft&#10;    dx = x2 - x1&#10;    dy = y2 - y1&#10;    dz = z2 - z1&#10;    length_ft = np.sqrt(dx**2 + dy**2 + dz**2)&#10;&#10;    # Check for zero-length members&#10;    if length_ft &lt; 1e-6:&#10;        print(f&quot;ERROR: Member {member_id} has zero length (nodes {start} to {end})&quot;)&#10;        print(f&quot;  Node {start}: ({x1}, {y1}, {z1})&quot;)&#10;        print(f&quot;  Node {end}: ({x2}, {y2}, {z2})&quot;)&#10;        continue  # Skip this member instead of exiting&#10;&#10;    length_in = length_ft * 12.0  # Convert to inches&#10;&#10;    # Calculate direction cosines for 3D&#10;    cx = dx / length_ft&#10;    cy = dy / length_ft&#10;    cz = dz / length_ft&#10;&#10;    # Store member properties&#10;    member_data[member_id] = {&#10;        &quot;start&quot;: start,&#10;        &quot;end&quot;: end,&#10;        &quot;length_ft&quot;: length_ft,&#10;        &quot;length_in&quot;: length_in,&#10;        &quot;EA&quot;: EA,&#10;        &quot;cx&quot;: cx,&#10;        &quot;cy&quot;: cy,&#10;        &quot;cz&quot;: cz,&#10;        &quot;section_id&quot;: section_id,&#10;        &quot;section_area&quot;: section_area&#10;    }&#10;&#10;    # Debug info for first few members&#10;    if member_id &lt;= 3:&#10;        print(f&quot;Member {member_id}: Length = {length_ft:.2f} ft ({length_in:.2f} in), EA = {EA:.2f} kip&quot;)&#10;        print(f&quot;  Direction cosines: cx = {cx:.4f}, cy = {cy:.4f}, cz = {cz:.4f}&quot;)&#10;&#10;    # Local to global transformation matrix for 3D truss element&#10;    # The transformation matrix is 6x6 for 3D (3 DOFs per node)&#10;    T = np.array([&#10;        [cx, cy, cz, 0,  0,  0],&#10;        [0,  0,  0, cx, cy, cz]&#10;    ])&#10;&#10;    # Element stiffness matrix in local coordinates (for a 3D truss element)&#10;    # k = EA/L in kip/in&#10;    k_axial = EA / length_in&#10;&#10;    k_local = k_axial * np.array([&#10;        [ 1, -1],&#10;        [-1,  1]&#10;    ])&#10;&#10;    # Transform to global coordinates: k_global = T^T * k_local * T&#10;    k_global = T.T @ k_local @ T&#10;&#10;    # Map local DOFs to global DOFs using node indices, not IDs&#10;    dof_start = get_dof(start)&#10;    dof_end = get_dof(end)&#10;    dof_indices = [*dof_start, *dof_end]&#10;&#10;    if member_id &lt;= 3:&#10;        print(f&quot;  DOF indices: {dof_indices}&quot;)&#10;&#10;    # Assemble into global stiffness matrix&#10;    for i in range(6):&#10;        for j in range(6):&#10;            K_global[dof_indices[i], dof_indices[j]] += k_global[i, j]&#10;&#10;# Apply external forces from member loads&#10;print(&quot;\nApplying loads...&quot;)&#10;if 'member_loads' in bridge:&#10;    for load in bridge['member_loads']:&#10;        member_id = load['member_uid']&#10;        if member_id not in member_data:&#10;            print(f&quot;WARNING: Load references non-existent member {member_id}&quot;)&#10;            continue&#10;&#10;        member = next(m for m in members if m['id'] == member_id)&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;&#10;        # Convert distributed load to equivalent nodal loads&#10;        wi = float(str(load['wi']).split()[0])  # kips/ft&#10;        wj = float(str(load['wj']).split()[0])  # kips/ft&#10;        length = member_data[member_id][&quot;length_ft&quot;]  # ft&#10;&#10;        # For uniform load, apply half to each node in y-direction&#10;        if abs(wi - wj) &lt; 1e-6:  # Uniform load&#10;            force = abs(wi) * length / 2  # kips (make positive)&#10;            _, dof_yi, _ = get_dof(i_node)&#10;            _, dof_yj, _ = get_dof(j_node)&#10;&#10;            # Debug info for first few loads&#10;            if member_id &lt;= 3:&#10;                print(f&quot;Load on member {member_id}: w = {wi} kips/ft, L = {length:.2f} ft&quot;)&#10;                print(f&quot;  Equivalent nodal forces: {force:.2f} kips (downward) at nodes {i_node} and {j_node}&quot;)&#10;&#10;            # Apply downward forces (negative in typical structural convention)&#10;            F_global[dof_yi] -= force  # Negative for downward&#10;            F_global[dof_yj] -= force  # Negative for downward&#10;        else:&#10;            # For non-uniform load (simplified approach)&#10;            force_i = abs(wi) * length / 3  # kips&#10;            force_j = abs(wj) * length / 3  # kips&#10;            _, dof_yi, _ = get_dof(i_node)&#10;            _, dof_yj, _ = get_dof(j_node)&#10;            F_global[dof_yi] -= force_i  # Negative for downward&#10;            F_global[dof_yj] -= force_j  # Negative for downward&#10;&#10;# Apply support constraints&#10;print(&quot;\nApplying support constraints:&quot;)&#10;constrained_dofs = []&#10;for support in supports:&#10;    node_id = support['node']&#10;&#10;    if node_id not in node_to_index:&#10;        print(f&quot;WARNING: Support references non-existent node {node_id}&quot;)&#10;        continue&#10;&#10;    dof_x, dof_y, dof_z = get_dof(node_id)&#10;&#10;    print(f&quot;Support at node {node_id}: ux={support['ux']}, uy={support['uy']}, uz={support.get('uz', 0)}&quot;)&#10;&#10;    if support['ux'] == 1:  # Fixed in x-direction&#10;        constrained_dofs.append(dof_x)&#10;        K_global[dof_x, :] = 0&#10;        K_global[:, dof_x] = 0&#10;        K_global[dof_x, dof_x] = 1&#10;        F_global[dof_x] = 0&#10;&#10;    if support['uy'] == 1:  # Fixed in y-direction&#10;        constrained_dofs.append(dof_y)&#10;        K_global[dof_y, :] = 0&#10;        K_global[:, dof_y] = 0&#10;        K_global[dof_y, dof_y] = 1&#10;        F_global[dof_y] = 0&#10;&#10;    if support.get('uz', 0) == 1:  # Fixed in z-direction&#10;        constrained_dofs.append(dof_z)&#10;        K_global[dof_z, :] = 0&#10;        K_global[:, dof_z] = 0&#10;        K_global[dof_z, dof_z] = 1&#10;        F_global[dof_z] = 0&#10;&#10;print(f&quot;Total constrained DOFs: {len(constrained_dofs)}&quot;)&#10;print(f&quot;Free DOFs: {dof - len(constrained_dofs)}&quot;)&#10;&#10;# Check for zero diagonal elements (indicates singularity)&#10;diag_zeros = np.where(np.abs(np.diag(K_global)) &lt; 1e-10)[0]&#10;if len(diag_zeros) &gt; 0:&#10;    print(f&quot;\nWARNING: Zero diagonal elements detected at DOFs: {diag_zeros}&quot;)&#10;    for dof_idx in diag_zeros:&#10;        # Find which node this DOF belongs to&#10;        node_idx = dof_idx // 3&#10;        # Find the node_id from the index&#10;        node_id = None&#10;        for nid, idx in node_to_index.items():&#10;            if idx == node_idx:&#10;                node_id = nid&#10;                break&#10;        dof_type = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;][dof_idx % 3]&#10;        print(f&quot;  DOF {dof_idx} (Node {node_id}, {dof_type}-direction)&quot;)&#10;&#10;# Check if the stiffness matrix is symmetric (it should be)&#10;is_symmetric = np.allclose(K_global, K_global.T, rtol=1e-5, atol=1e-8)&#10;print(f&quot;\nStiffness matrix is symmetric: {is_symmetric}&quot;)&#10;&#10;# Check for rows/columns that are all zeros (except diagonal)&#10;print(&quot;\nChecking for zero rows/columns in stiffness matrix...&quot;)&#10;zero_rows = []&#10;for i in range(dof):&#10;    row = K_global[i, :]&#10;    if np.sum(np.abs(row)) - np.abs(row[i]) &lt; 1e-10:  # Row has only diagonal element&#10;        zero_rows.append(i)&#10;        # Find which node this DOF belongs to&#10;        node_idx = i // 3&#10;        # Find the node_id from the index&#10;        node_id = None&#10;        for nid, idx in node_to_index.items():&#10;            if idx == node_idx:&#10;                node_id = nid&#10;                break&#10;        dof_type = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;][i % 3]&#10;        print(f&quot;  DOF {i} (Node {node_id}, {dof_type}-direction) has no off-diagonal connections&quot;)&#10;&#10;# Analyze the condition of the matrix&#10;try:&#10;    # Compute the condition number&#10;    cond = np.linalg.cond(K_global)&#10;    print(f&quot;Condition number of stiffness matrix: {cond:.2e}&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        print(&quot;\nWARNING: Very high condition number detected!&quot;)&#10;        print(&quot;The structure may have:&quot;)&#10;        print(&quot;1. Insufficient supports (mechanism)&quot;)&#10;        print(&quot;2. Disconnected parts&quot;)&#10;        print(&quot;3. Numerical scaling issues&quot;)&#10;        print(&quot;4. Duplicate nodes at the same location&quot;)&#10;&#10;        # Additional diagnostics&#10;        print(&quot;\nDiagnostic information:&quot;)&#10;        print(f&quot;- Number of duplicate node positions: {len(duplicate_nodes)}&quot;)&#10;        print(f&quot;- Number of isolated nodes: {len(isolated_nodes)}&quot;)&#10;        print(f&quot;- Number of zero rows/columns: {len(zero_rows)}&quot;)&#10;&#10;        # Check for specific problematic DOFs&#10;        if len(zero_rows) &gt; 0:&#10;            print(&quot;\nNodes with unconnected DOFs:&quot;)&#10;            problematic_nodes = set()&#10;            for dof_idx in zero_rows:&#10;                node_idx = dof_idx // 3&#10;                for nid, idx in node_to_index.items():&#10;                    if idx == node_idx:&#10;                        problematic_nodes.add(nid)&#10;                        break&#10;            print(f&quot;  Nodes with issues: {sorted(problematic_nodes)}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;Could not compute condition number: {e}&quot;)&#10;    cond = float('inf')&#10;&#10;# Apply scaling to improve conditioning&#10;print(&quot;\nAttempting to solve the system...&quot;)&#10;try:&#10;    # For very ill-conditioned systems, try regularization&#10;    if cond &gt; 1e14:&#10;        print(&quot;System is extremely ill-conditioned. Applying regularization...&quot;)&#10;        # Add small diagonal perturbation to improve conditioning&#10;        reg_factor = 1e-8 * np.max(np.abs(np.diag(K_global)))&#10;        K_regularized = K_global + reg_factor * np.eye(dof)&#10;&#10;        try:&#10;            displacements = linalg.solve(K_regularized, F_global, assume_a='sym')&#10;            print(&quot;Regularized solution successful&quot;)&#10;        except:&#10;            # Fall back to least squares&#10;            displacements, residuals, rank, s = linalg.lstsq(K_global, F_global)&#10;            print(f&quot;Least squares solution: rank={rank}/{dof}&quot;)&#10;    else:&#10;        # Try direct solution&#10;        displacements = linalg.solve(K_global, F_global, assume_a='sym')&#10;        print(&quot;Direct solution successful&quot;)&#10;&#10;    # Print first few displacement values for debugging&#10;    print(&quot;\nNodal displacements:&quot;)&#10;    print(&quot;Node | dx (in) | dy (in) | dz (in)&quot;)&#10;    print(&quot;-&quot; * 40)&#10;    for node_id in sorted(list(node_dict.keys()))[:10]:  # First 10 nodes&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        # Convert to inches for display&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        dz_in = displacements[dof_z] * 12&#10;        print(f&quot;{node_id:4} | {dx_in:7.4f} | {dy_in:7.4f} | {dz_in:7.4f}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;All solution methods failed: {e}&quot;)&#10;    print(&quot;Using zero displacements as fallback&quot;)&#10;    displacements = np.zeros(dof)&#10;&#10;# Find maximum vertical displacement&#10;max_vert_disp = 0&#10;max_disp_node = None&#10;for node_id in node_dict:&#10;    _, dof_y, _ = get_dof(node_id)&#10;    # Skip nodes that are supported&#10;    is_supported = any(s['node'] == node_id and s['uy'] == 1 for s in supports)&#10;    if not is_supported:&#10;        disp = abs(displacements[dof_y])&#10;        if disp &gt; max_vert_disp:&#10;            max_vert_disp = disp&#10;            max_disp_node = node_id&#10;&#10;# Convert to inches for display&#10;max_vert_disp_in = max_vert_disp * 12&#10;print(f&quot;\nMaximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}&quot;)&#10;&#10;# Calculate member forces&#10;member_forces = {}&#10;member_stresses = {}&#10;&#10;# Material properties (A36 steel)&#10;Fy = 36.0    # ksi - Yield strength&#10;Fu = 58.0    # ksi - Ultimate strength&#10;safety_factor_tension = 1.67&#10;safety_factor_compression = 1.67&#10;allowable_tension_stress = Fy / safety_factor_tension      # ksi&#10;allowable_compression_stress_max = Fy / safety_factor_compression  # ksi&#10;&#10;# Calculate forces and stresses for each member&#10;for member in members:&#10;    member_id = member['id']&#10;    if member_id not in member_data:&#10;        continue  # Skip members with zero length or missing data&#10;&#10;    mem_data = member_data[member_id]&#10;    start = mem_data[&quot;start&quot;]&#10;    end = mem_data[&quot;end&quot;]&#10;    area = mem_data[&quot;section_area&quot;]  # in&#10;    cx = mem_data[&quot;cx&quot;]&#10;    cy = mem_data[&quot;cy&quot;]&#10;    cz = mem_data[&quot;cz&quot;]&#10;&#10;    # Get displacements at both nodes (in feet)&#10;    dof_x1, dof_y1, dof_z1 = get_dof(start)&#10;    dof_x2, dof_y2, dof_z2 = get_dof(end)&#10;&#10;    # Calculate relative displacement in the axial direction (in feet)&#10;    delta_u1 = displacements[dof_x1] * cx + displacements[dof_y1] * cy + displacements[dof_z1] * cz&#10;    delta_u2 = displacements[dof_x2] * cx + displacements[dof_y2] * cy + displacements[dof_z2] * cz&#10;    delta_axial = delta_u2 - delta_u1&#10;&#10;    # Convert to inches for force calculation&#10;    delta_axial_in = delta_axial * 12&#10;&#10;    # Calculate axial force (F = EA/L * delta)&#10;    EA = mem_data[&quot;EA&quot;]  # kip&#10;    force = (EA / mem_data[&quot;length_in&quot;]) * delta_axial_in  # kips&#10;    member_forces[member_id] = force&#10;&#10;    # Calculate axial stress&#10;    stress = force / area  # kips/in = ksi&#10;    member_stresses[member_id] = stress&#10;&#10;    # Debug output for selected members&#10;    if member_id &lt;= 3 or member_id == 32:&#10;        print(f&quot;\nMember {member_id} analysis:&quot;)&#10;        print(f&quot;  Length = {mem_data['length_ft']:.2f} ft&quot;)&#10;        print(f&quot;  Node {start}: dx = {displacements[dof_x1]*12:.4f} in, dy = {displacements[dof_y1]*12:.4f} in, dz = {displacements[dof_z1]*12:.4f} in&quot;)&#10;        print(f&quot;  Node {end}: dx = {displacements[dof_x2]*12:.4f} in, dy = {displacements[dof_y2]*12:.4f} in, dz = {displacements[dof_z2]*12:.4f} in&quot;)&#10;        print(f&quot;  Delta axial = {delta_axial_in:.4f} in&quot;)&#10;        print(f&quot;  Force = {force:.2f} kips&quot;)&#10;        print(f&quot;  Stress = {stress:.2f} ksi&quot;)&#10;&#10;# Calculate safety factors for all members&#10;member_safety_factors = {}&#10;member_status = {}&#10;&#10;# Define zero force threshold&#10;ZERO_FORCE_THRESHOLD = 0.1  # Consider forces below this threshold as &quot;zero&quot;&#10;&#10;# Replace the problematic part in the safety factors calculation&#10;for member_id, stress in member_stresses.items():&#10;    section_id = member_data[member_id][&quot;section_id&quot;]&#10;    section = sections[section_id]&#10;&#10;    if abs(stress) &lt; ZERO_FORCE_THRESHOLD / section[&quot;area&quot;]:&#10;        # Zero/near-zero stress&#10;        safety_factor = float('inf')&#10;        limit = allowable_tension_stress  # Arbitrary for zero-force members&#10;        status = &quot;OK&quot;&#10;    elif stress &gt;= 0:  # Tension&#10;        safety_factor = allowable_tension_stress / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_tension_stress&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;    else:  # Compression&#10;        # Calculate allowable compression stress based on slenderness&#10;        length_inches = member_data[member_id][&quot;length_in&quot;]&#10;        slenderness = length_inches / section[&quot;r&quot;]&#10;&#10;        if slenderness &gt; 100:  # For slender members&#10;            critical_stress = (np.pi**2 * E) / (slenderness**2)&#10;            allowable_compression = min(allowable_compression_stress_max, critical_stress/safety_factor_compression)&#10;        else:  # For stocky members&#10;            allowable_compression = allowable_compression_stress_max&#10;&#10;        safety_factor = allowable_compression / abs(stress) if abs(stress) &gt; 0 else float('inf')&#10;        limit = allowable_compression&#10;        status = &quot;OK&quot; if safety_factor &gt;= 1.0 else &quot;OVERSTRESSED&quot;&#10;&#10;    member_safety_factors[member_id] = safety_factor&#10;    member_status[member_id] = {&#10;        &quot;stress&quot;: stress,&#10;        &quot;allowable&quot;: limit,&#10;        &quot;safety_factor&quot;: safety_factor,&#10;        &quot;status&quot;: status&#10;    }&#10;&#10;# After calculating safety factors, add a summary of members below minimum&#10;members_below_min_sf = []&#10;zero_force_members = []&#10;for member_id, status_info in member_status.items():&#10;    if status_info[&quot;safety_factor&quot;] &lt; min_safety_factor and status_info[&quot;safety_factor&quot;] &lt; 100:&#10;        members_below_min_sf.append({&#10;            'id': member_id,&#10;            'sf': status_info[&quot;safety_factor&quot;],&#10;            'stress': status_info[&quot;stress&quot;],&#10;            'allowable': status_info[&quot;allowable&quot;]&#10;        })&#10;    if abs(member_forces[member_id]) &lt; ZERO_FORCE_THRESHOLD:&#10;        zero_force_members.append(member_id)&#10;&#10;if members_below_min_sf:&#10;    print(f&quot;\n{len(members_below_min_sf)} members have safety factor below {min_safety_factor}:&quot;)&#10;    for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:10]:  # Show worst 10&#10;        print(f&quot;  Member {mem['id']}: SF = {mem['sf']:.2f}, Stress = {abs(mem['stress']):.1f} ksi&quot;)&#10;&#10;if zero_force_members:&#10;    print(f&quot;\n{len(zero_force_members)} zero-force members detected:&quot;)&#10;    print(f&quot;  Members: {sorted(zero_force_members)[:20]}&quot;)  # Show first 20&#10;&#10;# Create figure for the PDF - add timestamp to filenames&#10;# timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M%S')  # Now defined earlier&#10;pdf_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_3D_Analysis_{timestamp}.pdf&quot;)&#10;text_filename = os.path.join(os.path.dirname(__file__), f&quot;Pratt_Bridge_3D_Analysis_{timestamp}.txt&quot;)&#10;&#10;# Open the text file for writing the report&#10;with open(text_filename, 'w') as txt_report:&#10;    # Write header information&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(&quot;PRATT BRIDGE STRUCTURAL ANALYSIS REPORT\n&quot;)&#10;    txt_report.write(&quot;===============================================\n&quot;)&#10;    txt_report.write(f&quot;Analysis Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}\n&quot;)&#10;    txt_report.write(f&quot;Input File: {bridge_file}\n&quot;)&#10;    txt_report.write(f&quot;Design Minimum Safety Factor: {min_safety_factor}\n\n&quot;)&#10;&#10;    # Write model statistics&#10;    txt_report.write(&quot;MODEL STATISTICS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Number of nodes: {num_nodes}\n&quot;)&#10;    txt_report.write(f&quot;Number of members: {len(members)}\n&quot;)&#10;    txt_report.write(f&quot;Number of supports: {len(supports)}\n&quot;)&#10;    txt_report.write(f&quot;Degrees of freedom: {dof}\n&quot;)&#10;    txt_report.write(f&quot;Constrained DOFs: {len(constrained_dofs)}\n&quot;)&#10;    txt_report.write(f&quot;Free DOFs: {dof - len(constrained_dofs)}\n\n&quot;)&#10;&#10;    # Write material properties&#10;    txt_report.write(&quot;MATERIAL PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Material: A36 Steel\n&quot;)&#10;    txt_report.write(f&quot;Young's modulus: {E} ksi\n&quot;)&#10;    txt_report.write(f&quot;Yield strength: {Fy} ksi\n&quot;)&#10;    txt_report.write(f&quot;Ultimate strength: {Fu} ksi\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (tension): {safety_factor_tension}\n&quot;)&#10;    txt_report.write(f&quot;Safety factor (compression): {safety_factor_compression}\n\n&quot;)&#10;&#10;    # Write section properties&#10;    txt_report.write(&quot;SECTION PROPERTIES\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    for sec_id, props in sections.items():&#10;        txt_report.write(f&quot;Section {sec_id}: Area = {props['area']} in, r = {props['r']} in\n&quot;)&#10;    txt_report.write(&quot;\n&quot;)&#10;&#10;    # Write analysis results summary&#10;    txt_report.write(&quot;ANALYSIS RESULTS SUMMARY\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(f&quot;Maximum vertical displacement: {max_vert_disp_in:.4f} inches at node {max_disp_node}\n&quot;)&#10;    txt_report.write(f&quot;Stiffness matrix condition number: {cond:.2e}\n&quot;)&#10;&#10;    # Calculate critical values&#10;    critical_sf = float('inf')&#10;    critical_member = None&#10;    overstressed_count = 0&#10;    for member_id, status_info in member_status.items():&#10;        sf = status_info[&quot;safety_factor&quot;]&#10;        if sf &lt; critical_sf and sf &lt; 100:&#10;            critical_sf = sf&#10;            critical_member = member_id&#10;        if status_info[&quot;status&quot;] == &quot;OVERSTRESSED&quot;:&#10;            overstressed_count += 1&#10;&#10;    txt_report.write(f&quot;Number of tension members: {sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of compression members: {sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Number of zero-force members: {sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}\n&quot;)&#10;    txt_report.write(f&quot;Overstressed members: {overstressed_count}\n&quot;)&#10;    txt_report.write(f&quot;Maximum member force: {max(abs(f) for f in member_forces.values()):.2f} kips\n&quot;)&#10;    txt_report.write(f&quot;Maximum member stress: {max(abs(s) for s in member_stresses.values()):.2f} ksi\n&quot;)&#10;    txt_report.write(f&quot;Minimum safety factor: {critical_sf:.2f} (Member #{critical_member})\n\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;\nNUMERICAL STABILITY WARNING:\n&quot;)&#10;        txt_report.write(&quot;--------------------------------\n&quot;)&#10;        txt_report.write(f&quot;Condition number ({cond:.2e}) indicates severe numerical instability.\n&quot;)&#10;        txt_report.write(&quot;\nPossible causes:\n&quot;)&#10;        if duplicate_nodes:&#10;            txt_report.write(f&quot;1. Found {len(duplicate_nodes)} duplicate node pairs:\n&quot;)&#10;            for node1, node2 in duplicate_nodes[:5]:  # Show first 5&#10;                txt_report.write(f&quot;   - Nodes {node1} and {node2} at position {node_dict[node1]}\n&quot;)&#10;        if isolated_nodes:&#10;            txt_report.write(f&quot;2. Found {len(isolated_nodes)} isolated nodes\n&quot;)&#10;        if zero_rows:&#10;            txt_report.write(f&quot;3. Found {len(zero_rows)} DOFs with no off-diagonal connections\n&quot;)&#10;        txt_report.write(&quot;\nRecommended fixes:\n&quot;)&#10;        txt_report.write(&quot;- Merge duplicate nodes into single nodes\n&quot;)&#10;        txt_report.write(&quot;- Ensure proper connectivity between structural parts\n&quot;)&#10;        txt_report.write(&quot;- Verify all supports are correctly defined\n&quot;)&#10;        txt_report.write(&quot;- Check member connectivity references\n\n&quot;)&#10;&#10;    # Write detailed member results&#10;    txt_report.write(&quot;DETAILED MEMBER RESULTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Member | Nodes (i-j) | Force (kips) | Stress (ksi) | Type | S.F. | Status\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 80 + &quot;\n&quot;)&#10;&#10;    for member in sorted(members, key=lambda m: m['id']):&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;        stress = member_stresses[member_id]&#10;        sf = member_safety_factors[member_id]&#10;        status = member_status[member_id][&quot;status&quot;]&#10;&#10;        # Fix the text report formatting to use only ASCII&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            force_type = &quot;ZERO&quot;&#10;            sf_text = &quot;inf&quot;&#10;        elif force &gt; 0:&#10;            force_type = &quot;TENSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;        else:&#10;            force_type = &quot;COMPRESSION&quot;&#10;            sf_text = f&quot;{sf:.2f}&quot;  # Removed the sf&lt;100 condition&#10;&#10;        txt_report.write(&#10;            f&quot;{member_id:6} | {i_node:2}-{j_node:&lt;2} | {abs(force):11.2f} | {abs(stress):10.2f} | {force_type:10} | {sf_text:&gt;5} | {status}\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;&#10;    # Write nodal displacements&#10;    txt_report.write(&quot;NODAL DISPLACEMENTS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Node | dx (inches) | dy (inches) | dz (inches)\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 40 + &quot;\n&quot;)&#10;&#10;    for node_id in sorted(node_dict.keys()):&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        dx_in = displacements[dof_x] * 12&#10;        dy_in = displacements[dof_y] * 12&#10;        dz_in = displacements[dof_z] * 12&#10;        txt_report.write(f&quot;{node_id:4} | {dx_in:11.4f} | {dy_in:11.4f} | {dz_in:11.4f}\n&quot;)&#10;&#10;    # Add a section for closest node pairs&#10;    txt_report.write(&quot;\n\nCLOSEST NODE PAIRS\n&quot;)&#10;    txt_report.write(&quot;------------------------\n&quot;)&#10;    txt_report.write(&quot;Node 1 | Node 2 | Distance (ft)\n&quot;)&#10;    txt_report.write(&quot;-&quot; * 40 + &quot;\n&quot;)&#10;    &#10;    # Print the 30 closest pairs (excluding zero distances which might be duplicates)&#10;    closest_pairs = [pair for pair in node_pairs if pair[2] &gt; 1e-6]&#10;    for node1, node2, dist in closest_pairs[:30]:&#10;        txt_report.write(f&quot;{node1:6} | {node2:6} | {dist:10.3f}\n&quot;)&#10;        &#10;    txt_report.write(f&quot;\nNote: Complete list of node distances available in {os.path.basename(node_distances_file)}\n\n&quot;)&#10;&#10;    txt_report.write(&quot;\n\n&quot;)&#10;    txt_report.write(&quot;RECOMMENDATIONS FOR STRUCTURE REFINEMENT\n&quot;)&#10;    txt_report.write(&quot;----------------------------------------\n&quot;)&#10;&#10;    if members_below_min_sf:&#10;        txt_report.write(f&quot;1. {len(members_below_min_sf)} members have safety factor below the design minimum of {min_safety_factor}:\n&quot;)&#10;        for mem in sorted(members_below_min_sf, key=lambda x: x['sf'])[:20]:  # Show worst 20&#10;            member = next(m for m in members if m['id'] == mem['id'])&#10;            txt_report.write(f&quot;   - Member {mem['id']} (nodes {member['i_node']}-{member['j_node']}): SF = {mem['sf']:.2f}\n&quot;)&#10;&#10;        # Calculate required section increase&#10;        worst_sf = min(mem['sf'] for mem in members_below_min_sf)&#10;        required_increase = min_safety_factor / worst_sf&#10;        txt_report.write(f&quot;\n   Worst member requires approximately {required_increase:.1f}x increase in capacity.\n&quot;)&#10;        txt_report.write(f&quot;   Consider using larger sections or reducing the loading.\n&quot;)&#10;    else:&#10;        txt_report.write(&quot;1. All members meet the minimum safety factor requirement.\n&quot;)&#10;        txt_report.write(&quot;   Consider optimizing the structure by reducing sections for members with high safety factors.\n&quot;)&#10;&#10;    if max_vert_disp_in &gt; 2.0:  # Assuming 2 inches as a reasonable deflection limit&#10;        txt_report.write(f&quot;2. Consider stiffening the structure to reduce the maximum deflection (currently {max_vert_disp_in:.4f} inches).\n&quot;)&#10;&#10;    if cond &gt; 1e12:&#10;        txt_report.write(&quot;3. Fix numerical stability issues by reviewing structure connectivity and supports.\n&quot;)&#10;&#10;    txt_report.write(&quot;\nReport generated by pyMAOS Truss Analysis Tool\n&quot;)&#10;&#10;print(f&quot;Text report saved to: {text_filename}&quot;)&#10;&#10;with PdfPages(pdf_filename) as pdf:&#10;    # 1. BRIDGE ANALYSIS SUMMARY page&#10;    fig = plt.figure(figsize=(8.5, 11))&#10;    plt.axis('off')&#10;&#10;    # Add overall bridge status text - avoid using unicode characters&#10;    if overstressed_count == 0:&#10;        status_text = &quot;BRIDGE IS STRUCTURALLY ADEQUATE&quot;&#10;        status_color = 'green'&#10;    else:&#10;        status_text = f&quot;WARNING: BRIDGE HAS {overstressed_count} OVERSTRESSED MEMBERS&quot;&#10;        status_color = 'red'&#10;&#10;    plt.figtext(0.5, 0.9, &quot;BRIDGE ANALYSIS SUMMARY&quot;, ha='center', fontsize=16, weight='bold')&#10;    plt.figtext(0.5, 0.85, status_text, ha='center', fontsize=14, weight='bold', color=status_color)&#10;&#10;    # Add displacement information&#10;    plt.figtext(0.5, 0.78, f&quot;Maximum Vertical Displacement: {max_vert_disp_in:.4f} inches at Node {max_disp_node}&quot;,&#10;                ha='center', fontsize=12)&#10;&#10;    # Add summary statistics&#10;    critical_text = f&quot;Most critical member: #{critical_member} (Safety Factor: {critical_sf:.2f})&quot;&#10;    plt.figtext(0.5, 0.73, critical_text, ha='center', fontsize=12)&#10;&#10;    # Add a summary table of key statistics&#10;    summary_data = [&#10;        [&quot;Total Members&quot;, f&quot;{len(members)}&quot;],&#10;        [&quot;Tension Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &gt; ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Compression Members&quot;, f&quot;{sum(1 for f in member_forces.values() if f &lt; -ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Zero-Force Members&quot;, f&quot;{sum(1 for f in member_forces.values() if abs(f) &lt;= ZERO_FORCE_THRESHOLD)}&quot;],&#10;        [&quot;Overstressed Members&quot;, f&quot;{overstressed_count}&quot;],&#10;        [&quot;Maximum Member Force&quot;, f&quot;{max(abs(f) for f in member_forces.values()):.2f} kips&quot;],&#10;        [&quot;Maximum Member Stress&quot;, f&quot;{max(abs(s) for s in member_stresses.values()):.2f} ksi&quot;],&#10;        [&quot;Minimum Safety Factor&quot;, f&quot;{critical_sf:.2f}&quot;],&#10;        [&quot;Maximum Displacement&quot;, f&quot;{max_vert_disp_in:.4f} inches&quot;],&#10;    ]&#10;&#10;    # Create a table in the middle of the page&#10;    ax = plt.subplot(111)&#10;    ax.axis('off')&#10;    tbl = plt.table(cellText=summary_data, colLabels=[&quot;Metric&quot;, &quot;Value&quot;],&#10;                    loc='center', cellLoc='left')&#10;    tbl.auto_set_font_size(False)&#10;    tbl.set_fontsize(10)&#10;    tbl.scale(1, 1.5)&#10;&#10;    # Add design criteria info&#10;    criteria = (&#10;        f&quot;Design Criteria:\n&quot;&#10;        f&quot;- Material: A36 Steel (Fy = 36 ksi)\n&quot;&#10;        f&quot;- Allowable tension stress: {allowable_tension_stress:.1f} ksi\n&quot;&#10;        f&quot;- Allowable compression stress: Based on member slenderness\n&quot;&#10;        f&quot;- Safety factor: {safety_factor_tension:.2f}&quot;&#10;    )&#10;    plt.figtext(0.5, 0.2, criteria, ha='center', fontsize=10,&#10;                bbox=dict(facecolor='#eeeeee', alpha=0.7, boxstyle='round,pad=0.5'))&#10;&#10;    # Add timestamp&#10;    plt.figtext(0.5, 0.1, f&quot;Analysis completed on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}&quot;,&#10;                ha='center', fontsize=8)&#10;&#10;    # Save the summary page to PDF&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 2. 3D Structure Visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Plot members with color based on safety factors&#10;    cmap = plt.colormaps['RdYlGn']  # Red-Yellow-Green colormap&#10;    norm = plt.Normalize(0.5, 2.0)&#10;&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        safety_factor = member_safety_factors[member_id]&#10;        safety_factor_capped = min(safety_factor, 5.0)  # Cap extremely high values&#10;&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        color = cmap(norm(safety_factor_capped))&#10;&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color=color, linewidth=2)&#10;&#10;    # Plot nodes&#10;    for node_id, (x, y, z) in node_dict.items():&#10;        ax.scatter(x, y, z, c='black', s=20)&#10;&#10;    # Plot supports with different markers&#10;    for support in supports:&#10;        node_id = support['node']&#10;        x, y, z = node_dict[node_id]&#10;        if support['ux'] == 1 and support['uy'] == 1 and support.get('uz', 0) == 1:&#10;            ax.scatter(x, y-5, z, c='red', s=100, marker='s')  # Fixed support&#10;        else:&#10;            ax.scatter(x, y-5, z, c='blue', s=100, marker='o')  # Roller support&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title('3D Pratt Truss Bridge - Safety Factor Visualization')&#10;&#10;    # Add colorbar&#10;    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)&#10;    sm.set_array([])&#10;    cbar = plt.colorbar(sm, ax=ax, label='Safety Factor', shrink=0.6)&#10;&#10;    # Set aspect ratio&#10;    ax.set_box_aspect([2, 0.5, 0.5])  # Adjust based on bridge proportions&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 3. Member Forces - 3D visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Plot members with color based on tension/compression&#10;    for member in members:&#10;        member_id = member['id']&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        force = member_forces[member_id]&#10;&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        # Color based on force type&#10;        if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;            color = 'black'&#10;            linewidth = 1&#10;        elif force &gt; 0:&#10;            color = 'red'  # Tension&#10;            linewidth = 2 + min(3, abs(force)/50)&#10;        else:&#10;            color = 'blue'  # Compression&#10;            linewidth = 2 + min(3, abs(force)/50)&#10;&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color=color, linewidth=linewidth)&#10;&#10;    # Add legend&#10;    from matplotlib.lines import Line2D&#10;    red_line = Line2D([0], [0], color='red', linewidth=3, label='Tension')&#10;    blue_line = Line2D([0], [0], color='blue', linewidth=3, label='Compression')&#10;    black_line = Line2D([0], [0], color='black', linewidth=1, label='Zero Force')&#10;    ax.legend(handles=[red_line, blue_line, black_line], loc='upper right')&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title('3D Pratt Truss Bridge - Member Forces')&#10;    ax.set_box_aspect([2, 0.5, 0.5])&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # 4. 3D Displacement visualization&#10;    fig = plt.figure(figsize=(11, 8.5))&#10;    ax = fig.add_subplot(111, projection='3d')&#10;&#10;    # Calculate max displacement for scaling&#10;    max_disp_magnitude = 0&#10;    for node_id in node_dict:&#10;        dof_x, dof_y, dof_z = get_dof(node_id)&#10;        disp_magnitude = np.sqrt(displacements[dof_x]**2 + displacements[dof_y]**2 + displacements[dof_z]**2)&#10;        max_disp_magnitude = max(max_disp_magnitude, disp_magnitude)&#10;&#10;    # Calculate scale factor&#10;    max_span = max(node_dict[n][0] for n in node_dict) - min(node_dict[n][0] for n in node_dict)&#10;    target_max_disp = max_span * 0.05&#10;&#10;    if max_disp_magnitude &gt; 1e-10:&#10;        scale_factor = target_max_disp / max_disp_magnitude&#10;        scale_magnitude = 10 ** int(np.log10(scale_factor))&#10;        scale_factor = round(scale_factor / scale_magnitude) * scale_magnitude&#10;    else:&#10;        scale_factor = 50.0&#10;&#10;    # Draw original structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;        ax.plot([x1, x2], [y1, y2], [z1, z2], color='lightgray', linewidth=1, alpha=0.5)&#10;&#10;    # Draw displaced structure&#10;    for member in members:&#10;        i_node = member['i_node']&#10;        j_node = member['j_node']&#10;        x1, y1, z1 = node_dict[i_node]&#10;        x2, y2, z2 = node_dict[j_node]&#10;&#10;        # Get displacements&#10;        dof_x1, dof_y1, dof_z1 = get_dof(i_node)&#10;        dof_x2, dof_y2, dof_z2 = get_dof(j_node)&#10;&#10;        # Apply scaled displacements&#10;        x1_new = x1 + displacements[dof_x1] * scale_factor&#10;        y1_new = y1 + displacements[dof_y1] * scale_factor&#10;        z1_new = z1 + displacements[dof_z1] * scale_factor&#10;        x2_new = x2 + displacements[dof_x2] * scale_factor&#10;        y2_new = y2 + displacements[dof_y2] * scale_factor&#10;        z2_new = z2 + displacements[dof_z2] * scale_factor&#10;&#10;        ax.plot([x1_new, x2_new], [y1_new, y2_new], [z1_new, z2_new], color='blue', linewidth=1.5)&#10;&#10;    # Highlight max displacement node&#10;    if max_disp_node:&#10;        x, y, z = node_dict[max_disp_node]&#10;        dof_x, dof_y, dof_z = get_dof(max_disp_node)&#10;        x_new = x + displacements[dof_x] * scale_factor&#10;        y_new = y + displacements[dof_y] * scale_factor&#10;        z_new = z + displacements[dof_z] * scale_factor&#10;        ax.scatter(x_new, y_new, z_new, c='red', s=100)&#10;&#10;    # Format scale factor&#10;    if scale_factor &gt;= 1000:&#10;        scale_factor_text = f&quot;{scale_factor/1000:.1f}k&quot;&#10;    elif scale_factor &gt;= 100:&#10;        scale_factor_text = f&quot;{int(scale_factor)}&quot;&#10;    else:&#10;        scale_factor_text = f&quot;{scale_factor:.1f}&quot;&#10;&#10;    ax.set_xlabel('X (ft)')&#10;    ax.set_ylabel('Y (ft)')&#10;    ax.set_zlabel('Z (ft)')&#10;    ax.set_title(f'3D Pratt Truss Bridge - Displacement (Scale Factor: {scale_factor_text}x)')&#10;    ax.set_box_aspect([2, 0.5, 0.5])&#10;&#10;    # Add legend&#10;    gray_line = Line2D([0], [0], color='lightgray', linewidth=1, alpha=0.5, label='Original')&#10;    blue_line = Line2D([0], [0], color='blue', linewidth=1.5, label='Displaced')&#10;    ax.legend(handles=[gray_line, blue_line], loc='upper right')&#10;&#10;    pdf.savefig(fig)&#10;    plt.close(fig)&#10;&#10;    # Add PDF metadata&#10;    d = pdf.infodict()&#10;    d['Title'] = 'Pratt Bridge Structural Analysis'&#10;    d['Author'] = 'pyMAOS Truss Analysis Tool'&#10;    d['Subject'] = 'Structural analysis and reliability assessment'&#10;    d['Keywords'] = 'truss, structural analysis, bridge, reliability'&#10;    d['CreationDate'] = datetime.datetime.now()&#10;    d['ModDate'] = datetime.datetime.now()&#10;&#10;# Print summary of results to console&#10;print(&quot;\nMember Forces Summary:&quot;)&#10;print(&quot;----------------------&quot;)&#10;print(&quot;Member | Force (kips) | Type&quot;)&#10;print(&quot;----------------------&quot;)&#10;for member in sorted(members, key=lambda m: m['id']):&#10;    member_id = member['id']&#10;    force = member_forces[member_id]&#10;    if abs(force) &lt; ZERO_FORCE_THRESHOLD:&#10;        force_type = &quot;ZERO&quot;&#10;    elif force &gt; 0:&#10;        force_type = &quot;TENSION&quot;&#10;    else:&#10;        force_type = &quot;COMPRESSION&quot;&#10;    print(f&quot;{member_id:6} | {abs(force):11.2f} | {force_type}&quot;)&#10;&#10;# Print numerical stability information&#10;print(&quot;\nNumerical Stability Info:&quot;)&#10;print(&quot;-----------------------&quot;)&#10;print(f&quot;Matrix size: {dof}{dof}&quot;)&#10;print(f&quot;Condition number: {cond:.2e}&quot;)&#10;print(f&quot;Number of members: {len(member_data)}&quot;)&#10;print(f&quot;Maximum force magnitude: {max(abs(f) for f in member_forces.values()):.2f} kips&quot;)&#10;print(f&quot;Maximum displacement: {max_vert_disp_in:.4f} inches&quot;)&#10;&#10;if cond &gt; 1e12:&#10;    print(&quot;\nWARNING: High condition number indicates numerical instability.&quot;)&#10;    print(&quot;\nRECOMMENDATIONS:&quot;)&#10;    if duplicate_nodes:&#10;        for node1, node2 in duplicate_nodes[:3]:  # Show first 3 duplicates&#10;            pos = node_dict[node1]&#10;            print(f&quot;1. The duplicate nodes {node1} and {node2} at ({pos[0]}, {pos[1]}, {pos[2]}) should be merged&quot;)&#10;        print(&quot;2. Update member connectivity to reference the merged nodes&quot;)&#10;    else:&#10;        print(&quot;1. Check for nearly-coincident nodes that might be causing instability&quot;)&#10;        print(&quot;2. Verify member connectivity for proper structural integrity&quot;)&#10;    print(&quot;3. Ensure all supports are properly defined&quot;)&#10;    print(&quot;4. Check for any disconnected parts of the structure&quot;)&#10;&#10;# Display the plot on screen&#10;plt.show()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truss_bridges/show_Pratt_bridge.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truss_bridges/show_Pratt_bridge.py" />
              <option name="originalContent" value="import yaml&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;&#10;# Load the bridge definition&#10;with open('Pratt_Bridge.YAML', 'r') as file:&#10;    bridge = yaml.safe_load(file)&#10;&#10;# Extract nodes and members&#10;nodes = bridge['nodes']&#10;members = bridge['members']&#10;supports = bridge['supports']&#10;&#10;# Create figure&#10;fig, ax = plt.subplots(figsize=(12, 6))&#10;&#10;# Plot members&#10;for member in members:&#10;    i_node = member['i_node']&#10;    j_node = member['j_node']&#10;&#10;    # Find the coordinates for both nodes&#10;    node_i = next(node for node in nodes if node['id'] == i_node)&#10;    node_j = next(node for node in nodes if node['id'] == j_node)&#10;&#10;    # Extract x and y coordinates (removing the 'ft' unit)&#10;    x = [float(str(node_i['x']).split()[0]), float(str(node_j['x']).split()[0])]&#10;    y = [float(str(node_i['y']).split()[0]), float(str(node_j['y']).split()[0])]&#10;&#10;    # Plot the member&#10;    ax.plot(x, y, 'b-', linewidth=2)&#10;&#10;# Plot nodes&#10;for node in nodes:&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;    ax.plot(x, y, 'ro', markersize=6)&#10;&#10;# Plot supports&#10;for support in supports:&#10;    node_id = support['node']&#10;    node = next(node for node in nodes if node['id'] == node_id)&#10;    x = float(str(node['x']).split()[0])&#10;    y = float(str(node['y']).split()[0])&#10;&#10;    # Different markers for different support types&#10;    if support['ux'] == 1 and support['uy'] == 1:&#10;        # Pinned support - triangle&#10;        ax.plot(x, y-1, 'ks', markersize=10)&#10;    elif support['ux'] == 0 and support['uy'] == 1:&#10;        # Roller support - circle&#10;        ax.plot(x, y-1, 'ko', markersize=10)&#10;&#10;# Set plot limits and labels&#10;ax.set_xlim(-5, 205)&#10;ax.set_ylim(-5, 25)&#10;ax.set_aspect('equal')&#10;ax.set_xlabel('Length (ft)')&#10;ax.set_ylabel('Height (ft)')&#10;ax.set_title('Pratt Bridge Structure')&#10;ax.grid(True)&#10;&#10;plt.show()" />
              <option name="updatedContent" value="import yaml&#13;&#10;import matplotlib.pyplot as plt&#13;&#10;import numpy as np&#13;&#10;import os&#13;&#10;&#13;&#10;# Load the bridge definition&#13;&#10;bridge_file = 'Pratt_Truss.YAML'&#13;&#10;print(f&quot;Loading bridge from {bridge_file}&quot;)&#13;&#10;with open(os.path.join(os.path.dirname(__file__), bridge_file), 'r') as file:&#13;&#10;    bridge = yaml.safe_load(file)&#13;&#10;&#13;&#10;# Extract nodes and members&#13;&#10;nodes = bridge['nodes']&#13;&#10;members = bridge['members']&#13;&#10;supports = bridge['supports']&#13;&#10;&#13;&#10;# Create a dictionary for easier node lookup&#13;&#10;node_dict = {}&#13;&#10;for node in nodes:&#13;&#10;    node_id = node['id']&#13;&#10;    x = float(str(node['x']).split()[0])&#13;&#10;    y = float(str(node['y']).split()[0])&#13;&#10;    z = float(str(node.get('z', '0 ft')).split()[0])  # Default to 0 if z not present&#13;&#10;    node_dict[node_id] = (x, y, z)&#13;&#10;&#13;&#10;# Define function to get DOF indices for a node&#13;&#10;def get_dof(node_id):&#13;&#10;    return 2 * (node_id - 1), 2 * (node_id - 1) + 1&#13;&#10;&#13;&#10;# Initialize global stiffness matrix and force vector&#13;&#10;num_nodes = len(nodes)&#13;&#10;dof = 2 * num_nodes  # Degrees of freedom (x and y for each node)&#13;&#10;K_global = np.zeros((dof, dof))&#13;&#10;F_global = np.zeros(dof)&#13;&#10;&#13;&#10;# Calculate axial stiffness for each member (assuming EA=1 for simplicity)&#13;&#10;EA = 29000 * 7.65  # ksi * in = kip&#13;&#10;&#13;&#10;# Assemble global stiffness matrix&#13;&#10;for member in members:&#13;&#10;    start = member['i_node']&#13;&#10;    end = member['j_node']&#13;&#10;    x1, y1, _ = node_dict[start]&#13;&#10;    x2, y2, _ = node_dict[end]&#13;&#10;    length = ((x2 - x1)**2 + (y2 - y1)**2)**0.5&#13;&#10;    cos = (x2 - x1) / length&#13;&#10;    sin = (y2 - y1) / length&#13;&#10;&#13;&#10;    # Local stiffness matrix for the member&#13;&#10;    k_local = (EA / length) * np.array([&#13;&#10;        [cos**2, cos*sin, -cos**2, -cos*sin],&#13;&#10;        [cos*sin, sin**2, -cos*sin, -sin**2],&#13;&#10;        [-cos**2, -cos*sin, cos**2, cos*sin],&#13;&#10;        [-cos*sin, -sin**2, cos*sin, sin**2]&#13;&#10;    ])&#13;&#10;&#13;&#10;    # Map local stiffness to global stiffness&#13;&#10;    dof_start = get_dof(start)&#13;&#10;    dof_end = get_dof(end)&#13;&#10;    dof_indices = [*dof_start, *dof_end]&#13;&#10;    for i in range(4):&#13;&#10;        for j in range(4):&#13;&#10;            K_global[dof_indices[i], dof_indices[j]] += k_local[i, j]&#13;&#10;&#13;&#10;# Apply external forces - add loads from member_loads&#13;&#10;F_global = np.zeros(dof)&#13;&#10;if 'member_loads' in bridge:&#13;&#10;    for load in bridge['member_loads']:&#13;&#10;        member_id = load['member_uid']&#13;&#10;        member = next(m for m in members if m['id'] == member_id)&#13;&#10;        i_node = member['i_node']&#13;&#10;        j_node = member['j_node']&#13;&#10;        &#13;&#10;        # Convert distributed load to equivalent nodal loads&#13;&#10;        # Assuming vertical loads only for simplicity&#13;&#10;        wi = float(str(load['wi']).split()[0])&#13;&#10;        wj = float(str(load['wj']).split()[0])&#13;&#10;        length = np.linalg.norm(np.array(node_dict[j_node][:2]) - np.array(node_dict[i_node][:2]))&#13;&#10;        &#13;&#10;        # For uniform load, apply half to each node&#13;&#10;        if abs(wi - wj) &lt; 1e-6:  # Uniform load&#13;&#10;            force = wi * length / 2&#13;&#10;            _, dof_yi = get_dof(i_node)&#13;&#10;            _, dof_yj = get_dof(j_node)&#13;&#10;            F_global[dof_yi] -= force&#13;&#10;            F_global[dof_yj] -= force&#13;&#10;        else:&#13;&#10;            # For non-uniform load (simplified)&#13;&#10;            force_i = wi * length / 3&#13;&#10;            force_j = wj * length / 3&#13;&#10;            _, dof_yi = get_dof(i_node)&#13;&#10;            _, dof_yj = get_dof(j_node)&#13;&#10;            F_global[dof_yi] -= force_i&#13;&#10;            F_global[dof_yj] -= force_j&#13;&#10;&#13;&#10;# Apply support constraints&#13;&#10;for support in supports:&#13;&#10;    node_id = support['node']&#13;&#10;    dof_x, dof_y = get_dof(node_id)&#13;&#10;    &#13;&#10;    if support['ux'] == 1:  # Fixed in x-direction&#13;&#10;        K_global[dof_x, :] = 0&#13;&#10;        K_global[:, dof_x] = 0&#13;&#10;        K_global[dof_x, dof_x] = 1&#13;&#10;        F_global[dof_x] = 0&#13;&#10;        &#13;&#10;    if support['uy'] == 1:  # Fixed in y-direction&#13;&#10;        K_global[dof_y, :] = 0&#13;&#10;        K_global[:, dof_y] = 0&#13;&#10;        K_global[dof_y, dof_y] = 1&#13;&#10;        F_global[dof_y] = 0&#13;&#10;&#13;&#10;# Solve for displacements&#13;&#10;try:&#13;&#10;    displacements = np.linalg.solve(K_global, F_global)&#13;&#10;    print(f&quot;Solved for {len(displacements)//2} node displacements&quot;)&#13;&#10;except np.linalg.LinAlgError:&#13;&#10;    print(&quot;Error: Stiffness matrix is singular. Check support conditions.&quot;)&#13;&#10;    displacements = np.zeros(dof)&#13;&#10;&#13;&#10;# Calculate member forces&#13;&#10;member_forces = {}&#13;&#10;for member in members:&#13;&#10;    member_id = member['id']&#13;&#10;    start = member['i_node']&#13;&#10;    end = member['j_node']&#13;&#10;    x1, y1, _ = node_dict[start]&#13;&#10;    x2, y2, _ = node_dict[end]&#13;&#10;    length = ((x2 - x1)**2 + (y2 - y1)**2)**0.5&#13;&#10;    cos = (x2 - x1) / length&#13;&#10;    sin = (y2 - y1) / length&#13;&#10;&#13;&#10;    dof_start = get_dof(start)&#13;&#10;    dof_end = get_dof(end)&#13;&#10;    dof_indices = [*dof_start, *dof_end]&#13;&#10;&#13;&#10;    # Extract displacements for the member&#13;&#10;    u = displacements[dof_indices]&#13;&#10;&#13;&#10;    # Calculate axial force in the member&#13;&#10;    # Positive force = tension, Negative force = compression&#13;&#10;    force = (EA / length) * np.dot(np.array([-cos, -sin, cos, sin]), u)&#13;&#10;    member_forces[member_id] = force&#13;&#10;&#13;&#10;# Create figure&#13;&#10;fig, ax = plt.subplots(figsize=(14, 7))&#13;&#10;&#13;&#10;# Plot members with color based on tension/compression&#13;&#10;for member in members:&#13;&#10;    member_id = member['id']&#13;&#10;    i_node = member['i_node']&#13;&#10;    j_node = member['j_node']&#13;&#10;    force = member_forces[member_id]&#13;&#10;&#13;&#10;    # Find the coordinates for both nodes&#13;&#10;    x1, y1, _ = node_dict[i_node]&#13;&#10;    x2, y2, _ = node_dict[j_node]&#13;&#10;    x = [x1, x2]&#13;&#10;    y = [y1, y2]&#13;&#10;&#13;&#10;    # Color: red for tension, blue for compression&#13;&#10;    if force &gt; 0:&#13;&#10;        color = 'red'  # Tension&#13;&#10;        linestyle = '-'&#13;&#10;        linewidth = 2 + min(5, abs(force)/20)  # Scale width with force magnitude&#13;&#10;    else:&#13;&#10;        color = 'blue'  # Compression&#13;&#10;        linestyle = '-'&#13;&#10;        linewidth = 2 + min(5, abs(force)/20)  # Scale width with force magnitude&#13;&#10;&#13;&#10;    # Plot the member&#13;&#10;    ax.plot(x, y, color=color, linestyle=linestyle, linewidth=linewidth)&#13;&#10;    &#13;&#10;    # Add force label at midpoint&#13;&#10;    mid_x = (x1 + x2) / 2&#13;&#10;    mid_y = (y1 + y2) / 2&#13;&#10;    ax.text(mid_x, mid_y, f&quot;{abs(force):.1f}&quot;, &#13;&#10;            fontsize=8, ha='center', va='center', &#13;&#10;            bbox=dict(facecolor='white', alpha=0.7, pad=1))&#13;&#10;&#13;&#10;# Plot nodes&#13;&#10;for node_id, (x, y, _) in node_dict.items():&#13;&#10;    ax.plot(x, y, 'ko', markersize=6)&#13;&#10;    ax.text(x+0.5, y+0.5, f&quot;{node_id}&quot;, fontsize=9)&#13;&#10;&#13;&#10;# Plot supports&#13;&#10;for support in supports:&#13;&#10;    node_id = support['node']&#13;&#10;    x, y, _ = node_dict[node_id]&#13;&#10;&#13;&#10;    # Different markers for different support types&#13;&#10;    if support['ux'] == 1 and support['uy'] == 1:&#13;&#10;        # Pinned support - triangle&#13;&#10;        ax.plot(x, y-1, 'ks', markersize=10)&#13;&#10;    elif support['ux'] == 0 and support['uy'] == 1:&#13;&#10;        # Roller support - circle&#13;&#10;        ax.plot(x, y-1, 'ko', markersize=10)&#13;&#10;&#13;&#10;# Add legend&#13;&#10;red_line = plt.Line2D([0], [0], color='red', linewidth=3, label='Tension')&#13;&#10;blue_line = plt.Line2D([0], [0], color='blue', linewidth=3, label='Compression')&#13;&#10;ax.legend(handles=[red_line, blue_line], loc='upper right')&#13;&#10;&#13;&#10;# Set plot limits and labels&#13;&#10;max_x = max(node_dict[n][0] for n in node_dict)&#13;&#10;max_y = max(node_dict[n][1] for n in node_dict)&#13;&#10;ax.set_xlim(-5, max_x + 5)&#13;&#10;ax.set_ylim(-5, max_y + 5)&#13;&#10;ax.set_aspect('equal')&#13;&#10;ax.set_xlabel('Length (ft)')&#13;&#10;ax.set_ylabel('Height (ft)')&#13;&#10;ax.set_title('Pratt Truss Bridge Analysis - Red=Tension, Blue=Compression')&#13;&#10;ax.grid(True)&#13;&#10;&#13;&#10;# Print summary of results&#13;&#10;print(&quot;\nMember Forces Summary:&quot;)&#13;&#10;print(&quot;----------------------&quot;)&#13;&#10;print(&quot;Member | Force (kips) | Type&quot;)&#13;&#10;print(&quot;----------------------&quot;)&#13;&#10;for member in sorted(members, key=lambda m: m['id']):&#13;&#10;    member_id = member['id']&#13;&#10;    force = member_forces[member_id]&#13;&#10;    force_type = &quot;TENSION&quot; if force &gt; 0 else &quot;COMPRESSION&quot;&#13;&#10;    print(f&quot;{member_id:6} | {abs(force):11.2f} | {force_type}&quot;)&#13;&#10;&#13;&#10;plt.tight_layout()&#13;&#10;plt.show()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/units/convert_units.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/units/convert_units.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Convert JSON structural model from any unit system to SI units.&#10;&quot;&quot;&quot;&#10;import os&#10;import json&#10;import re&#10;import sys&#10;import argparse&#10;import pint&#10;&#10;# Initialize unit registry&#10;from pyMAOS import unit_manager&#10;&#10;Q_ = unit_manager.ureg.Quantity&#10;&#10;# Define dimension mappings - what fields have what physical dimensions&#10;DIMENSION_REGISTRY = {&#10;    &quot;nodes&quot;: {&#10;        &quot;x&quot;: &quot;length&quot;,&#10;        &quot;y&quot;: &quot;length&quot;,&#10;        &quot;z&quot;: &quot;length&quot;&#10;    },&#10;    &quot;materials&quot;: {&#10;        &quot;E&quot;: &quot;pressure&quot;,&#10;        &quot;G&quot;: &quot;pressure&quot;,&#10;        &quot;rho&quot;: &quot;density&quot;,&#10;        &quot;alpha&quot;: &quot;thermal_expansion&quot;&#10;    },&#10;    &quot;sections&quot;: {&#10;        &quot;area&quot;: &quot;area&quot;,&#10;        &quot;r&quot;: &quot;length&quot;,&#10;        &quot;ixx&quot;: &quot;moment_of_inertia&quot;&#10;    },&#10;    &quot;joint_loads&quot;: {&#10;        &quot;fx&quot;: &quot;force&quot;,&#10;        &quot;fy&quot;: &quot;force&quot;,&#10;        &quot;fz&quot;: &quot;force&quot;,&#10;        &quot;mx&quot;: &quot;moment&quot;,&#10;        &quot;my&quot;: &quot;moment&quot;,&#10;        &quot;mz&quot;: &quot;moment&quot;&#10;    },&#10;    &quot;member_loads&quot;: {&#10;        &quot;wi&quot;: &quot;distributed_load&quot;,&#10;        &quot;wj&quot;: &quot;distributed_load&quot;,&#10;        &quot;a&quot;: &quot;length&quot;,&#10;        &quot;b&quot;: &quot;length&quot;&#10;    }&#10;}&#10;&#10;# Define SI unit for each dimension&#10;SI_UNITS = {&#10;    &quot;length&quot;: &quot;m&quot;,&#10;    &quot;area&quot;: &quot;m^2&quot;,&#10;    &quot;moment_of_inertia&quot;: &quot;m^4&quot;,&#10;    &quot;force&quot;: &quot;N&quot;,&#10;    &quot;pressure&quot;: &quot;Pa&quot;,&#10;    &quot;moment&quot;: &quot;N*m&quot;,&#10;    &quot;distributed_load&quot;: &quot;N/m&quot;,&#10;    &quot;angle&quot;: &quot;rad&quot;,&#10;    &quot;rotation&quot;: &quot;rad&quot;,&#10;    &quot;density&quot;: &quot;kg/m^3&quot;,&#10;    &quot;thermal_expansion&quot;: &quot;1/K&quot;&#10;}&#10;&#10;def parse_value_with_units(value_string):&#10;    &quot;&quot;&quot;Parse a string that may contain a value with units.&quot;&quot;&quot;&#10;    if not isinstance(value_string, str):&#10;        return value_string&#10;&#10;    # Match pattern: [numeric value][units]&#10;    match = re.match(r'([-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?)(.*)', value_string.strip())&#10;&#10;    if match:&#10;        value_str, unit_str = match.groups()&#10;        value = float(value_str)&#10;&#10;        if unit_str and unit_str.strip():&#10;            try:&#10;                # Create quantity with units&#10;                return Q_(value, unit_str)&#10;            except:&#10;                print(f&quot;Warning: Could not parse unit '{unit_str}', treating as dimensionless&quot;)&#10;                return value&#10;        return value&#10;&#10;    # If no match, try to evaluate as a simple numeric expression&#10;    try:&#10;        return float(eval(value_string))&#10;    except:&#10;        raise ValueError(f&quot;Could not parse value: {value_string}&quot;)&#10;&#10;def format_value_with_units(value, unit):&#10;    &quot;&quot;&quot;Format a numeric value with its unit as a string.&quot;&quot;&quot;&#10;    # Handle special formatting for different types of values&#10;    if isinstance(value, float):&#10;        # Use appropriate precision based on magnitude&#10;        if abs(value) &lt; 0.001:&#10;            formatted = f&quot;{value:.6e}&quot;&#10;        elif abs(value) &lt; 1:&#10;            formatted = f&quot;{value:.6f}&quot;&#10;        elif abs(value) &lt; 1000:&#10;            formatted = f&quot;{value:.4f}&quot;&#10;        else:&#10;            formatted = f&quot;{value:.2f}&quot;&#10;&#10;        # Remove trailing zeros and decimal point if no fractional part&#10;        formatted = formatted.rstrip('0').rstrip('.') if '.' in formatted else formatted&#10;&#10;    else:&#10;        formatted = str(value)&#10;&#10;    # Combine value with unit&#10;    return f&quot;{formatted} {unit}&quot;.strip()&#10;&#10;def convert_to_si(value, dimension, unit_system, default_units):&#10;    &quot;&quot;&quot;Convert a value to SI units based on its dimension and return as string with unit.&quot;&quot;&quot;&#10;    si_unit = SI_UNITS.get(dimension, &quot;&quot;)&#10;&#10;    if isinstance(value, pint.Quantity):&#10;        # Value already has explicit units&#10;        if si_unit:&#10;            si_value = value.to(si_unit).magnitude&#10;            return format_value_with_units(si_value, si_unit)&#10;    elif isinstance(value, (int, float)) and dimension in default_units:&#10;        # Value has implicit units based on default_units&#10;        implicit_unit = default_units[dimension]&#10;        quantity = Q_(value, implicit_unit)&#10;        if si_unit:&#10;            si_value = quantity.to(si_unit).magnitude&#10;            return format_value_with_units(si_value, si_unit)&#10;    elif isinstance(value, str):&#10;        # Try parsing the string as a value with units&#10;        parsed = parse_value_with_units(value)&#10;        if isinstance(parsed, pint.Quantity) and si_unit:&#10;            si_value = parsed.to(si_unit).magnitude&#10;            return format_value_with_units(si_value, si_unit)&#10;&#10;    # No conversion needed or possible - return original value&#10;    return value&#10;&#10;def convert_json_to_si(json_data, output_file=None):&#10;    &quot;&quot;&quot;Convert all values in a JSON structure to SI units with string representation.&quot;&quot;&quot;&#10;    # Extract unit system and default units&#10;    unit_system = json_data.get(&quot;unit_system&quot;, &quot;SI&quot;).lower()&#10;    default_units = json_data.get(&quot;units&quot;, {})&#10;&#10;    # Set up output data structure&#10;    si_data = json_data.copy()&#10;&#10;    # Replace unit system&#10;    si_data[&quot;unit_system&quot;] = &quot;SI&quot;&#10;&#10;    # Update units section to SI&#10;    si_data[&quot;units&quot;] = {&#10;        &quot;length&quot;: &quot;m&quot;,&#10;        &quot;pressure&quot;: &quot;Pa&quot;,&#10;        &quot;force&quot;: &quot;N&quot;,&#10;        &quot;area&quot;: &quot;m^2&quot;,&#10;        &quot;moment_of_inertia&quot;: &quot;m^4&quot;,&#10;        &quot;distributed_load&quot;: &quot;N/m&quot;,&#10;        &quot;angle&quot;: &quot;rad&quot;,&#10;        &quot;density&quot;: &quot;kg/m^3&quot;&#10;    }&#10;&#10;    # Process each section with physical dimensions&#10;    for section_name, field_dimensions in DIMENSION_REGISTRY.items():&#10;        if section_name in json_data:&#10;            section_data = json_data[section_name]&#10;&#10;            # Handle array sections&#10;            if isinstance(section_data, list):&#10;                for i, item in enumerate(section_data):&#10;                    for field, dimension in field_dimensions.items():&#10;                        if field in item:&#10;                            original_value = item[field]&#10;                            print(f&quot;Converting {section_name}[{i}].{field} from {original_value} to SI units&quot;)&#10;&#10;                            # Convert and format the value with SI units&#10;                            si_data[section_name][i][field] = convert_to_si(&#10;                                original_value, dimension, unit_system, default_units)&#10;&#10;                            print(f&quot;Converted {section_name}[{i}].{field} to SI: {si_data[section_name][i][field]}&quot;)&#10;&#10;    # Write to output file or print to stdout&#10;    if output_file:&#10;        with open(output_file, 'w') as f:&#10;            json.dump(si_data, f, indent=2)&#10;        print(f&quot;Converted data written to {output_file}&quot;)&#10;    else:&#10;        print(json.dumps(si_data, indent=2))&#10;&#10;    return si_data&#10;&#10;def convert_si_to_display_units(si_data, output_file=None, display_units=None):&#10;    &quot;&quot;&quot;&#10;    Convert structural analysis results from SI units to display units with string representation&#10;&#10;    Parameters&#10;    ----------&#10;    si_data : dict or str&#10;        JSON data structure or path to JSON file with SI units&#10;    output_file : str, optional&#10;        Path to output file (defaults to None, which returns converted data)&#10;    display_units : dict, optional&#10;        Dictionary mapping dimensions to display units (defaults to using&#10;        current display units from pyMAOS.units_mod)&#10;&#10;    Returns&#10;    -------&#10;    dict&#10;        Data structure with values converted to display units as strings&#10;    &quot;&quot;&quot;&#10;    import json&#10;    from copy import deepcopy&#10;&#10;    # Handle case where si_data is a file path&#10;    if isinstance(si_data, str):&#10;        with open(si_data, 'r') as f:&#10;            si_data = json.load(f)&#10;&#10;    # Get display units if not provided&#10;    if display_units is None:&#10;        try:&#10;            from pyMAOS.units_mod import DISPLAY_UNITS&#10;            display_units = DISPLAY_UNITS&#10;        except ImportError:&#10;            # Fallback to some standard display units&#10;            display_units = {&#10;                &quot;force&quot;: &quot;lbf&quot;,&#10;                &quot;length&quot;: &quot;ft&quot;,&#10;                &quot;moment&quot;: &quot;lbf*ft&quot;,&#10;                &quot;pressure&quot;: &quot;psi&quot;,&#10;                &quot;area&quot;: &quot;in^2&quot;,&#10;                &quot;moment_of_inertia&quot;: &quot;in^4&quot;,&#10;                &quot;distributed_load&quot;: &quot;lbf/ft&quot;,&#10;                &quot;rotation&quot;: &quot;rad&quot;,&#10;                &quot;density&quot;: &quot;lb/ft^3&quot;,&#10;                &quot;thermal_expansion&quot;: &quot;1/F&quot;&#10;            }&#10;&#10;    # Define SI units for each dimension&#10;    si_units = {&#10;        &quot;force&quot;: &quot;N&quot;,&#10;        &quot;length&quot;: &quot;m&quot;,&#10;        &quot;moment&quot;: &quot;N*m&quot;,&#10;        &quot;pressure&quot;: &quot;Pa&quot;,&#10;        &quot;area&quot;: &quot;m^2&quot;,&#10;        &quot;moment_of_inertia&quot;: &quot;m^4&quot;,&#10;        &quot;distributed_load&quot;: &quot;N/m&quot;,&#10;        &quot;rotation&quot;: &quot;rad&quot;,&#10;        &quot;density&quot;: &quot;kg/m^3&quot;,&#10;        &quot;thermal_expansion&quot;: &quot;1/K&quot;&#10;    }&#10;&#10;    # Create a copy of the data to modify&#10;    display_data = deepcopy(si_data)&#10;&#10;    # Update the units section&#10;    if &quot;units&quot; in display_data:&#10;        display_data[&quot;units&quot;] = display_units&#10;&#10;    # Convert a single value using pint and return as string with units&#10;    def convert_value_with_format(value, from_unit, to_unit):&#10;        try:&#10;            # Handle string with units&#10;            if isinstance(value, str):&#10;                parsed = parse_value_with_units(value)&#10;                if isinstance(parsed, pint.Quantity):&#10;                    value = parsed.magnitude&#10;                    from_unit = str(parsed.units)&#10;                else:&#10;                    value = parsed  # Use the parsed numeric value&#10;&#10;            # Skip conversion for values very close to zero&#10;            if isinstance(value, (int, float)) and abs(float(value)) &lt; 1e-12:&#10;                return format_value_with_units(0.0, to_unit)&#10;&#10;            # Convert using pint&#10;            quantity = Q_(float(value), from_unit)&#10;            converted = quantity.to(to_unit).magnitude&#10;&#10;            return format_value_with_units(converted, to_unit)&#10;        except Exception as e:&#10;            print(f&quot;Error converting {value} from {from_unit} to {to_unit}: {e}&quot;)&#10;            return value&#10;&#10;    # Process dimensions in node data&#10;    for section_name, field_dimensions in DIMENSION_REGISTRY.items():&#10;        if section_name in si_data:&#10;            section_data = si_data[section_name]&#10;&#10;            # Handle array sections&#10;            if isinstance(section_data, list):&#10;                for i, item in enumerate(section_data):&#10;                    for field, dimension in field_dimensions.items():&#10;                        if field in item:&#10;                            # Get the appropriate SI and display units for this dimension&#10;                            from_unit = si_units.get(dimension, &quot;&quot;)&#10;                            to_unit = display_units.get(dimension, from_unit)&#10;&#10;                            # Convert the value&#10;                            original_value = item[field]&#10;                            display_data[section_name][i][field] = convert_value_with_format(&#10;                                original_value, from_unit, to_unit)&#10;&#10;    # Write to output file if provided&#10;    if output_file:&#10;        with open(output_file, 'w') as f:&#10;            json.dump(display_data, f, indent=2)&#10;        print(f&quot;Converted results written to {output_file}&quot;)&#10;&#10;    return display_data&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    status = 0&#10;    &quot;&quot;&quot;Command line interface for unit conversion.&quot;&quot;&quot;&#10;    parser = argparse.ArgumentParser(description=&quot;Convert JSON structural model to SI units&quot;)&#10;    parser.add_argument(&quot;input_file&quot;, help=&quot;Input JSON file path&quot;)&#10;    parser.add_argument(&quot;-o&quot;, &quot;--output&quot;, default=None, help=&quot;Output JSON file path&quot;)&#10;    args = parser.parse_args()&#10;&#10;    # Determine output filename without using Path module&#10;    if not args.output:&#10;        input_basename = os.path.basename(args.input_file)&#10;        input_name, input_ext = os.path.splitext(input_basename)&#10;        output_basename = f&quot;{input_name}_SI{input_ext}&quot;&#10;        args.output = os.path.join(os.path.dirname(args.input_file), output_basename)&#10;&#10;    if args.output == args.input_file:&#10;        print(f&quot;Warning: Output file {args.output} is the same as input file {args.input_file}.&quot;)&#10;&#10;    if os.path.exists(args.output):&#10;        print(f&quot;Warning: Output file {args.output} already exists. It will be overwritten.&quot;)&#10;        os.remove(args.output)&#10;    try:&#10;        with open(args.input_file, 'r') as f:&#10;            json_data = json.load(f)&#10;&#10;        convert_json_to_si(json_data, args.output)&#10;        print(f&quot;Successfully converted {args.input_file} to SI units&quot;)&#10;&#10;        # Print the contents of the output file&#10;        with open(args.output, 'r') as f:&#10;            print(f.read())&#10;&#10;    except FileNotFoundError:&#10;        print(f&quot;Error: File {args.input_file} not found&quot;)&#10;        status = 1&#10;    except json.JSONDecodeError:&#10;        print(f&quot;Error: Invalid JSON in {args.input_file}&quot;)&#10;        status = 1&#10;    except Exception as e:&#10;        print(f&quot;Error: {str(e)}&quot;)&#10;        status = 1&#10;&#10;    sys.exit(status)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Convert JSON structural model from any unit system to SI units.&#10;&quot;&quot;&quot;&#10;import os&#10;import json&#10;import re&#10;import sys&#10;import argparse&#10;import pint&#10;&#10;# Initialize unit registry&#10;from pyMAOS import unit_manager&#10;&#10;Q_ = unit_manager.ureg.Quantity&#10;&#10;# Define dimension mappings - what fields have what physical dimensions&#10;DIMENSION_REGISTRY = {&#10;    &quot;nodes&quot;: {&#10;        &quot;x&quot;: &quot;length&quot;,&#10;        &quot;y&quot;: &quot;length&quot;,&#10;        &quot;z&quot;: &quot;length&quot;&#10;    },&#10;    &quot;materials&quot;: {&#10;        &quot;E&quot;: &quot;pressure&quot;,&#10;        &quot;G&quot;: &quot;pressure&quot;,&#10;        &quot;rho&quot;: &quot;density&quot;,&#10;        &quot;alpha&quot;: &quot;thermal_expansion&quot;&#10;    },&#10;    &quot;sections&quot;: {&#10;        &quot;area&quot;: &quot;area&quot;,&#10;        &quot;r&quot;: &quot;length&quot;,&#10;        &quot;ixx&quot;: &quot;moment_of_inertia&quot;&#10;    },&#10;    &quot;joint_loads&quot;: {&#10;        &quot;fx&quot;: &quot;force&quot;,&#10;        &quot;fy&quot;: &quot;force&quot;,&#10;        &quot;fz&quot;: &quot;force&quot;,&#10;        &quot;mx&quot;: &quot;moment&quot;,&#10;        &quot;my&quot;: &quot;moment&quot;,&#10;        &quot;mz&quot;: &quot;moment&quot;&#10;    },&#10;    &quot;member_loads&quot;: {&#10;        &quot;wi&quot;: &quot;distributed_load&quot;,&#10;        &quot;wj&quot;: &quot;distributed_load&quot;,&#10;        &quot;a&quot;: &quot;length&quot;,&#10;        &quot;b&quot;: &quot;length&quot;&#10;    }&#10;}&#10;&#10;# Define SI unit for each dimension&#10;SI_UNITS = {&#10;    &quot;length&quot;: &quot;m&quot;,&#10;    &quot;area&quot;: &quot;m^2&quot;,&#10;    &quot;moment_of_inertia&quot;: &quot;m^4&quot;,&#10;    &quot;force&quot;: &quot;N&quot;,&#10;    &quot;pressure&quot;: &quot;Pa&quot;,&#10;    &quot;moment&quot;: &quot;N*m&quot;,&#10;    &quot;distributed_load&quot;: &quot;N/m&quot;,&#10;    &quot;angle&quot;: &quot;rad&quot;,&#10;    &quot;rotation&quot;: &quot;rad&quot;,&#10;    &quot;density&quot;: &quot;kg/m^3&quot;,&#10;    &quot;thermal_expansion&quot;: &quot;1/K&quot;&#10;}&#10;&#10;def parse_value_with_units(value_string):&#10;    &quot;&quot;&quot;Parse a string that may contain a value with units.&quot;&quot;&quot;&#10;    if not isinstance(value_string, str):&#10;        return value_string&#10;&#10;    # Match pattern: [numeric value][units]&#10;    match = re.match(r'([-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?)(.*)', value_string.strip())&#10;&#10;    if match:&#10;        value_str, unit_str = match.groups()&#10;        value = float(value_str)&#10;&#10;        if unit_str and unit_str.strip():&#10;            try:&#10;                # Create quantity with units&#10;                return Q_(value, unit_str)&#10;            except:&#10;                print(f&quot;Warning: Could not parse unit '{unit_str}', treating as dimensionless&quot;)&#10;                return value&#10;        return value&#10;&#10;    # If no match, try to evaluate as a simple numeric expression&#10;    try:&#10;        return float(eval(value_string))&#10;    except:&#10;        raise ValueError(f&quot;Could not parse value: {value_string}&quot;)&#10;&#10;def format_value_with_units(value, unit):&#10;    &quot;&quot;&quot;Format a numeric value with its unit as a string.&quot;&quot;&quot;&#10;    # Handle special formatting for different types of values&#10;    if isinstance(value, float):&#10;        # Use appropriate precision based on magnitude&#10;        if abs(value) &lt; 0.001:&#10;            formatted = f&quot;{value:.6e}&quot;&#10;        elif abs(value) &lt; 1:&#10;            formatted = f&quot;{value:.6f}&quot;&#10;        elif abs(value) &lt; 1000:&#10;            formatted = f&quot;{value:.4f}&quot;&#10;        else:&#10;            formatted = f&quot;{value:.2f}&quot;&#10;&#10;        # Remove trailing zeros and decimal point if no fractional part&#10;        formatted = formatted.rstrip('0').rstrip('.') if '.' in formatted else formatted&#10;&#10;    else:&#10;        formatted = str(value)&#10;&#10;    # Combine value with unit&#10;    return f&quot;{formatted} {unit}&quot;.strip()&#10;&#10;def convert_to_si(value, dimension, unit_system, default_units, as_string=True):&#10;    &quot;&quot;&quot;&#10;    Convert a value to SI units based on its dimension.&#10;    &#10;    Parameters&#10;    ----------&#10;    value : str, float, int, or pint.Quantity&#10;        The value to convert&#10;    dimension : str&#10;        The physical dimension of the value&#10;    unit_system : str&#10;        The unit system of the input value&#10;    default_units : dict&#10;        Dictionary mapping dimensions to units for the input&#10;    as_string : bool, optional&#10;        Whether to return the result as a string with units (True) or numeric value (False)&#10;    &#10;    Returns&#10;    -------&#10;    str or float&#10;        The converted value, either as a string with units or as a numeric value&#10;    &quot;&quot;&quot;&#10;    si_unit = SI_UNITS.get(dimension, &quot;&quot;)&#10;    &#10;    try:&#10;        if isinstance(value, pint.Quantity):&#10;            # Value already has explicit units&#10;            if si_unit:&#10;                si_value = value.to(si_unit).magnitude&#10;                return format_value_with_units(si_value, si_unit) if as_string else si_value&#10;        elif isinstance(value, (int, float)) and dimension in default_units:&#10;            # Value has implicit units based on default_units&#10;            implicit_unit = default_units[dimension]&#10;            quantity = Q_(value, implicit_unit)&#10;            if si_unit:&#10;                si_value = quantity.to(si_unit).magnitude&#10;                return format_value_with_units(si_value, si_unit) if as_string else si_value&#10;        elif isinstance(value, str):&#10;            # Try parsing the string as a value with units&#10;            parsed = parse_value_with_units(value)&#10;            if isinstance(parsed, pint.Quantity) and si_unit:&#10;                si_value = parsed.to(si_unit).magnitude&#10;                return format_value_with_units(si_value, si_unit) if as_string else si_value&#10;            elif isinstance(parsed, (int, float)) and dimension in default_units:&#10;                # Parsed value was numeric, use default units&#10;                implicit_unit = default_units[dimension]&#10;                quantity = Q_(parsed, implicit_unit)&#10;                if si_unit:&#10;                    si_value = quantity.to(si_unit).magnitude&#10;                    return format_value_with_units(si_value, si_unit) if as_string else si_value&#10;    except Exception as e:&#10;        print(f&quot;Warning: Error converting '{value}' for dimension '{dimension}': {e}&quot;)&#10;    &#10;    # No conversion needed or possible - return original value&#10;    return value&#10;&#10;def convert_json_to_si(json_data, output_file=None, as_string=True):&#10;    &quot;&quot;&quot;&#10;    Convert all values in a JSON structure to SI units.&#10;    &#10;    Parameters&#10;    ----------&#10;    json_data : dict&#10;        The JSON data to convert&#10;    output_file : str, optional&#10;        Path to output file&#10;    as_string : bool, optional&#10;        Whether to output quantities as strings with units (True) or raw numeric values (False)&#10;    &#10;    Returns&#10;    -------&#10;    dict&#10;        The converted data&#10;    &quot;&quot;&quot;&#10;    # Extract unit system and default units&#10;    unit_system = json_data.get(&quot;unit_system&quot;, &quot;SI&quot;).lower()&#10;    default_units = json_data.get(&quot;units&quot;, {})&#10;    &#10;    print(f&quot;Converting from {unit_system} system to SI units&quot;)&#10;    print(f&quot;Output format: {'String with units' if as_string else 'Numeric values'}&quot;)&#10;&#10;    # Set up output data structure&#10;    si_data = json_data.copy()&#10;&#10;    # Replace unit system&#10;    si_data[&quot;unit_system&quot;] = &quot;SI&quot;&#10;&#10;    # Update units section to SI&#10;    si_data[&quot;units&quot;] = {&#10;        &quot;length&quot;: &quot;m&quot;,&#10;        &quot;pressure&quot;: &quot;Pa&quot;,&#10;        &quot;force&quot;: &quot;N&quot;,&#10;        &quot;area&quot;: &quot;m^2&quot;,&#10;        &quot;moment_of_inertia&quot;: &quot;m^4&quot;,&#10;        &quot;distributed_load&quot;: &quot;N/m&quot;,&#10;        &quot;angle&quot;: &quot;rad&quot;,&#10;        &quot;density&quot;: &quot;kg/m^3&quot;&#10;    }&#10;&#10;    # Process each section with physical dimensions&#10;    for section_name, field_dimensions in DIMENSION_REGISTRY.items():&#10;        if section_name in json_data:&#10;            section_data = json_data[section_name]&#10;&#10;            # Handle array sections&#10;            if isinstance(section_data, list):&#10;                for i, item in enumerate(section_data):&#10;                    for field, dimension in field_dimensions.items():&#10;                        if field in item:&#10;                            original_value = item[field]&#10;                            print(f&quot;Converting {section_name}[{i}].{field} from {original_value} to SI units&quot;)&#10;                            &#10;                            # Convert the value with the appropriate output format&#10;                            si_data[section_name][i][field] = convert_to_si(&#10;                                original_value, dimension, unit_system, default_units, as_string=as_string)&#10;                            &#10;                            print(f&quot;Converted {section_name}[{i}].{field} to SI: {si_data[section_name][i][field]}&quot;)&#10;&#10;    # Write to output file or print to stdout&#10;    if output_file:&#10;        with open(output_file, 'w') as f:&#10;            json.dump(si_data, f, indent=2)&#10;        print(f&quot;Converted data written to {output_file}&quot;)&#10;    else:&#10;        print(json.dumps(si_data, indent=2))&#10;    &#10;    return si_data&#10;&#10;def convert_si_to_display_units(si_data, output_file=None, display_units=None, as_string=True):&#10;    &quot;&quot;&quot;&#10;    Convert structural analysis results from SI units to display units&#10;    &#10;    Parameters&#10;    ----------&#10;    si_data : dict or str&#10;        JSON data structure or path to JSON file with SI units&#10;    output_file : str, optional&#10;        Path to output file (defaults to None, which returns converted data)&#10;    display_units : dict, optional&#10;        Dictionary mapping dimensions to display units&#10;    as_string : bool, optional&#10;        Whether to output quantities as strings with units (True) or raw numeric values (False)&#10;    &#10;    Returns&#10;    -------&#10;    dict&#10;        Data structure with values converted to display units&#10;    &quot;&quot;&quot;&#10;    import json&#10;    from copy import deepcopy&#10;&#10;    # Handle case where si_data is a file path&#10;    if isinstance(si_data, str):&#10;        with open(si_data, 'r') as f:&#10;            si_data = json.load(f)&#10;&#10;    # Get display units if not provided&#10;    if display_units is None:&#10;        try:&#10;            from pyMAOS.units_mod import DISPLAY_UNITS&#10;            display_units = DISPLAY_UNITS&#10;        except ImportError:&#10;            # Fallback to some standard display units&#10;            display_units = {&#10;                &quot;force&quot;: &quot;lbf&quot;,&#10;                &quot;length&quot;: &quot;ft&quot;,&#10;                &quot;moment&quot;: &quot;lbf*ft&quot;,&#10;                &quot;pressure&quot;: &quot;psi&quot;,&#10;                &quot;area&quot;: &quot;in^2&quot;,&#10;                &quot;moment_of_inertia&quot;: &quot;in^4&quot;,&#10;                &quot;distributed_load&quot;: &quot;lbf/ft&quot;,&#10;                &quot;rotation&quot;: &quot;rad&quot;,&#10;                &quot;density&quot;: &quot;lb/ft^3&quot;,&#10;                &quot;thermal_expansion&quot;: &quot;1/F&quot;&#10;            }&#10;&#10;    # Define SI units for each dimension&#10;    si_units = {&#10;        &quot;force&quot;: &quot;N&quot;,&#10;        &quot;length&quot;: &quot;m&quot;,&#10;        &quot;moment&quot;: &quot;N*m&quot;,&#10;        &quot;pressure&quot;: &quot;Pa&quot;,&#10;        &quot;area&quot;: &quot;m^2&quot;,&#10;        &quot;moment_of_inertia&quot;: &quot;m^4&quot;,&#10;        &quot;distributed_load&quot;: &quot;N/m&quot;,&#10;        &quot;rotation&quot;: &quot;rad&quot;,&#10;        &quot;density&quot;: &quot;kg/m^3&quot;,&#10;        &quot;thermal_expansion&quot;: &quot;1/K&quot;&#10;    }&#10;&#10;    # Create a copy of the data to modify&#10;    display_data = deepcopy(si_data)&#10;&#10;    # Update the units section&#10;    if &quot;units&quot; in display_data:&#10;        display_data[&quot;units&quot;] = display_units&#10;&#10;    # Convert a single value using pint and return as string with units or numeric value&#10;    def convert_value_with_format(value, from_unit, to_unit, as_string=True):&#10;        try:&#10;            # Handle string with units&#10;            if isinstance(value, str):&#10;                parsed = parse_value_with_units(value)&#10;                if isinstance(parsed, pint.Quantity):&#10;                    value = parsed.magnitude&#10;                    from_unit = str(parsed.units)&#10;                else:&#10;                    value = parsed  # Use the parsed numeric value&#10;            &#10;            # Skip conversion for values very close to zero&#10;            if isinstance(value, (int, float)) and abs(float(value)) &lt; 1e-12:&#10;                return format_value_with_units(0.0, to_unit) if as_string else 0.0&#10;&#10;            # Convert using pint&#10;            quantity = Q_(float(value), from_unit)&#10;            converted = quantity.to(to_unit).magnitude&#10;            &#10;            return format_value_with_units(converted, to_unit) if as_string else converted&#10;        except Exception as e:&#10;            print(f&quot;Error converting {value} from {from_unit} to {to_unit}: {e}&quot;)&#10;            return value&#10;&#10;    # Process dimensions in node data&#10;    for section_name, field_dimensions in DIMENSION_REGISTRY.items():&#10;        if section_name in si_data:&#10;            section_data = si_data[section_name]&#10;            &#10;            # Handle array sections&#10;            if isinstance(section_data, list):&#10;                for i, item in enumerate(section_data):&#10;                    for field, dimension in field_dimensions.items():&#10;                        if field in item:&#10;                            # Get the appropriate SI and display units for this dimension&#10;                            from_unit = si_units.get(dimension, &quot;&quot;)&#10;                            to_unit = display_units.get(dimension, from_unit)&#10;                            &#10;                            # Convert the value&#10;                            original_value = item[field]&#10;                            display_data[section_name][i][field] = convert_value_with_format(&#10;                                original_value, from_unit, to_unit, as_string=as_string)&#10;&#10;    # Write to output file if provided&#10;    if output_file:&#10;        with open(output_file, 'w') as f:&#10;            json.dump(display_data, f, indent=2)&#10;        print(f&quot;Converted results written to {output_file}&quot;)&#10;&#10;    return display_data&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    status = 0&#10;    &quot;&quot;&quot;Command line interface for unit conversion.&quot;&quot;&quot;&#10;    parser = argparse.ArgumentParser(description=&quot;Convert JSON structural model to SI units&quot;)&#10;    parser.add_argument(&quot;input_file&quot;, help=&quot;Input JSON file path&quot;)&#10;    parser.add_argument(&quot;-o&quot;, &quot;--output&quot;, default=None, help=&quot;Output JSON file path&quot;)&#10;    parser.add_argument(&quot;--output_type&quot;, choices=[&quot;string&quot;, &quot;numeric&quot;], default=&quot;string&quot;,&#10;                      help=&quot;Format of output quantities: 'string' includes units, 'numeric' for raw values&quot;)&#10;    args = parser.parse_args()&#10;&#10;    # Determine output filename without using Path module&#10;    if not args.output:&#10;        input_basename = os.path.basename(args.input_file)&#10;        input_name, input_ext = os.path.splitext(input_basename)&#10;        &#10;        # Remove &quot;_imperial&quot; from input name if present&#10;        if &quot;_imperial&quot; in input_name:&#10;            input_name = input_name.replace(&quot;_imperial&quot;, &quot;&quot;)&#10;        &#10;        # Add appropriate suffix based on output type&#10;        output_type_suffix = &quot;_SI_string&quot; if args.output_type == &quot;string&quot; else &quot;_SI_numeric&quot;&#10;        output_basename = f&quot;{input_name}{output_type_suffix}{input_ext}&quot;&#10;        &#10;        args.output = os.path.join(os.path.dirname(args.input_file), output_basename)&#10;&#10;    if args.output == args.input_file:&#10;        print(f&quot;Warning: Output file {args.output} is the same as input file {args.input_file}.&quot;)&#10;&#10;    if os.path.exists(args.output):&#10;        print(f&quot;Warning: Output file {args.output} already exists. It will be overwritten.&quot;)&#10;        os.remove(args.output)&#10;    &#10;    try:&#10;        print(f&quot;Converting {args.input_file} to SI units with {args.output_type} format&quot;)&#10;        with open(args.input_file, 'r') as f:&#10;            json_data = json.load(f)&#10;&#10;        # Convert to SI with appropriate output format&#10;        as_string = args.output_type == &quot;string&quot;&#10;        convert_json_to_si(json_data, args.output, as_string=as_string)&#10;        print(f&quot;Successfully converted {args.input_file} to SI units&quot;)&#10;&#10;        # Print the contents of the output file&#10;        with open(args.output, 'r') as f:&#10;            print(f.read())&#10;&#10;    except FileNotFoundError:&#10;        print(f&quot;Error: File {args.input_file} not found&quot;)&#10;        status = 1&#10;    except json.JSONDecodeError:&#10;        print(f&quot;Error: Invalid JSON in {args.input_file}&quot;)&#10;        status = 1&#10;    except Exception as e:&#10;        print(f&quot;Error: {str(e)}&quot;)&#10;        status = 1&#10;&#10;    sys.exit(status)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>